<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星星</title>
  
  <subtitle>We are all stardust</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://javastar.club/"/>
  <updated>2019-08-08T03:41:29.963Z</updated>
  <id>http://javastar.club/</id>
  
  <author>
    <name>小星星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>debug技巧总结</title>
    <link href="http://javastar.club/archives/fe81e267.html"/>
    <id>http://javastar.club/archives/fe81e267.html</id>
    <published>2019-08-08T03:41:29.000Z</published>
    <updated>2019-08-08T03:41:29.963Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>英语阅读</title>
    <link href="http://javastar.club/archives/c20ae70.html"/>
    <id>http://javastar.club/archives/c20ae70.html</id>
    <published>2019-08-08T01:58:16.000Z</published>
    <updated>2019-08-08T03:04:18.031Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Every atom in your body came from a star that exploded.And, the atoms in your left hand probably came from a different star than your right hand.It really is the most poetic thing I know about physics.You are all stardust.--Lawrence M. Krauss</code></pre><a id="more"></a><ol>  <li>    <p>If I should meet thee<br>After long years,<br>How should I greet      thee?<br>With silence and tears.<br>–Byron</p>  </li>  <li>    <p>Time doth transfix the flourish set on youth<br>And delves the parallels      in beauty’s brow,<br>Feeds one the rarities of nature’s truth,<br>And      nothing stands but for his scythe to mow<br>–Shakespeare’ sonnets</p>  </li>  <li>    <p>Do not fall in love with people like me,<br>I will take you to      museums,and parks, and monuments.</p>    <p>And kiss you in every beautiful place,<br>so that you can never go back      to them</p>    <p>Without tasting me like blood in your mouth.<br>I will destroy you in the      most beautiful way possible.</p>    <p>And when I leave you will finally understand,<br>Why storms are named      after people.<br>–Caitlyn Siehl</p>  </li>  <li>    <p>I will return, find you, love you ,marry you and live<br>without shame.    </p>  </li>  <li>    <p>We are all in the gutter, but some of us are looking<br>at the      stars.<br>– Wilde</p>  </li>  <li>    <p>Sometimes ever, sometimes never.</p>  </li>  <li>    <p>If I could, surely would.</p>  </li>  <li>    <p>May there be enough clouds in you life to make a<br>beautiful sunset.</p>  </li>  <li>    <p>No pains, no gains.</p>  </li>  <li>    <p>Life is like a box of chocolates,you never know what<br>what you are      going to get.</p>  </li>  <li>    <p>You must always have faith in who you are.</p>  </li>  <li>    <p>The longest day has an end.<br>– Howell</p>  </li>  <li>    <p>Do not cry because it is over,smile because it<br>happened.</p>  </li>  <li>    <p>To be,or not to be - that is the question.<br>–hamlet</p>  </li>  <li>    <p>When you feel like hope is gone, look inside you and<br>search your soul,      you will find a hero lies in you mind. Dreams are hard to follow,but don’t      let anyone steal your dream.</p>  </li>  <li>    <p>And forever has no end.</p>  </li>  <li>    <p>Love is a game that two can play and both win.</p>  </li>  <li>    <p>Life has taught us that love does not consist in<br>gazing at each other      but in looking outward together in the same direction.</p>  </li>  <li>    <p>Love alone could waken love!</p>  </li>  <li>    <p>Some of us get dipped in flat, some in satin, some in<br>gloss.<br>But      every once in a while you find someone who’s iridescent, and when you do,      nothing will ever compare.</p>  </li></ol><h3 id="Reading-Comprehension"><a href="#Reading-Comprehension" class="headerlink" title="Reading Comprehension"></a>Reading  Comprehension</h3><p> France,which prides itself as the global innovator of fashion, has decided  its fashion industry has lost an absolute right to define physical beauty for  women.<br> Its lawmakers gave preliminary approval last week to a<br> law that  would make it a crime to employ ultra-thin models on runways.</p><p> The parliament also agreed to ban websites that “incite excessive thinness”  by promoting extreme dieting.</p><p> Such measures have a couple of uplifting motives. They suggest beauty should  not be defined by looks that end<br> up impinging on health. That’s a start.  And the ban on ultra-thin models seems to go beyond protecting models from  starving themselves to death–as some have done.<br> It tells the fashion  industry that it must take responsibility for the signal it sends women,  especially teenage girls, about the social tape-measure they must use to  determine their individual worth.</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Every atom in your body came from a star that exploded.

And, the atoms in your left hand probably came from a different star than your right hand.

It really is the most poetic thing I know about physics.

You are all stardust.
--Lawrence M. Krauss&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="English" scheme="http://javastar.club/categories/English/"/>
    
    
      <category term="English" scheme="http://javastar.club/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>数学基础复习:概率论</title>
    <link href="http://javastar.club/archives/fb566d07.html"/>
    <id>http://javastar.club/archives/fb566d07.html</id>
    <published>2019-08-06T08:32:15.000Z</published>
    <updated>2019-08-07T10:28:33.474Z</updated>
    
    <content type="html"><![CDATA[<p>三大基础数学复习：概率论</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三大基础数学复习：概率论&lt;/p&gt;
    
    </summary>
    
      <category term="数学基础" scheme="http://javastar.club/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数学基础" scheme="http://javastar.club/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数学基础复习</title>
    <link href="http://javastar.club/archives/83ff8e26.html"/>
    <id>http://javastar.club/archives/83ff8e26.html</id>
    <published>2019-08-05T07:00:43.000Z</published>
    <updated>2019-08-07T07:14:52.720Z</updated>
    
    <content type="html"><![CDATA[<p>三大基础数学复习</p><a id="more"></a><h1 id="一、高等数学复习"><a href="#一、高等数学复习" class="headerlink" title="一、高等数学复习"></a>一、高等数学复习</h1><h2 id="高数-上"><a href="#高数-上" class="headerlink" title="高数(上)"></a>高数(上)</h2><h3 id="第一章、函数与极限"><a href="#第一章、函数与极限" class="headerlink" title="第一章、函数与极限"></a>第一章、函数与极限</h3><ol>  <li>函数</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/1.%E5%87%BD%E6%95%B0/1%E5%87%BD%E6%95%B0_1.jpg" alt="函数与极限"></p><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/1.%E5%87%BD%E6%95%B0/1%E5%87%BD%E6%95%B0_2.jpg" alt="函数与极限"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/1.%E5%87%BD%E6%95%B0/1%E5%87%BD%E6%95%B0_3.jpg" alt="测试"></p><ol start="2">  <li>数列极限 </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/2.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/2%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/2.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/2%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90_2.jpg" alt="测试"></p><ol start="3">  <li>函数极限</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/3.%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/3%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/3.%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/3%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/3.%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/3%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90_3.jpg" alt="测试"></p><ol start="4">  <li>无穷小和无穷大</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/4.%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7/4%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/4.%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7/4%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7_2.jpg" alt="测试"></p><ol start="5">  <li>极限的运算法则</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/5.%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/5%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/5.%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/5%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/5.%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/5%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/5.%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/5%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99_4.jpg" alt="测试"></p><ol start="6">  <li>极限存在准则 两个重要极限<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/6.%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90/6%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90_1.jpg" alt="测试">  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/6.%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90/6%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/6.%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90/6%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/6.%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90/6%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90_4.jpg" alt="测试"></p><ol start="7">  <li>无穷小的比较</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/7.%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83/7%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/7.%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83/7%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/7.%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83/7%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83_3.jpg" alt="测试"></p><ol start="8">  <li>函数的连续型与间断点</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/8.%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E4%B8%8E%E9%97%B4%E6%96%AD%E7%82%B9/8%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E9%97%B4%E6%96%AD%E7%82%B9_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/8.%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E4%B8%8E%E9%97%B4%E6%96%AD%E7%82%B9/8%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E9%97%B4%E6%96%AD%E7%82%B9_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/8.%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E4%B8%8E%E9%97%B4%E6%96%AD%E7%82%B9/8%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E9%97%B4%E6%96%AD%E7%82%B9_3.jpg" alt="测试"></p><ol start="9">  <li>连续函数运算及初等函数连续性</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/9.%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7/9%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/9.%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7/9%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7_2.jpg" alt="测试"></p><ol start="10">  <li>闭区间上连续函数的性质<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/10.%E9%97%AD%E5%8C%BA%E9%97%B4%E4%B8%8A%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8/10%E9%97%AD%E5%8C%BA%E9%97%B4%E4%B8%8A%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/10.%E9%97%AD%E5%8C%BA%E9%97%B4%E4%B8%8A%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8/10%E9%97%AD%E5%8C%BA%E9%97%B4%E4%B8%8A%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8_2.jpg" alt="测试">  </li></ol><h3 id="第二章、导数与微分"><a href="#第二章、导数与微分" class="headerlink" title="第二章、导数与微分"></a>第二章、导数与微分</h3><ol>  <li>    <p>导数的概念<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/1.%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/1%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/1.%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/1%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/1.%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/1%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/1.%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/1%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5_4.jpg" alt="测试">    </p>  </li>  <li>    <p>求导法则(一)</p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/2.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%B8%80)_1.jpg" alt="测试">_  <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/2.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%B8%80)_2.jpg" alt="测试">_  <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/2.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%B8%80)_3.jpg" alt="测试">_</p><ol start="3">  <li>    <p>求导法则(二)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/3.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%BA%8C)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/3.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%BA%8C)_2.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/3.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%BA%8C)_3.jpg" alt="测试">_    </p>  </li>  <li>    <p>高阶导数<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/4.%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/4%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/4.%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/4%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/4.%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/4%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/4.%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/4%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0_4.jpg" alt="测试">    </p>  </li>  <li>    <p>隐函数及由参数方程确定的函数求导<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/5.%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/5%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/5.%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/5%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/5.%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/5%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC_3.jpg" alt="测试">    </p>  </li>  <li>    <p>微分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_4.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_5.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_6.jpg" alt="测试">    </p>  </li></ol><h3 id="第三章-微分中值定理及导数的应用"><a href="#第三章-微分中值定理及导数的应用" class="headerlink" title="第三章 微分中值定理及导数的应用"></a>第三章  微分中值定理及导数的应用</h3><ol>  <li>微分中值定理(一)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/1.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/1%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%B8%80)_1.jpg" alt="测试">_    <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/1.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/1%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%B8%80)_2.jpg" alt="测试">_  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/1.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/1%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%B8%80)_3.jpg" alt="测试">_</p><ol start="2">  <li>    <p>微分中值定理(二)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/2.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%BA%8C)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/2.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%BA%8C)_2.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/2.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%BA%8C)_3.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/2.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%BA%8C)_4.jpg" alt="测试">_    </p>  </li>  <li>    <p>洛必达法则<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/3.%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/3%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99_1.jpg" alt="测试">    </p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/3.%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/3%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/3.%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/3%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99_3.jpg" alt="测试"></p><ol start="4">  <li>    <p>Taylor公式<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/4.Taylor%E5%85%AC%E5%BC%8F/4%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/4.Taylor%E5%85%AC%E5%BC%8F/4%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/4.Taylor%E5%85%AC%E5%BC%8F/4%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/4.Taylor%E5%85%AC%E5%BC%8F/4%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F_4.jpg" alt="测试">    </p>  </li>  <li>    <p>函数单调性与曲线凹凸性(一)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/5.%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89/5%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7(%E4%B8%80)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/5.%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89/5%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7(%E4%B8%80)_2.jpg" alt="测试">_    </p>  </li>  <li>    <p>函数单调性与曲线凹凸性（二）<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/6.%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89/6%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7(%E4%BA%8C)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/6.%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89/6%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7(%E4%BA%8C)_2.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/6.%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89/6%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7(%E4%BA%8C)_3.jpg" alt="测试">_    </p>  </li>  <li>    <p>极值与最值<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/7.%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/7%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/7.%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/7%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/7.%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/7%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/7.%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/7%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC_4.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/7.%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/7%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC_5.jpg" alt="测试">    </p>  </li>  <li>    <p>函数图像描绘<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/8.%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98/8%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/8.%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98/8%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/8.%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98/8%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98_3.jpg" alt="测试">    </p>  </li>  <li>    <p>弧微分与曲率</p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/9.%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87/9%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/9.%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87/9%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87_2.jpg" alt="测试"></p><h3 id="第四章-不定积分"><a href="#第四章-不定积分" class="headerlink" title="第四章 不定积分"></a>第四章  不定积分</h3><ol>  <li>    <p>不定积分的概念与性质<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/1.%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/1%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/1.%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/1%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/1.%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/1%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_3.jpg" alt="测试">    </p>  </li>  <li>    <p>换元积分法(一)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/2.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%B8%80)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/2.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%B8%80)_2.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/2.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%B8%80)_3.jpg" alt="测试">_    </p>  </li>  <li>    <p>换元积分法(二)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%BA%8C)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%BA%8C)_2.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%BA%8C)_3.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%BA%8C)_4.jpg" alt="测试">_    </p>  </li>  <li>    <p>分部积分法<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_3.jpg" alt="测试">    </p>  </li></ol><h3 id="第五章、定积分"><a href="#第五章、定积分" class="headerlink" title="第五章、定积分"></a>第五章、定积分</h3><ol>  <li>    <p>定积分的概念与性质<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/1.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8%EF%BC%88%E4%B8%80%EF%BC%89/1%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/1.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8%EF%BC%88%E4%B8%80%EF%BC%89/1%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_2.jpg" alt="测试">    </p>  </li>  <li>    <p>定积分的概念与性质(二)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/2.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8(%E4%BA%8C)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/2.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8(%E4%BA%8C)_2.jpg" alt="测试">_    </p>  </li>  <li>    <p>积分基本公式<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/3%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/3%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/3%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F_3.jpg" alt="测试">    </p>  </li>  <li>    <p>定积分的换元积分法与分部积分法<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_4.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_5.jpg" alt="测试">    </p>  </li>  <li>    <p>反常积分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/5.%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/5%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/5.%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/5%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/5.%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/5%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/5.%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/5%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86_4.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/5.%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/5%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86_5.jpg" alt="测试">    </p>  </li></ol><h3 id="第六章-定积分应用"><a href="#第六章-定积分应用" class="headerlink" title="第六章 定积分应用"></a>第六章  定积分应用</h3><ol>  <li>    <p>元素法<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/1.%E5%85%83%E7%B4%A0%E6%B3%95/1%E5%85%83%E7%B4%A0%E6%B3%95.jpg" alt="测试">    </p>  </li>  <li>    <p>几何应用<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/2.%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/2%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/2.%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/2%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/2.%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/2%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/2.%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/2%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_4.jpg" alt="测试">    </p>  </li>  <li>    <p>定积分在物理学上的应用<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/3.%E5%AE%9A%E7%A7%AF%E5%88%86%E5%9C%A8%E7%89%A9%E7%90%86%E5%AD%A6%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/3%E5%AE%9A%E7%A7%AF%E5%88%86%E5%9C%A8%E7%89%A9%E7%90%86%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8.jpg" alt="测试">    </p>  </li></ol><h3 id="第七章-微分方程"><a href="#第七章-微分方程" class="headerlink" title="第七章 微分方程"></a>第七章  微分方程</h3><ol>  <li>    <p>微分方程的基本概念<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/1.%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpg" alt="测试">    </p>  </li>  <li>    <p>可分离变量的微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/2.%E5%8F%AF%E5%88%86%E7%A6%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/2%E5%8F%AF%E5%88%86%E7%A6%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B.jpg" alt="测试">    </p>  </li>  <li>    <p>齐次微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/3.%E9%BD%90%E6%AC%A1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/3%E9%BD%90%E6%AC%A1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B.jpg" alt="测试">    </p>  </li>  <li>    <p>一阶线性微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/4.%E4%B8%80%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/4%E4%B8%80%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/4.%E4%B8%80%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/4%E4%B8%80%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">    </p>  </li>  <li>    <p>可降阶的高阶微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/5.%E5%8F%AF%E9%99%8D%E9%98%B6%E7%9A%84%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/5%E5%8F%AF%E9%99%8D%E9%98%B6%E7%9A%84%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/5.%E5%8F%AF%E9%99%8D%E9%98%B6%E7%9A%84%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/5%E5%8F%AF%E9%99%8D%E9%98%B6%E7%9A%84%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">    </p>  </li>  <li>    <p>高阶线性微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/6.%E9%AB%98%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/6%E9%AB%98%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/6.%E9%AB%98%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/6%E9%AB%98%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">    </p>  </li>  <li>    <p>常系数齐次线性微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7.%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7.%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">    </p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7.%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_3.jpg" alt="测试"></p><ol start="8">  <li>常系数非齐次线性微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/8.%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/8%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/8.%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/8%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">  </li></ol><h2 id="高数-下"><a href="#高数-下" class="headerlink" title="高数(下)"></a>高数(下)</h2><h3 id="第八章-向量代数与空间解析几何"><a href="#第八章-向量代数与空间解析几何" class="headerlink" title="第八章 向量代数与空间解析几何"></a>第八章  向量代数与空间解析几何</h3><ol>  <li>    <p>向量及其线性运算<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/1.%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97/1%E5%90%91%E9%87%8F%E5%8F%8A%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/1.%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97/1%E5%90%91%E9%87%8F%E5%8F%8A%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/1.%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97/1%E5%90%91%E9%87%8F%E5%8F%8A%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97_3.jpg" alt="测试">    </p>  </li>  <li>    <p>向量的数量积与向量积<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/2.%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF/2%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/2.%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF/2%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/2.%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF/2%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF_3.jpg" alt="测试">    </p>  </li>  <li>    <p>向量应用（一）——平面及其方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/3.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B/3%E5%BA%94%E7%94%A8(%E4%B8%80)%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/3.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B/3%E5%BA%94%E7%94%A8(%E4%B8%80)%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">    </p>  </li>  <li>    <p>应用(二)空间直线<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/4.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF/4%E5%BA%94%E7%94%A8(%E4%BA%8C)%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/4.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF/4%E5%BA%94%E7%94%A8(%E4%BA%8C)%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/4.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF/4%E5%BA%94%E7%94%A8(%E4%BA%8C)%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/4.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF/4%E5%BA%94%E7%94%A8(%E4%BA%8C)%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF_4.jpg" alt="测试">    </p>  </li>  <li>    <p>空间曲面及方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/5.%E7%A9%BA%E9%97%B4%E6%9B%B2%E9%9D%A2%E5%8F%8A%E6%96%B9%E7%A8%8B/5%E7%A9%BA%E9%97%B4%E6%9B%B2%E9%9D%A2%E5%8F%8A%E6%96%B9%E7%A8%8B.jpg" alt="测试">    </p>  </li>  <li>    <p>空间曲线及方程</p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/6.%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BF%E5%8F%8A%E6%96%B9%E7%A8%8B/6%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BF%E5%8F%8A%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/6.%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BF%E5%8F%8A%E6%96%B9%E7%A8%8B/6%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BF%E5%8F%8A%E6%96%B9%E7%A8%8B_2.jpg" alt="测试"></p><h3 id="第九章-多元函数微分学及应用"><a href="#第九章-多元函数微分学及应用" class="headerlink" title="第九章 多元函数微分学及应用"></a>第九章  多元函数微分学及应用</h3><ol>  <li>    <p>多元函数的基本概念<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/1.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/1.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/1.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_3.jpg" alt="测试">    </p>  </li>  <li>    <p>偏导数<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/2.%E5%81%8F%E5%AF%BC%E6%95%B0/2%E5%81%8F%E5%AF%BC%E6%95%B0_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/2.%E5%81%8F%E5%AF%BC%E6%95%B0/2%E5%81%8F%E5%AF%BC%E6%95%B0_2.jpg" alt="测试">    </p>  </li>  <li>    <p>全微分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/3.%E5%85%A8%E5%BE%AE%E5%88%86/3%E5%85%A8%E5%BE%AE%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/3.%E5%85%A8%E5%BE%AE%E5%88%86/3%E5%85%A8%E5%BE%AE%E5%88%86_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/3.%E5%85%A8%E5%BE%AE%E5%88%86/3%E5%85%A8%E5%BE%AE%E5%88%86_3.jpg" alt="测试">    </p>  </li>  <li>    <p>多元复合函数求导法则<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/4.%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/4%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/4.%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/4%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/4.%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/4%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99_3.jpg" alt="测试">    </p>  </li>  <li>    <p>隐函数求导法则<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/5.%E9%9A%90%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/5%E9%9A%90%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC.jpg" alt="测试">    </p>  </li>  <li>    <p>多元函数微分学的几何应用<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/6.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E7%9A%84%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/6%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E7%9A%84%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/6.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E7%9A%84%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/6%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E7%9A%84%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_2.jpg" alt="测试">    </p>  </li>  <li>    <p>方向导数与梯度<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/7.%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E4%B8%8E%E6%A2%AF%E5%BA%A6/7%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E4%B8%8E%E6%A2%AF%E5%BA%A6_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/7.%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E4%B8%8E%E6%A2%AF%E5%BA%A6/7%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E4%B8%8E%E6%A2%AF%E5%BA%A6_2.jpg" alt="测试">    </p>  </li>  <li>    <p>代数应用——多元函数的极值<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/8.%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC/8%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC_1.jpg" alt="测试">    </p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/8.%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC/8%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC_2.jpg" alt="测试"></p><h3 id="第十章-重积分"><a href="#第十章-重积分" class="headerlink" title="第十章 重积分"></a>第十章  重积分</h3><ol>  <li>    <p>二重积分的概念和性质<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/1.%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/1%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/1.%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/1%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_2.jpg" alt="测试">    </p>  </li>  <li>    <p>二重积分的计算法<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/2.%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%E6%B3%95/2%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%E6%B3%95_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/2.%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%E6%B3%95/2%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%E6%B3%95_2.jpg" alt="测试">    </p>  </li>  <li>    <p>三重积分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/3.%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86/3%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/3.%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86/3%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/3.%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86/3%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86_3.jpg" alt="测试">    </p>  </li>  <li>    <p>重积分的应用<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/4.%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8/4%E9%87%8D%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/4.%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8/4%E9%87%8D%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8_2.jpg" alt="测试">    </p>  </li></ol><h3 id="第十一章-曲线积分与曲面积分"><a href="#第十一章-曲线积分与曲面积分" class="headerlink" title="第十一章 曲线积分与曲面积分"></a>第十一章  曲线积分与曲面积分</h3><ol>  <li>    <p>对弧长的曲线积分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/1.%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/1%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/1.%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/1%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86_2.jpg" alt="测试">    </p>  </li>  <li>    <p>对坐标的曲线积分</p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/2.%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/2%E5%AF%B9%E5%9D%90%E6%A0%87%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/2.%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/2%E5%AF%B9%E5%9D%90%E6%A0%87%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86_2.jpg" alt="测试"></p><ol start="3">  <li>    <p>格林公式及应用<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/3.%E6%A0%BC%E6%9E%97%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8/3%E6%A0%BC%E6%9E%97%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/3.%E6%A0%BC%E6%9E%97%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8/3%E6%A0%BC%E6%9E%97%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8_2.jpg" alt="测试">    </p>  </li>  <li>    <p>对面积的曲面积分</p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/4.%E5%AF%B9%E9%9D%A2%E7%A7%AF%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/4%E5%AF%B9%E9%9D%A2%E7%A7%AF%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86.jpg" alt="测试"></p><ol start="5">  <li>    <p>对坐标的曲面积分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/5.%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/5%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/5.%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/5%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86_2.jpg" alt="测试">    </p>  </li>  <li>    <p>高斯公式<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/6.%E9%AB%98%E6%96%AF%E5%85%AC%E5%BC%8F/6%E9%AB%98%E6%96%AF%E5%85%AC%E5%BC%8F.jpg" alt="测试">    </p>  </li>  <li>    <p>斯托克斯公式<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/7.%E6%96%AF%E6%89%98%E5%85%8B%E6%96%AF%E5%85%AC%E5%BC%8F/7%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%AF%E6%89%98%E5%85%8B%E6%96%AF%E5%85%AC%E5%BC%8F.jpg" alt="测试">    </p>  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三大基础数学复习&lt;/p&gt;
    
    </summary>
    
      <category term="数学基础" scheme="http://javastar.club/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数学基础" scheme="http://javastar.club/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火算法</title>
    <link href="http://javastar.club/archives/a0d601b7.html"/>
    <id>http://javastar.club/archives/a0d601b7.html</id>
    <published>2019-08-05T03:50:24.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>SA:python语言实现</p><a id="more"></a><h3 id="模拟退火算法-SimulatedAnnealing"><a href="#模拟退火算法-SimulatedAnnealing" class="headerlink" title="模拟退火算法(SimulatedAnnealing)"></a>模拟退火算法(SimulatedAnnealing)</h3><p>是基于Monte-Carlo迭代求解策略的一种随机寻优算法,主要用于组合优化问题的求解。<br>例如：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">f(x)=x^3-60*x^2-4*x+6</span><br></pre>      </td>    </tr>  </table></figure><p>  目标：求解在0到100范围内的最小值<br>数学方法一般求导计算.如果不求导计算，可能第一反应都是穷举法，把范围内每个值都算一遍再比较大小。如果求的是整数范围，那么要算100遍，但是如果要精确到小数后8位，则要算10000000000次，即便使用计算机依然是一个庞大的运算过程。而优化问题中很多都类似于问题，无法用穷举法解出答案，我们叫这类问题为NP难问题（可查看维基百科：NP-hard）</p><p>模拟退火算法，它是一种启发式搜索算法，即按照预定的控制策略进行搜索，在搜索过程中获取的中间信息将用来改进控制策略</p><ol>  <li>模拟退火算法的原理</li></ol><p><strong>1.1概念</strong></p><p>  模拟退火算法的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。</p><p>  模拟退火算法从某一高温出发，在高温状态下计算初始解，然后以预设的邻域函数产生一个扰动量，从而得到新的状态，即模拟粒子的无序运动，比较新旧状态下的能量，即目标函数的解。如果新状态的能量小于旧状态，则状态发生转化；如果新状态的能量大于旧状态，则以一定的概率准则发生转化。当状态稳定后，便可以看作达到了当前状态的最优解，便可以开始降温，在下一个温度继续迭代，最终达到低温的稳定状态，便得到了模拟退火算法产生的结果。</p><p><strong>1.2状态空间与邻域函数</strong></p><p>  状态空间也称为搜索空间，它由经过编码的可行解的集合所组成。而邻域函数应尽可能满足产生的候选解遍布全部状态空间。其通常由产生候选解的方式和候选解产生的概率分布组成。候选解一般按照某一概率密度函数对解空间进行随机采样获得，而概率分布可以为均匀分布、正态分布、指数分布等。</p><p><strong>1.3状态转移概率（Metropolis准则)</strong></p><p>状态转移概率是指从一个状态转换成另一个状态的概率，模拟退火算法中一般采用Metropolis准则<br><strong>1.4冷却进度表</strong></p><p>冷却进度表是指从某一高温状态T向低温状态冷却时的降温函数</p><p><strong>1.5初始温度</strong></p><p>一般来说，初始温度越大，获得高质量解的几率越大，但是花费的时间也会随之增加，因此，初温的确定应该同时考虑计算效率与优化质量，常用的方法包括：</p><p>(1)均匀抽样一组状态，以各状态目标值的方差为初温。</p><p>(2)随机产生一组状态，确定各状态间的最大目标值差，然后根据差值，利用一定的函数确定初温<br><strong>1.6循环终止准则</strong></p><p>内循环终止准则：</p><p>（1）检验目标函数的均值是否稳定</p><p>（2）连续若干步的目标值变化较小</p><p>（3）按一定的步数进行抽样</p><p>外循环终止准则</p><p>（1）设置终止温度</p><p>（2）设置外循环迭代次数</p><p>（3）算法搜索到的最优值连续若干步保持不变</p><p>（4）检验系统熵是否稳定</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SA:python语言实现&lt;/p&gt;
    
    </summary>
    
      <category term="SA" scheme="http://javastar.club/categories/SA/"/>
    
    
      <category term="SA" scheme="http://javastar.club/tags/SA/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法</title>
    <link href="http://javastar.club/archives/9cfaa3ca.html"/>
    <id>http://javastar.club/archives/9cfaa3ca.html</id>
    <published>2019-08-05T03:50:13.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>GA算法：Python实现</p><a id="more"></a><h3 id="GA"><a href="#GA" class="headerlink" title="GA"></a>GA</h3><p>遗传算法（Genetic  Algorithm)和模拟退火算法一样，也是搜索启发式算法的一种，它是借鉴了自然界优胜劣汰与适者生存的思想，通过模拟自然界这一过程来搜索最优解，在机器学习、组合优化等方面有广泛的用途。</p><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>遗传算法的组成主要包括4个部分：<br>（1）编码<br>（2）适应度函数<br>（3）遗传算子（选择，交叉，变异）<br>（4）运行参数 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GA算法：Python实现&lt;/p&gt;
    
    </summary>
    
      <category term="GA" scheme="http://javastar.club/categories/GA/"/>
    
    
      <category term="GA" scheme="http://javastar.club/tags/GA/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读笔记</title>
    <link href="http://javastar.club/archives/b6ab39d1.html"/>
    <id>http://javastar.club/archives/b6ab39d1.html</id>
    <published>2019-08-02T03:46:06.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>源代码阅读：基于JDK12.0，若有不对，请指正。</p><a id="more"></a><h1 id="ArrayList源码阅读"><a href="#ArrayList源码阅读" class="headerlink" title="ArrayList源码阅读"></a>ArrayList源码阅读</h1><p><strong>ArrayList简介</strong></p><ul>  <li>    <p>ArrayList 是一个数组队列，相当于 动态数组。</p>  </li>  <li>    <p>与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable,      java.io.Serializable这些接口。</p>  </li>  <li>    <p>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p>  </li>  <li>    <p>ArrayList      实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。    </p>  </li>  <li>    <p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p>  </li>  <li>    <p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输* 。</p>  </li>  <li>    <p>      和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。    </p>  </li></ul><h3 id="ArrayList属性"><a href="#ArrayList属性" class="headerlink" title="ArrayList属性"></a>ArrayList属性</h3><p>  ArrayList属性主要就是当前数组长度size，以及存放数组的对象elementData数组，除此之外还有一个经常用到的属性就是从AbstractList继承过来的modCount属性，代表ArrayList集合的修改次数。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">//序列化ID</span><br><span class="line">    private static final long serialVersionUID = 8683452581122892189L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Default initial capacity.</span><br><span class="line">       默认初始容量=10</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Shared empty array instance used for empty instances.</span><br><span class="line">       用于空实例的共享空数组实例</span><br><span class="line">     */</span><br><span class="line">    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      Shared empty array instance used for default sized empty instances. We</span><br><span class="line">      distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class="line">      first element is added.</span><br><span class="line">      共享空数组实例，用于默认大小的空实例。</span><br><span class="line">      我们将其与上面的EMPTY_ELEMENTDATA区分开来，当添加第一个元素时，我们将了解动态数组扩大了多少容量。</span><br><span class="line">      </span><br><span class="line">     */</span><br><span class="line">    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line">      The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line">      empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">      will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line">     存储ArrayList元素的数组缓冲区。</span><br><span class="line">     ArrayList的容量是这个数组缓冲区的长度。</span><br><span class="line">     任何空的ArrayList在使用时，如果 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">     那么在添加第一个元素时扩展为DEFAULT_CAPACITY=10  容量</span><br><span class="line">     */</span><br><span class="line">    transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line">    //非私有以简化嵌套类访问，当前数据对象存放地方，当前对象不参与序列化</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The size of the ArrayList (the number of elements it contains).</span><br><span class="line">     *ArrayList的大小(它包含的元素的数量)。</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    private int size;</span><br><span class="line"> /*Java中对象的序列化是指：将对象转换成以字节序列的形式来表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache(内存空间不够有可能会本地存储到硬盘)或远程调用rpc(网络传输)的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</span><br><span class="line">  只要某个类实现了Serilizable接口，这个类所有的属性和方法都会自动序列化。</span><br><span class="line">   transient</span><br><span class="line">   作用：让某些被修饰符的成员属性变量不被序列化。</span><br><span class="line">   什么时候可以使用该关键字呢？</span><br><span class="line">   1. 类中的字段值可以根据其他字段推导出来，如一个长方形类有三个属性：长、宽、面积。那么在序列化的时候，面积这个属性就没必要被序列化了。</span><br><span class="line">   2. 实际开发过程中，某些敏感信息不希望在网络中被传输，这些信息对应的变量就可以加上transient关键字。即，这个字段的生命周期仅存于调用者的内存中，而不会被写到磁盘里持久化。</span><br><span class="line">   总而言之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。*/</span><br><span class="line">    /**</span><br><span class="line">      The maximum size of array to allocate (unless necessary).</span><br><span class="line">      Some VMs reserve some header words in an array.</span><br><span class="line">      Attempts to allocate larger arrays may result in</span><br><span class="line">      OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">      要分配的数组的最大大小(除非必要)。</span><br><span class="line">      一些VM在数组中保留一些头信息。</span><br><span class="line">      尝试分配更大的数组可能会导致</span><br><span class="line">      OutOfMemoryError:请求的数组大小超过VM限制</span><br><span class="line">     */</span><br><span class="line">    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //省略了里面的方法</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="ArrayList构造函数"><a href="#ArrayList构造函数" class="headerlink" title="ArrayList构造函数"></a>ArrayList构造函数</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line">     * Constructs an empty list with the specified initial capacity.</span><br><span class="line">     </span><br><span class="line">       @param  initialCapacity  the initial capacity of the list</span><br><span class="line">       @throws IllegalArgumentException if the specified initial capacity</span><br><span class="line">             is negative</span><br><span class="line"></span><br><span class="line">构造具有指定初始容量的空列表。</span><br><span class="line">@param 参数 ：initialCapacity 列表的初始容量</span><br><span class="line">如果指定初始容量，@抛出IllegalArgumentException异常</span><br><span class="line">   带int类型的构造函数</span><br><span class="line">如果传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常，构造方法如下：</span><br><span class="line">     */</span><br><span class="line">    public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &gt; 0) &#123;</span><br><span class="line">            this.elementData = new Object[initialCapacity];</span><br><span class="line">        &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs an empty list with an initial capacity of ten.</span><br><span class="line">     构造一个初始容量为10的空列表。</span><br><span class="line">     注意：此时我们创建的ArrayList对象中的elementData中的长度是1，size是0,当进行第一次add的时候，elementData将会变成默认的长度：10.</span><br><span class="line">     无参构造函数</span><br><span class="line">     如果不传入参数，则使用默认无参构建方法创建ArrayList对象，如下：</span><br><span class="line">     */</span><br><span class="line">    public ArrayList() &#123;</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs a list containing the elements of the specified</span><br><span class="line">       collection, in the order they are returned by the collection&apos;s</span><br><span class="line">       iterator.</span><br><span class="line">     </span><br><span class="line">      @param c the collection whose elements are to be placed into this list</span><br><span class="line">      @throws NullPointerException if the specified collection is null</span><br><span class="line"></span><br><span class="line">      构造一个包含指定元素的列表</span><br><span class="line">      集合，按照顺序，它们将通过集合迭代器返回。</span><br><span class="line">     @param参数： c集合，它的元素将被放置到这个列表中</span><br><span class="line">       如果指定的集合为空，@抛出NullPointerException</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">带Collection对象的构造函数:</span><br><span class="line">1）将collection对象转换成数组，然后将数组的地址的赋给elementData。</span><br><span class="line">2）更新size的值，同时判断size的大小，如果是size等于0，直接将空对象EMPTY_ELEMENTDATA的地址赋给elementData</span><br><span class="line">3）如果size的值大于0，则执行Arrays.copyOf方法，把collection对象的内容（可以理解为深拷贝）copy到elementData中。</span><br><span class="line"></span><br><span class="line">注意：this.elementData = arg0.toArray(); 这里执行的简单赋值时浅拷贝，所以要执行Arrays.copyOf() 做深拷贝</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">    public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        if ((size = elementData.length) != 0) &#123;</span><br><span class="line"></span><br><span class="line">            // defend against c.toArray (incorrectly) not returning Object[]</span><br><span class="line">            // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)</span><br><span class="line"></span><br><span class="line">            if (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // replace with empty array.</span><br><span class="line"></span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>遇到的问题：</strong><br>？是“任意类”的意思，extends继承不多说，E是指定类型。<br>E是element  元素,用来定义泛型,可以不写,但是取值的时候要强转,用了泛型就不需要强转(强制类型转换) </p><p>首先，E是泛型。这是java 1.5以后引入的。<br>从此以后，定义一个空的ArrayList需要这样，比如我需要一个MyClass的顺序表，则：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ArrayList&lt;MyClass&gt; myList = new ArrayList&lt;MyClass&gt;();</span><br></pre>      </td>    </tr>  </table></figure><p>这是因为ArrayList类的声明是public class ArrayList<e>。</e></p><p>而此时，MyClass就是“指定类型”E了，意味着所有ArrayList类中声明的E, 换成了MyClass。</p><p>同理如果要使用public ArrayList(Collection&lt;? extends E&gt; c)来构造一个ArrayList，则：</p><p>如我有MySubClass是MyClass的子类。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Collection&lt;MyClass&gt; myCollection; //myCollection里有很多元素。</span><br><span class="line">Collection&lt;MySubClass&gt; mySubCollection; //mySubCollection里有很多元素。</span><br><span class="line">ArrayList&lt;MyClass&gt; myList = new ArrayList&lt;MyClass&gt;(myCollection);</span><br></pre>      </td>    </tr>  </table></figure><p>也可以：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ArrayList&lt;MyClass&gt; myList = new ArrayList&lt;MyClass&gt;(mySubCollection);</span><br></pre>      </td>    </tr>  </table></figure><p>意思是，凡是MyClass或者MyClass的子类的Collection均可以构造成ArrayList<myclass></myclass></p><h3 id="ArrayList的add方法"><a href="#ArrayList的add方法" class="headerlink" title="ArrayList的add方法"></a>ArrayList的add方法</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line">      This helper method split out from add(E) to keep method</span><br><span class="line">      bytecode size under 35 (the -XX:MaxInlineSize default value),</span><br><span class="line">      which helps when add(E) is called in a C1-compiled loop.</span><br><span class="line">这个helper方法从add(E)中分离出来以保留方法</span><br><span class="line">字节码大小小于35 (-XX:MaxInlineSize默认值)，</span><br><span class="line">这有助于在c1编译的循环中调用add(E)。</span><br><span class="line">     */</span><br><span class="line">    private void add(E e, Object[] elementData, int s) &#123;</span><br><span class="line">        if (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">        elementData[s] = e;</span><br><span class="line">        size = s + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      Appends the specified element to the end of this list.</span><br><span class="line">     </span><br><span class="line">      @param e element to be appended to this list</span><br><span class="line">      @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"></span><br><span class="line">      将指定的元素追加到此列表的末尾。</span><br><span class="line">      要添加到此列表中的@param e元素</span><br><span class="line">     @return &#123;@code true&#125;(由&#123;@link Collection#add&#125;指定)</span><br><span class="line">     */</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        add(e, elementData, size);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      Inserts the specified element at the specified position in this</span><br><span class="line">      list. Shifts the element currently at that position (if any) and</span><br><span class="line">      any subsequent elements to the right (adds one to their indices).</span><br><span class="line">     </span><br><span class="line">     @param index index at which the specified element is to be inserted</span><br><span class="line">     @param element element to be inserted</span><br><span class="line">     @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">     将指定元素插入其中的指定位置</span><br><span class="line">    列表。将当前位于该位置(如果有)的元素移动，并</span><br><span class="line">     右边的任何后续元素(将一个元素添加到它们的索引中)。</span><br><span class="line">    @param索引要插入指定元素的索引</span><br><span class="line">    要插入的@param元素</span><br><span class="line">     @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">     /</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        modCount++;</span><br><span class="line">        final int s;</span><br><span class="line">        Object[] elementData;</span><br><span class="line">        if ((s = size) == (elementData = this.elementData).length)</span><br><span class="line">            elementData = grow();</span><br><span class="line">        System.arraycopy(elementData, index,</span><br><span class="line">                         elementData, index + 1,</span><br><span class="line">                         s - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size = s + 1;</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源代码阅读：基于JDK12.0，若有不对，请指正。&lt;/p&gt;
    
    </summary>
    
      <category term="源代码" scheme="http://javastar.club/categories/%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JDK" scheme="http://javastar.club/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>nginx核心知识</title>
    <link href="http://javastar.club/archives/9015eb1.html"/>
    <id>http://javastar.club/archives/9015eb1.html</id>
    <published>2019-08-01T06:07:11.000Z</published>
    <updated>2019-08-07T07:14:52.720Z</updated>
    
    <content type="html"><![CDATA[<p>nginx学习入门</p><a id="more"></a><h3 id="Nginx的三个主要应用场景"><a href="#Nginx的三个主要应用场景" class="headerlink" title="Nginx的三个主要应用场景"></a>Nginx的三个主要应用场景</h3><ul>  <li>静态资源服务：通过本地文件系统提供服务</li>  <li>反向代理服务：Nginx的强大性能、缓存、负载均衡</li>  <li>API服务：OpenResty</li></ul><h3 id="Nginx的主要优点"><a href="#Nginx的主要优点" class="headerlink" title="Nginx的主要优点"></a>Nginx的主要优点</h3><ol>  <li>高并发、高性能</li>  <li>可扩展性好</li>  <li>高可靠性</li>  <li>热部署</li>  <li>BSD许可证</li></ol><h3 id="Nginx的组成"><a href="#Nginx的组成" class="headerlink" title="Nginx的组成"></a>Nginx的组成</h3><ol>  <li>Nginx二进制可执行文件：由各模块源码编译出的一个文件</li>  <li>Nginx.conf配置文件：控制Nginx的行为</li>  <li>access.log访问日志：记录每一条http请求信息</li>  <li>error.log错误日志：定位问题</li></ol><h3 id="Nginx配置语法"><a href="#Nginx配置语法" class="headerlink" title="Nginx配置语法"></a>Nginx配置语法</h3><ol>  <li>配置文件由指令和指令块构成</li>  <li>每条指令以；分号结尾，指令与参数间以空格符号分隔。</li>  <li>使用$符号使用变量</li>  <li>使用#符号添加注释</li>  <li>指令块以{}大括号将多条指令组织在一起</li>  <li>include语句允许组合多个配置文件以提高可维护性</li>  <li>部分指令的参数支持正则表达式</li></ol><h3 id="Nginx语法示例"><a href="#Nginx语法示例" class="headerlink" title="Nginx语法示例"></a>Nginx语法示例</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">http&#123;</span><br><span class="line">include mime.types;</span><br><span class="line">upstream thwp&#123;</span><br><span class="line">server 127.0.0.1:8000;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">listen 443 http2;</span><br><span class="line">#Nginx配置语法</span><br><span class="line">limit_req_zone $binary_remote_addr Zone=one:10m rate=1r/s;</span><br><span class="line">location ~* \.(gir|jpg|jpeg)$ &#123;</span><br><span class="line">proxy_cache my_cache;</span><br><span class="line">expires 3m;proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">proxy_cache_valid 200 304 302 1d;</span><br><span class="line">proxy_pass http://javastar.club;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p><strong>时间的单位</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ms:milliseconds</span><br><span class="line">d:days</span><br><span class="line">s:seconds</span><br><span class="line">w:weeks</span><br><span class="line">m:minutes</span><br><span class="line">h:hours</span><br><span class="line">M:months,30days</span><br><span class="line">y:years,365days</span><br></pre>      </td>    </tr>  </table></figure><p><strong>空间的单位</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">    bytes</span><br><span class="line">k/K:kilobytes</span><br><span class="line">m/M:megabytes</span><br><span class="line">g/G:gigabytes</span><br></pre>      </td>    </tr>  </table></figure><h3 id="Nginx命令行"><a href="#Nginx命令行" class="headerlink" title="Nginx命令行"></a>Nginx命令行</h3><ol>  <li>格式：nginx -s reload</li>  <li>帮助：-? -h</li>  <li>使用指定的配置文件： -c</li>  <li>指定配置指令：-g</li>  <li>指定运行目录：-p</li>  <li>发送信号：-s (立刻停止服务： stop 优雅的停止服务： quit 重载配置文件： reload 重新开始记录日志文件：reopen)</li>  <li>测试配置文件是否有语法错误：-t -T</li>  <li>打印nginx的版本信息、编译信息等：-v -V</li></ol><h3 id="SSL-Secure-Sockets-Layer-TLS-Transport-Layer-Security"><a href="#SSL-Secure-Sockets-Layer-TLS-Transport-Layer-Security" class="headerlink" title="SSL(Secure Sockets Layer) TLS(Transport Layer Security)"></a>SSL(Secure  Sockets Layer) TLS(Transport Layer Security)</h3><p>  <strong>ISO/OSI模型</strong><br>应用层<br>表示层<br>会话层<br>传输层<br>网络层<br>数据链路层<br>物理层<br><strong>TCP/IP模型</strong><br>应用层<br>传输层<br>网络层<br>链路层<br><strong>TLS安全密码套件</strong></p><p>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</p><p>ECDHE:密钥交换算法<br>RSA：身份验证算法<br>AES_128_GCM:对称加密算法、强度、分组模式<br>SHA256:签名hash算法</p><h3 id="PKI公钥基础设施"><a href="#PKI公钥基础设施" class="headerlink" title="PKI公钥基础设施"></a>PKI公钥基础设施</h3><p>证书签名申请(request certificate issuance,CSR)<br>证书类型：<br>域名验证(domain  validated,DV)证书<br>组织验证(organization validated,OV)证书<br>扩展验证(extended  validation,EV)证书<br>证书链</p><h3 id="TLS通讯过程"><a href="#TLS通讯过程" class="headerlink" title="TLS通讯过程"></a>TLS通讯过程</h3><ol>  <li>验证身份</li>  <li>达成安全套件共识</li>  <li>传递密钥</li>  <li>加密通讯</li></ol><h3 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h3><p>Nginx 是一款轻量级的 Web （HTTP）服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器<br>优势：能支持高达 50,000  个并发连接数 ；支持热部署 ；很高的稳定性（抵御dos攻击）</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p> 在 unix 系统中会以 daemon （守护进程）的方式在后台运行，后台进程包含一个 master 进程和多个 worker  进程（多进程的工作方式）<br> 1、多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。</p><p>2、一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。</p><p>3、推荐设置 worker 的个数为 cpu 的核数</p><p>4、异步非阻塞 （非阻塞不会让出cpu导致切换浪费）</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>1、connection</strong></p><p>是对 tcp 连接的封装;</p><p>Nginx 通过设置 worker_connectons 来设置每个worker进程支持的最大连接数;</p><p>Nginx 能建立的最大连接数，应该是worker_connections * worker_processes;对于 HTTP  请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，而如果是 HTTP  作为反向代理来说，最大并发数量应该是worker_connections *  worker_processes/2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p><p><strong>2、request</strong></p><p>Nginx 中指 http 请求;</p><p>web服务器工作流：http 请求是典型的请求-响应类型的的网络协议，而 http  是文本协议，所以我们在分析请求行与请求头，以及输出响应行与响应头，往往是一行一行的进行处理。如果我们自己来写一个 http  服务器，通常在一个连接建立好后，客户端会发送请求过来。然后我们读取一行数据，分析出请求行中包含的 method、uri、http_version  信息。然后再一行一行处理请求头，并根据请求 method  与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。在将响应发送给客户端之后，一个完整的请求就处理完了。</p><p><strong>3、keepalive</strong></p><p>长连接: http 请求是基于 TCP 协议之上的，那么，当客户端在发起请求前，需要先与服务端建立 TCP 连接(三次握手)，当连接断开后（四次挥手）。而  http  请求是请求应答式的，如果我们能知道每个请求头与响应体的长度，那么我们是可以在一个连接上面执行多个请求的，这就是所谓的长连接，但前提条件是我们先得确定请求头与响应体的长度。对于请求来说，如果当前请求需要有body，如  POST 请求，那么 Nginx 就需要客户端在请求头中指定 content-length 来表明 body 的大小，否则返回 400  错误。也就是说，请求体的长度是确定的，那么响应体的长度呢？先来看看 http 协议中关于响应 body 长度的确定：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">对于 http1.0 协议来说，如果响应头中有 content-length 头，则以 content-length 的长度就可以知道 body 的长度了，客户端在接收 body 时，就可以依照这个长度来接收数据，接收完后，就表示这个请求完成了。而如果没有 content-length 头，则客户端会一直接收数据，直到服务端主动断开连接，才表示 body 接收完了。</span><br><span class="line">而对于 http1.1 协议来说，如果响应头中的 Transfer-encoding 为 chunked 传输，则表示 body 是流式输出，body 会被分成多个块，每块的开始会标识出当前块的长度，此时，body 不需要通过长度来指定。如果是非 chunked 传输，而且有 content-length，则按照 content-length 来接收数据。否则，如果是非 chunked，并且没有 content-length，则客户端接收数据，直到服务端主动断开连接。</span><br></pre>      </td>    </tr>  </table></figure><p>从上面，我们可以看到，除了 http1.0 不带 content-length 以及 http1.1 非 chunked 不带  content-length 外，body 的长度是可知的。此时，当服务端在输出完 body  之后，会可以考虑使用长连接。能否使用长连接，也是有条件限制的。如果客户端的请求头中的 connection为close，则表示客户端需要关掉长连接，如果为  keep-alive，则客户端需要打开长连接，如果客户端的请求中没有 connection 这个头，那么根据协议，如果是 http1.0，则默认为  close，如果是 http1.1，则默认为 keep-alive。如果结果为 keepalive，那么，Nginx 在输出完响应体后，会设置当前连接的  keepalive 属性，然后等待客户端下一次请求。当然，Nginx 不可能一直等待下去，如果客户端一直不发数据过来，岂不是一直占用这个连接？所以当  Nginx 设置了 keepalive 等待下一次的请求时，同时也会设置一个最大等待时间，这个时间是通过选项 keepalive_timeout  来配置的，如果配置为 0，则表示关掉 keepalive，此时，http 版本无论是 1.1 还是 1.0，客户端的 connection 不管是  close 还是 keepalive，都会强制为 close。</p><p>如果服务端最后的决定是 keepalive 打开，那么在响应的 http 头里面，也会包含有 connection  头域，其值是”Keep-Alive”，否则就是”Close”。如果 connection 值为 close，那么在 Nginx  响应完数据后，会主动关掉连接。所以，对于请求量比较大的 Nginx 来说，关掉 keepalive 最后会产生比较多的 time-wait 状态的  socket。一般来说，当客户端的一次访问，需要多次访问同一个 server 时，打开 keepalive  的优势非常大，比如图片服务器，通常一个网页会包含很多个图片。打开 keepalive 也会大量减少 time-wait 的数量。</p><p><strong>4、pipe</strong></p><p>http1.1 引入新特性,keepalive 的一种升华，基于长连接的，目的就是利用一个连接做多次请求;</p><p>对 pipeline 来说，客户端不必等到第一个请求处理完后，就可以马上发起第二个请求;</p><p><strong>5、linger_close</strong></p><p>延迟关闭，也就是说，当 Nginx 要关闭连接时，并非立即关闭连接，而是先关闭 tcp 连接的写，再等待一段时间后再关掉连接的读。</p><h3 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h3><p><strong>1、nginx.conf</strong></p><p>指令上下文：</p><pre><code>main: Nginx 在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。http: 与提供 http 服务相关的一些配置参数。例如：是否使用 keepalive 啊，是否使用gzip进行压缩等。server: http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server，每个 server 通过监听的地址来区分。location: http 服务中，某些特定的URL对应的一系列配置项。mail: 实现 email 相关的 SMTP/IMAP/POP3 代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。</code></pre><p>示例：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre>      </td>      <td class="code">        <pre><span class="line">worker_processes 1;      //一般设置为cpu核数</span><br><span class="line"></span><br><span class="line">error_log logs/error.log error;</span><br><span class="line">pid logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">　　worker_connections 1024;     //每个worker的最大连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">　　include mime.types;</span><br><span class="line">　　default_type application/octet-stream;</span><br><span class="line">　　sendfile on;</span><br><span class="line">　　tcp_nopush on;</span><br><span class="line">　　server_names_hash_bucket_size 128;</span><br><span class="line">　　keepalive_timeout 1800s;      //支持长连接</span><br><span class="line"></span><br><span class="line">　　client_max_body_size 0;</span><br><span class="line"></span><br><span class="line">　　proxy_connect_timeout 5s;</span><br><span class="line">　　proxy_read_timeout 1800s;</span><br><span class="line"></span><br><span class="line">　　proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">　　proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">　　proxy_set_header Host $http_host;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     upstream web_vmaxfmproxy_pool &#123; server 10.43.136.220:27430; &#125;</span><br><span class="line">     upstream web_vmaxdatacheck_pool &#123; server 10.43.136.220:27340; &#125;</span><br><span class="line"></span><br><span class="line">　　server &#123;</span><br><span class="line">　　　　listen 28888;</span><br><span class="line">           server_name web_web_pool;</span><br><span class="line">　　　　location ~ ^/web/cometd &#123;</span><br><span class="line">                     proxy_pass http://web_web_pool;</span><br><span class="line">                     proxy_http_version 1.1;</span><br><span class="line">                     proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">                     proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　     location / &#123;</span><br><span class="line">　　　　　　if ($uri ~ ^/vmaxfmproxy/)&#123; proxy_pass http://web_vmaxfmproxy_pool; break; &#125;</span><br><span class="line">　　　　　　if ($uri ~ ^/vmaxdatacheck/)&#123; proxy_pass http://web_vmaxdatacheck_pool; break; &#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　location /rdk/service &#123;</span><br><span class="line">　　　　　　proxy_pass http://localhost:5555;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　location ~ /rdk/app/(?&lt;section&gt;.*) &#123;</span><br><span class="line">　　　　　　proxy_pass http://web_rdk_server_pool/rdk_server/app/$section;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　location /web/res/web-framework/default.html &#123;</span><br><span class="line">　　　　　　rewrite /web/res/web-framework/default.html /rdk/app/portal/web/index.html permanent;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="五、nginx模块"><a href="#五、nginx模块" class="headerlink" title="五、nginx模块"></a>五、nginx模块</h3><pre><code>event module: 搭建了独立于操作系统的事件处理机制的框架，及提供了各具体事件的处理。包括 ngx_events_module， ngx_event_core_module和ngx_epoll_module 等。Nginx 具体使用何种事件处理模块，这依赖于具体的操作系统和编译选项。phase handler: 此类型的模块也被直接称为 handler 模块。主要负责处理客户端请求并产生待响应内容，比如 ngx_http_static_module 模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。output filter: 也称为 filter 模块，主要是负责对输出的内容进行处理，可以对输出进行修改。例如，可以实现对输出的所有 html 页面增加预定义的 footbar 一类的工作，或者对输出的图片的 URL 进行替换之类的工作。upstream: upstream 模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream 模块是一种特殊的 handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。load-balancer: 负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器。</code></pre><h3 id="六、nginx-请求过程"><a href="#六、nginx-请求过程" class="headerlink" title="六、nginx 请求过程"></a>六、nginx  请求过程</h3><p>所有实际上的业务处理逻辑都在 worker 进程。worker 进程中有一个函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个  Nginx 服务被停止。</p><p>worker 进程中，ngx_worker_process_cycle()函数就是这个无限循环的处理函数。在这个函数中，一个请求的简单处理流程如下：</p><pre><code>操作系统提供的机制（例如 epoll, kqueue 等）产生相关的事件。接收和处理这些事件，如是接受到数据，则产生更高层的 request 对象。处理 request 的 header 和 body。产生响应，并发送回客户端。完成 request 的处理。重新初始化定时器及其他事件。</code></pre><p>为了让大家更好的了解 Nginx 中请求处理过程，我们以 HTTP Request 为例，来做一下详细地说明。</p><p>从 Nginx 的内部来看，一个 HTTP Request 的处理过程涉及到以下几个阶段。</p><pre><code>初始化 HTTP Request（读取来自客户端的数据，生成 HTTP Request 对象，该对象含有该请求所有的信息）。处理请求头。处理请求体。如果有的话，调用与此请求（URL 或者 Location）关联的 handler。依次调用各 phase handler 进行处理。</code></pre><p>在这里，我们需要了解一下 phase handler 这个概念。phase 字面的意思，就是阶段。所以 phase handlers  也就好理解了，就是包含若干个处理阶段的一些 handler。</p><p>在每一个阶段，包含有若干个 handler，再处理到某个阶段的时候，依次调用该阶段的 handler 对 HTTP Request 进行处理。</p><p>通常情况下，一个 phase handler 对这个 request 进行处理，并产生一些输出。通常 phase handler  是与定义在配置文件中的某个 location 相关联的。</p><p>一个 phase handler 通常执行以下几项任务：</p><pre><code>获取 location 配置。产生适当的响应。发送 response header。发送 response body。</code></pre><p>当 Nginx 读取到一个 HTTP Request 的 header 的时候，Nginx  首先查找与这个请求关联的虚拟主机的配置。如果找到了这个虚拟主机的配置，那么通常情况下，这个 HTTP Request 将会经过以下几个阶段的处理（phase  handlers）：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line">NGX_HTTP_POST_READ_PHASE: 读取请求内容阶段</span><br><span class="line">NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段</span><br><span class="line">NGX_HTTP_FIND_CONFIG_PHASE: 配置查找阶段:</span><br><span class="line">NGX_HTTP_REWRITE_PHASE: Location请求地址重写阶段</span><br><span class="line">NGX_HTTP_POST_REWRITE_PHASE: 请求地址重写提交阶段</span><br><span class="line">NGX_HTTP_PREACCESS_PHASE: 访问权限检查准备阶段</span><br><span class="line">NGX_HTTP_ACCESS_PHASE: 访问权限检查阶段</span><br><span class="line">NGX_HTTP_POST_ACCESS_PHASE: 访问权限检查提交阶段</span><br><span class="line">NGX_HTTP_TRY_FILES_PHASE: 配置项 try_files 处理阶段</span><br><span class="line">NGX_HTTP_CONTENT_PHASE: 内容产生阶段</span><br><span class="line">NGX_HTTP_LOG_PHASE: 日志模块处理阶段</span><br></pre>      </td>    </tr>  </table></figure><p>在内容产生阶段，为了给一个 request 产生正确的响应，Nginx 必须把这个 request 交给一个合适的 content handler  去处理。如果这个 request 对应的 location 在配置文件中被明确指定了一个 content handler，那么Nginx 就可以通过对  location 的匹配，直接找到这个对应的 handler，并把这个 request 交给这个 content handler  去处理。这样的配置指令包括像，perl，flv，proxy_pass，mp4等。</p><p>如果一个 request 对应的 location 并没有直接有配置的 content handler，那么 Nginx 依次尝试:</p><pre><code>如果一个 location 里面有配置 random_index on，那么随机选择一个文件，发送给客户端。如果一个 location 里面有配置 index 指令，那么发送 index 指令指明的文件，给客户端。如果一个 location 里面有配置 autoindex on，那么就发送请求地址对应的服务端路径下的文件列表给客户端。如果这个 request 对应的 location 上有设置 gzip_static on，那么就查找是否有对应的.gz文件存在，有的话，就发送这个给客户端（客户端支持 gzip 的情况下）。请求的 URI 如果对应一个静态文件，static module 就发送静态文件的内容到客户端。</code></pre><p>内容产生阶段完成以后，生成的输出会被传递到 filter 模块去进行处理。filter 模块也是与 location 相关的。所有的 fiter  模块都被组织成一条链。输出会依次穿越所有的 filter，直到有一个 filter 模块的返回值表明已经处理完成。</p><p>这里列举几个常见的 filter 模块，例如：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">server-side includes。</span><br><span class="line">XSLT filtering。</span><br><span class="line">图像缩放之类的。</span><br><span class="line">gzip 压缩。</span><br></pre>      </td>    </tr>  </table></figure><p>在所有的 filter 中，有几个 filter 模块需要关注一下。按照调用的顺序依次说明如下：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">write: 写输出到客户端，实际上是写到连接对应的 socket 上。</span><br><span class="line">postpone: 这个 filter 是负责 subrequest 的，也就是子请求的。</span><br><span class="line">copy: 将一些需要复制的 buf(文件或者内存)重新复制一份然后交给剩余的 body filter 处理。</span><br></pre>      </td>    </tr>  </table></figure><h3 id="七、upstream模块"><a href="#七、upstream模块" class="headerlink" title="七、upstream模块"></a>七、upstream模块</h3><p><strong>1、upstream 模块</strong></p><p>将使 Nginx 跨越单机的限制，完成网络数据的接收、处理和转发。</p><p>数据转发功能，为 Nginx 提供了跨越单机的横向处理能力，使 Nginx  摆脱只能为终端节点提供单一功能的限制，而使它具备了网路应用级别的拆分、封装和整合的战略功能。<br>在云模型大行其道的今天，数据转发是 Nginx  有能力构建一个网络应用的关键组件。</p><p>upstream 属于 handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容，所以才称为  upstream（上游）。<br>请求并取得响应内容的整个过程已经被封装到 Nginx 内部，所以 upstream  模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。</p><p><strong>2、负载均衡模块</strong></p><p>负载均衡模块用于从upstream指令定义的后端主机列表中选取一台主机。</p><p>Nginx 先使用负载均衡模块找到一台主机，再使用 upstream 模块实现与这台主机的交互。</p><p>如果需要使用 ip hash 的负载均衡算法：</p><p>示例 :</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre>      </td>      <td class="code">        <pre><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/error.log  error;</span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;   </span><br><span class="line">    sendfile       on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line">    server_names_hash_bucket_size 128;  </span><br><span class="line">    keepalive_timeout  600s;</span><br><span class="line">    proxy_connect_timeout 5s;</span><br><span class="line">    proxy_read_timeout 600s;</span><br><span class="line">    </span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line"></span><br><span class="line">    upstream lw_web_rdk_server_pool &#123;</span><br><span class="line">         server  10.43.149.160:26180  weight=1;</span><br><span class="line"></span><br><span class="line">         server  10.43.136.220:5812  weight=1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen  26188;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        location /&#123;</span><br><span class="line">        proxy_pass  http://lw_web_rdk_server_pool;</span><br><span class="line">        proxy_redirect default;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">       listen  26185;</span><br><span class="line">       server_name localhost;</span><br><span class="line">       location /rdk/service &#123;</span><br><span class="line">                            proxy_pass http://localhost:5812;</span><br><span class="line">                    &#125;</span><br><span class="line">       location / &#123;</span><br><span class="line">        root   ../../;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="Nginx源码剖析，本次代码分析主要基于nginx-1-17-2版本"><a href="#Nginx源码剖析，本次代码分析主要基于nginx-1-17-2版本" class="headerlink" title="Nginx源码剖析，本次代码分析主要基于nginx-1.17.2版本"></a>Nginx源码剖析，本次代码分析主要基于nginx-1.17.2版本</h2><p>Nginx的源码主要分布在src/目录下，而src/目录下主要包含三部分比较重要的模块。</p><ol>  <li>    <p>core：包含了Nginx的最基础的库和框架。包括了内存池、链表、hashmap、String等常用的数据结构。</p>  </li>  <li>    <p>      event：事件模块。Nginx自己实现了事件模型。而我们所熟悉的Memcached是使用了Libevent的事件库。自己实现event会性能和效率方便更加高效。    </p>  </li>  <li>    <p>http：实现HTTP的模块。实现了HTTP的具体协议的各种模块，该部分内容量比较大。</p>  </li></ol><h3 id="Nginx架构"><a href="#Nginx架构" class="headerlink" title="Nginx架构"></a>Nginx架构</h3><p>Nginx是一款多进程的软件。Nginx启动后，会产生一个master进程和N个工作进程。其中nginx.conf中可以配置工作进程的个数：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">worker_processes  1;</span><br></pre>      </td>    </tr>  </table></figure><p>多进程模块有一个非常大的好处，就是不需要太多考虑并发锁的问题。</p><p>  Nginx的内存管理是通过内存池来实现的。Nginx的内存池的设计非常的精巧，很多场景下，我们可以将Nginx的内存池实现抽象出来改造成我们开发中的内存池。</p><h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>一般我们使用malloc/alloc/free等函数来分配和释放内存。但是直接使用这些函数会有一些弊端：</p><ol>  <li>    <p>      虽然系统自带的ptmalloc内存分配管理器，也有自己的内存优化管理方案（申请内存块以及将内存交还给系统都有自己的优化方案，具体可以研究一下ptmalloc的源码），但是直接使用malloc/alloc/free，仍然会导致内存分配的性能比较低。    </p>  </li>  <li>    <p>      频繁使用这些函数分配和释放内存，会导致内存碎片，不容易让系统直接回收内存。典型的例子就是大并发频繁分配和回收内存，会导致进程的内存产生碎片，并且不会立马被系统回收。    </p>  </li>  <li>    <p>容易产生内存泄露。</p>  </li></ol><p>使用内存池分配内存有几点好处：</p><ol>  <li>    <p>提升内存分配效率。不需要每次分配内存都执行malloc/alloc等函数。</p>  </li>  <li>    <p>让内存的管理变得更加简单。内存的分配都会在一块大的内存上，回收的时候只需要回收大块内存就能将所有的内存回收，防止了内存管理混乱和内存泄露问题。    </p>  </li></ol><h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>先看ngx_palloc.h里面的结构体定义：<br><strong>ngx_pool_t 内存池主结构</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * Nginx 内存池数据结构</span><br><span class="line"> */</span><br><span class="line">struct ngx_pool_s &#123;</span><br><span class="line">    ngx_pool_data_t       d;        /* 内存池的数据区域*/</span><br><span class="line">    size_t                max;      /* 最大每次可分配内存 */</span><br><span class="line">    ngx_pool_t           *current;  /* 指向当前的内存池指针地址。ngx_pool_t链表上最后一个缓存池结构*/</span><br><span class="line">    ngx_chain_t          *chain;    /* 缓冲区链表 */</span><br><span class="line">    ngx_pool_large_t     *large;    /* 存储大数据的链表 */</span><br><span class="line">    ngx_pool_cleanup_t   *cleanup;  /* 可自定义回调函数，清除内存块分配的内存 */</span><br><span class="line">    ngx_log_t            *log;      /* 日志 */</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>ngx_pool_data_t 数据区域结构</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">typedef struct &#123;</span><br><span class="line">    u_char               *last;  /* 内存池中未使用内存的开始节点地址 */</span><br><span class="line">    u_char               *end;   /* 内存池的结束地址 */</span><br><span class="line">    ngx_pool_t           *next;  /* 指向下一个内存池 */</span><br><span class="line">    ngx_uint_t            failed;/* 失败次数 */</span><br><span class="line">&#125; ngx_pool_data_t;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>ngx_pool_large_t 大数据块结构</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">struct ngx_pool_large_s &#123;</span><br><span class="line">    ngx_pool_large_t     *next;   /* 指向下一个存储地址 通过这个地址可以知道当前块长度 */</span><br><span class="line">    void                 *alloc;  /* 数据块指针地址 */</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>ngx_pool_cleanup_t 自定义清理回调的数据结构</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">struct ngx_pool_cleanup_s &#123;</span><br><span class="line">    ngx_pool_cleanup_pt   handler;  /* 清理的回调函数 */</span><br><span class="line">    void                 *data;     /* 指向存储的数据地址 */</span><br><span class="line">    ngx_pool_cleanup_t   *next;     /* 下一个ngx_pool_cleanup_t */</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure><ol>  <li>    <p>      Nginx的内存池会放在ngx_pool_t的数据结构上（ngx_pool_data_t用于记录内存块block的可用地址空间和内存块尾部）。当初始化分配的内存块大小不能满足需求的时候，Nginx就会调用ngx_palloc_block函数来分配一个新的内存块，通过链表的形式连接起来。    </p>  </li>  <li>    <p>      当申请的内存大于pool-&gt;max的值的时候，Nginx就会单独分配一块large的内存块，会放置在pool-&gt;large的链表结构上。    </p>  </li>  <li>    <p>pool-&gt;cleanup的链表结构主要存放需要通过回调函数清理的内存数据。（例如文件描述符）</p>  </li></ol><h3 id="创建内存池ngx-create-pool"><a href="#创建内存池ngx-create-pool" class="headerlink" title="创建内存池ngx_create_pool"></a>创建内存池ngx_create_pool</h3><p>调用ngx_create_pool这个方法就可以创建一个内存池。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 创建一个内存池</span><br><span class="line"> */</span><br><span class="line">ngx_pool_t *</span><br><span class="line">ngx_create_pool(size_t size, ngx_log_t *log) &#123;</span><br><span class="line">    ngx_pool_t *p;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 相当于分配一块内存 ngx_alloc(size, log)</span><br><span class="line">     */</span><br><span class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Nginx会分配一块大内存，其中内存头部存放ngx_pool_t本身内存池的数据结构</span><br><span class="line">     * ngx_pool_data_t  p-&gt;d 存放内存池的数据部分（适合小于p-&gt;max的内存块存储）</span><br><span class="line">     * p-&gt;large 存放大内存块列表</span><br><span class="line">     * p-&gt;cleanup 存放可以被回调函数清理的内存块（该内存块不一定会在内存池上面分配）</span><br><span class="line">     */</span><br><span class="line">    p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t); //内存开始地址，指向ngx_pool_t结构体之后数据取起始位置</span><br><span class="line">    p-&gt;d.end = (u_char *) p + size; //内存结束地址</span><br><span class="line">    p-&gt;d.next = NULL; //下一个ngx_pool_t 内存池地址</span><br><span class="line">    p-&gt;d.failed = 0; //失败次数</span><br><span class="line"> </span><br><span class="line">    size = size - sizeof(ngx_pool_t);</span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"> </span><br><span class="line">    /* 只有缓存池的父节点，才会用到下面的这些  ，子节点只挂载在p-&gt;d.next,并且只负责p-&gt;d的数据内容*/</span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = NULL;</span><br><span class="line">    p-&gt;large = NULL;</span><br><span class="line">    p-&gt;cleanup = NULL;</span><br><span class="line">    p-&gt;log = log;</span><br><span class="line"> </span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="销毁内存池ngx-destroy-pool"><a href="#销毁内存池ngx-destroy-pool" class="headerlink" title="销毁内存池ngx_destroy_pool"></a>销毁内存池ngx_destroy_pool</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 销毁内存池。</span><br><span class="line"> */</span><br><span class="line">void ngx_destroy_pool(ngx_pool_t *pool) &#123;</span><br><span class="line">    ngx_pool_t *p, *n;</span><br><span class="line">    ngx_pool_large_t *l;</span><br><span class="line">    ngx_pool_cleanup_t *c;</span><br><span class="line"> </span><br><span class="line">    /* 首先清理pool-&gt;cleanup链表 */</span><br><span class="line">    for (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        /* handler 为一个清理的回调函数 */</span><br><span class="line">        if (c-&gt;handler) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,</span><br><span class="line">                    &quot;run cleanup: %p&quot;, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 清理pool-&gt;large链表（pool-&gt;large为单独的大数据内存块）  */</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line"> </span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0, &quot;free: %p&quot;, l-&gt;alloc);</span><br><span class="line"> </span><br><span class="line">        if (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">#if (NGX_DEBUG)</span><br><span class="line"> </span><br><span class="line">    /*</span><br><span class="line">     * we could allocate the pool-&gt;log from this pool</span><br><span class="line">     * so we cannot use this log while free()ing the pool</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">    for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,</span><br><span class="line">                &quot;free: %p, unused: %uz&quot;, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line"> </span><br><span class="line">        if (n == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">    /* 对内存池的data数据区域进行释放 */</span><br><span class="line">    for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line"> </span><br><span class="line">        if (n == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="重设内存池ngx-reset-pool"><a href="#重设内存池ngx-reset-pool" class="headerlink" title="重设内存池ngx_reset_pool"></a>重设内存池ngx_reset_pool</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 重设内存池</span><br><span class="line"> */</span><br><span class="line">void ngx_reset_pool(ngx_pool_t *pool) &#123;</span><br><span class="line">    ngx_pool_t *p;</span><br><span class="line">    ngx_pool_large_t *l;</span><br><span class="line"> </span><br><span class="line">    /* 清理pool-&gt;large链表（pool-&gt;large为单独的大数据内存块）  */</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    pool-&gt;large = NULL;</span><br><span class="line"> </span><br><span class="line">    /* 循环重新设置内存池data区域的 p-&gt;d.last；data区域数据并不擦除*/</span><br><span class="line">    for (p = pool; p; p = p-&gt;d.next) &#123;</span><br><span class="line">        p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用内存池分配一块内存ngx-palloc和ngx-pnalloc"><a href="#使用内存池分配一块内存ngx-palloc和ngx-pnalloc" class="headerlink" title="使用内存池分配一块内存ngx_palloc和ngx_pnalloc"></a>使用内存池分配一块内存ngx_palloc和ngx_pnalloc</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 内存池分配一块内存，返回void类型指针</span><br><span class="line"> */</span><br><span class="line">void *</span><br><span class="line">ngx_palloc(ngx_pool_t *pool, size_t size) &#123;</span><br><span class="line">    u_char *m;</span><br><span class="line">    ngx_pool_t *p;</span><br><span class="line"> </span><br><span class="line">    /* 判断每次分配的内存大小，如果超出pool-&gt;max的限制，则需要走大数据内存分配策略 */</span><br><span class="line">    if (size &lt;= pool-&gt;max) &#123;</span><br><span class="line"> </span><br><span class="line">        p = pool-&gt;current;</span><br><span class="line"> </span><br><span class="line">        /*</span><br><span class="line">         * 循环读取缓存池链p-&gt;d.next的各个的ngx_pool_t节点，</span><br><span class="line">         * 如果剩余的空间可以容纳size，则返回指针地址</span><br><span class="line">         *</span><br><span class="line">         * 这边的循环，实际上最多只有4次，具体可以看ngx_palloc_block函数</span><br><span class="line">         * */</span><br><span class="line">        do &#123;</span><br><span class="line">            /* 对齐操作,会损失内存，但是提高内存使用速度 */</span><br><span class="line">            m = ngx_align_ptr(p-&gt;d.last, NGX_ALIGNMENT);</span><br><span class="line"> </span><br><span class="line">            if ((size_t)(p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">                p-&gt;d.last = m + size;</span><br><span class="line"> </span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            p = p-&gt;d.next;</span><br><span class="line"> </span><br><span class="line">        &#125; while (p);</span><br><span class="line"> </span><br><span class="line">        /* 如果没有缓存池空间没有可以容纳大小为size的内存块，则需要重新申请一个缓存池pool节点 */</span><br><span class="line">        return ngx_palloc_block(pool, size);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 走大数据分配策略 ，在pool-&gt;large链表上分配 */</span><br><span class="line">    return ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 内存池分配一块内存，返回void类型指针</span><br><span class="line"> * 不考虑对齐情况</span><br><span class="line"> */</span><br><span class="line">void *</span><br><span class="line">ngx_pnalloc(ngx_pool_t *pool, size_t size) &#123;</span><br><span class="line">    u_char *m;</span><br><span class="line">    ngx_pool_t *p;</span><br><span class="line"> </span><br><span class="line">    /* 判断每次分配的内存大小，如果超出pool-&gt;max的限制，则需要走大数据内存分配策略 */</span><br><span class="line">    if (size &lt;= pool-&gt;max) &#123;</span><br><span class="line"> </span><br><span class="line">        p = pool-&gt;current;</span><br><span class="line"> </span><br><span class="line">        /* 循环读取数据区域的各个ngx_pool_t缓存池链，如果剩余的空间可以容纳size，则返回指针地址*/</span><br><span class="line">        do &#123;</span><br><span class="line">            m = p-&gt;d.last; //分配的内存块的地址</span><br><span class="line"> </span><br><span class="line">            if ((size_t)(p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">                p-&gt;d.last = m + size;</span><br><span class="line"> </span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            p = p-&gt;d.next;</span><br><span class="line"> </span><br><span class="line">        &#125; while (p);</span><br><span class="line"> </span><br><span class="line">        /* 如果没有缓存池空间没有可以容纳大小为size的内存块，则需要重新申请一个缓存池*/</span><br><span class="line">        return ngx_palloc_block(pool, size);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 走大数据分配策略 */</span><br><span class="line">    return ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>内存分配逻辑:</strong></p><ol>  <li>    <p>分配一块内存，如果分配的内存size小于内存池的pool-&gt;max的限制，则属于小内存块分配，走小内存块分配逻辑；否则走大内存分配逻辑。    </p>  </li>  <li>    <p>      小内存分配逻辑：循环读取pool-&gt;d上的内存块，是否有足够的空间容纳需要分配的size，如果可以容纳，则直接分配内存；否则内存池需要申请新的内存块，调用ngx_palloc_block。    </p>  </li>  <li>    <p>      大内存分配逻辑：当分配的内存size大于内存池的pool-&gt;max的限制，则会直接调用ngx_palloc_large方法申请一块独立的内存块，并且将内存块挂载到pool-&gt;large的链表上进行统一管理。    </p>  </li></ol><p>ngx_palloc_block，内存池扩容：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 申请一个新的缓存池 ngx_pool_t</span><br><span class="line"> * 新的缓存池会挂载在主缓存池的 数据区域 （pool-&gt;d-&gt;next）</span><br><span class="line"> */</span><br><span class="line">static void *</span><br><span class="line">ngx_palloc_block(ngx_pool_t *pool, size_t size) &#123;</span><br><span class="line">    u_char *m;</span><br><span class="line">    size_t psize;</span><br><span class="line">    ngx_pool_t *p, *new, *current;</span><br><span class="line"> </span><br><span class="line">    psize = (size_t)(pool-&gt;d.end - (u_char *) pool);</span><br><span class="line"> </span><br><span class="line">    /* 申请新的块 */</span><br><span class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;log);</span><br><span class="line">    if (m == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    new = (ngx_pool_t *) m;</span><br><span class="line"> </span><br><span class="line">    new-&gt;d.end = m + psize;</span><br><span class="line">    new-&gt;d.next = NULL;</span><br><span class="line">    new-&gt;d.failed = 0;</span><br><span class="line"> </span><br><span class="line">    /* 分配size大小的内存块，返回m指针地址 */</span><br><span class="line">    m += sizeof(ngx_pool_data_t);</span><br><span class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">    new-&gt;d.last = m + size;</span><br><span class="line"> </span><br><span class="line">    current = pool-&gt;current;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 缓存池的pool数据结构会挂载子节点的ngx_pool_t数据结构</span><br><span class="line">     * 子节点的ngx_pool_t数据结构中只用到pool-&gt;d的结构，只保存数据</span><br><span class="line">     * 每添加一个子节点，p-&gt;d.failed就会+1，当添加超过4个子节点的时候，</span><br><span class="line">     * pool-&gt;current会指向到最新的子节点地址</span><br><span class="line">     *</span><br><span class="line">     * 这个逻辑主要是为了防止pool上的子节点过多，导致每次ngx_palloc循环pool-&gt;d.next链表</span><br><span class="line">     * 将pool-&gt;current设置成最新的子节点之后，每次最大循环4次，不会去遍历整个缓存池链表</span><br><span class="line">     */</span><br><span class="line">    for (p = current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        if (p-&gt;d.failed++ &gt; 4) &#123;</span><br><span class="line">            current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    p-&gt;d.next = new;</span><br><span class="line"> </span><br><span class="line">    /* 最终这个还是没变 */</span><br><span class="line">    pool-&gt;current = current ? current : new;</span><br><span class="line"> </span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>分配一块大内存，挂载到pool-&gt;large链表上ngx_palloc_large</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 当分配的内存块大小超出pool-&gt;max限制的时候,需要分配在pool-&gt;large上</span><br><span class="line"> */</span><br><span class="line">static void *</span><br><span class="line">ngx_palloc_large(ngx_pool_t *pool, size_t size) &#123;</span><br><span class="line">    void *p;</span><br><span class="line">    ngx_uint_t n;</span><br><span class="line">    ngx_pool_large_t *large;</span><br><span class="line"> </span><br><span class="line">    /* 分配一块新的大内存块 */</span><br><span class="line">    p = ngx_alloc(size, pool-&gt;log);</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    n = 0;</span><br><span class="line"> </span><br><span class="line">    /* 去pool-&gt;large链表上查询是否有NULL的，只在链表上往下查询3次，主要判断大数据块是否有被释放的，如果没有则只能跳出*/</span><br><span class="line">    for (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        if (large-&gt;alloc == NULL) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (n++ &gt; 3) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 分配一个ngx_pool_large_t 数据结构 */</span><br><span class="line">    large = ngx_palloc(pool, sizeof(ngx_pool_large_t));</span><br><span class="line">    if (large == NULL) &#123;</span><br><span class="line">        ngx_free(p); //如果分配失败，删除内存块</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"> </span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>大内存块的释放ngx_pfree</p><p>内存池释放需要走ngx_destroy_pool，独立大内存块的单独释放，可以走ngx_pfree方法。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 大内存块释放  pool-&gt;large</span><br><span class="line"> */</span><br><span class="line">ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p) &#123;</span><br><span class="line">    ngx_pool_large_t *l;</span><br><span class="line"> </span><br><span class="line">    /* 在pool-&gt;large链上循环搜索，并且只释放内容区域，不释放ngx_pool_large_t数据结构*/</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (p == l-&gt;alloc) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,</span><br><span class="line">                    &quot;free: %p&quot;, l-&gt;alloc);</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = NULL;</span><br><span class="line"> </span><br><span class="line">            return NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>cleanup机制 可以回调函数清理数据</p><p>  Nginx的内存池cleanup机制，设计的非常巧妙。pool-&gt;cleanup本身是一个链表，每个ngx_pool_cleanup_t的数据结构上，保存着内存数据的本身cleanup-&gt;data和回调清理函数cleanup-&gt;handler。</p><p>  通过cleanup的机制，我们就可以在内存池上保存例如文件句柄fd的资源。当我们调用ngx_destroy_pool方法销毁内存池的时候，首先会来清理pool-&gt;cleanup，并且都会执行c-&gt;handler(c-&gt;data)回调函数，用于清理资源。</p><p>Nginx的这个机制，最显著的就是让文件描述符和需要自定义清理的数据的管理变得更加简单。</p><p>分配一个cleanup结构：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 分配一个可以用于回调函数清理内存块的内存</span><br><span class="line"> * 内存块仍旧在p-&gt;d或p-&gt;large上</span><br><span class="line"> *</span><br><span class="line"> * ngx_pool_t中的cleanup字段管理着一个特殊的链表，该链表的每一项都记录着一个特殊的需要释放的资源。</span><br><span class="line"> * 对于这个链表中每个节点所包含的资源如何去释放，是自说明的。这也就提供了非常大的灵活性。</span><br><span class="line"> * 意味着，ngx_pool_t不仅仅可以管理内存，通过这个机制，也可以管理任何需要释放的资源，</span><br><span class="line"> * 例如，关闭文件，或者删除文件等等的。下面我们看一下这个链表每个节点的类型</span><br><span class="line"> *</span><br><span class="line"> * 一般分两种情况：</span><br><span class="line"> * 1. 文件描述符</span><br><span class="line"> * 2. 外部自定义回调函数可以来清理内存</span><br><span class="line"> */</span><br><span class="line">ngx_pool_cleanup_t *</span><br><span class="line">ngx_pool_cleanup_add(ngx_pool_t *p, size_t size) &#123;</span><br><span class="line">    ngx_pool_cleanup_t *c;</span><br><span class="line"> </span><br><span class="line">    /* 分配一个ngx_pool_cleanup_t */</span><br><span class="line">    c = ngx_palloc(p, sizeof(ngx_pool_cleanup_t));</span><br><span class="line">    if (c == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 如果size !=0 从pool-&gt;d或pool-&gt;large分配一个内存块 */</span><br><span class="line">    if (size) &#123;</span><br><span class="line">        /*  */</span><br><span class="line">        c-&gt;data = ngx_palloc(p, size);</span><br><span class="line">        if (c-&gt;data == NULL) &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        c-&gt;data = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* handler为回调函数 */</span><br><span class="line">    c-&gt;handler = NULL;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"> </span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"> </span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;log, 0, &quot;add cleanup: %p&quot;, c);</span><br><span class="line"> </span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>手动清理 p-&gt;cleanup链表上的数据：（内存池销毁函数ngx_destroy_pool也会清理p-&gt;cleanup）</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 清除 p-&gt;cleanup链表上的内存块（主要是文件描述符）</span><br><span class="line"> * 回调函数：ngx_pool_cleanup_file</span><br><span class="line"> */</span><br><span class="line">void ngx_pool_run_cleanup_file(ngx_pool_t *p, ngx_fd_t fd) &#123;</span><br><span class="line">    ngx_pool_cleanup_t *c;</span><br><span class="line">    ngx_pool_cleanup_file_t *cf;</span><br><span class="line"> </span><br><span class="line">    for (c = p-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        if (c-&gt;handler == ngx_pool_cleanup_file) &#123;</span><br><span class="line"> </span><br><span class="line">            cf = c-&gt;data;</span><br><span class="line"> </span><br><span class="line">            if (cf-&gt;fd == fd) &#123;</span><br><span class="line">                c-&gt;handler(cf); /* 调用回调函数 */</span><br><span class="line">                c-&gt;handler = NULL;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>关闭文件的回调函数和删除文件的回调函数。这个是文件句柄通用的回调函数，可以放置在p-&gt;cleanup-&gt;handler上。 </p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 关闭文件回调函数</span><br><span class="line"> * ngx_pool_run_cleanup_file方法执行的时候，用了此函数作为回调函数的，都会被清理</span><br><span class="line"> */</span><br><span class="line">void ngx_pool_cleanup_file(void *data) &#123;</span><br><span class="line">    ngx_pool_cleanup_file_t *c = data;</span><br><span class="line"> </span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, c-&gt;log, 0, &quot;file cleanup: fd:%d&quot;,</span><br><span class="line">            c-&gt;fd);</span><br><span class="line"> </span><br><span class="line">    if (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno,</span><br><span class="line">                ngx_close_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 删除文件回调函数</span><br><span class="line"> */</span><br><span class="line">void ngx_pool_delete_file(void *data) &#123;</span><br><span class="line">    ngx_pool_cleanup_file_t *c = data;</span><br><span class="line"> </span><br><span class="line">    ngx_err_t err;</span><br><span class="line"> </span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, c-&gt;log, 0, &quot;file cleanup: fd:%d %s&quot;,</span><br><span class="line">            c-&gt;fd, c-&gt;name);</span><br><span class="line"> </span><br><span class="line">    if (ngx_delete_file(c-&gt;name) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        err = ngx_errno;</span><br><span class="line"> </span><br><span class="line">        if (err != NGX_ENOENT) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_CRIT, c-&gt;log, err,</span><br><span class="line">                    ngx_delete_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno,</span><br><span class="line">                ngx_close_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx学习入门&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://javastar.club/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://javastar.club/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>道家思想研究一</title>
    <link href="http://javastar.club/archives/14a6c290.html"/>
    <id>http://javastar.club/archives/14a6c290.html</id>
    <published>2019-07-31T13:01:27.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>佛学研究一</title>
    <link href="http://javastar.club/archives/bdc98c68.html"/>
    <id>http://javastar.club/archives/bdc98c68.html</id>
    <published>2019-07-31T13:01:08.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>  佛言：“人本立神，一身清明，能有所益。奉于正行，强有所观，不解本无，自见有身，因生五阴六衰之惑，反为所迷，不至正真；后解三界一切皆空，五阴悉除，三毒自灭，乃至无上正真之道。”</p><a id="more"></a><p>  布施度贪心、忍辱度嗔心、般若度痴心<br>佛家所谓修行，即是修心，只有把这心修圆满了，才能打破生死的界限。<br>物理学上指出，能量是不会消失的，只会从一种状态转换到另一种状态。从物理学角度看，几千亿年前，我们也是一颗星辰，我们体内的所有物质都是原子组成，那我们即是一颗原子的聚合体，死亡是体内无法产生电流，思考不能继续，那么我们是否依然存活，只依赖于保持脑部电流的流通？</p><h3 id="摘录句子"><a href="#摘录句子" class="headerlink" title="摘录句子"></a>摘录句子</h3><ol>  <li>浮世万千，吾爱有三。<br>日，月与卿。<br>日为朝，月为暮，<br>卿为朝朝暮暮。</li>  <li>坐亦禅行亦禅，一花一世界，一叶一如来，春来花自青，秋至叶飘零，无穷般若心自在，语默动静体自然。 无我相，无人相，无众生相，无寿者相。 </li>  <li>凡所有相，皆是虚妄。若见诸相非相，即见如来。 </li>  <li>诸法因缘生，诸法因缘灭。因缘生灭法，佛说皆是空。 </li>  <li>一切皆流，无物永驻。 </li>  <li>舍利子、色不异空、空不异色。</li>  <li>色即是空、空即是色、受想行识、亦复如是。</li>  <li>舍利子、是诸法空相、不生不灭、不垢不净、不增不减。</li>  <li>心生种种法生，心灭种种法灭。</li>  <li>我自无心于万物，何妨万物常围绕。 </li>  <li>欲知前世因，今生受者是；欲知来世果，今生作者是。</li>  <li>唯心所现，唯识所变。</li>  <li>圣人求心不求佛，愚人求佛不求心。 </li>  <li>此有故彼有，此生故彼生；此无故彼无，此灭故彼灭。 </li>  <li>心有所住，即为非住。应无所住，而生其心。 </li>  <li>爱不重不生娑婆，念不一不生净土。 </li>  <li>净心之要，无如念佛。一念相应一念佛，念念相应念念佛，佛号投于乱心，乱心不得不佛。 </li>  <li>人不如我意，是我无量；我不如人意，是我无德。 </li>  <li>人身难得，佛法难闻。人身难得今已得，佛法难闻今亦闻。此身不向今生度，更向何生度此身。 </li>  <li>世出世间思维遍，不念弥陀更念谁。 </li>  <li>念佛时，即见佛时，亦即成佛时。求生时，即往生时，亦即度生时。</li>  <li>智人除心不除境，愚人除境不除心。心既除矣，境岂实有。 </li>  <li>观身不净，观受是苦，观心无常，观法无我。 </li>  <li>千悟万悟悟不到，原来一句佛名号。 </li>  <li>梦里明明有六趣，觉后空空无大千。 </li>  <li>是心作佛，是心是佛。 </li>  <li>善恶报应，祸福相承，身自当之，无谁代者。 </li>  <li>着相修行百千劫，无相修行刹那间，若能万法尽舍却，顿悟入道须臾间。 </li>  <li>祸福无门，惟人自召 善恶之报，如影随形，积善之家，必有余庆，积不善之家，必有余殃。</li>  <li>知幻即离,不作方便,离幻即觉,亦无渐次。 </li>  <li>一切有为法，尽是因缘合和，缘起时起，缘尽还无，不外如是。 </li>  <li>缘起法身偈诸法因缘生，我说是因缘。因缘尽故灭，我作如是说。 </li>  <li>世间万物皆空。唯其空，便能包容万物。</li></ol><h2 id="《金刚经》读书笔记"><a href="#《金刚经》读书笔记" class="headerlink" title="《金刚经》读书笔记"></a>《金刚经》读书笔记</h2><p><strong>【第一品 法会因由】</strong></p><p>如是我闻。一时佛在舍卫国祇树给孤独园。与大比丘众千二百五十人俱。尔时世尊食时。着衣持钵。入舍</p><p>卫大城乞食。于其城中次第乞已。还至本处。饭食讫。收衣钵。洗足已。敷座而坐。</p><p>【解读】</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>      </td>      <td class="code">        <pre><span class="line">自然无量真空生天育地，生万物，化万灵。人类生在天地中，顶天立地，天地中枢，动物之长，万物之灵</span><br><span class="line"></span><br><span class="line">，天之骄子，继天立极，代天宣化。天不言，地不语，天地借人把道宣，人类心法由真空灵源直贯而下。</span><br><span class="line"></span><br><span class="line">原始初祖伏羲，是中华民族的文化之祖，创造文明，文教文化，后由炎黄继承。人类进化，伏羲为宗祖，</span><br><span class="line"></span><br><span class="line">在原始人类最初的野生时代，无人造物质，赤身裸休，无语言文字。自然生育人类，自然教化理法，天地</span><br><span class="line"></span><br><span class="line">生人天教化。圣祖的思想觉悟直贯真空灵源，圣由天纵万化通。自然真空天地人类万物是同体，无量虚无</span><br><span class="line"></span><br><span class="line">真空一总体。伏羲一画开天立无极。文字依此立，文化由此起。真空妙有无为理，人类法会因由始开基。</span><br><span class="line"></span><br><span class="line">继文化宗祖后，无为大法炎黄理，继祖进化宣真机、创万理，五千年文明史奠基。尧、舜、禹、汤、文、</span><br><span class="line"></span><br><span class="line">武、周公圣君先贤，后来的老子、孔子，同立真空无为理。中华民族世世代代继圣基，一脉相传兴文化，</span><br><span class="line"></span><br><span class="line">文明古国耸立在人间，始祖古老文化永流传。皇天不断无为路，人类地地代代出圣贤。大圣人生于西方，</span><br><span class="line"></span><br><span class="line">前无古，后无今。真空妙有无为理，明心法会因由倡宏遍地、人人处处亲。中古传到今，无为大法未来新</span><br><span class="line"></span><br><span class="line">。如是我闻心心相印理，无闻无说法会因由何为根？法由心源起，说法谢知音，用心闻观自心，闻我是我</span><br><span class="line"></span><br><span class="line">闻。我闻自闻法，缘起佛的心。心是如是法，印心才明心。定慧圆明理，继往开来心传心。《金刚经》真</span><br><span class="line"></span><br><span class="line">宗正教，佛传后人明心旨，遵旨照行、妙觉圆通报佛拯救天赋明命恩。释迦妙语圆音贯耳根，耳闻心受心</span><br><span class="line"></span><br><span class="line">闻心。闻心闻知佛因是自我，闻我两亡空寂默，无闻无我自佛真。如是我闻通佛义，心心相印古到今。大</span><br><span class="line"></span><br><span class="line">法弘扬，放眼宽心观未来人。</span><br></pre>      </td>    </tr>  </table></figure><p> 众生皆有命。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;
  佛言：“人本立神，一身清明，能有所益。奉于正行，强有所观，不解本无，自见有身，因生五阴六衰之惑，反为所迷，不至正真；后解三界一切皆空，五阴悉除，三毒自灭，乃至无上正真之道。”
&lt;/p&gt;
    
    </summary>
    
      <category term="生活哲学" scheme="http://javastar.club/categories/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"/>
    
    
      <category term="佛学" scheme="http://javastar.club/tags/%E4%BD%9B%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java密码学学习笔记</title>
    <link href="http://javastar.club/archives/13cff302.html"/>
    <id>http://javastar.club/archives/13cff302.html</id>
    <published>2019-07-31T03:28:44.000Z</published>
    <updated>2019-08-07T07:14:52.673Z</updated>
    
    <content type="html"><![CDATA[<p>Java加密与解密读书笔记</p><a id="more"></a><h3 id="密码学常用术语"><a href="#密码学常用术语" class="headerlink" title="密码学常用术语"></a>密码学常用术语</h3><p>  明文(Plaintext):指待加密信息，明文可以是文本文件、图片文件、二进制数据等。<br>密文(Ciphertext):指经过加密后的明文，密文通常以文本、二进制数据等形式存在。<br>发送者(Sender):指发送消息的人。<br>接受者(Receiver):指接收消息的人。<br>加密(Encryption):指将明文转换为密文的过程。<br>加密算法(Encryption  Algorithm)<br>加密密钥(Encryption Key)<br>密码体制(Cipher  System):由明文空间、密文空间、密钥空间、加密算法那及解密算法五部分组成。</p><h3 id="密码学分类"><a href="#密码学分类" class="headerlink" title="密码学分类"></a>密码学分类</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java加密与解密读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="密码学" scheme="http://javastar.club/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="java" scheme="http://javastar.club/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发之synchronized实现原理</title>
    <link href="http://javastar.club/archives/95e81.html"/>
    <id>http://javastar.club/archives/95e81.html</id>
    <published>2019-07-29T06:34:52.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>java并发之synchronized实现原理</p><a id="more"></a><p>造成线程安全问题的主要原因：</p><ol>  <li>存在共享数据(临界资源)</li>  <li>存在多条线程共同操作共享数据。</li></ol><p>  <strong>互斥锁</strong>，当一个共享数据被当前正在访问的线程加上互斥锁后，在同一时刻，其他线程只能处于等待状态，直到当前线程处理完毕释放该锁。</p><p>  synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者代码（主要是对方法或者代码块中存在共享数据的操作)，另外，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能）</p><h3 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h3><ul>  <li>    <p>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</p>  </li>  <li>    <p>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</p>  </li>  <li>    <p>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</p>  </li></ul><p><strong>synchronized作用于实例方法</strong></p><p>所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法，注意是实例方法不包括静态方法，如下:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class AccountingSync implements Runnable&#123;</span><br><span class="line">    //共享资源(临界资源)</span><br><span class="line">    static int i=0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * synchronized 修饰实例方法</span><br><span class="line">     */</span><br><span class="line">    public synchronized void increase()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int j=0;j&lt;1000000;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        AccountingSync instance=new AccountingSync();</span><br><span class="line">        Thread t1=new Thread(instance);</span><br><span class="line">        Thread t2=new Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 输出结果:</span><br><span class="line">     * 2000000</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>  上述代码中，我们开启两个线程操作同一个共享资源即变量i，由于i++;操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全。</p><p>  此时我们应该注意到synchronized修饰的是实例方法increase，在这样的情况下，当前线程的锁便是实例对象instance，注意Java中的线程同步锁可以是任意对象。从代码执行结果来看确实是正确的，倘若我们没有使用synchronized关键字，其最终输出结果就很可能小于2000000，这便是synchronized关键字的作用。</p><p>这里我们还需要意识到，当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized  方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，但是其他线程还是可以访问该实例对象的其他非synchronized方法，当然如果是一个线程  A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的  synchronized 方法  f2(当前对象锁是obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了，如下代码将演示出该现象</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class AccountingSyncBad implements Runnable&#123;</span><br><span class="line">    static int i=0;</span><br><span class="line">    public synchronized void increase()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int j=0;j&lt;1000000;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //new新实例</span><br><span class="line">        Thread t1=new Thread(new AccountingSyncBad());</span><br><span class="line">        //new新实例</span><br><span class="line">        Thread t2=new Thread(new AccountingSyncBad());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        //join含义:当前线程A等待thread线程终止之后才能从thread.join()返回</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>  上述代码与前面不同的是我们同时创建了两个新实例AccountingSyncBad，然后启动两个不同的线程对共享变量i进行操作，但很遗憾操作结果是1452317而不是期望结果2000000，因为上述代码犯了严重的错误，虽然我们使用synchronized修饰了increase方法，但却new了两个不同的实例对象，这也就意味着存在着两个不同的实例对象锁，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的。<br>解决这种困境的的方式是将synchronized作用于静态的increase方法，这样的话，对象锁就当前类对象，由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的。下面我们看看如何使用将synchronized作用于静态的increase方法.</p><h3 id="synchronized作用于静态方法"><a href="#synchronized作用于静态方法" class="headerlink" title="synchronized作用于静态方法"></a>synchronized作用于静态方法</h3><p>  当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态  成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态  synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态  synchronized 方法占用的锁是当前实例对象锁，看如下代码</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class AccountingSyncClass implements Runnable&#123;</span><br><span class="line">    static int i=0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 作用于静态方法,锁是当前class对象,也就是</span><br><span class="line">     * AccountingSyncClass类对应的class对象</span><br><span class="line">     */</span><br><span class="line">    public static synchronized void increase()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 非静态,访问时锁不一样不会发生互斥</span><br><span class="line">     */</span><br><span class="line">    public synchronized void increase4Obj()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int j=0;j&lt;1000000;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //new新实例</span><br><span class="line">        Thread t1=new Thread(new AccountingSyncClass());</span><br><span class="line">        //new心事了</span><br><span class="line">        Thread t2=new Thread(new AccountingSyncClass());</span><br><span class="line">        //启动线程</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>  由于synchronized关键字修饰的是静态increase方法，与修饰实例方法不同的是，其锁对象是当前类的class对象。注意代码中的increase4Obj方法是实例方法，其对象锁是当前实例对象，如果别的线程调用该方法，将不会产生互斥现象，毕竟锁对象不同，但我们应该意识到这种情况下可能会发现线程安全问题(操作了共享静态变量i)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java并发之synchronized实现原理&lt;/p&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://javastar.club/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java并发" scheme="http://javastar.club/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java基础知识补充二</title>
    <link href="http://javastar.club/archives/945dffd.html"/>
    <id>http://javastar.club/archives/945dffd.html</id>
    <published>2019-07-29T06:34:29.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础细节学习</p><a id="more"></a><h3 id="Java-8系列之重新认识HashMap"><a href="#Java-8系列之重新认识HashMap" class="headerlink" title="Java 8系列之重新认识HashMap"></a>Java  8系列之重新认识HashMap</h3><h6 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h6><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet  Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>  Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap<br>下面针对各个实现类的特点做一些说明：</p><p>(1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。  HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用  Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><p>(2)  Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><p>(3)  LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>(4)  TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p><p>  对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p><p>  通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>  搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。</p><h5 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h5><p>  从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的.<br>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p><p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[]  table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;    //用来定位数组索引位置</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   //链表的下一个node</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        public final K getKey()&#123; ... &#125;</span><br><span class="line">        public final V getValue() &#123; ... &#125;</span><br><span class="line">        public final String toString() &#123; ... &#125;</span><br><span class="line">        public final int hashCode() &#123; ... &#125;</span><br><span class="line">        public final V setValue(V newValue) &#123; ... &#125;</span><br><span class="line">        public final boolean equals(Object o) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p><p>(2)  HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">map.put(&quot;javastar&quot;,&quot;xin&quot;);</span><br></pre>      </td>    </tr>  </table></figure><p>系统将调用”javastar”这个key的hashCode()方法得到其hashCode  值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p><p>  如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[]  table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p><p>  在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">int threshold;             // 所能容纳的key-value对极限 </span><br><span class="line">    final float loadFactor;    // 负载因子</span><br><span class="line">    int modCount;  </span><br><span class="line">    int size;</span><br></pre>      </td>    </tr>  </table></figure><p>首先，Node[] table的初始化长度length(默认值是16)，Load  factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold =  length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>结合负载因子的定义公式可知，threshold就是在此Load  factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load  factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p><p>  size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p><p>  在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数.<br>Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p>  这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p><h4 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a>功能实现-方法</h4><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p><ol>  <li>确定哈希桶数组索引位置</li></ol><p>  不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p><p>方法一：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">static final int hash(Object key) &#123;   //jdk1.8 &amp; jdk1.7</span><br><span class="line">     int h;</span><br><span class="line">     // h = key.hashCode() 为第一步 取hashCode值</span><br><span class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>方法二：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">static int indexFor(int h, int length) &#123;  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span><br><span class="line">     return h &amp; (length-1);  //第三步 取模运算</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p><p>  对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length  -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp;  (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h  &gt;&gt;&gt;  16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java基础细节学习&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://javastar.club/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://javastar.club/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="http://javastar.club/archives/eea60a6a.html"/>
    <id>http://javastar.club/archives/eea60a6a.html</id>
    <published>2019-07-29T06:12:23.000Z</published>
    <updated>2019-08-07T07:14:52.720Z</updated>
    
    <content type="html"><![CDATA[<p>字典树相关习题</p><a id="more"></a><h3 id="前缀树的结构"><a href="#前缀树的结构" class="headerlink" title="前缀树的结构"></a>前缀树的结构</h3><p>Trie树，又叫字典树、前缀树（Prefix  Tree）、单词查找树或键树，是一种多叉树结构.<br>用于处理大量字符串，优点是：利用字符串的公共前缀，在存储时节约存储空间，并在查询时最大限度的减少无谓的字符串比较。</p><h3 id="字典树的作用"><a href="#字典树的作用" class="headerlink" title="字典树的作用"></a>字典树的作用</h3><ol>  <li>以最节约空间的方式存储大量字符串.且存好后是有序的</li></ol><p>因为是有序的,故而字典树不仅可用于大量字符串的存储,还可用于大量字符串的排序.</p><ol start="2">  <li>快速查询某字符串s在字典树中是否已存在,甚至出现过几次</li></ol><p>因为当字典树预处理好之后,查询字符串s在当前的出现情况的效率为strlen(s),异常高效,故而常用于搜索引擎等.</p><p>版权声明：本文为博主原创文章，转载请附上博文链接！</p><h3 id="Trie树的基本性质："><a href="#Trie树的基本性质：" class="headerlink" title="Trie树的基本性质："></a>Trie树的基本性质：</h3><ol>  <li>根节点不包含字符，除根节点以外的每一个子节点都包含一个字符。</li>  <li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>  <li>每个节点的所有子节点包含的字符互不相同。</li>  <li>从第一字符开始有连续重复的字符只占用一个节点.</li></ol><h3 id="前缀树的应用"><a href="#前缀树的应用" class="headerlink" title="前缀树的应用"></a>前缀树的应用</h3><ol>  <li>前缀匹配</li>  <li>字符串检索</li>  <li>词频统计</li>  <li>字符串排序等。</li></ol><p><strong>前缀匹配</strong><br>定义前缀树结构：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Tries&#123;</span><br><span class="line">    Boolean isTrie ;</span><br><span class="line">    HashMap&lt;Character, Tries&gt; children=new HashMap&lt;Character, Tries&gt;(); </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>上面的 isTrie 用来标记单词是否遍历完。children表示该节点的子节点。<br><strong>建立前缀树</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public static boolean insertNode(String str,Tries head)</span><br><span class="line">&#123;</span><br><span class="line">    if(str==null||str.length()==0)</span><br><span class="line">        return false;</span><br><span class="line">        //如果插入的单词为null 或者单词长度为0直接返回false，false代表该单词不是前缀树中某个单词的前缀，</span><br><span class="line">        //或者前缀树中某个单词是该单词的前缀。</span><br><span class="line">    char chs[]=str.toCharArray();</span><br><span class="line">    int i=0;</span><br><span class="line">    Tries cur=head;</span><br><span class="line">    //将字符串的每个字符插入到前缀树中</span><br><span class="line">    while(i&lt;chs.length)</span><br><span class="line">    &#123;           </span><br><span class="line">        if(!cur.children.containsKey(chs[i]))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cur.children.put(chs[i], new Tries());</span><br><span class="line">            //如果当前节点中的子树节点中不包含当前字符，新建一个子节点。</span><br><span class="line">        &#125;</span><br><span class="line">        //否则复用该节点</span><br><span class="line">        cur=cur.children.get(chs[i]);</span><br><span class="line">        if(cur.count==true)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot; trie tree&quot;);</span><br><span class="line">            return true;</span><br><span class="line">            //判断前缀树中是否有字符串为当前字符串的前缀。</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.count=true;</span><br><span class="line">    if(cur.children.size()&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot; trie tree&quot;);</span><br><span class="line">        return true;</span><br><span class="line">        //判断当前字符串是否是前缀树中某个字符的前缀。</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>前缀树的建立过程就是插入字符串的过程，同时在插入节点的时候可以判断插入的字符串是否是前缀树里面某个单词的前缀，或者前缀树中的某个单词是否是该单词的前缀。</p><ol>  <li>先将字符串转换为字符数组，然后对每个字符进行处理，如果当前节点的子节点中包含有要处理的字符字节复用。否则新建一个子节点。</li>  <li>判断是否是前缀单词的时候，有两个步骤，首先要看该字符串是否是其他字符串的前缀，还有看其他字符串是否是当前字符串的前缀。</li></ol><p>判断前缀单词的完整代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class isTrie &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Tries tries=new Tries();</span><br><span class="line">        String strs[]=&#123;&quot;abc&quot;,&quot;abd&quot;,&quot;b&quot;,&quot;abdc&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;strs.length;i++)  </span><br><span class="line">            insertNode(strs[i], tries);                 </span><br><span class="line">    &#125;</span><br><span class="line">public static boolean insertNode(String str,Tries head)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str==null||str.length()==0)</span><br><span class="line">            return false;</span><br><span class="line">        char chs[]=str.toCharArray();</span><br><span class="line">        int i=0;</span><br><span class="line">        Tries cur=head;</span><br><span class="line">        while(i&lt;chs.length)</span><br><span class="line">        &#123;           </span><br><span class="line">            if(!cur.children.containsKey(chs[i]))</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                cur.children.put(chs[i], new Tries());</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.children.get(chs[i]);</span><br><span class="line">            if(cur.count==true)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot; trie tree&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.count=true;</span><br><span class="line">        if(cur.children.size()&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot; trie tree&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Tries&#123;</span><br><span class="line">    boolean isTrie;</span><br><span class="line">    HashMap&lt;Character, Tries&gt; children=new HashMap&lt;Character, Tries&gt;(); </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="模板代码："><a href="#模板代码：" class="headerlink" title="模板代码："></a>模板代码：</h3><ol>  <li>    <p>以数组模拟动态分配的只带增查的字典树模板</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre>          </td>          <td class="code">            <pre><span class="line">//一个只带添加字符串与查找字符串的字典树（为了效率以数组实现） </span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">int charmapping[256]; //字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] </span><br><span class="line">void init_charmapping()&#123;</span><br><span class="line">    for(int i=&apos;a&apos;;i&lt;=&apos;z&apos;;i++)&#123; //我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. </span><br><span class="line">        charmapping[i]=i-&apos;a&apos;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">const int maxn=26; //这里假设字符串中只出现26个小写字母 </span><br><span class="line">const int maxm=100000;</span><br><span class="line">struct treenode&#123;</span><br><span class="line">    bool end; //标志此节点是否是某字符串的结尾 </span><br><span class="line">    treenode* next[maxn]; </span><br><span class="line">&#125;head;</span><br><span class="line"> </span><br><span class="line">treenode memory[maxm]; //字典树所用到的数组空间</span><br><span class="line">int mallocp=0;  //模拟内存分配</span><br><span class="line"> </span><br><span class="line">void init()&#123;</span><br><span class="line">    head.end=1;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++) head.next[i]=NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">treenode* createnew()&#123;</span><br><span class="line">    treenode* newnode;</span><br><span class="line">    newnode=&amp;memory[mallocp++];</span><br><span class="line">    newnode-&gt;end=0;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++) newnode-&gt;next[i]=NULL;</span><br><span class="line">    return newnode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void update(char* s)&#123;</span><br><span class="line">    int k=0,temp;</span><br><span class="line">    treenode* t=&amp;head;</span><br><span class="line">    while(s[k])&#123;</span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        if(!t-&gt;next[temp]) t-&gt;next[temp]=createnew(); </span><br><span class="line">        t=t-&gt;next[temp];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;end=1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool search(char* s)&#123;</span><br><span class="line">    int k=0,temp;</span><br><span class="line">    treenode* t=&amp;head;</span><br><span class="line">    while(s[k])&#123;</span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        if(!t-&gt;next[temp]) return false;</span><br><span class="line">        t=t-&gt;next[temp];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t-&gt;end) return true;</span><br><span class="line">    return false; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    char x[1000];</span><br><span class="line">    char t;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        fflush(stdin);</span><br><span class="line">        scanf(&quot;%c&quot;,&amp;t);</span><br><span class="line">        if(t==&apos;q&apos;)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,&amp;x);</span><br><span class="line">            if(search(x)) printf(&quot;匹配成功！\n&quot;);</span><br><span class="line">            else printf(&quot;匹配失败！\n&quot;); </span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==&apos;u&apos;)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,&amp;x);</span><br><span class="line">            update(x);</span><br><span class="line">            printf(&quot;更新完毕！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==&apos;e&apos;)&#123;</span><br><span class="line">            printf(&quot;退出ing....\n&quot;); </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else printf(&quot;无效命令！,请重新输入！\n&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>以动态分配为实现的带增删改查的字典树模板</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre>          </td>          <td class="code">            <pre><span class="line">//一个以链表实现带删除功能允许重复字符串的字典树</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int charmapping[256]; //字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] </span><br><span class="line">void init_charmapping()&#123;</span><br><span class="line">    for(int i=&apos;a&apos;;i&lt;=&apos;z&apos;;i++)&#123; //我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. </span><br><span class="line">        charmapping[i]=i-&apos;a&apos;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">const int maxn=26; //这里假设字符串中只出现26个小写字母 </span><br><span class="line">const int maxm=100000;</span><br><span class="line">struct treenode&#123;</span><br><span class="line">    int count; //标志此节点所表示字符串在所有字符串中以前缀形式出现的总次数 </span><br><span class="line">    treenode* next[maxn]; </span><br><span class="line">&#125;head;</span><br><span class="line"> </span><br><span class="line">void init_trie()&#123;</span><br><span class="line">    head.count=1; //初始化为1包括空串并且避免树头被删 </span><br><span class="line">    for(int i=0;i&lt;maxn;i++) head.next[i]=NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">treenode* createnew()&#123; //申请一个新结点并初始化它</span><br><span class="line">    treenode* newnode;</span><br><span class="line">    newnode=(treenode*)malloc(sizeof(treenode));</span><br><span class="line">    newnode-&gt;count=0;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++) newnode-&gt;next[i]=NULL;</span><br><span class="line">    return newnode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void update(char* s,int num)&#123; //向字典树添加num个字符串s </span><br><span class="line">    int k=0,temp;</span><br><span class="line">    treenode* t=&amp;head;</span><br><span class="line">    while(s[k])&#123;</span><br><span class="line">        t-&gt;count+=num;</span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        if(!t-&gt;next[temp]) t-&gt;next[temp]=createnew(); </span><br><span class="line">        t=t-&gt;next[temp];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;count+=num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool search(char* s,int num)&#123;  //查找字典树中是否已经存在num个字符串s</span><br><span class="line">    int k=0,temp;</span><br><span class="line">    treenode* t=&amp;head;</span><br><span class="line">    while(s[k])&#123;</span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        if(!t-&gt;next[temp]||t-&gt;next[temp]-&gt;count&lt;num) return false; //根本不存在字符串s或者存在的数目小于num直接失败 </span><br><span class="line">        t=t-&gt;next[temp];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    int snum=t-&gt;count;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++) if(t-&gt;next[i]) snum-=t-&gt;next[i]-&gt;count; //这里是核心!!!结点t代表的字符串出现的次数就是总次数减去所有子节点次数和 </span><br><span class="line">    if(snum&gt;=num) return true; //如果字符串s的数目snum大于等于num </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void erase(char* s,int num)&#123;  //删除字典树中的num个字符串s并释放无用结点,删除前一定要先search是否存在 </span><br><span class="line">    int k=0,temp;</span><br><span class="line">    treenode* t=&amp;head;</span><br><span class="line">    treenode* t1; //t1后面的结点都是删除后需要被释放的 </span><br><span class="line">    head.count-=num;</span><br><span class="line">    while(s[k])&#123;</span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        t-&gt;next[temp]-&gt;count-=num;</span><br><span class="line">        if(t-&gt;next[temp]-&gt;count==0)&#123;</span><br><span class="line">            t1=t-&gt;next[temp];</span><br><span class="line">            t-&gt;next[temp]=NULL;</span><br><span class="line">            k++;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        t=t-&gt;next[temp];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(s[k])&#123; //释放无用结点 </span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        t=t1-&gt;next[temp];</span><br><span class="line">        free(t1);</span><br><span class="line">        t1=t;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    free(t1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">char temp[1000];</span><br><span class="line">void printall(treenode* tnode,int pos)&#123; //递归打印字典树咯,打出了就是字典序升序的 </span><br><span class="line">    int count=tnode-&gt;count;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++) if(tnode-&gt;next[i]) count-=tnode-&gt;next[i]-&gt;count;</span><br><span class="line">    for(int i=0;i&lt;count;i++) printf(&quot;\&quot;%s\&quot;\n&quot;,temp);</span><br><span class="line">    for(int i=&apos;a&apos;;i&lt;=&apos;z&apos;;i++)&#123;</span><br><span class="line">        if(tnode-&gt;next[charmapping[i]])&#123;</span><br><span class="line">            temp[pos]=i;</span><br><span class="line">            temp[++pos]=&apos;\0&apos;;</span><br><span class="line">            printall(tnode-&gt;next[charmapping[i]],pos);</span><br><span class="line">            temp[--pos]=&apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    init_charmapping(); //初始化映射 </span><br><span class="line">    init_trie();        //初始化字典树 </span><br><span class="line">    char x[1000];</span><br><span class="line">    char order; //命令 </span><br><span class="line">    int num;    //数目 </span><br><span class="line">    printf(&quot;q：查询\nu：插入\nd：删除\np：打印字典树\ne：退出\n&quot;);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;请输入命令：&quot;);</span><br><span class="line">        fflush(stdin);</span><br><span class="line">        scanf(&quot;%c&quot;,&amp;order);</span><br><span class="line">        if(order==&apos;q&apos;)&#123;</span><br><span class="line">            printf(&quot;请输入要查找的字符串与数目：&quot;);</span><br><span class="line">            scanf(&quot;%s%d&quot;,&amp;x,&amp;num);</span><br><span class="line">            if(search(x,num)) printf(&quot;匹配成功。\n\n&quot;);</span><br><span class="line">            else printf(&quot;匹配失败，不存在%d个\&quot;%s\&quot;\n\n&quot;,num,x); </span><br><span class="line">        &#125;</span><br><span class="line">        else if(order==&apos;u&apos;)&#123;</span><br><span class="line">            printf(&quot;请输入要插入的字符串与数目：&quot;);</span><br><span class="line">            scanf(&quot;%s%d&quot;,&amp;x,&amp;num);</span><br><span class="line">            update(x,num);</span><br><span class="line">            printf(&quot;%d个\&quot;%s\&quot;已加入字典树。\n\n&quot;,num,x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(order==&apos;d&apos;)&#123;</span><br><span class="line">            printf(&quot;请输入要删除的字符串与数目：&quot;);</span><br><span class="line">            scanf(&quot;%s%d&quot;,&amp;x,&amp;num);</span><br><span class="line">            if(!search(x,num))&#123;</span><br><span class="line">                printf(&quot;树中无%d个字符串\&quot;%s\&quot;请重新键入命令！\n\n&quot;,num,x);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            erase(x,num);</span><br><span class="line">            printf(&quot;%d个\&quot;%s\&quot;已从字典树中删除。\n\n&quot;,num,x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(order==&apos;p&apos;)&#123;</span><br><span class="line">            printf(&quot;当前字典树内有如下字符串：\n&quot;);</span><br><span class="line">            temp[0]=&apos;\0&apos;;</span><br><span class="line">            printall(&amp;head,0);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(order==&apos;e&apos;)&#123;</span><br><span class="line">            printf(&quot;退出ing....\n&quot;); </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else printf(&quot;无效命令,请重新输入！\n命令q：查询是否存在字符串\n命令u：往字典树加入字符串\n命令d：删除某个字符串\n命令p：按字典序升序输出字典树\n命令e：退出程序\n\n&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h3 id="添加与搜索单词-数据结构设计"><a href="#添加与搜索单词-数据结构设计" class="headerlink" title="添加与搜索单词 - 数据结构设计"></a>添加与搜索单词  - 数据结构设计</h3><p>设计一个支持以下两种操作的数据结构：</p><p>void addWord(word)<br>bool search(word)</p><p>search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。</p><p>示例:</p><p>addWord(“bad”)<br>addWord(“dad”)<br>addWord(“mad”)<br>search(“pad”) -&gt;  false<br>search(“bad”) -&gt; true<br>search(“.ad”) -&gt; true<br>search(“b..”)  -&gt; true</p><p>说明:</p><p>你可以假设所有单词都是由小写字母 a-z 组成的。<br>链接：<a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/add-and-search-word-data-structure-design</a></p><p>Trie  树又称“前缀树”，它的典型应用对象是字符串，可以用于保存、统计。其特点是：用边表示字符，当走到叶子结点的时候，沿途所经过的边组成了一个字符串。其优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p><p>关于这道问题的难点是通配符 “.” 的处理，其实也不难：在遇到 “.” 的时候，使用递归方法，将该结点的每一个分支都看过去，只要有一个分支返回 true  就可以了，全部分支都走过去，都没有返回 true 的才返回 false。<br>这里要注意的是，一个结点指向孩子结点的“指针”（一般情况下多于 1  个），可以使用数组表示，也可以使用哈希表表示，如果题目中限制了测试用例“所有的输入都是由小写字母 a-z 构成的”，则可以使用数组表示。</p><p>1、一个结点指向孩子结点的“指针”们用数组表示；</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class WordDictionary &#123;</span><br><span class="line"></span><br><span class="line">    class Node &#123;</span><br><span class="line">        private Node[] next;</span><br><span class="line">        private boolean isWord;</span><br><span class="line"></span><br><span class="line">        public Node() &#123;</span><br><span class="line">            next = new Node[26];</span><br><span class="line">            isWord = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Initialize your data structure here.</span><br><span class="line">     */</span><br><span class="line">    public WordDictionary() &#123;</span><br><span class="line">        root = new Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Adds a word into the data structure.</span><br><span class="line">     */</span><br><span class="line">    public void addWord(String word) &#123;</span><br><span class="line">        int len = word.length();</span><br><span class="line">        Node curNode = root;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            char curChar = word.charAt(i);</span><br><span class="line">            Node next = curNode.next[curChar - &apos;a&apos;];</span><br><span class="line">            if (next == null) &#123;</span><br><span class="line">                curNode.next[curChar - &apos;a&apos;] = new Node();</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.next[curChar - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        if (!curNode.isWord) &#123;</span><br><span class="line">            curNode.isWord = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter.</span><br><span class="line">     */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        return match(word, root, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean match(String word, Node node, int start) &#123;</span><br><span class="line">        if (start == word.length()) &#123;</span><br><span class="line">            return node.isWord;</span><br><span class="line">        &#125;</span><br><span class="line">        char alpha = word.charAt(start);</span><br><span class="line">        if (alpha == &apos;.&apos;) &#123;</span><br><span class="line">            for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">                if (node.next[i] != null &amp;&amp; match(word, node.next[i], start + 1)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (node.next[alpha - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return match(word, node.next[alpha - &apos;a&apos;], start + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>2、一个结点指向孩子结点的“指针”们用哈希表表示。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre>      </td>      <td class="code">        <pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class WordDictionary &#123;</span><br><span class="line"></span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    private class Node &#123;</span><br><span class="line">        private boolean isWord;</span><br><span class="line">        private HashMap&lt;Character, Node&gt; next;</span><br><span class="line"></span><br><span class="line">        public Node() &#123;</span><br><span class="line">            this.next = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Initialize your data structure here.</span><br><span class="line">     */</span><br><span class="line">    public WordDictionary() &#123;</span><br><span class="line">        root = new Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Adds a word into the data structure.</span><br><span class="line">     */</span><br><span class="line">    public void addWord(String word) &#123;</span><br><span class="line">        Node curNode = root;</span><br><span class="line">        for (int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            Character c = word.charAt(i);</span><br><span class="line">            if (!curNode.next.containsKey(c)) &#123;</span><br><span class="line">                curNode.next.put(c, new Node());</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!curNode.isWord) &#123;</span><br><span class="line">            curNode.isWord = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter.</span><br><span class="line">     */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        return search(root, word, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean search(Node node, String word, int depth) &#123;</span><br><span class="line">        if (depth == word.length()) &#123;</span><br><span class="line">            // 只要能搜索到最后，就表示文本与模式匹配</span><br><span class="line">            // 这一步很容易被忽视</span><br><span class="line">            return node.isWord;</span><br><span class="line">        &#125;</span><br><span class="line">        Character c = word.charAt(depth);</span><br><span class="line">        if (c == &apos;.&apos;) &#123;</span><br><span class="line">            Set&lt;Character&gt; keys = node.next.keySet();</span><br><span class="line">            for (Character key : keys) &#123;</span><br><span class="line">                Node nextNode = node.next.get(key);</span><br><span class="line">                if (search(nextNode, word, depth + 1)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 循环都走完都没有找到，那就说明没有</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (!node.next.containsKey(c)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return search(node.next.get(c), word, depth + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WordDictionary wordDictionary = new WordDictionary();</span><br><span class="line">        wordDictionary.addWord(&quot;bad&quot;);</span><br><span class="line">        wordDictionary.addWord(&quot;dad&quot;);</span><br><span class="line">        wordDictionary.addWord(&quot;mad&quot;);</span><br><span class="line">        boolean search1 = wordDictionary.search(&quot;pad&quot;);// -&gt; false</span><br><span class="line">        System.out.println(search1);</span><br><span class="line">        boolean search2 = wordDictionary.search(&quot;bad&quot;); // -&gt; true</span><br><span class="line">        System.out.println(search2);</span><br><span class="line">        boolean search3 = wordDictionary.search(&quot;.ad&quot;); // -&gt; true</span><br><span class="line">        System.out.println(search3);</span><br><span class="line">        boolean search4 = wordDictionary.search(&quot;b..&quot;); //-&gt; true</span><br><span class="line">        System.out.println(search4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字典树相关习题&lt;/p&gt;
    
    </summary>
    
      <category term="算法刷题" scheme="http://javastar.club/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="字典树" scheme="http://javastar.club/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>深度优先搜索</title>
    <link href="http://javastar.club/archives/1857aa15.html"/>
    <id>http://javastar.club/archives/1857aa15.html</id>
    <published>2019-07-29T06:12:02.000Z</published>
    <updated>2019-08-07T07:14:52.720Z</updated>
    
    <content type="html"><![CDATA[<p>DFS</p><a id="more"></a><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><pre><code>节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。</code></pre><p>示例 1:</p><p>输入:<br> 2<br> / <br> 1 3<br>输出: true</p><p>示例 2:</p><p>输入:<br> 5<br> / <br> 1 4<br> / <br> 3 6<br>输出: false<br>解释: 输入为:  [5,1,4,null,null,3,6]。<br> 根节点的值为 5 ，但是其右子节点值为 4 。<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/validate-binary-search-tree</a><br>算法思路：</p><ol>  <li>    <p>      递归<br>首先将结点的值与上界和下界比较，然后对左右子树递归进行该过程。<br>时间复杂度：O(N)每个结点访问了一次<br>空间复杂度：O(N)整棵树<br>参考代码：    </p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>          </td>          <td class="code">            <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> //1.递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">  public boolean help(TreeNode node, Integer lower, Integer upper) &#123;</span><br><span class="line">    if (node == null) return true;</span><br><span class="line"></span><br><span class="line">    int val = node.val;</span><br><span class="line">    if (lower != null &amp;&amp; val &lt;= lower) return false;</span><br><span class="line">    if (upper != null &amp;&amp; val &gt;= upper) return false;</span><br><span class="line"></span><br><span class="line">    if (! help(node.right, val, upper)) return false;</span><br><span class="line">    if (! help(node.left, lower, val)) return false;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">    return help(root, null, null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>迭代<br>通过使用栈，DFS比BFS快。<br>时间复杂度：O(N)每个结点访问了一次<br>空间复杂度：O(N)整棵树<br>参考代码：    </p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>          </td>          <td class="code">            <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack=new LinkedList();</span><br><span class="line">    LinkedList&lt;Integer&gt; uppers=new LinkedList();</span><br><span class="line">    LinkedList&lt;Integer&gt; lowers=new LinkedList();</span><br><span class="line">    public void update(TreeNode root,Integer lower,Integer upper)&#123;</span><br><span class="line">    stack.add(root);</span><br><span class="line">    lowers.add(lower);</span><br><span class="line">    uppers.add(upper);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        Integer lower=null,upper=null,val;</span><br><span class="line">        update(root,lower,upper);</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">        root=stack.poll();</span><br><span class="line">        lower=lowers.poll();</span><br><span class="line">        upper=uppers.poll();</span><br><span class="line">        if(root==null)continue;</span><br><span class="line">        val=root.val;</span><br><span class="line">        if(lower!=null&amp;&amp; val&lt;=lower) return false;</span><br><span class="line">        if(upper!=null&amp;&amp;val&gt;=upper)return false;</span><br><span class="line">        update(root.right,val,upper);</span><br><span class="line">        update(root.left,lower,val);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h3 id="207课程表"><a href="#207课程表" class="headerlink" title="207课程表"></a>207课程表</h3><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p>示例 1:</p><p>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p><p>示例 2:</p><p>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程  0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p><p>说明:</p><pre><code>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。</code></pre><p>提示:</p><pre><code>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。拓扑排序也可以通过 BFS 完成。</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/course-schedule" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/course-schedule</a><br>算法思路：</p><ol>  <li>拓扑排序<br>拓扑排序实际上应用的是贪心算法。贪心算法简而言之：每一步最优，全局就最优。</li></ol><p>具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，我们可以设置一个入度数组，每一轮都输出入度为 0  的结点，并移除它、修改它指向的结点的入度（−1即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。</p><p>  拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。拓扑排序还可以用于检测一个有向图是否有环。相关的概念还有  AOV 网，这里就不展开了。</p><p>算法流程：</p><p>1、在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 0 的结点放入队列。</p><p>2、只要队列非空，就从队首取出入度为 0的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减 1，在减 1  以后，如果这个被减 1 的结点的入度为 0，就继续入队。</p><p>3、当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。</p><p>思考这里为什么要使用队列？</p><p>在代码具体实现的时候，除了保存入度为 0 的队列，我们还需要两个辅助的数据结构：<br>1、邻接表：通过结点的索引，我们能够得到这个结点的后继结点；</p><p>2、入度数组：通过结点的索引，我们能够得到指向这个结点的结点个数。</p><p>这个两个数据结构在遍历题目给出的邻边以后就可以很方便地得到。</p><p>时间复杂度：O(E+V)。这里 E表示邻边的条数，V 表示结点的个数。初始化入度为 0的集合需要遍历整张图，具体做法是检查每个结点和每条边，因此复杂度为  O(E+V)，然后对该集合进行操作，又需要遍历整张图中的每个结点和每条边，复杂度也为 O(E+V)；</p><p>空间复杂度：O(V)：入度数组、邻接表的长度都是结点的个数 V，即使使用队列，队列最长的时候也不会超过 V，因此空间复杂度是 O(V)。</p><p>如果不使用队列，要想得到当前入度为 0 的结点，就得遍历一遍入度数组。使用队列即用空间换时间。</p><p>Java:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        if(numCourses&lt;=0) return false;</span><br><span class="line">        int plen=prerequisites.length;</span><br><span class="line">        if(plen==0) return true;</span><br><span class="line">        int[] inDegree=new int[numCourses];</span><br><span class="line">        for(int[] p:prerequisites)&#123;</span><br><span class="line">        inDegree[p[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue=new LinkedList();</span><br><span class="line">        // 首先加入入度为 0 的结点</span><br><span class="line">        for(int i=0;i&lt;numCourses;i++)&#123;</span><br><span class="line">        if(inDegree[i]==0) queue.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 拓扑排序的结果</span><br><span class="line">        List&lt;Integer&gt; res=new ArrayList();</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">        Integer num=queue.removeFirst();</span><br><span class="line">        res.add(num);</span><br><span class="line">// 把邻边全部遍历一下</span><br><span class="line">        for(int[] p: prerequisites)&#123;</span><br><span class="line">        if(p[1]==num)&#123;</span><br><span class="line">        inDegree[p[0]]--;</span><br><span class="line">        if(inDegree[p[0]]==0)&#123;</span><br><span class="line">        queue.addLast(p[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">           // System.out.println(&quot;拓扑排序结果：&quot;);</span><br><span class="line">        // System.out.println(res);</span><br><span class="line">        return res.size()==numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><ol start="2">  <li>DFS<br>深度优先遍历</li></ol><p>这里要使用逆邻接表。其实就是检测这个有向图中有没有环，只要存在环，这些课程就不能按要求学完。</p><p>具体方法是：</p><p>第 1 步：构建逆邻接表；</p><p>第 2 步：递归处理每一个还没有被访问的结点，具体做法很简单：对于一个结点来说，先输出指向它的所有顶点，再输出自己。</p><p>第 3  步：如果这个顶点还没有被遍历过，就递归遍历它，把所有指向它的结点都输出了，再输出自己。注意：当访问一个结点的时候，应当先递归访问它的前驱结点，直至前驱结点没有前驱结点为止。<br>复杂度分析：</p><pre><code>时间复杂度：O(E+V)空间复杂度：O(V)</code></pre><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Solution &#123;</span><br><span class="line"> public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        if (numCourses &lt;= 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int plen = prerequisites.length;</span><br><span class="line">        if (plen == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] marked = new int[numCourses];</span><br><span class="line"></span><br><span class="line">        // 初始化有向图 begin</span><br><span class="line">        HashSet&lt;Integer&gt;[] graph = new HashSet[numCourses];</span><br><span class="line">        for (int i = 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph[i] = new HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        // 初始化有向图 end</span><br><span class="line">        // 有向图的 key 是前驱结点，value 是后继结点的集合</span><br><span class="line">        for (int[] p : prerequisites) &#123;</span><br><span class="line">            graph[p[1]].add(p[0]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            if (dfs(i, graph, marked)) &#123;</span><br><span class="line">                // 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回 false</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环</span><br><span class="line">        // 所有课程任务可以完成，应该返回 true</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注意这个 dfs 方法的语义</span><br><span class="line">     * @param i      当前访问的课程结点</span><br><span class="line">     * @param graph</span><br><span class="line">     * @param marked 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了</span><br><span class="line">     * @return true 表示图中存在环，false 表示访问过了，不用再访问了</span><br><span class="line">     */</span><br><span class="line">    private boolean dfs(int i,</span><br><span class="line">                        HashSet&lt;Integer&gt;[] graph,</span><br><span class="line">                        int[] marked) &#123;</span><br><span class="line">        // 如果访问过了，就不用再访问了</span><br><span class="line">        if (marked[i] == 1) &#123;</span><br><span class="line">            // 从正在访问中，到正在访问中，表示遇到了环</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (marked[i] == 2) &#123;</span><br><span class="line">            // 表示在访问的过程中没有遇到环，这个节点访问过了</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 走到这里，是因为初始化呢，此时 marked[i] == 0</span><br><span class="line">        // 表示正在访问中</span><br><span class="line">        marked[i] = 1;</span><br><span class="line">        // 后继结点的集合</span><br><span class="line">        HashSet&lt;Integer&gt; successorNodes = graph[i];</span><br><span class="line"></span><br><span class="line">        for (Integer successor : successorNodes) &#123;</span><br><span class="line">            if (dfs(successor, graph, marked)) &#123;</span><br><span class="line">                // 层层递归返回 true ，表示图中存在环</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span><br><span class="line">        // 状态设置为 2</span><br><span class="line">        marked[i] = 2;</span><br><span class="line">        // false 表示图中不存在环</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h3><p> 二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p>示例 1:</p><p>输入: [1,3,null,null,2]</p><p> 1<br> /<br> 3<br> <br> 2</p><p>输出: [3,1,null,null,2]</p><p> 3<br> /<br> 1<br> <br> 2</p><p>示例 2:</p><p>输入: [3,1,4,null,null,2]</p><p> 3<br> / <br>1 4<br> /<br> 2</p><p>输出: [2,1,4,null,null,3]</p><p> 2<br> / <br>1 4<br> /<br> 3</p><p>进阶:</p><pre><code>使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/recover-binary-search-tree</a><br>算法思路：<br>因为只有两个节点错误，所以只要找出这两个节点然后交换值即可。<br>中序遍历,使用三个指针指示节点，cur为当前节点，wrong1为第一个错误节点，wrong2为找出的第二个错误节点。</p><ol>  <li>    <p>迭代<br>Java实现：</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>          </td>          <td class="code">            <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void recoverTree(TreeNode root) &#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack=new LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode wrong1=null;</span><br><span class="line">        TreeNode wrong2=null;</span><br><span class="line">        TreeNode pre=new TreeNode(Integer.MIN_VALUE);</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        while(cur!=null||!stack.isEmpty())&#123;</span><br><span class="line">            while(cur!=null)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=stack.pop();</span><br><span class="line">            if(wrong1==null&amp;&amp;pre.val&gt;cur.val) wrong1=pre;</span><br><span class="line">            if(wrong1!=null&amp;&amp;pre.val&gt;cur.val) wrong2=cur;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp=wrong1.val;</span><br><span class="line">        wrong1.val=wrong2.val;</span><br><span class="line">        wrong2.val=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>递归 11ms</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>          </td>          <td class="code">            <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode wrong1=null;</span><br><span class="line">        TreeNode wrong2=null;</span><br><span class="line">        TreeNode pre=new TreeNode(Integer.MIN_VALUE);</span><br><span class="line">    public void recoverTree(TreeNode root) &#123;</span><br><span class="line">         order(root);</span><br><span class="line">         int tmp=wrong1.val;</span><br><span class="line">         wrong1.val=wrong2.val;</span><br><span class="line">         wrong2.val=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    private void order(TreeNode root)&#123;</span><br><span class="line">         if(root==null) return;</span><br><span class="line">         order(root.left);</span><br><span class="line">         if(wrong1==null&amp;&amp;pre.val&gt;root.val) wrong1=pre;</span><br><span class="line">         if(wrong1!=null&amp;&amp;pre.val&gt;root.val)</span><br><span class="line">         wrong2=root;</span><br><span class="line"></span><br><span class="line">         pre=root;</span><br><span class="line">         order(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><p>输入: 1 1<br> / \ / <br> 2 3 2 3</p><pre><code>[1,2,3],   [1,2,3]</code></pre><p>输出: true</p><p>示例 2:</p><p>输入: 1 1<br> / <br> 2 2</p><pre><code>[1,2],     [1,null,2]</code></pre><p>输出: false</p><p>示例 3:</p><p>输入: 1 1<br> / \ / <br> 2 1 1 2</p><pre><code>[1,2,1],   [1,1,2]</code></pre><p>输出: false<br>链接：<a href="https://leetcode-cn.com/problems/same-tree" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/same-tree</a></p><p>算法思路：</p><ol>  <li>递归，首先判断p和q 是不是空，然后判断它们的值是否相等。<br>若以上判断通过，则递归对子节点做同样操作。</li></ol><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(p==null&amp;&amp;q==null) return true;</span><br><span class="line">        if(q==null||p==null) return false;</span><br><span class="line">        if(p.val!=q.val) return false;</span><br><span class="line">        return isSameTree(p.right,q.right)&amp;&amp;isSameTree(p.left,q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133.克隆图"></a>133.克隆图</h3><p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。</p><p>示例：</p><p><img src="https://github.com/starstarb/clouding/blob/master/leetcode/113_sample.png" alt="error"><br>输入：<br>{“$id”:”1”,”neighbors”:[{“$id”:”2”,”neighbors”:[{“$ref”:”1”},{“$id”:”3”,”neighbors”:[{“$ref”:”2”},{“$id”:”4”,”neighbors”:[{“$ref”:”3”},{“$ref”:”1”}],”val”:4}],”val”:3}],”val”:2},{“$ref”:”4”}],”val”:1}</p><p>解释：<br>节点 1 的值是 1，它有两个邻居：节点 2 和 4 。<br>节点 2 的值是 2，它有两个邻居：节点 1 和 3 。<br>节点 3  的值是 3，它有两个邻居：节点 2 和 4 。<br>节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</p><p>提示：</p><pre><code>节点数介于 1 到 100 之间。无向图是一个简单图，这意味着图中没有重复的边，也没有自环。由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。必须将给定节点的拷贝作为对克隆图的引用返回。</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/clone-graph" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/clone-graph</a></p><p>算法思路：<br>遍历整个图，记录已经访问的点，用一个字典记录</p><ol>  <li>DFS</li></ol><ol start="2">  <li>BFS</li></ol><p>参考代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line"></span><br><span class="line">    public Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Node(int _val,List&lt;Node&gt; _neighbors) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node cloneGraph(Node node) &#123;</span><br><span class="line">        Map&lt;Node,Node&gt; lookup=new HashMap&lt;&gt;();</span><br><span class="line">        return dfs(node,lookup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node dfs(Node node,Map&lt;Node,Node&gt; lookup)&#123;</span><br><span class="line">      if(node==null)return null;</span><br><span class="line">      if(lookup.containsKey(node)) return lookup.get(node);</span><br><span class="line">      Node clone=new Node(node.val,new ArrayList&lt;&gt;());</span><br><span class="line">      lookup.put(node,clone);</span><br><span class="line">      for(Node n: node.neighbors) clone.neighbors.add(dfs(n,lookup));</span><br><span class="line">      return clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node cloneGraph(Node node) &#123;</span><br><span class="line">        if (node == null) return null;</span><br><span class="line">        Map&lt;Node, Node&gt; lookup = new HashMap&lt;&gt;();</span><br><span class="line">        Node clone = new Node(node.val, new ArrayList&lt;&gt;());</span><br><span class="line">        lookup.put(node, clone);</span><br><span class="line">        Deque&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Node tmp = queue.poll();</span><br><span class="line">            for (Node n : tmp.neighbors) &#123;</span><br><span class="line">                if (!lookup.containsKey(n)) &#123;</span><br><span class="line">                    lookup.put(n, new Node(n.val, new ArrayList&lt;&gt;()));</span><br><span class="line">                    queue.offer(n);</span><br><span class="line">                &#125;</span><br><span class="line">                lookup.get(tmp).neighbors.add(lookup.get(n));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104.  二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>3</code></pre><p> / <br> 9 20<br> / <br> 15 7</p><p>返回它的最大深度 3<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p><ol>  <li>递归：<br>时间复杂度: O(N)<br>空间复杂度: O(N) 最好情况：完全平衡树：O(log(N))<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>          </td>          <td class="code">            <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root==null) &#123;</span><br><span class="line">          return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">          int left_height=maxDepth(root.left);</span><br><span class="line">          int right_height=maxDepth(root.right);</span><br><span class="line">          return java.lang.Math.max(left_height,right_height)+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><p>DFS: 通过栈，将递归转化为迭代。  使用DFS访问每个节点，同时在每次访问时更新最大深度。<br>从包含根节点且相应深度为1的栈开始，将当前节点弹出栈并推入子节点，每一步都会更新深度。<br>时间、空间复杂度：O(N)</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">import javafx.util.Pair;</span><br><span class="line">import java.lang.Math;</span><br><span class="line">class Solution&#123;</span><br><span class="line">  public int maxDepth(TreeNode root)&#123;</span><br><span class="line">    Queue&lt;Pair&lt;TreeNode,Integer&gt;&gt; stack=new LinkedList&lt;&gt;();</span><br><span class="line">    if(root!=null)&#123;</span><br><span class="line">      stack.add(new Pair(root,1));</span><br><span class="line">    &#125;</span><br><span class="line">    int depth=0;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">      Pair&lt;TreeNode,Integer&gt; current=stack.poll();</span><br><span class="line">      root=current.getKey();</span><br><span class="line">      int current_depth=current.getValue();</span><br><span class="line">      if(root!=null)&#123;</span><br><span class="line">        depth=Math.max(depth,current_depth);</span><br><span class="line">        stack.add(new Pair(root.left,current_depth+1));</span><br><span class="line">        stack.add(new Pair(root.right,current_depth+1));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return depth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>  这里提一点，为什么在这里DFS比递归慢很多，因为测试的数据量太少，如果数据量大，选择DFS不会爆栈同时会比递归执行时间少很多，因此，以后在项目中要根据实际情况选择合适的算法。</p><h3 id="祖玛游戏"><a href="#祖玛游戏" class="headerlink" title="祖玛游戏"></a>祖玛游戏</h3><p>回忆一下祖玛游戏。现在桌上有一串球，颜色有红色(R)，黄色(Y)，蓝色(B)，绿色(G)，还有白色(W)。 现在你手里也有几个球。</p><p>  每一次，你可以从手里的球选一个，然后把这个球插入到一串球中的某个位置上（包括最左端，最右端）。接着，如果有出现三个或者三个以上颜色相同的球相连的话，就把它们移除掉。重复这一步骤直到桌上所有的球都被移除。</p><p>找到插入并可以移除掉桌上所有球所需的最少的球数。如果不能移除桌上所有的球，输出 -1 。</p><p>示例:<br>输入: “WRRBBW”, “RB”<br>输出: -1<br>解释: WRRBBW -&gt; WRR[R]BBW -&gt; WBBW  -&gt; WBB[B]W -&gt; WW （翻译者标注：手上球已经用完，桌上还剩两个球无法消除，返回-1）</p><p>输入: “WWRRBBWW”, “WRBRW”<br>输出: 2<br>解释: WWRRBBWW -&gt; WWRR[R]BBWW -&gt;  WWBBWW -&gt; WWBB[B]WW -&gt; WWWW -&gt; empty</p><p>输入:”G”, “GGGGG”<br>输出: 2<br>解释: G -&gt; G[G] -&gt; GG[G] -&gt; empty </p><p>输入: “RBYYBBRRB”, “YRBGB”<br>输出: 3<br>解释: RBYYBBRRB -&gt; RBYY[Y]BBRRB -&gt;  RBBBRRB -&gt; RRRB -&gt; B -&gt; B[B] -&gt; BB[B] -&gt; empty </p><p>标注:</p><pre><code>你可以假设桌上一开始的球中，不会有三个及三个以上颜色相同且连着的球。桌上的球不会超过20个，输入的数据中代表这些球的字符串的名字是 &quot;board&quot; 。你手中的球不会超过5个，输入的数据中代表这些球的字符串的名字是 &quot;hand&quot;。输入的两个字符串均为非空字符串，且只包含字符 &apos;R&apos;,&apos;Y&apos;,&apos;B&apos;,&apos;G&apos;,&apos;W&apos;。</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/zuma-game" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/zuma-game</a></p><p>思路：<br>题目希望我们用最少的球来消掉桌上所有的球，如果不能完全消掉，返回-1。</p><p>我们使用哈希表来统计手中每种球的个数。</p><p>  然后我们遍历桌上的球，我们找连续相同球的个数，在没有可以消除的情况下，连续的个数只能是1个或2个，然后我们用3减去连续个数，就是我们需要补充的球数以使其可以被消除，那么我们在哈希表表中看我们手中的该类型的球够不够，如果够就表示可以消除，我们在哈希表中减去需要使用掉的球数，然后将消掉的球移除。</p><p>  然后对新的字符串调用递归，如果可以成功消除，会返回一个结果，该结果加上之前需要的球数用来更新结果res，注意调用完递归要恢复哈希表的状态(backtrack)。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Solution &#123;</span><br><span class="line">    int MAXCOUNT = 6;</span><br><span class="line">    // the max balls you need will not exceed 6 since &quot;The number of balls in your hand won&apos;t exceed 5&quot;</span><br><span class="line">    public int findMinStep(String board, String hand) &#123;</span><br><span class="line">        int[] handCount = new int[26];</span><br><span class="line">        for (int i = 0; i &lt; hand.length(); i++) &#123;</span><br><span class="line">            handCount[hand.charAt(i) - &apos;A&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int result = backtrack(board + &quot;#&quot;, handCount);</span><br><span class="line">        // append a &quot;#&quot; to avoid special process while j==board.length, make the code shorter.</span><br><span class="line">        return result == MAXCOUNT ? -1 : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int backtrack(String s, int[] h) &#123;</span><br><span class="line">        s = removeConsecutive(s);</span><br><span class="line">        if (s.equals(&quot;#&quot;)) return 0;</span><br><span class="line">        int rs = MAXCOUNT, need = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int j = 0 ; j &lt; s.length(); ++j) &#123;</span><br><span class="line">            if (s.charAt(j) == s.charAt(i)) continue;</span><br><span class="line">            need = 3 - (j - i);</span><br><span class="line">            //balls need to remove current consecutive balls.</span><br><span class="line">            if (h[s.charAt(i) - &apos;A&apos;] &gt;= need) &#123;</span><br><span class="line">                h[s.charAt(i) - &apos;A&apos;] -= need;</span><br><span class="line">                rs = Math.min(rs, need + backtrack(s.substring(0, i) + s.substring(j), h));</span><br><span class="line">                h[s.charAt(i) - &apos;A&apos;] += need;</span><br><span class="line">            &#125;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return rs;</span><br><span class="line">    &#125;</span><br><span class="line">    //remove consecutive balls longer than 3</span><br><span class="line">    private String removeConsecutive(String board) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int j = 0; j &lt; board.length(); ++j) &#123;</span><br><span class="line">            if (board.charAt(j) == board.charAt(i)) continue;</span><br><span class="line">            if (j - i &gt;= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));</span><br><span class="line">            else i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>算法</strong><br>(dfs)</p><p>  我们先将手中的球用哈希表来存储一下，然后看桌上的球能否在哈希表里的球添加后消除，然后消除后递归处理剩下的。中间记录需要的球数，用来更新需要球数的最小值。如果最小值超出了手中球的个数，则无法消除。</p><p>时间复杂度分析：桌上的球不会超过20个，手中的球不会超过5个，所以时间复杂度为O(m+n).<br>C++ 代码</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string del(string board)&#123;</span><br><span class="line">        for(int i=0;i&lt;board.size();)&#123;</span><br><span class="line">            int j=i;</span><br><span class="line">            while(j&lt;board.size()&amp;&amp;board[i]==board[j])j++;</span><br><span class="line">            if(j-i&gt;=3)</span><br><span class="line">                return del(board.substr(0,i)+board.substr(j));</span><br><span class="line">            else i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        return board;</span><br><span class="line">    &#125;</span><br><span class="line">    int dfs(string board, unordered_map&lt;char,int&gt;&amp;hash)&#123;</span><br><span class="line">        board=del(board);</span><br><span class="line">        if(board.size()==0)return 0;</span><br><span class="line">        int rs=6,need=0;</span><br><span class="line">        for(int i=0;i&lt;board.size();)&#123;</span><br><span class="line">            int j=i;</span><br><span class="line">            while(j&lt;board.size()&amp;&amp;board[i]==board[j])j++;</span><br><span class="line">            need=3-(j-i);</span><br><span class="line">            if(hash[board[i]]&gt;=need)&#123;</span><br><span class="line">                hash[board[i]]-=need;</span><br><span class="line">                rs=min(rs,need+dfs(board.substr(0,i)+board.substr(j),hash));</span><br><span class="line">                hash[board[i]]+=need;</span><br><span class="line">            &#125;</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        return rs;</span><br><span class="line">    &#125;</span><br><span class="line">    int findMinStep(string board, string hand) &#123;</span><br><span class="line">        unordered_map&lt;char,int&gt;hash;</span><br><span class="line">        for(auto x:hand)hash[x]++;</span><br><span class="line">        int res=dfs(board,hash);</span><br><span class="line">        return res==6?-1:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DFS&lt;/p&gt;
    
    </summary>
    
      <category term="DFS" scheme="http://javastar.club/categories/DFS/"/>
    
    
      <category term="DFS" scheme="http://javastar.club/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="http://javastar.club/archives/59a0de58.html"/>
    <id>http://javastar.club/archives/59a0de58.html</id>
    <published>2019-07-29T06:11:44.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>树状数组</p><a id="more"></a><h3 id="区域和检索-–数组可修改"><a href="#区域和检索-–数组可修改" class="headerlink" title="区域和检索 –数组可修改"></a>区域和检索  –数组可修改</h3><p>给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。</p><p>update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。</p><p>示例:</p><p>Given nums = [1, 3, 5]</p><p>sumRange(0, 2) -&gt; 9<br>update(1, 2)<br>sumRange(0, 2) -&gt; 8</p><p>说明:</p><pre><code>数组仅可以在 update 函数下进行修改。你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-mutable" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/range-sum-query-mutable</a><br>算法思路：<br>方法一：<br>区域和检索的一个简单的解决方案  - RSQ(i, j) 是将数组从索引 i 迭代到 j 并对每个元素求和。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">private int[] nums;</span><br><span class="line">public int sumRange(int i, int j) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int l = i; l &lt;= j; l++) &#123;</span><br><span class="line">        sum += data[l];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int update(int i, int val) &#123;</span><br><span class="line">    nums[i] = val;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>复杂度分析:</p><pre><code>时间复杂度：O(n)。区域和检索 O(1) 的更新查询 对于区域和检索，我们从数组中访问每个元素的时间是固定的，在最坏的情况下，我们访问 n 元素。因此，时间复杂度为 O(n)O。更新查询的时间复杂度为 O(1))。空间复杂度：O(1)</code></pre><p>方法二：sqrt 分解</p><p>其思想是将数组分割成块，块的长度为 sqrt（n）<br>​。然后我们计算每个块的和，并将其存储在辅助存储器 b 中。<br>要查询 RSQ(i,  j)，我们将添加位于内部的所有块和部分在范围[i…j] 重叠的块的总和。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre>      </td>      <td class="code">        <pre><span class="line">private int[] b;</span><br><span class="line">private int len;</span><br><span class="line">private int[] nums;</span><br><span class="line">public NumArray(int [] nums)</span><br><span class="line">&#123;</span><br><span class="line">this.nums=nums;</span><br><span class="line">double l=Math.sqrt(nums.length);</span><br><span class="line">len=(int) Math.ceil(nums.length/l);</span><br><span class="line">b=new int[len];</span><br><span class="line">for(int i=0;i&lt;nums.length;i++)</span><br><span class="line">b[i/len]+=nums[i];</span><br><span class="line">&#125;</span><br><span class="line">public int sumRange(int i,int j)&#123;</span><br><span class="line">int sum=0;</span><br><span class="line">int startBlock=i/len;</span><br><span class="line">int endBlock=j/len;</span><br><span class="line">if(startBlock==endBlock)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=i;k&lt;=j;k++)</span><br><span class="line">sum+=nums[k];</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">for(int k=i;k&lt;=(startBlock+1)*len-1;k++)</span><br><span class="line">sum+=nums[k];</span><br><span class="line">for(int k=startBlock+1;k&lt;=endBlock-1;k++)</span><br><span class="line">sum+=b[k];</span><br><span class="line">for(int k=endBlock*len;k&lt;=j;k++)</span><br><span class="line">sum+=nums[k];</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">public void update(int i,int val)</span><br><span class="line">&#123;</span><br><span class="line">int b_l=i/len;</span><br><span class="line">b[b_l] = b[b_l] - nums[i] + val;</span><br><span class="line">    nums[i] = val;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树状数组&lt;/p&gt;
    
    </summary>
    
      <category term="算法刷题" scheme="http://javastar.club/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="树状数组" scheme="http://javastar.club/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>多线程笔试题</title>
    <link href="http://javastar.club/archives/190a403c.html"/>
    <id>http://javastar.club/archives/190a403c.html</id>
    <published>2019-07-29T06:11:32.000Z</published>
    <updated>2019-08-07T07:14:52.720Z</updated>
    
    <content type="html"><![CDATA[<p>多线程面试</p><a id="more"></a><p><strong>补充基础知识：</strong></p><h3 id="线程的概述（Introduction）"><a href="#线程的概述（Introduction）" class="headerlink" title="线程的概述（Introduction）"></a>线程的概述（Introduction）</h3><p>线程是一个程序的多个执行路径，执行调度的单位，依托于进程存在。  线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。</p><p>注意：Java中的多线程是一种抢占机制而不是分时机制。抢占机制指的是有多个线程处于可运行状态，但是只允许一个线程在运行，他们通过竞争的方式抢占CPU。</p><h3 id="线程的定义（Defining）"><a href="#线程的定义（Defining）" class="headerlink" title="线程的定义（Defining）"></a>线程的定义（Defining）</h3><p> 定义一个线程（Defining a Thread）有两种方法</p><p> 1) 继承java.lang.Thread类</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 使用继承java.lang.Thread类的方式创建一个线程</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class ThreadTest extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写（Override）run()方法 JVM会自动调用该方法</span><br><span class="line">     */</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;I&apos;m running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>注意：重写(override)run()方法在该线程的start()方法被调用后，JVM会自动调用run方法来执行任务；<br>  但是重载（overload）run()方法，该方法和普通的成员方法一样，并不会因调用该线程的start()方法而被JVM自动运行。 例如：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class ThreadTest extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写（Override）run()方法 JVM会自动调用该方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;I&apos;m running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重载（Overload）run()方法 和普通的方法一样，并不会在该线程的start()方法被调用后被JVM自动运行</span><br><span class="line">     */</span><br><span class="line">    public void run(int times) &#123;</span><br><span class="line">        System.out.println(&quot;I&apos;m running!(Overload)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>注意：</strong>  不建议使用此方法定义线程，因为采用继承Thread的方式定义线程后，你不能在继承其他的类了，导致程序的可扩展性大大降低。<br> 2)  实现java.lang.Runnable接口<br>  <figure class="highlight plain">    <table>      <tr>        <td class="gutter">          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>        </td>        <td class="code">          <pre><span class="line">  /**</span><br><span class="line"> * 通过实现Runnable接口创建一个线程</span><br><span class="line"> */</span><br><span class="line">public class ThreadTest implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">            System.out.println(&quot;I&apos;m running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>        </td>      </tr>    </table>  </figure></p><h3 id="线程的启动（Starting）"><a href="#线程的启动（Starting）" class="headerlink" title="线程的启动（Starting）"></a>线程的启动（Starting）</h3><p> 任何一个线程的执行的前提都是必须有Thread class的实例存在，并且通过调用run()方法启动线程。</p><p> 1）如果线程是继承Thread类，则创建方式如下： </p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ThreadTest1 tt = new ThreadTest1();</span><br><span class="line">tt.start();</span><br></pre>      </td>    </tr>  </table></figure><p> 2）如果是实现Runnable接口，则创建方式如下：<br>  <figure class="highlight plain">    <table>      <tr>        <td class="gutter">          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>        </td>        <td class="code">          <pre><span class="line">ThreadTest2 tt = new ThreadTest2();</span><br><span class="line">Thread t = new Thread(tt);</span><br><span class="line">t.start();</span><br></pre>        </td>      </tr>    </table>  </figure></p><h3 id="线程的状态（State）"><a href="#线程的状态（State）" class="headerlink" title="线程的状态（State）"></a>线程的状态（State）</h3><p><strong>新生状态（New)</strong>：  当一个线程的实例被创建即使用new关键字和Thread类或其子类创建一个线程对象后，此时该线程处于新生(new)状态，处于新生状态的线程有自己的内存空间，但该线程并没有运行，此时线程还不是活着的（not  alive）；</p><p><strong>就绪状态（Runnable）</strong>：  通过调用线程实例的start()方法来启动线程使线程进入就绪状态(runnable)；处于就绪状态的线程已经具备了运行条件，但还没有被分配到CPU即不一定会被立即执行，此时处于线程就绪队列，等待系统为其分配CPCU，等待状态并不是执行状态；  此时线程是活着的（alive）；</p><p><strong>运行状态（Running)</strong>：  一旦获取CPU(被JVM选中)，线程就进入运行(running)状态，线程的run()方法才开始被执行；在运行状态的线程执行自己的run()方法中的操作，直到调用其他的方法而终止、或者等待某种资源而阻塞、或者完成任务而死亡；如果在给定的时间片内没有执行结束，就会被系统给换下来回到线程的等待状态；此时线程是活着的（alive）；</p><p>  <strong>阻塞状态（Blocked）</strong>：通过调用join()、sleep()、wait()或者资源被暂用使线程处于阻塞(blocked)状态；处于Blocking状态的线程仍然是活着的（alive）</p><p>  <strong>死亡状态（Dead）</strong>：当一个线程的run()方法运行完毕或被中断或被异常退出，该线程到达死亡(dead)状态。此时可能仍然存在一个该Thread的实例对象，当该Thready已经不可能在被作为一个可被独立执行的线程对待了，线程的独立的call  stack已经被dissolved。一旦某一线程进入Dead状态，他就再也不能进入一个独立线程的生命周期了。对于一个处于Dead状态的线程调用start()方法，会出现一个运行期(runtime  exception)的异常；处于Dead状态的线程不是活着的（not alive）。</p><h3 id="线程的方法（Method）、属性（Property）"><a href="#线程的方法（Method）、属性（Property）" class="headerlink" title="线程的方法（Method）、属性（Property）"></a>线程的方法（Method）、属性（Property）</h3><ol>  <li>优先级（priority）</li></ol><p>  每个类都有自己的优先级，一般property用1-10的整数表示，默认优先级是5，优先级最高是10；优先级高的线程并不一定比优先级低的线程执行的机会高，只是执行的机率高；默认一个线程的优先级和创建他的线程优先级相同；</p><ol start="2">  <li>Thread.sleep()/sleep(long millis)</li></ol><p>  当前线程睡眠/millis的时间（millis指定睡眠时间是其最小的不执行时间，因为sleep(millis)休眠到达后，无法保证会被JVM立即调度）；sleep()是一个静态方法(static  method) ，所以他不会停止其他的线程也处于休眠状态；线程sleep()时不会失去拥有的对象锁。  作用：保持对象锁，让出CPU，调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留一定的时间给其他线程执行的机会；</p><ol start="3">  <li>    <p>Thread.yield()</p>    <p>      让出CPU的使用权，给其他线程执行机会、让同等优先权的线程运行（但并不保证当前线程会被JVM再次调度、使该线程重新进入Running状态），如果没有同等优先权的线程，那么yield()方法将不会起作用。    </p>  </li>  <li>    <p>thread.join()</p>    <p>使用该方法的线程会在此之间执行完毕后再往下继续执行。</p>  </li>  <li>    <p>object.wait()</p>    <p>当一个线程执行到wait()方法时，他就进入到一个和该对象相关的等待池(Waiting      Pool)中，同时失去了对象的机锁—暂时的，wait后还要返还对象锁。当前线程必须拥有当前对象的锁，如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常,所以wait()必须在synchronized      block中调用。</p>  </li>  <li>    <p>object.notify()/notifyAll()</p>    <p>      唤醒在当前对象等待池中等待的第一个线程/所有线程。notify()/notifyAll()也必须拥有相同对象锁，否则也会抛出IllegalMonitorStateException异常。    </p>  </li>  <li>    <p>Synchronizing Block<br>Synchronized      Block/方法控制对类成员变量的访问；Java中的每一个对象都有唯一的一个内置的锁，每个Synchronized      Block/方法只有持有调用该方法被锁定对象的锁才可以访问，否则所属线程阻塞；机锁具有独占性、一旦被一个Thread持有，其他的Thread就不能再拥有（不能访问其他同步方法），方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。    </p>  </li></ol><h3 id="按序打印"><a href="#按序打印" class="headerlink" title="按序打印"></a>按序打印</h3><p>我们提供了一个类：</p><p>public class Foo {<br> public void one() { print(“one”); }<br> public void  two() { print(“two”); }<br> public void three() { print(“three”); }<br>}</p><p>三个不同的线程将会共用一个 Foo 实例。</p><pre><code>线程 A 将会调用 one() 方法线程 B 将会调用 two() 方法线程 C 将会调用 three() 方法</code></pre><p>请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p><p>示例 1:</p><p>输入: [1,2,3]<br>输出: “onetwothree”<br>解释:<br>有三个线程会被异步启动。<br>输入 [1,2,3] 表示线程 A  将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。<br>正确的输出是  “onetwothree”。</p><p>示例 2:</p><p>输入: [1,3,2]<br>输出: “onetwothree”<br>解释:<br>输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程  B 将会调用 three() 方法，线程 C 将会调用 two() 方法。<br>正确的输出是 “onetwothree”。</p><p>注意:</p><p>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</p><p>你看到的输入格式主要是为了确保测试的全面性。<br>链接：<a href="https://leetcode-cn.com/problems/print-in-order" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/print-in-order</a><br>算法思路：</p><p>Java 中，我们使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除。<br>参考代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Foo &#123;</span><br><span class="line">private boolean firstFinished;</span><br><span class="line">private boolean secondFinished;</span><br><span class="line">private Object lock=new Object();</span><br><span class="line"></span><br><span class="line">    public Foo() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        // printFirst.run() outputs &quot;first&quot;. Do not change or remove this line.</span><br><span class="line">       </span><br><span class="line">       synchronized(lock)&#123;</span><br><span class="line">       printFirst.run();</span><br><span class="line">       firstFinished=true;</span><br><span class="line">       lock.notifyAll();</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        // printSecond.run() outputs &quot;second&quot;. Do not change or remove this line.</span><br><span class="line">        </span><br><span class="line">        synchronized(lock)&#123;</span><br><span class="line">        while(!firstFinished)&#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        printSecond.run();</span><br><span class="line">        secondFinished=true;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        // printThird.run() outputs &quot;third&quot;. Do not change or remove this line.</span><br><span class="line">        synchronized(lock)&#123;</span><br><span class="line">        while(!secondFinished)&#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        printThird.run();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程面试&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://javastar.club/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="多线程笔试" scheme="http://javastar.club/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ACM常用算法模板</title>
    <link href="http://javastar.club/archives/a95aaa1f.html"/>
    <id>http://javastar.club/archives/a95aaa1f.html</id>
    <published>2019-07-28T02:33:21.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>算法模板学习</p><a id="more"></a><h4 id="文本输入输出"><a href="#文本输入输出" class="headerlink" title="文本输入输出"></a>文本输入输出</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">void fre()&#123;</span><br><span class="line">freopen(&quot;C:\\Users\\Desktop\\输入文本.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">freopen(&quot;C:\\Users\\Desktop\\输出文本.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">&#125;    //注意都是双\</span><br></pre>      </td>    </tr>  </table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Eg:1 2 2 3 4 =》 1 2 3 4 2</span><br><span class="line">int b[N];</span><br><span class="line">sort(b,b+N);</span><br><span class="line">int len = unique(b, b + n) - b;//返回的是4的位置</span><br></pre>      </td>    </tr>  </table></figure><h3 id="GCD、LCM"><a href="#GCD、LCM" class="headerlink" title="GCD、LCM"></a>GCD、LCM</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">int gcd(int a,int b)&#123;  return b?gcd(b,a%b):a;&#125;    //最大公约数 b==0</span><br><span class="line">lcm = a * b / gcd(a,b)    //最小公倍数</span><br></pre>      </td>    </tr>  </table></figure><h3 id="字符串-lt-gt-整型"><a href="#字符串-lt-gt-整型" class="headerlink" title="字符串 &lt;-&gt; 整型"></a>字符串  &lt;-&gt; 整型</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sscanf(s,&quot;%d&quot;,&amp;n);//从字符串s中读入整数n</span><br><span class="line">sprintf(s,&quot;%d&quot;,n);//将n转换为字符串s</span><br></pre>      </td>    </tr>  </table></figure><h3 id="getchar-读入转str"><a href="#getchar-读入转str" class="headerlink" title="getchar()读入转str"></a>getchar()读入转str</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">while ((x1[0] = getchar()) &amp;&amp; x1[0] != &apos;\n&apos;)&#123;</span><br><span class="line">int len1 = 1;</span><br><span class="line">while ((x1[len1] = getchar()) &amp;&amp; x1[len1] != &apos; &apos;)len1++;</span><br><span class="line">x1[len1] = &apos;\0&apos;;</span><br><span class="line">string s1 = x1;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="char-转Int"><a href="#char-转Int" class="headerlink" title="char[]转Int"></a>char[]转Int</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">char s[100];</span><br><span class="line">int x=atoi(s);</span><br></pre>      </td>    </tr>  </table></figure><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">(a+b)%m=(a%m)+(b%m)</span><br><span class="line">(a-b)%m=(a%m)-(b%m)  //稍微留意负数情况</span><br><span class="line">(a*b)%m=(a%m)*(b%m)</span><br><span class="line">m^n%c=(m%c)^n%c;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="求n-位数"><a href="#求n-位数" class="headerlink" title="求n!位数"></a>求n!位数</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">for(int i=2;i&lt;=n;i++) </span><br><span class="line">    len+=log10(i*1.0);  </span><br><span class="line">ans=(int)len+1;</span><br></pre>      </td>    </tr>  </table></figure><p>斯特林公式：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">len=0.5*log10(2*3.1415927*n)+n*log10(n/2.718281828459); </span><br><span class="line">ans=(int)len+1;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>N个方格m种颜色问有多少种染色方案：</p><p>设F(m)为在n个方格上使用m种颜色任意染色的方案数</p><p>F(m)=m^n，使用快速幂求一次F(m)的时间为O(log(n))</p><p>Ans=C(m,m)F(m)-C(m,m-1)F(m-1)+C(m,m-2)F(m-2)-C(m,m-3)F(m-3)+……</p><p>用杨辉三角预处理出C(m,n)花费O(m^2)</p><p>总时间复杂度为O(m^2+mlog(n))</p><h3 id="Log与自然对数e"><a href="#Log与自然对数e" class="headerlink" title="Log与自然对数e"></a>Log与自然对数e</h3><p>Log（x）表示ln（x） ，其他例如：log10（x） ，log2（x），用exp（x）来表示e^</p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>      </td>      <td class="code">        <pre><span class="line">long long Pow(long long a,long long n)&#123;</span><br><span class="line">long long ret=1;</span><br><span class="line">while(n)&#123;</span><br><span class="line">if(n&amp;1)ret*=a;</span><br><span class="line">a*=a;</span><br><span class="line">n&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">long long Mod_Pow(long long a,long long n,long long mod)&#123;</span><br><span class="line">long long ret=1;</span><br><span class="line">while(n)&#123;</span><br><span class="line">if(n&amp;1)ret=(ret*a)%mod;</span><br><span class="line">a=(a*a)%mod;</span><br><span class="line">n&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p> 快速幂算法——可迅速求出a^b。其主要理论依据如下：</p><p> 1，当b为偶数时，a^b可以转为a^2的b/2次方。</p><p>  2，当b为奇数时，a^b可以转为a^2的b/2次方，再乘以a。<br>而a^2的b/2次方，可以使用上述方式转为a^4的b/4次方再乘以某个数。<br>在每一次进行循环时，如果b为奇数，则a^b可以转为a^2的b/2次方乘以a。所以每一次进行a^2计算时，需要根据b是否为奇数决定是否在最终的结果上乘以a。<br>a  = a* a;此步计算完成后，则a是下一个进行平方运算的数。这样当所有的循环结束后，a就是a^k，其中k是离b最近的，且为2的整数次方的数。</p><p>利用快速幂方法可以迅速求出一个数的任意次方。再结合a* b%m=(a%m)*  (b%m)%m，只是要相乘后再取模，就可以先取模再相乘，然后再取模的规律。我们不考虑a最终会用来做什么，反正a就是用来相乘然后取模的，所以可以直接将a进行取模，然后再进行相乘。<br>同理，对于if判断中的操作也是如此：因为要相乘再取模，所以就先取模再相乘。</p><h3 id="求1到n的数的异或和O（1）"><a href="#求1到n的数的异或和O（1）" class="headerlink" title="求1到n的数的异或和O（1）"></a>求1到n的数的异或和O（1）</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">unsigned xor_n(unsigned n)&#123;</span><br><span class="line">unsigned t = n &amp; 3;</span><br><span class="line">if (t &amp; 1) return t / 2u ^ 1;   //照着打就行，u默认为unsigned int</span><br><span class="line">return t / 2u ^ n;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>给定一个凸n边形，问将其划分成三角形的方法数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">1,1,2,5,14,42,132….</span><br><span class="line"></span><br><span class="line">h(n)=h(n-1)*(4*n-2)/(n+1)</span><br><span class="line">h(n)=C(2n,n)/(n+1)</span><br><span class="line">h(0)=1</span><br></pre>      </td>    </tr>  </table></figure><h3 id="错排公式"><a href="#错排公式" class="headerlink" title="错排公式"></a>错排公式</h3><p>给定n种颜色篮子和n种颜色球，求全放错情况数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">D(n)=(n-1)*(D(n-2)+D(n-1))</span><br><span class="line">D(1)=0,D(2)=1</span><br></pre>      </td>    </tr>  </table></figure><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><p>（N以内有大概num=N/ln（x）个素数，N越大越准）</p><ol>  <li>    <p>简单素数打表：O(n* sqrt(n))</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>          </td>          <td class="code">            <pre><span class="line">void prim()&#123;</span><br><span class="line">int num = 0;</span><br><span class="line">for (int i = 2; i &lt; maxn; i++)&#123;</span><br><span class="line">int k = 1;</span><br><span class="line">for (int j = 2; j &lt;= (int)sqrt(i);j++)</span><br><span class="line">if (i%j == 0) &#123; k = 0; break; &#125;</span><br><span class="line">if (k) pri[num++] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>素数筛法：O(nlogn)</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>          </td>          <td class="code">            <pre><span class="line">vector&lt;int&gt; pri;</span><br><span class="line">void prim()&#123;</span><br><span class="line">vis[0] = vis[1] = true;</span><br><span class="line">for (int i = 2; i &lt; maxn; i++)</span><br><span class="line">if (!vis[i])&#123;</span><br><span class="line">pri.push_back(i);</span><br><span class="line">for (int j = i + i; j &lt; maxn; j += i)</span><br><span class="line">vis[j] = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>高效素数打表:O(n)<br>(线性筛法–欧拉 )</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>          </td>          <td class="code">            <pre><span class="line">void prim()&#123;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">int num = 0;</span><br><span class="line">for (int i = 2; i &lt;= M; ++i)&#123;</span><br><span class="line">if (!vis[i])  pri[num++] = i;   </span><br><span class="line">for (int j = 1; ((j &lt;= num) &amp;&amp; (i * pri[j] &lt;= M)); ++j)&#123;</span><br><span class="line">vis[i * pri[j]] = 1;</span><br><span class="line">if (i % pri[j] == 0) break;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;//1不是素数，最小素数为2</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line">vector&lt;int&gt; V[N]; </span><br><span class="line">void getDiv(int x, int idx) &#123; //得到的是所有种类 eg：12=》2，3</span><br><span class="line">if (x == 1) &#123;</span><br><span class="line">V[idx].push_back  (1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int len = (int)sqrt(x);</span><br><span class="line">for (int i = 2; i &lt;= (int)len; i++)</span><br><span class="line">if (x % i == 0)</span><br><span class="line">V[idx].push_back  (i), V[idx].push_back  (x / i);</span><br><span class="line">if (len * len == x)</span><br><span class="line">V[idx].pop_back();</span><br><span class="line">V[idx].push_back  (x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void fun(long long x) &#123;//得到的是所有质因数 eg：12=》2，2，3</span><br><span class="line">p.clear();</span><br><span class="line">for (long long i = 2; i &lt;=sqrt(x); i++)&#123;</span><br><span class="line">while (x%i == 0)&#123;</span><br><span class="line">p.push_back(i);</span><br><span class="line">x /= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br><span class="line">       if (x != 1) p.push_back(x);   </span><br><span class="line"> &#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="吉姆拉尔森公式"><a href="#吉姆拉尔森公式" class="headerlink" title="吉姆拉尔森公式"></a>吉姆拉尔森公式</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">int CaculateWeekDay(int y,int m, int d)  </span><br><span class="line">&#123;  </span><br><span class="line">    if(m==1||m==2) &#123;//把一月和二月看为是上一年的十三月和十四月</span><br><span class="line">        m+=12;  </span><br><span class="line">        y--;  </span><br><span class="line">    &#125;  </span><br><span class="line">    int iWeek=(d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7;  </span><br><span class="line">    return iWeek;  </span><br><span class="line">&#125;  //给定年月日O（1）算周数</span><br></pre>      </td>    </tr>  </table></figure><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/*</span><br><span class="line">**高精度，支持乘法和加法</span><br><span class="line">*/</span><br><span class="line">struct  Big_Num</span><br><span class="line">&#123;</span><br><span class="line">const  static  int   mod = 10000;//每4位数存一次</span><br><span class="line">const  static  int   DLEN = 4;</span><br><span class="line">int  num[600],  len;  </span><br><span class="line">Big_Num()</span><br><span class="line">&#123;</span><br><span class="line">memset(num, 0, sizeof(num));</span><br><span class="line">len = 1;</span><br><span class="line">&#125;</span><br><span class="line">Big_Num(int   v)</span><br><span class="line">&#123;</span><br><span class="line">memset(num, 0, sizeof(num));</span><br><span class="line">len = 0;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">num[len++] = v%mod;</span><br><span class="line">v /= mod;</span><br><span class="line">&#125; while (v);</span><br><span class="line">&#125;</span><br><span class="line">Big_Num(const char  s[])</span><br><span class="line">&#123;</span><br><span class="line">memset(num, 0, sizeof(num));</span><br><span class="line">int L = strlen(s);</span><br><span class="line">len = L / DLEN;</span><br><span class="line">if (L%DLEN)len++;</span><br><span class="line">int index = 0;</span><br><span class="line">for (int i = L - 1; i &gt;= 0; i -= DLEN)</span><br><span class="line">&#123;</span><br><span class="line">int t = 0;</span><br><span class="line">int k = i - DLEN + 1;</span><br><span class="line">if (k &lt; 0)k = 0;</span><br><span class="line">for (int j = k; j &lt;= i; j++)</span><br><span class="line">t = t * 10 + s[j] - &apos;0&apos;;</span><br><span class="line">num[index++] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Big_Num  operator +(const Big_Num &amp;b)const</span><br><span class="line">&#123;</span><br><span class="line">Big_Num  res;</span><br><span class="line">res.len = max(len, b.len);</span><br><span class="line">for (int i = 0; i &lt;= res.len; i++)</span><br><span class="line">res.num[i] = 0;</span><br><span class="line">for (int i = 0; i &lt; res.len; i++)</span><br><span class="line">&#123;</span><br><span class="line">res.num[i] += ((i &lt; len) ? num[i] : 0) + ((i &lt; b.len) ? b.num[i] : 0);</span><br><span class="line">res.num[i + 1] += res.num[i] / mod;</span><br><span class="line">res.num[i] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">if (res.num[res.len] &gt; 0)res.len++;</span><br><span class="line">return  res;</span><br><span class="line">&#125;</span><br><span class="line">Big_Num  operator *(const Big_Num &amp;b)const</span><br><span class="line">&#123;</span><br><span class="line">Big_Num  res;</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">int up = 0;</span><br><span class="line">for (int j = 0; j &lt; b.len; j++)</span><br><span class="line">&#123;</span><br><span class="line">int temp = num[i] * b.num[j] + res.num[i + j] + up;</span><br><span class="line">res.num[i + j] = temp%mod;</span><br><span class="line">up = temp / mod;</span><br><span class="line">&#125;</span><br><span class="line">if (up != 0)</span><br><span class="line">res.num[i + b.len] = up;</span><br><span class="line">&#125;</span><br><span class="line">res.len = len + b.len;</span><br><span class="line">while (res.num[res.len - 1] == 0 &amp;&amp; res.len &gt; 1)res.len--;</span><br><span class="line">return  res;</span><br><span class="line">&#125;</span><br><span class="line">void  output()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;, num[len - 1]);</span><br><span class="line">for (int i = len - 2; i &gt;= 0; i--)</span><br><span class="line">printf(&quot;%04d&quot;, num[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="完全高精度"><a href="#完全高精度" class="headerlink" title="完全高精度"></a>完全高精度</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5 + 50;</span><br><span class="line">/*</span><br><span class="line">*完全大数模板</span><br><span class="line">*输入cin&gt;&gt;a</span><br><span class="line">*输出a.print();</span><br><span class="line">*注意这个输入不能自动去掉前导0的，可以先读入到char数组，去掉前导0，再用构造函数。</span><br><span class="line">*/</span><br><span class="line">#define MAXN 9999</span><br><span class="line">#define MAXSIZE 1010</span><br><span class="line">#define DLEN 4</span><br><span class="line">class  BigNum</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int a[500];                               //可以控制大数的位数</span><br><span class="line">int  len;</span><br><span class="line">public:</span><br><span class="line">BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125;//构造函数</span><br><span class="line">BigNum(const   int);                      //将一个int类型的变量转化成大数</span><br><span class="line">BigNum(const   char*);                    //将一个字符串类型的变量转化为大数</span><br><span class="line">BigNum(const BigNum &amp;);                   //拷贝构造函数</span><br><span class="line">BigNum &amp;operator=(const  BigNum &amp;);       //重载赋值运算符，大数之间进行赋值运算</span><br><span class="line">friend istream&amp;   operator &gt;&gt; (istream&amp;, BigNum&amp;);//重载输入运算符</span><br><span class="line">friend ostream&amp;   operator&lt;&lt;(ostream&amp;, BigNum&amp;);//重载输出运算符</span><br><span class="line">BigNum  operator+(const  BigNum &amp;)const;  //重载加法运算符，两个大数之间的相加运算</span><br><span class="line">BigNum  operator-(const  BigNum &amp;)const;  //重载减法运算符，两个大数之间的相减运算</span><br><span class="line">BigNum  operator*(const  BigNum &amp;)const;  //重载乘法运算符，两个大数之间的相乘运算</span><br><span class="line">BigNum  operator/(const   int &amp;)const;    //重载除法运算符，大数对一个整数进行相除运算</span><br><span class="line">BigNum  operator^(const   int &amp;)const;    //大数的n次方运算</span><br><span class="line">int   operator%(const   int &amp;)const;      //大数对一个int类型的变量进行取模运算</span><br><span class="line">bool  operator&gt;(const BigNum  &amp;T)const;   //大数和另一个大数的大小比较</span><br><span class="line">bool  operator&gt;(const   int &amp;t)const;     //大数和一个int类型的变量的大小比较</span><br><span class="line">void  print();                            //输出大数</span><br><span class="line">&#125;;</span><br><span class="line">BigNum::BigNum(const   int b)   //将一个int类型的变量转化为大数</span><br><span class="line">&#123;</span><br><span class="line">int  c, d = b;</span><br><span class="line">len = 0;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">while (d&gt;MAXN)</span><br><span class="line">&#123;</span><br><span class="line">c = d - (d / (MAXN + 1))*(MAXN + 1);</span><br><span class="line">d = d / (MAXN + 1);</span><br><span class="line">a[len++] = c;</span><br><span class="line">&#125;</span><br><span class="line">a[len++] = d;</span><br><span class="line">&#125;</span><br><span class="line">BigNum::BigNum(const   char *s)  //将一个字符串类型的变量转化为大数</span><br><span class="line">&#123;</span><br><span class="line">int  t, k, index, L, i;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">L = strlen(s);</span><br><span class="line">len = L / DLEN;</span><br><span class="line">if (L%DLEN)len++;</span><br><span class="line">index = 0;</span><br><span class="line">for (i = L - 1; i &gt;= 0; i -= DLEN)</span><br><span class="line">&#123;</span><br><span class="line">t = 0;</span><br><span class="line">k = i - DLEN + 1;</span><br><span class="line">if (k&lt;0)k = 0;</span><br><span class="line">for (int j = k; j &lt;= i; j++)</span><br><span class="line">t = t * 10 + s[j] - &apos;0&apos;;</span><br><span class="line">a[index++] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BigNum::BigNum(const BigNum  &amp;T) :len(T.len)  //拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line">int  i;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">for (i = 0; i&lt;len; i++)</span><br><span class="line">a[i] = T.a[i];</span><br><span class="line">&#125;</span><br><span class="line">BigNum &amp;  BigNum::operator=(const  BigNum &amp;n)  //重载赋值运算符，大数之间赋值运算</span><br><span class="line">&#123;</span><br><span class="line">int  i;</span><br><span class="line">len = n.len;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">for (i = 0; i&lt;len; i++)</span><br><span class="line">a[i] = n.a[i];</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp;  operator &gt;&gt; (istream &amp;in, BigNum &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">char  ch[MAXSIZE * 4];</span><br><span class="line">int  i = -1;</span><br><span class="line">in &gt;&gt; ch;</span><br><span class="line">int L = strlen(ch);</span><br><span class="line">int  count = 0, sum = 0;</span><br><span class="line">for (i = L - 1; i &gt;= 0;)</span><br><span class="line">&#123;</span><br><span class="line">sum = 0;</span><br><span class="line">int  t = 1;</span><br><span class="line">for (int j = 0; j &lt; 4 &amp;&amp; i &gt;= 0; j++, i--, t *= 10)</span><br><span class="line">&#123;</span><br><span class="line">sum += (ch[i] - &apos;0&apos;)*t;</span><br><span class="line">&#125;</span><br><span class="line">b.a[count] = sum;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">b.len = count++;</span><br><span class="line">return  in;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp;  operator&lt;&lt;(ostream&amp;  out, BigNum&amp; b)  //重载输出运算符</span><br><span class="line">&#123;</span><br><span class="line">int  i;</span><br><span class="line">cout &lt;&lt; b.a[b.len - 1];</span><br><span class="line">for (i = b.len - 2; i &gt;= 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%04d&quot;, b.a[i]);</span><br><span class="line">&#125;</span><br><span class="line">return  out;</span><br><span class="line">&#125;</span><br><span class="line">BigNum  BigNum::operator+(const  BigNum &amp;T)const   //两个大数之间的相加运算</span><br><span class="line">&#123;</span><br><span class="line">BigNum t(*this);</span><br><span class="line">int  i, big;</span><br><span class="line">big = T.len&gt;len ? T.len : len;</span><br><span class="line">for (i = 0; i&lt;big; i++)</span><br><span class="line">&#123;</span><br><span class="line">t.a[i] += T.a[i];</span><br><span class="line">if (t.a[i]&gt;MAXN)</span><br><span class="line">&#123;</span><br><span class="line">t.a[i + 1]++;</span><br><span class="line">t.a[i] -= MAXN + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (t.a[big] != 0)</span><br><span class="line">t.len = big + 1;</span><br><span class="line">else  t.len = big;</span><br><span class="line">return  t;</span><br><span class="line">&#125;</span><br><span class="line">BigNum  BigNum::operator-(const  BigNum &amp;T)const  //两个大数之间的相减运算</span><br><span class="line">&#123;</span><br><span class="line">int  i, j, big;</span><br><span class="line">bool  flag;</span><br><span class="line">BigNum  t1, t2;</span><br><span class="line">if (*this&gt;T)</span><br><span class="line">&#123;</span><br><span class="line">t1 = *this;</span><br><span class="line">t2 = T;</span><br><span class="line">flag = 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">t1 = T;</span><br><span class="line">t2 = *this;</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">big = t1.len;</span><br><span class="line">for (i = 0; i&lt;big; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (t1.a[i]&lt;t2.a[i])</span><br><span class="line">&#123;</span><br><span class="line">j = i + 1;</span><br><span class="line">while (t1.a[j] == 0)</span><br><span class="line">j++;</span><br><span class="line">t1.a[j--]--;</span><br><span class="line">while (j&gt;i)</span><br><span class="line">t1.a[j--] += MAXN;</span><br><span class="line">t1.a[i] += MAXN + 1 - t2.a[i];</span><br><span class="line">&#125;</span><br><span class="line">else  t1.a[i] -= t2.a[i];</span><br><span class="line">&#125;</span><br><span class="line">t1.len = big;</span><br><span class="line">while (t1.a[len - 1] == 0 &amp;&amp; t1.len&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">t1.len--;</span><br><span class="line">big--;</span><br><span class="line">&#125;</span><br><span class="line">if (flag)</span><br><span class="line">t1.a[big - 1] = 0 - t1.a[big - 1];</span><br><span class="line">return  t1;</span><br><span class="line">&#125;</span><br><span class="line">BigNum  BigNum::operator*(const  BigNum &amp;T)const  //两个大数之间的相乘</span><br><span class="line">&#123;</span><br><span class="line">BigNum  ret;</span><br><span class="line">int  i, j, up;</span><br><span class="line">int  temp, temp1;</span><br><span class="line">for (i = 0; i&lt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">up = 0;</span><br><span class="line">for (j = 0; j&lt;T.len; j++)</span><br><span class="line">&#123;</span><br><span class="line">temp = a[i] * T.a[j] + ret.a[i + j] + up;</span><br><span class="line">if (temp&gt;MAXN)</span><br><span class="line">&#123;</span><br><span class="line">temp1 = temp - temp / (MAXN + 1)*(MAXN + 1);</span><br><span class="line">up = temp / (MAXN + 1);</span><br><span class="line">ret.a[i + j] = temp1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">up = 0;</span><br><span class="line">ret.a[i + j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (up != 0)</span><br><span class="line">ret.a[i + j] = up;</span><br><span class="line">&#125;</span><br><span class="line">ret.len = i + j;</span><br><span class="line">while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len&gt;1)ret.len--;</span><br><span class="line">return  ret;</span><br><span class="line">&#125;</span><br><span class="line">BigNum  BigNum::operator/(const    int &amp;b)const  //大数对一个整数进行相除运算</span><br><span class="line">&#123;</span><br><span class="line">BigNum  ret;</span><br><span class="line">int  i, down = 0;</span><br><span class="line">for (i = len - 1; i &gt;= 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">ret.a[i] = (a[i] + down*(MAXN + 1)) / b;</span><br><span class="line">down = a[i] + down*(MAXN + 1) - ret.a[i] * b;</span><br><span class="line">&#125;</span><br><span class="line">ret.len = len;</span><br><span class="line">while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len&gt;1)</span><br><span class="line">ret.len--;</span><br><span class="line">return  ret;</span><br><span class="line">&#125;</span><br><span class="line">int  BigNum::operator%(const    int &amp;b)const  //大数对一个 int类型的变量进行取模</span><br><span class="line">&#123;</span><br><span class="line">int  i, d = 0;</span><br><span class="line">for (i = len - 1; i &gt;= 0; i--)</span><br><span class="line">d = ((d*(MAXN + 1)) % b + a[i]) % b;</span><br><span class="line">return  d;</span><br><span class="line">&#125;</span><br><span class="line">BigNum  BigNum::operator^(const    int &amp;n)const  //大数的n次方运算</span><br><span class="line">&#123;</span><br><span class="line">BigNum  t, ret(1);</span><br><span class="line">int  i;</span><br><span class="line">if (n&lt;0)exit(-1);</span><br><span class="line">if (n == 0)return  1;</span><br><span class="line">if (n == 1)return *this;</span><br><span class="line">int  m = n;</span><br><span class="line">while (m&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">t = *this;</span><br><span class="line">for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1)</span><br><span class="line">t = t*t;</span><br><span class="line">m -= i;</span><br><span class="line">ret = ret*t;</span><br><span class="line">if (m == 1)ret = ret*(*this);</span><br><span class="line">&#125;</span><br><span class="line">return  ret;</span><br><span class="line">&#125;</span><br><span class="line">bool  BigNum::operator&gt;(const  BigNum &amp;T)const</span><br><span class="line">//大数和另一个大数的大小比较</span><br><span class="line">&#123;</span><br><span class="line">int  ln;</span><br><span class="line">if (len&gt;T.len)return  true;</span><br><span class="line">else  if (len == T.len)</span><br><span class="line">&#123;</span><br><span class="line">ln = len - 1;</span><br><span class="line">while (a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0)</span><br><span class="line">ln--;</span><br><span class="line">if (ln &gt;= 0 &amp;&amp; a[ln]&gt;T.a[ln])</span><br><span class="line">return  true;</span><br><span class="line">else</span><br><span class="line">return  false;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return  false;</span><br><span class="line">&#125;</span><br><span class="line">bool  BigNum::operator&gt;(const   int &amp;t)const  //大数和一个int类型的变量的大小比较</span><br><span class="line">&#123;</span><br><span class="line">BigNum  b(t);</span><br><span class="line">return *this&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">void  BigNum::print()   //输出大数</span><br><span class="line">&#123;</span><br><span class="line">int  i;</span><br><span class="line">printf(&quot;%d&quot;, a[len - 1]);</span><br><span class="line">for (i = len - 2; i &gt;= 0; i--)</span><br><span class="line">printf(&quot;%04d&quot;, a[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">BigNum f[110];//卡特兰数</span><br><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">f[0] = 1;</span><br><span class="line">for (int i = 1; i &lt;= 100; i++)</span><br><span class="line">f[i] = f[i - 1] * (4 * i - 2) / (i + 1);//卡特兰数递推式</span><br><span class="line">int  n;</span><br><span class="line">while (~scanf(&quot;%d&quot;, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if (n == -1)break;</span><br><span class="line">f[n].print();</span><br><span class="line">&#125;</span><br><span class="line">return  0;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="strtok和sscanf结合输入"><a href="#strtok和sscanf结合输入" class="headerlink" title="strtok和sscanf结合输入"></a>strtok和sscanf结合输入</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">char s[] = &quot;ab-cd:ef;gh: i-jkl;mnop;qrs-tu:vwx-y;z&quot;;</span><br><span class="line">char *delim = &quot;-: &quot;;   //分割条件字符串，目前里面有三个字符‘-’,’：’,‘  ’</span><br><span class="line">char *p;            //当目标字符串s中遇到分割条件字符时自动改写成‘\0’</span><br><span class="line">printf(&quot;%s &quot;, strtok(s, delim));</span><br><span class="line">while ((p = strtok(NULL, delim)))</span><br><span class="line">printf(&quot;%s &quot;, p);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">int a, b, c;</span><br><span class="line">char str[] = &quot;2018:7:15&quot;;</span><br><span class="line">sscanf(str, &quot;%d:%d:%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="解决爆栈，手动加栈"><a href="#解决爆栈，手动加栈" class="headerlink" title="解决爆栈，手动加栈"></a>解决爆栈，手动加栈</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#pragma comment(linker,  &quot;/STACK:1024000000,1024000000&quot;)</span><br></pre>      </td>    </tr>  </table></figure><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><ol>  <li>优先队列 priority_queue</li></ol><p>empty()如果队列为空返回真</p><p>pop()删除对顶元素</p><p>push()加入一个元素</p><p>size()返回优先队列中拥有的元素个数</p><p>top()返回优先队列队顶元素</p><p>在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>      </td>      <td class="code">        <pre><span class="line">priority_queue&lt;int&gt;q1;//大的先出对</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;  &gt;q2; //小的先出队</span><br><span class="line">自定义比较函数：</span><br><span class="line">struct  cmp</span><br><span class="line">&#123;</span><br><span class="line">bool operator ()(int x, int  y)</span><br><span class="line">&#123;</span><br><span class="line">return x &gt; y; // x小的优先级高</span><br><span class="line">//也可以写成其他方式，如： return p[x] &gt; p[y];表示p[i]小的优先级高</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;,  cmp&gt;q;//定义方法</span><br><span class="line">//其中，第二个参数为容器类型。第三个参数为比较函数。</span><br><span class="line">结构体排序：</span><br><span class="line">struct  node</span><br><span class="line">&#123;</span><br><span class="line">int x, y;</span><br><span class="line">friend bool operator &lt; (node a, node  b)</span><br><span class="line">&#123;</span><br><span class="line">return a.x &gt; b.x; //结构体中，x小的优先级高</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;//定义方法</span><br><span class="line">//在该结构中，y为值, x为优先级。</span><br><span class="line">//通过自定义operator&lt;操作符来比较元素中的优先级。</span><br><span class="line">//在重载”&lt;”时，最好不要重载”&gt;”，可能会发生编译错误</span><br></pre>      </td>    </tr>  </table></figure><ol start="2">  <li>set 和 multiset</li></ol><p>set和 multiset用法一样，就是 multiset允许重复元素。</p><p>元素放入容器时，会按照一定的排序法则自动排序，默认是按照 less&lt;&gt;排序规则来排序。不</p><p>能修改容器里面的元素值，只能插入和删除。</p><p>自定义 int排序函数：（默认的是从小到大的，下面这个从大到小）</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>      </td>      <td class="code">        <pre><span class="line">struct classcomp  &#123;</span><br><span class="line">bool operator() (const int&amp; lhs, const int&amp; rhs)  const</span><br><span class="line">&#123;return  lhs&gt;rhs;&#125;</span><br><span class="line">&#125;;//这里有个逗号的，注意</span><br><span class="line">multiset&lt;int,classcomp&gt; fifth;</span><br><span class="line">// class as Compare</span><br><span class="line">上面这样就定义成了从大到小排列了。</span><br><span class="line">结构体自定义排序函数：</span><br><span class="line">（定义 set或者   multiset的时候定义了排序函数，定义迭代器时一样带上排序函数）</span><br><span class="line">struct  Node</span><br><span class="line">&#123;</span><br><span class="line">int  x,y;</span><br><span class="line">&#125;;</span><br><span class="line">struct classcomp//先按照 x从小到大排序，x相同则按照y从大到小排序</span><br><span class="line">&#123;</span><br><span class="line">bool  operator()(const Node &amp;a,const Node &amp;b)const</span><br><span class="line">&#123;</span><br><span class="line">if(a.x!=b.x)return  a.x&lt;b.x;</span><br><span class="line">else  return  a.y&gt;b.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; //注意这里有个逗号</span><br><span class="line">multiset&lt;Node,classcomp&gt;mt;</span><br><span class="line">multiset&lt;Node,classcomp&gt;::iterator  it;</span><br><span class="line">Multiset      //该函数是set的多重集合形式可保存eg：1 2 2 3 3 4 5</span><br><span class="line">multimap&lt;int, int&gt;a;</span><br><span class="line">int main()&#123;</span><br><span class="line">a.insert(pair&lt;int,int&gt;(1, 1));</span><br><span class="line">a.insert(pair&lt;int, int&gt;(2, 1));</span><br><span class="line">a.insert(pair&lt;int, int&gt;(1, 2));</span><br><span class="line">for (multimap&lt;int, int&gt;::iterator it = a.begin(); it != a.end(); it++)</span><br><span class="line">cout &lt;&lt; (*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>主要函数：</p><p>begin()返回指向第一个元素的迭代器</p><p>clear()清除所有元素</p><p>count()返回某个值元素的个数</p><p>empty()如果集合为空，返回 （true）</p><p>end()返回指向最后一个元素的迭代器</p><p>erase()删除集合中的元素 (参数是一个元素值，或者迭代器 )</p><p>find()返回一个指向被查找到元素的迭代器</p><p>insert()在集合中插入元素</p><p>size()集合中元素的数目</p><p>lower_bound()返回指向大于（或等于）某值的第一个元素的迭代器</p><p>upper_bound()返回大于某个值元素的迭代器</p><p>equal_range()返回集合中与给定值相等的上下限的两个迭代器</p><p>(注意对于 multiset删除操作之间删除值会把所以这个值的都删掉，删除一个要用迭代器 )</p><ol start="3">  <li>lower_bound and upper_bound</li></ol><p>lower_bound()  //在first和last中的前闭后开区间进行二分查找（故要先sort()），返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置（且a[last]不存在）</p><p>Eg: Pos= lower_bound(a,a+N,val)-a;</p><p>upper_bound() //也是前闭后开区间，且返回第一个大于val的位置，如果所有元素都小于val，则返回last的位置。</p><p>Eg: Pos= upper_bound (a,a+N,val)-a;<br>4.next_permutation and  prev_permutation</p><p>next_permutation（） //排列组合使用，eg：1 2 3 4 =》1 2 4 3 =》1 3 2 4 =》…</p><p>prev_permutation（） //和上面的相反，返回上一项结果</p><p>Eg: next_permutation（a,a+N）; //执行成功返回1，否则返回0</p><ol start="5">  <li>reverse()</li></ol><p>//可以对数组，字符串，vector等进行翻转操作123=》321</p><p>Eg： reverse(a，a+N);</p><ol start="6">  <li>    <p>Map</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>          </td>          <td class="code">            <pre><span class="line">map&lt;int, char&gt;m;</span><br><span class="line">map&lt;int, char&gt;::iterator it;</span><br><span class="line">m[8] = &apos;a&apos;;</span><br><span class="line">m[6] = &apos;b&apos;;</span><br><span class="line">m[11] = &apos;c&apos;;</span><br><span class="line">it = m.begin();</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; //输出6 b</span><br><span class="line">it = m.end(); it--;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; //输出11 c</span><br><span class="line">//map按照平衡二叉树原理类似，begin（）为最左下角（min）</span><br><span class="line">                             //end（）为最右下角（max）</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>迭代器</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>          </td>          <td class="code">            <pre><span class="line">在C++11情况下可以使用auto</span><br><span class="line">For（auto it=a.begin();it!=a.end();i++）</span><br><span class="line">任何情况都可以的</span><br><span class="line">for(vector&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)</span><br><span class="line">//注意，这里vector可以这么用，快很多：for(int i=0;i&lt;a.size();i++)  a[i]即为队列中第i个</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法模板学习&lt;/p&gt;
    
    </summary>
    
      <category term="算法模板" scheme="http://javastar.club/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="算法模板" scheme="http://javastar.club/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列学习计划(三)</title>
    <link href="http://javastar.club/archives/388be574.html"/>
    <id>http://javastar.club/archives/388be574.html</id>
    <published>2019-07-28T02:22:27.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>Spring系列博客学习</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring系列博客学习&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://javastar.club/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://javastar.club/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud入门基础</title>
    <link href="http://javastar.club/archives/e08dbd6c.html"/>
    <id>http://javastar.club/archives/e08dbd6c.html</id>
    <published>2019-07-28T02:21:48.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>Spring系列博客学习</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring系列博客学习&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://javastar.club/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://javastar.club/tags/Spring/"/>
    
  </entry>
  
</feed>
