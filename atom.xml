<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星星</title>
  
  <subtitle>We are all stardust</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://javastar.club/"/>
  <updated>2019-08-07T08:47:08.052Z</updated>
  <id>http://javastar.club/</id>
  
  <author>
    <name>小星星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数学基础复习:离散数学</title>
    <link href="http://javastar.club/archives/fb566d07.html"/>
    <id>http://javastar.club/archives/fb566d07.html</id>
    <published>2019-08-06T08:32:15.000Z</published>
    <updated>2019-08-07T08:47:08.052Z</updated>
    
    <content type="html"><![CDATA[<p>三大基础数学复习：离散数学</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="集合与元素"><a href="#集合与元素" class="headerlink" title="集合与元素"></a>集合与元素</h2><p>集合与元素：集合是元素的全体。</p><h3 id="标记法"><a href="#标记法" class="headerlink" title="标记法"></a>标记法</h3><p>集合通常使用大写字母表示，元素通常使用小写字母表示。</p><p>因此术语“p是A的元素”或等价于“p属于A”记作：<br>p ∈ A</p><h3 id="外延公理"><a href="#外延公理" class="headerlink" title="外延公理"></a>外延公理</h3><p>两个集合A和B相等当且仅当其元素相同。</p><p>如果集合A与B相等，则记作 A = B，否则 A ≠ B。</p><h3 id="集合的表示"><a href="#集合的表示" class="headerlink" title="集合的表示"></a>集合的表示</h3><p>集合有两种基本素方法，一是枚举元素，二是描述元素特征性质。</p><p>如：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">V = &#123;a, e, i, o, u&#125;, 或</span><br><span class="line">V = &#123;x: x是英文字母，x是元音字母&#125;</span><br><span class="line"></span><br><span class="line">E = &#123;x: x &gt; 0, x mod 2 = 0&#125; 或</span><br><span class="line">E = &#123;2, 4, 6, 8, 10, ...&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="常用的集合及其表示"><a href="#常用的集合及其表示" class="headerlink" title="常用的集合及其表示"></a>常用的集合及其表示</h3><table>  <thead>    <tr>      <th>符号</th>      <th>意义</th>    </tr>  </thead>  <tbody>    <tr>      <td>N</td>      <td>全体正整数</td>    </tr>    <tr>      <td>Z</td>      <td>全体整数</td>    </tr>    <tr>      <td>Q</td>      <td>全体有理数</td>    </tr>    <tr>      <td>R</td>      <td>全体实数</td>    </tr>    <tr>      <td>C</td>      <td>全体复数</td>    </tr>  </tbody></table><h3 id="抽象原则"><a href="#抽象原则" class="headerlink" title="抽象原则"></a>抽象原则</h3><p>给定集合U和性质P，则存在集合A恰好包含U中具有性质P的那些元素。</p><h2 id="全集与空集"><a href="#全集与空集" class="headerlink" title="全集与空集"></a>全集与空集</h2><h3 id="全集"><a href="#全集" class="headerlink" title="全集"></a>全集</h3><p>记号为U。</p><h3 id="空集"><a href="#空集" class="headerlink" title="空集"></a>空集</h3><p>没有元素的集合；又称“零集”，记号为 ∅，或者 { }。</p><h4 id="空集的特性："><a href="#空集的特性：" class="headerlink" title="空集的特性："></a>空集的特性：</h4><ul>  <li>∀A: A ⊆ ∅ ⇒ A = ∅</li>  <li>P(∅) = {∅}</li>  <li>card(∅) = 0</li>  <li>∀A: ∅ ⊆ A</li>  <li>∀A: A ∪ ∅ = ∅</li>  <li>∀A: A ∩ ∅ = ∅</li>  <li>∀A: A × ∅ = ∅</li></ul><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>如果集合A的每个元素都是集合B的元素，则称A为B的一个子集。也称A包含于B或者B包含A。记作：</p><p>A ⊆ B 或 B ⊇ A</p><p>或者A不是B的子集，即A至少有一个元素不属于B，则记作<br><code>A \nsubseteq B</code> 或者 <code>A    \not\subseteq B</code>，  <code>A \nsuperseteq A</code> 或者 <code>B \not\superseteq A</code>。</p><h3 id="定理1-1"><a href="#定理1-1" class="headerlink" title="定理1.1"></a>定理1.1</h3><ul>  <li>对于任意集合A, ∅ &lt;= A &lt;= U</li>  <li>对于任意集合A，A &lt;= A</li>  <li>如果A &lt;= B，且 B&lt;= C，则 A&lt;= C</li>  <li>A = B 当且仅当 A &lt;= B 且 B &lt;= A</li></ul><h1 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h1><h2 id="集合的并与交"><a href="#集合的并与交" class="headerlink" title="集合的并与交"></a>集合的并与交</h2><ul>  <li>    <p>属于A或者属于B的所有元素的集合，称为集合A和B的并集，记作：A∪B，即：</p>    <p>A∪B = {x: x ∈ A 或 x ∈ B}</p>  </li>  <li>    <p>属于A并且属于B的所有元素的集合，称为集合A和B的交集，记作：A∩B，即：</p>    <p>A∩B = {x: x ∈ A 且 x ∈ B}</p>    <p>如果A和B没有公共元素，则称集合A和B是不交的， A∩B = ∅。<br>此时，A与B的并集称为 不交的并(disjoint union)。    </p>  </li></ul><h3 id="定理1-2"><a href="#定理1-2" class="headerlink" title="定理1.2"></a>定理1.2</h3><p>下述语句等价：A ⊆ B，A ∩ B = A，A ∪ B = B。</p><h2 id="集合的补"><a href="#集合的补" class="headerlink" title="集合的补"></a>集合的补</h2><p>所有属于全集U但不属于A的元素构成的集合：</p><p>$$<br>A^c = {x: x \in \mathbb{U}, x \not\in A }。  $$</p><p>也记作 A` 或者 Aᶜ。</p><h3 id="相对补-差"><a href="#相对补-差" class="headerlink" title="相对补/差"></a>相对补/差</h3><p>集合B关于集合A的相对补，或称集合A与集合B的差，记作 A\B，是由所有属于A但不属于B的元素构成的集合，即：</p><p>A\B = {x: x ∈ A, x ∉ B}。</p><p>也记作：A-B 或者 A~B。<br>（本质上：A\B = A ∩ B` 。）</p><h2 id="集合的基本积"><a href="#集合的基本积" class="headerlink" title="集合的基本积"></a>集合的基本积<a href="#fundamental-products"></a></h2><p>对于 n 个不同的集合 A1, A2, …, An, 它们的基本积是以下形式的任一集合：<br>A1* \cap A2* \cap … \cap An*  (Ai* = A 或 Ai* = A^c)</p><h2 id="对称差"><a href="#对称差" class="headerlink" title="对称差"></a>对称差</h2><p>集合A和B的对称差，记作<br>$$<br>A ⊕ B<br>$$<br>是所有属于A或B但不同时属于A和B的元素的集合。即：</p><p>$$<br>A \oplus B = {x | (x \in A \land x \not\in B) \lor (x \in B \land x  \not\in A)}<br>$$</p><p>性质：</p><p>$$<br>A \oplus B = (A \cup B) \setminus (A \cap B) \<br>A \oplus B = (A  \setminus B) \cup (B \setminus A)<br>$$</p><h2 id="集合的代数运算及对偶性"><a href="#集合的代数运算及对偶性" class="headerlink" title="集合的代数运算及对偶性"></a>集合的代数运算及对偶性</h2><p>定理1.3，集合满足以下表所列的规律：</p><h3 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h3><p>  设E为集合代数运算的一个方程，则E的对偶E*是由将E中的并与交互换，全集与空集互换，得到的方程。<br>在集合的代数运算中，对偶原理成立。即如果一个方程E成立，则其对偶方程E*必定成立。</p><h2 id="有限集及计数原理"><a href="#有限集及计数原理" class="headerlink" title="有限集及计数原理"></a>有限集及计数原理</h2><p>一个集合称为有限集，如果它恰好含有m个相异的元素，其中m为某非负整数；否则，称集合为无限集。</p><p>用记号n(A)表示有限集A中元素的个数，也可以用 #(A)，|A| 或者 card(n)。</p><h3 id="引理1-4"><a href="#引理1-4" class="headerlink" title="引理1.4"></a>引理1.4</h3><p>如果A，B为不交的有限集，则A∪B为有限集且</p><p>n(A ∪ B) = n(A) + n(B)。</p><h3 id="定理1-5"><a href="#定理1-5" class="headerlink" title="定理1.5"></a>定理1.5</h3><p>如果A，B均为有限集，则A ∪ B和A ∩ B均为有限集，且</p><p>n(A ∪ B) = n(A) + n(B) - n(A ∩ B)。</p><h3 id="推论1-6"><a href="#推论1-6" class="headerlink" title="推论1.6"></a>推论1.6</h3><p>如果A，B，C均为有限集，则A ∪ B ∪ C均为有限集，且</p><p>n(A ∪ B ∪ B) = n(A) + n(B) + n(C) - n(A ∩ B) - n(A ∩ C) - n(B ∩ C) + n(A ∩ B  ∩ C)。</p><h2 id="集族，幂集和集合的划分"><a href="#集族，幂集和集合的划分" class="headerlink" title="集族，幂集和集合的划分"></a>集族，幂集和集合的划分</h2><p>集合的集合称为集类或者集族。集族中的元素（集合），称为子类或子族。</p><h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p>对于给定的集合S，其所有可能子集的族，称为集合S的幂集。记作：Power(S)。如果S为有限集，则Power(S)也是有限集。并且：</p><p>n(Power(S)) = 2 ^ n(S)</p><h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h3><p>设S是一个非集合，S的一个划分是将S剖分为一些不交叠的非空子集。即：S的一个划分是S的一族非空子集<code>{A_i}</code>，满足：<br>  1. S中的每个元素a属于一个A_i；<br> 2. <code>{A_i}</code>中的集合互不相交，即对于两个不同的集合， <code>A_i ∩    A_j = 0</code>。</p><p>划分中的子集叫<strong>胞腔</strong>。</p><p>$$<br>partition(S) = { A | (\forall x \in S, \exists A \to x \in A) \land  (\forall A_i, \forall A_j, A_i \neq A_j \to A_i \cap A_j = \emptyset)}<br>$$</p><h2 id="集合运算的推广"><a href="#集合运算的推广" class="headerlink" title="集合运算的推广"></a>集合运算的推广</h2><h3 id="定理1-7"><a href="#定理1-7" class="headerlink" title="定理1.7"></a>定理1.7</h3><p>设 \mathscr{A} 为集族，则：<br>$$<br>[ \cup(A | A \in \mathscr{A}) ]^c = \cap(A^c |  A \in \mathscr{A}) \<br>[ \cap(A | A \in \mathscr{A}) ]^c = \cup(A^c | A \in  \mathscr{A})  $$</p><h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><h3 id="数学归纳法原理I"><a href="#数学归纳法原理I" class="headerlink" title="数学归纳法原理I"></a>数学归纳法原理I</h3><p>设 P 是定义于正整数集合N上的一个命题，即对N中的每个n，P(n) 或者正确或者不正确。假设P具有下列两个性质：</p><pre><code>1. P(1)为真，2. 只要P(n)为真，P(n+1)亦为真</code></pre><p>则对任意正整数，P都为真。</p><h3 id="数学归纳法原理II"><a href="#数学归纳法原理II" class="headerlink" title="数学归纳法原理II"></a>数学归纳法原理II</h3><p>设P是定义于正整数N上的一个命题，使得：</p><pre><code>1. P(1)为真，2. 当对于所有的 1 &lt;= k &lt; n，P(k) 为真时，有P(n)为真，</code></pre><p>则P对于所有的正整数为真。</p><h3 id="代码练习"><a href="#代码练习" class="headerlink" title="代码练习"></a>代码练习</h3><p>example.tex</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">  \usepackage&#123;amsmath&#125;</span><br><span class="line">  \usepackage&#123;amssymb&#125;</span><br><span class="line">  \newcommand&#123;\setcomp&#125;[1] &#123;&#123;#1&#125;^&#123;\mathsf&#123;c&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item Prove $B\setminus A = B\cap \setcomp&#123;A&#125;$.</span><br><span class="line">  \item Prove the following are equivalent:</span><br><span class="line">  $A\subseteq B, A \cap B = A, A\cup B = B$.</span><br><span class="line"></span><br><span class="line">  \item Prove the Distributive Law:</span><br><span class="line">  $A\cap(B\cap C) = (A\cap B)\cup (A\cap C)$.</span><br><span class="line"></span><br><span class="line">  \item Write the dual of:</span><br><span class="line">  $</span><br><span class="line">  (\textbf&#123;U&#125; \cap A)\cup (B\cap A) = A,</span><br><span class="line">  (A\cap \textbf&#123;U&#125;)\cap (\emptyset \cup \setcomp&#123;A&#125;) = \emptyset</span><br><span class="line">  $.</span><br><span class="line"></span><br><span class="line">  \item Prove $(A\cup B)\setminus (A\cap B) = (A\setminus B)\cup (B\setminus A)$.</span><br><span class="line"></span><br><span class="line">  \item Prove:</span><br><span class="line"></span><br><span class="line">    a. $(A\cap B)\cup (A\cap \setcomp&#123;B&#125;) = A$</span><br><span class="line"></span><br><span class="line">    b. $A\cup B = (A\cap \setcomp&#123;B&#125;)\cup (\setcomp&#123;A&#125;\cap B)\cup (A\cap B)$</span><br><span class="line"></span><br><span class="line">  \item Prove $n(P(S)) = 2^&#123;n(S)&#125;$ if $S$ is a finite set.</span><br><span class="line"></span><br><span class="line">  \item Try to figure out the formula for: $n(partition(S))$.</span><br><span class="line"></span><br><span class="line">  \item Let $[A_1, A_2, \cdots, A_m]$ and $[B_1, B_2, \cdots, B_m]$ be partitions of a set S.</span><br><span class="line">  Prove the following collection is also a partition (called the \textsl&#123;cross partition&#125;) of S:</span><br><span class="line">  $$</span><br><span class="line">  P = [A_i\cap B_j | i = 1, \cdots, m, j = 1, \cdots, n]\setminus \emptyset</span><br><span class="line">  $$</span><br><span class="line"></span><br><span class="line">  \item Prove the following properties of the symmetric difference:</span><br><span class="line"></span><br><span class="line">    a. Associative Law $(A\oplus B)\oplus C = A\oplus(B \oplus C)$</span><br><span class="line"></span><br><span class="line">    b. Comutative Law $A\oplus B = B\oplus A$</span><br><span class="line"></span><br><span class="line">    c. Cancellation Law $A\oplus B = A\oplus C \implies B = C$</span><br><span class="line"></span><br><span class="line">    d. Distributive Law $A\cap (B\oplus C) = (A\cap B)\oplus (A\cap C)$</span><br><span class="line"></span><br><span class="line">  \item Consider $m$ nonempty distinct sets, $A_1, A_2, \cdots, A_m$ in a universal set $\textbf&#123;U&#125;$. Prove:</span><br><span class="line"></span><br><span class="line">    a. There are $2^m$ fundamental products of the $m$ sets.</span><br><span class="line"></span><br><span class="line">    b. Any two fundamental products are disjoint.</span><br><span class="line"></span><br><span class="line">    c. $\textbf&#123;U&#125;$ is the union of all the fundamental products.</span><br><span class="line"></span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>      </td>    </tr>  </table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>  <li>集合 set (, class, collection, family)</li>  <li>元素 element, member</li>  <li>内涵</li>  <li>外延</li>  <li>Venn图 Venn diagrams</li>  <li>外延公理</li>  <li>抽象原则</li>  <li>全集 universal set</li>  <li>空集 empty set</li>  <li>子集 subset<ul>      <li>包含 contains</li>      <li>包含于 be contained in</li>      <li>真子集 proper subset</li>    </ul>  </li>  <li>不交 disjoint, nonintersecting</li>  <li>集合的运算 set operations<ul>      <li>集合并 union</li>      <li>不交的并 disjoint union</li>      <li>集合交 intersection</li>      <li>（绝对）补 (absolute) complement</li>      <li>相对补 relative complement, difference</li>      <li>对称差 symmetric difference</li>      <li><a href="operations.md#fundamental-products">集合基本积 fundamental          product</a></li>    </ul>  </li>  <li>集合代数运算规则<ul>      <li>幂等律 idempotent laws</li>      <li>结合律 associative laws</li>      <li>交换律 commutative laws</li>      <li>分配律 distributive laws</li>      <li>同一律 identity laws</li>      <li>对合律 involution laws</li>      <li>互补律 complement laws</li>      <li>DeMorgan律 DeMorgan’s laws</li>    </ul>  </li>  <li>对偶性 duality</li>  <li>有限集 finite sets</li>  <li>计数原理 counting principle</li>  <li>集族 classes of sets</li>  <li>幂集 power set</li>  <li>集合的划分 set partitions<ul>      <li>胞腔 cell</li>    </ul>  </li>  <li>数学归纳法 mathematical induction</li></ul><h3 id="标志约定"><a href="#标志约定" class="headerlink" title="标志约定"></a>标志约定</h3><p>为了方便表示集合关系，这里约束集合运算中所用到的标志。</p><table>  <thead>    <tr>      <th></th>      <th>Latex</th>      <th>Unicode</th>      <th>意义</th>    </tr>  </thead>  <tbody>    <tr>      <td>equal</td>      <td>=</td>      <td>=</td>      <td>相等</td>    </tr>    <tr>      <td>not equal</td>      <td>\neq; \ne</td>      <td>≠</td>      <td>不相等</td>    </tr>    <tr>      <td>elements of</td>      <td>\in</td>      <td>∈</td>      <td>属于</td>    </tr>    <tr>      <td>not element of</td>      <td>\notin</td>      <td>∉</td>      <td>不属于</td>    </tr>    <tr>      <td>subset</td>      <td>\subseteq</td>      <td>⊆</td>      <td>子集</td>    </tr>    <tr>      <td>superset</td>      <td>\supseteq</td>      <td>⊇</td>      <td>父集</td>    </tr>    <tr>      <td>proper subset</td>      <td>\subset</td>      <td>⊂</td>      <td>真子集</td>    </tr>    <tr>      <td>proper superset</td>      <td>supset</td>      <td>⊃</td>      <td>真父集</td>    </tr>    <tr>      <td>not a subset</td>      <td>\not\subset</td>      <td>⊄</td>      <td></td>    </tr>    <tr>      <td>not a superset</td>      <td>\not\supset</td>      <td>⊅</td>      <td></td>    </tr>    <tr>      <td>for all</td>      <td>\forall</td>      <td>∀</td>      <td>任意</td>    </tr>    <tr>      <td>exist</td>      <td>\exists</td>      <td>∃</td>      <td>存在</td>    </tr>    <tr>      <td>and</td>      <td>\land</td>      <td></td>      <td>并</td>    </tr>    <tr>      <td>or</td>      <td>\lor</td>      <td></td>      <td>或</td>    </tr>    <tr>      <td>if and only if</td>      <td>\iff</td>      <td></td>      <td>当且仅当</td>    </tr>    <tr>      <td>union</td>      <td>\cup</td>      <td>∪</td>      <td></td>    </tr>    <tr>      <td>intersection</td>      <td>\cap</td>      <td>∩</td>      <td></td>    </tr>    <tr>      <td>cartesian product</td>      <td>\times</td>      <td>×</td>      <td>笛卡尔积</td>    </tr>    <tr>      <td>empty set</td>      <td>\emptyset; \varnothing</td>      <td>∅</td>      <td>空集</td>    </tr>  </tbody></table><p><a href="https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols" rel="external nofollow noopener noreferrer" target="_blank">LaTex    Symbols</a></p><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ul>  <li>集簇</li>  <li>幂集</li>  <li>划分</li></ul><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><h2 id="有序偶"><a href="#有序偶" class="headerlink" title="有序偶"></a>有序偶</h2><p>关系由元素的有序偶(a, b)来定义，这里a作为第一元素，b为第二元素。</p><p>特别地，(a, b) = (c, d) 当且仅当 a = c 且 b = d。</p><h3 id="使用集合定义有序偶"><a href="#使用集合定义有序偶" class="headerlink" title="使用集合定义有序偶"></a>使用集合定义有序偶</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>      </td>      <td class="code">        <pre><span class="line">- Wiener&apos;s</span><br><span class="line">$$</span><br><span class="line">(a, b) := \&#123;\&#123;\&#123;a\&#125;, \emptyset\&#125;, \&#123;\&#123;b\&#125;\&#125;\&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">- Hausdorff</span><br><span class="line">$$</span><br><span class="line">(a, b) := \&#123;\&#123;a, 1\&#125;, \&#123;b, 2\&#125;\&#125;</span><br><span class="line">$$</span><br><span class="line">（注：此处的 1 和 2 不是数字 1 和 2，而是代表与 a 和 b 不相等的两个互不相等的元素）</span><br><span class="line"></span><br><span class="line">- Kuratowski 定义</span><br><span class="line">$$</span><br><span class="line">(a, b) = \&#123;\&#123;a\&#125;, \&#123;a, b\&#125;\&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">有序偶第一元素的定义：</span><br><span class="line">$$</span><br><span class="line">\forall Y \in p : x \in Y</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">有序偶第二元素的定义：</span><br><span class="line">$$</span><br><span class="line">(\exist Y \in p : x \in Y) \land (\forall Y_1, Y_2 \in p : Y_1 \neq Y_2 \rarrow (x \not\in Y_1 \lor x \not\in Y_2))</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">- Cantor-Frege 定义</span><br><span class="line">(a, b) := \&#123; R: aRb \&#125;</span><br><span class="line">（使用关系来定义）</span><br></pre>      </td>    </tr>  </table></figure><p>此外，还有多种其它定义形式，此处不再介绍。</p><h2 id="集合的积（笛卡尔积）"><a href="#集合的积（笛卡尔积）" class="headerlink" title="集合的积（笛卡尔积）"></a>集合的积（笛卡尔积）</h2><p>对于任意两个集合A，B，称所有有序偶(a, b)的集合为A，B的积或笛卡尔积，其中 a ∈ A，b ∈ B。<br>A，B的积记作 A × B。</p><p>A × B = {(a, b): a ∈ A 且 b ∈ B}</p><p>A × A 通常也记作 A^2。</p><p>笛卡尔积有以下性质：</p><ol>  <li>    <p>not commutative:<br>A != B -&gt; A × B != B × A<br>A × B = B × A      &lt;–&gt; A = B</p>  </li>  <li>    <p>n(A × B) = n(B × A) = n(A) n(B)</p>  </li>  <li>    <p>not associative:<br>(A × B) × C != A × (B × C)</p>  </li>  <li>    <p>A × (B ∩ C) = (A × B) ∩ (A × C)<br>A × (B ∪ C) = (A × B) ∪ (A × C)<br>A ×      (B \ C) = (A × B) \ (A × C)<br>(A × C)^C = (A^C × B^C) ∪ (A^C × B) ∪ (A ×      B^C)</p>  </li>  <li>    <p>(A ∩ B) × (C ∩ D) = (A × C) ∩ (B × D)</p>    <p>(A ∪ B) × (C ∪ D) \neq (A × C) ∪ (B × D)</p>    <p>(A ∪ B) × (C ∪ D) = [(A \ B) × C] ∪ [(A ∩ B) × (C ∪ D)] ∪ [(B \ A) × D]    </p>    <p>(A × C) \ (B × D) = [A ×(C \ D)] ∪ [(A \ B) × C]</p>  </li>  <li>    <p>A ⊆ B -&gt; A × C ⊆ B × C<br>A, B != ∅ -&gt; (A × B ⊆ C × D &lt;–&gt; A ⊆      C \land B ⊆ D)</p>  </li></ol><h3 id="笛卡尔平面"><a href="#笛卡尔平面" class="headerlink" title="笛卡尔平面"></a>笛卡尔平面</h3><p>R表示实数集，R^2可以表示平面上的点的集合，R^2常称为笛卡尔平面。</p><h3 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h3><ul>  <li>A × B ≠ B × A</li>  <li>card(A × B) = card(A) * card(B)</li></ul><h3 id="集合积的推广"><a href="#集合积的推广" class="headerlink" title="集合积的推广"></a>集合积的推广</h3><p>集合积的概念可以推广到任意有限多个集合，对于任意的集合 A1, A2, …, An，<br>称全体n元有限组(a1, a2, …, an)的集合为 A1,  A2, …, An 的积，记作：</p><p>A1 × A2 × … × An 或：</p><p>$$<br>\prod_{i=1}^{i=n} A_{i}<br>$$</p><h2 id="关系-1"><a href="#关系-1" class="headerlink" title="关系"></a>关系</h2><p><strong>定义</strong> 设A，B为集合，A×B的任一子集称为从A到B的一个二元关系或者简称关系。</p><p>假定R是从A到B的一个关系，则R是一个有序偶的集合，在每个有序偶中，第一个元素<br>来自A而第二元素来自B，即对于每一对a ∈ A 和 b ∈  B，下列两种情况恰具其一：<br> 1. (a, b) ∈ R，称 a 与 b 之间具有关系R，记作 aRb；<br> 2. (a, b) ∉ R，称 a  与 b 之间不具有关系R，记作 aꞦb；</p><p>如果R是集合A到自身的一个关系，即 R 是 A^2 的一个子集，则称 R 是 A 上的一个关系。</p><p>R的定义域是属于R的有序偶的第一元素的集合，而称所有第二元素的集合为R的值域。</p><h3 id="相等关系"><a href="#相等关系" class="headerlink" title="相等关系"></a>相等关系</h3><p>设A为任一集合A上的一个重要关系为相等：</p><p>{(a, a): a ∈ A}</p><p>通常记作“=”。这个关系也称为集合A上的恒等或者对角线关系。记作Δ_A或简记为Δ。</p><h3 id="完全关系和空关系"><a href="#完全关系和空关系" class="headerlink" title="完全关系和空关系"></a>完全关系和空关系</h3><p>设A为任一集合，则 A × A 和 ∅ 都是 A × A 的子集，因而也都是上A上的关系，分别称为完全关系和空关系。</p><h2 id="逆关系"><a href="#逆关系" class="headerlink" title="逆关系"></a>逆关系</h2><p>设R为从集合A到B的任意一个关系，R的逆，记作 R^-1，是将R中的所有有序偶逆转后的有序偶的集合，<br>是一个从B到A的关系，即：</p><p>R^-1 = {(b, a): (a, b) ∈ R}</p><h2 id="关系的图示"><a href="#关系的图示" class="headerlink" title="关系的图示"></a>关系的图示</h2><p>通常，一个关系由满足某给定方程</p><p>E(x, y) = 0</p><p>的有序实数偶构成。通常将该关系与这个方程等同。<br>称E(x, y) = 0 为关系。</p><h3 id="有限集上关系的图示"><a href="#有限集上关系的图示" class="headerlink" title="有限集上关系的图示"></a>有限集上关系的图示</h3><p>设A，B为有限集，下面给出图示A到B的关系R的两种方法。</p><ul>  <li>构造一个矩阵，以A的元素和B的元素分别标注其行与列，对于a ∈ A和b ∈    B，视a，b是否具有关系R，在a行和b列交叉处标上1或0.<br>这样得到的矩阵称为<strong>关系矩阵</strong>。</li>  <li>    在两个不相交的碟形区域中分别写下A和B的元素，当a，b具有关系R时，则画一个从a到b的箭头。<br>这样得到的图示称为关系的<strong>箭头图</strong>。  </li></ul><h3 id="集上关系的有向图"><a href="#集上关系的有向图" class="headerlink" title="集上关系的有向图"></a>集上关系的有向图</h3><p>  当R为有限集到自身的关系时，可以用另一种方法给出R的图示，先写下给定集合的元素，对于每一个元素x，如果x与元素y之间具有关系R，<br>我们就画一个自x到y的箭头，这样得到的图形称为关系的<strong>有向图</strong>。</p><h2 id="关系的合成"><a href="#关系的合成" class="headerlink" title="关系的合成"></a>关系的合成</h2><p>设A，B，C为集合，且R为从A到B的一个关系，S为从B到C的一个关系，即R为A × B的子集，<br>则由R和S决定了从A到C的一个关系，记作  R*S。定义为：</p><p>a(R * S)c 如果对于某b ∈ B 我们有aRb且bSc，</p><p>即</p><p>R * S = {(a, c): 存在 b ∈ B 使得(a, b) ∈ R且(b, c) ∈ S}</p><h3 id="关系的合成与矩阵"><a href="#关系的合成与矩阵" class="headerlink" title="关系的合成与矩阵"></a>关系的合成与矩阵</h3><p>设 M_R 和 M_S 分别表示关系R和S的矩阵，则将 M_R 与 M_S，得矩阵M = M_R *  M_S。<br>这个矩阵中的非零元素表示其所对应的元素具有关系。</p><h3 id="定理2-1"><a href="#定理2-1" class="headerlink" title="定理2.1"></a>定理2.1</h3><p>设A，B，C，D为集合，假定R为从A到B的关系，S为从B到C的关系，T为从C到D的关系，则：</p><p>(R * S) * T = R * (S * T)</p><h2 id="典型关系"><a href="#典型关系" class="headerlink" title="典型关系"></a>典型关系</h2><h3 id="自反关系"><a href="#自反关系" class="headerlink" title="自反关系"></a>自反关系</h3><p>集合A上的关系R称为自反的，如果对于每个a ∈ A，总有aRa，即如果对每个a ∈ A， (a, a) ∈ R.</p><p>因此，如果存在a ∈ A，使得(a, a) ∉ R，则R不是自反的。</p><h3 id="对称和反对称关系"><a href="#对称和反对称关系" class="headerlink" title="对称和反对称关系"></a>对称和反对称关系</h3><p><strong>对称</strong> 集合A上的关系R称为是对称的，如果由 aRb 必可推出 bRa，即只要 (a, b) ∈ R，则(b, a) ∈  R。<br>于是，如果存在 a, b ∈ A，使得 (a, b) ∈ R，但 (b, a) ∉ R，则R是不对称的。</p><p>常见的对称关系：垂直，平行，相等。</p><p><strong>反对称</strong> 集合A上的关系R称为是反对称的，如果aRb且bRa则必有a=b，即只要(a, b), (b, a) ∈ R，就有  a = b。<br>于是，如果存在 a，b ∈ A 使得 (a, b) 与 (b, a) 都属于 R，但 a ≠ b，则R是不对称的。</p><p>常见的反对称关系：大于等于，小于等于，等于，整除（对于正整数）。</p><h3 id="传递关系"><a href="#传递关系" class="headerlink" title="传递关系"></a>传递关系</h3><p>集合A上的关系R称为是传递的，如果aRb 且bRc，则有aRc，即只要(a, b)，(b, c) ∈ R 就必有(a, c) ∈  R。<br>于是，如果存在 (a, b)，(b, c) ∈ R，但(a, c) ∉ R，则 R 不是传递的。</p><h4 id="定理2-2"><a href="#定理2-2" class="headerlink" title="定理2.2"></a>定理2.2</h4><p>一个关系R是传递的，当且仅当对于 n &gt;= 1 有 R^n ⊆ R。</p><h2 id="闭包性质"><a href="#闭包性质" class="headerlink" title="闭包性质"></a>闭包性质</h2><p>对于给定的集合A，考虑其上所有关系构成的集族，设℘为这些关系的一个性质，比如对称或者传递等等，我们将具有 性质 P 的关系称为一个 P-  关系。<br>集合 A 上关系 R 的 P-闭包 是一个 P-关系，满足对每个包含R的 P- 关系 S 有：</p><p>R ⊆ P(R) ⊆ S</p><p>R 的闭包记作 P(R)，有的书本记作$Cl_{p}(R)$。</p><p>P(R) 即在 A 上的最小关系，使得其包含 R 和满足性质 P。亦即，在 R 上添加最小数量的有序偶，使得 R 有获取性质 P。</p><p>对于自反，对称，传递关系R，记：<br>$$<br>\text{reflexive}(R), \text{symmetric}(R),  \text{transitive}(R)<br>$$<br>分别表示其闭包。</p><p>一般地，P(R) 未必存在，但是在某些条件下，P(R) 总是存在的。<br>假设 P 是一个性质，至少存在一个包含 R 的 P- 关系，而且任意 P-  关系的交仍然是一个 P- 关系。则可证明：</p><p>P(R) = ∩ { S: S 是 P- 关系，且 R ⊆ S }</p><h3 id="自反闭包和对称闭包"><a href="#自反闭包和对称闭包" class="headerlink" title="自反闭包和对称闭包"></a>自反闭包和对称闭包</h3><p>记 Δ(A) = {(a, a): a ∈ A }</p><p><strong>定理 2.3</strong> 设 R 为集合 A 上的一个关系，则：<br> 1. R ∪ Δ(A) 为 R 的自反闭包；<br> 2.  R ∪ R^-1 为 R 的对称闭包；</p><h3 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h3><p>设 R 为集合 A 上的一个关系，定义：</p><p>$$<br>R^* = \prod_{i=i}^{\infty} R^i<br>$$</p><p><strong>定理2.4</strong></p><p>R^n 是关系R的传递空包，设A为含有n个元素的有限集，则：</p><p>$$<br>R^* = R_1 \cup R_2 \cup \ldots \cup R_n<br>$$</p><p><strong>定理2.5</strong></p><p>设R为含n个元素的有限集A上的一个关系，则：<br>$$<br>transitive(R) = R \cup R^2<br>$$</p><h2 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h2><p>设 S 为非空集合，R 是 S 上的一个关系，如果 R 是自反的，对称的和传递的，则称 R 为一个等价关系；<br>即 S 上的关系 R  称为等价关系，如果 R 满足下列三条性质：</p><pre><code>1. 对每个 a ∈ S，有 aRa；2. 如果 aRb，则 bRa；3. 如果 aRb 且 bRc，则 aRc；</code></pre><p><strong>常见的等价关系</strong>：  1. 对于欧氏平面上的直线集合L，平行是L上的一个等价关系；<br> 对于欧氏平面上的三角形T，全等与相似均为T上的等价关系。<br> 2. 正整数的  模m同余 是一个等价关系。</p><h3 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h3><p>集合 A 上的一个等价类 R 可以将集合 A 划分为若干个互不相交的子集，称为等价类。</p><p>对于 A 中的每个元素 a，使用 [a] 表示 a 的等价类。即：</p><p>$$<br>[a] = { b | bRa }<br>$$</p><h3 id="等价关系与集合的划分"><a href="#等价关系与集合的划分" class="headerlink" title="等价关系与集合的划分"></a>等价关系与集合的划分</h3><p>假定R是集合S上的一个等价关系，对于每个 a \in R，设[a]表示与a具有关系R的S中的元素的集合，即：</p><p>[a] = {x: (a, x) \in R}</p><p>我们称[a]为元素a在S中的等价类。任意 b \in [a]称为该等价类的代表。</p><p>在关系R下，集合S的所有元素的等价类构成的集族记作S/R，即：<br>$$<br>S/R = { [a]: a \in R  }<br>$$<br>称为S关于R的商集。商集的基本性质由下面的定理给出：</p><p><strong>定理2.6</strong> 设R是集合S上的一个等价关系，则商集S/R是S的一个划分，特别地，</p><ul>  <li>    <p>对于每个a \in S，有 a \in [a]</p>  </li>  <li>    <p>[a] = [b]当且仅当(a, b) \in R</p>  </li>  <li>    <p>若[a] \neq [b]，则[a]与[b]不交</p>    <p>反之，给定集合S的一个划分{A_i}，则存在S上的一个等价关系R，使得A_i是关于R的等价类。</p>  </li></ul><h2 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h2><p>R 为集合 S  上的一个关系，如果R是<em>自反</em>的，<em>反对称</em>的及<em>可传递</em>的，则R称为一个<strong>偏序</strong>。</p><p>集合S与偏序关系R一起，称为一个<strong>偏序集</strong>。</p><h2 id="n元关系"><a href="#n元关系" class="headerlink" title="n元关系"></a>n元关系</h2><p>n元关系，是指一个n元有序组的集合，对于任意的集合S，积集S^n 的子集称为S上的一个n元关系。<br>特别地，S^3的子集称为S上的三元关系。</p><h1 id="附录-1"><a href="#附录-1" class="headerlink" title="附录"></a>附录</h1><h2 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h2><ul>  <li>    <p>有序偶 ordered pair</p>    <ul>      <li>有序偶的第一元素 first entry</li>      <li>有序偶的第二元素 second entry</li>    </ul>  </li>  <li>    <p>集合的积 product of set</p>  </li>  <li>    <p>集合的笛卡尔积 Cartesian product of set</p>  </li>  <li>    <p>关系 relation</p>    <ul>      <li>关系的定义域 domain of a relation</li>      <li>关系的值域 range of a relation</li>    </ul>  </li>  <li>    <p>二元组 2-tuple</p>  </li>  <li>    <p>n元组 n-tuple</p>  </li>  <li>    <p>二元关系 binary relation</p>  </li>  <li>    <p>n元关系 n-ary relation</p>  </li>  <li>    <p>逆关系 inverse relation</p>  </li>  <li>    <p>关系的图示 pictorial representation of relations</p>    <ul>      <li>关系矩阵 matrix of the relation</li>      <li>关系箭头图 arrow diagram of the relation</li>      <li>关系有向图</li>    </ul>  </li>  <li>    <p>关系的合成 composition of relations</p>  </li>  <li>    <p>典型关系 types of relations</p>    <ul>      <li>自反关系 reflexive relations</li>      <li>空关系 the empty relation</li>      <li>全关系 the universal relation</li>      <li>对称关系 symmetric relations</li>      <li>反对称关系 antisymmentric relations</li>      <li>传递关系 transitive relations</li>    </ul>  </li>  <li>    <p>闭包性质 closure properties</p>    <ul>      <li>自反闭包</li>      <li>对称闭包</li>      <li>对角线</li>      <li>恒等关系</li>      <li>传递闭包</li>    </ul>  </li>  <li>    <p>等价关系</p>  </li>  <li>    <p>偏序关系</p>  </li>  <li>    <p>n元关系</p>  </li></ul><h4 id="examples-tex"><a href="#examples-tex" class="headerlink" title="examples.tex"></a>examples.tex</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">1. Based on Kuratowski&apos;s definition of ordered pairs, prove that:</span><br><span class="line">$$</span><br><span class="line">(a, b) = (c, d) \iff (a = b \land c = d)</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">According to Kuratowski&apos;s definition, $(x, y) = &#123;&#123;x&#125;, &#123;x, y&#125;&#125;$.</span><br><span class="line"></span><br><span class="line">If $(a, b) = (c, d)$, then $&#123;&#123;a&#125;, &#123;a, b&#125;&#125; = &#123;&#123;c&#125;, &#123;c, d&#125;&#125;$</span><br><span class="line"></span><br><span class="line">  1. if $a = b$,</span><br><span class="line">     then $&#123;&#123;a&#125;, &#123;a, b&#125;&#125; = &#123;&#123;a&#125;, &#123;a, a&#125;&#125; = &#123;&#123;a&#125;&#125; = &#123;&#123;c&#125;, &#123;c, d&#125;&#125;$,</span><br><span class="line">     then $&#123;c&#125; = &#123;c, d&#125; = &#123;a&#125;$,</span><br><span class="line">     then $a = c = d$,</span><br><span class="line">     then $b = a = d$</span><br><span class="line">     then $a = c, b = d$</span><br><span class="line"></span><br><span class="line">  2. if $a \neq b$</span><br><span class="line">     a. if $&#123;a&#125; = &#123;c, d&#125;$,</span><br><span class="line">        then $a = c = d$, $&#123;&#123;c&#125;, &#123;c, d&#125;&#125; = &#123;&#123;a&#125;&#125;$,</span><br><span class="line">        then $&#123;&#123;a&#125;, &#123;a, b&#125;&#125; = &#123;&#123;a&#125;&#125;$,</span><br><span class="line">        then $a = b$,</span><br><span class="line">        which contradicts $a \neq b$.</span><br><span class="line">     b. the same goes for $&#123;c&#125; = &#123;a, b&#125;$</span><br><span class="line">     c. if $&#123;a&#125; = &#123;c&#125;$,</span><br><span class="line">        then $a = c$,</span><br><span class="line">        then $&#123;&#123;a&#125;, &#123;a, b&#125;&#125; = &#123;&#123;c&#125;, &#123;c, d&#125;&#125; = &#123;&#123;a&#125;, &#123;a, d&#125;&#125;$,</span><br><span class="line">        then $&#123;a, b&#125; = &#123;a, d&#125;$,</span><br><span class="line">        then $b = d$.</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>      </td>    </tr>  </table></figure><h5 id="exercise"><a href="#exercise" class="headerlink" title="exercise"></a>exercise</h5><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\documentclass[a4paper, 12pt]&#123;article&#125;</span><br><span class="line">\usepackage&#123;color&#125;</span><br><span class="line"></span><br><span class="line">\title&#123;Exercise&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item Prove: Let $A, B, C, D$ be sets. Suppose $R$ is a relation from $A$ to $B$,</span><br><span class="line">  $S$ is a relation from $B$ to $C$ and $T$ is a relation from $C$ to $D$.</span><br><span class="line">  Then $(R\circ S)\circ T = R\circ (S\circ T)$</span><br><span class="line"></span><br><span class="line">  \item Suppse $C$ is a collection of relations $S$ on a set $A$,</span><br><span class="line">  and let $T$ be the intersection of the relations $S$ in $C$, that is $T = \cap(S|S \in C)$.</span><br><span class="line">  Prove:</span><br><span class="line">  a. If every S is symmetric, then T is symmetric.</span><br><span class="line">  b. If every S is transitive, then T is transitive.</span><br><span class="line"></span><br><span class="line">  \item let $R$ be a relation on a set $A$, and let $P$ be a property of relations,</span><br><span class="line">  such as symmetry and transitivity. Then $P$ will be called \texsl&#123;R-closable&#125; if $P$ satisfies:</span><br><span class="line">  i. There is a \textsl&#123;P&#125;-relation S containing $R$.</span><br><span class="line">  ii. The intersection of \textsl&#123;P&#125;-relations is a \textsl&#123;P&#125;-relation.</span><br><span class="line">  a. Show that symmetry and transitivity are \texsl&#123;R-closable&#125; for any relation $R$.</span><br><span class="line">  b. Suppose $P$ is \texsl&#123;R-closable&#125;. Then $P(R)$, the \texsl&#123;P-closure&#125; of $R$,</span><br><span class="line">  is the intersection of all \texsl&#123;P&#125;-relations $S$ containing $R$, that is:</span><br><span class="line">  $$</span><br><span class="line">  P(R) = \cap(S | \textrm&#123;S is a P-relation and &#125; R \subseteq S)</span><br><span class="line">  $$</span><br><span class="line"></span><br><span class="line">  \item Consider the \textbf&#123;Z&#125; of integers and an integer $m &gt; 1$.</span><br><span class="line">  We say that $x$ is congruent to $y$ modulo $m$, written</span><br><span class="line">  $$</span><br><span class="line">  x \equiv y (mod m)</span><br><span class="line">  $$</span><br><span class="line">  if $x - y$ is divisible by $m$. Show that this defines an equivalence relation on \textbf&#123;Z&#125;.</span><br><span class="line"></span><br><span class="line">  \item Let A be a set of nonzero integers and let $\sim$ be the relation on $A\tims A$ defined by</span><br><span class="line">  $$</span><br><span class="line">  (a, b) \sim (c, d) \textrm&#123;whenever&#125; ad = bc</span><br><span class="line">  $$</span><br><span class="line">  Prove that $\sim$ is an equivalence relation.</span><br><span class="line"></span><br><span class="line">  \item Prove: Let $R$ be an equivalence relation in a set $A$. Then the quotient set $A/R$ is a partition of A.</span><br><span class="line">  Specifically,</span><br><span class="line">  i.   $\forall a \in A \to a\in [a]$</span><br><span class="line">  ii.  $[a] = [b] \iff (a, b) \in R$</span><br><span class="line">  iii. $[a] \neq [b] \to [a]\cap [b] = \emptyset$</span><br><span class="line"></span><br><span class="line">  \item Prove: Let $\textsc&#123;l&#125;$ be any collection of sets,</span><br><span class="line">  the relation of set inclusion $\subseteq$ a partial order on $\textsc&#123;l&#125;$.</span><br><span class="line"></span><br><span class="line">  \item Suppose $R$ and $S$ are relations on a set $A$, and $R$ is antisymmetric.</span><br><span class="line">  Prove that $R\cap S$ is antisymmetric.</span><br><span class="line"></span><br><span class="line">  \item Prove that if $R$ is an equivalence relation on set $A$, the $R^&#123;-1&#125;$ is also an equivalence relation on $A$.</span><br><span class="line"></span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>      </td>    </tr>  </table></figure><h1 id="函数与算法"><a href="#函数与算法" class="headerlink" title="函数与算法"></a>函数与算法</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>假定对于集合A中的每个元素，我们都惟一地分配集合B的一个元素与之对应，这样的分配称为从A到B的<strong>函数</strong>。  集合A称为此函数的<strong>定义域</strong>，集合B称为此函数的<strong>上域</strong>。</p><p>通常用记号来表示函数，设f表示从A到B的函数，则记：</p><p>$$<br>f: A \to B<br>$$</p><p>诗作“f为从A到B的函数”或者“f将A映射到B”。</p><p>如果a \in  A，则f(a)（读作a的f像）表示由f分配给a的B中的惟一的元素，称为a在f下的<em>像值</em>，或者f在a处的值。<br>所有这些像值的集合称为f的  <em>值域</em> 或 <em>像</em>。  f: A \to 的像记作 Ran(f) 或者 Im(f) 或 f(A).</p><p>常常使用数学公式表示函数，如：<br>$$<br>f(x) = x^2, x \to x^2，y = x^2<br>$$</p><p>对于最后一种记法，x称为<strong>自变量</strong>，y称为<strong>因变量</strong>。</p><h3 id="函数与关系"><a href="#函数与关系" class="headerlink" title="函数与关系"></a>函数与关系</h3><p>每个函数f: A \to B产生一个从A到B的关系，称为<em>f 的图</em>，定义为：<br>$$<br>图 f = {(a, b): a \in  A, b = f(a)}<br>$$</p><p>两个函数f: A \to B 与g: A \to B称为相等，记作 f = g，如果对每个a \in A，有 f(a) =  g(a)。<br>也就是说，它们有相同的图。</p><p><strong>定义3.1</strong> 函数 f: A \to B是一个从A到B的关系（即A \times B的一个子集），使得每个a \in  A都属于f的惟一有序偶(a, b)。</p><h3 id="复合函数"><a href="#复合函数" class="headerlink" title="复合函数"></a>复合函数</h3><p>考虑函数f: A \to B和 g: B \to  C，即f的上域就是g的定义域，由此我们可以得到一个新的从A到C的函数，称为f与g的复合函数，记作<br>g \circ f，定义为：<br>$$<br>(g  \circ f)(a) \equiv g(f(a))<br>$$</p><p>对于任意的函数f: A \to B，有<br>$$<br>f \circ l_A = f, l_B \circ f = f<br>$$</p><p>其中，l_A与l_B分别为A，B上的<strong>恒同函数</strong>。</p><h2 id="一一的、映上的与可逆的函数"><a href="#一一的、映上的与可逆的函数" class="headerlink" title="一一的、映上的与可逆的函数"></a>一一的、映上的与可逆的函数</h2><p><strong>一一</strong> 函数f: A \to B，如果定义域A中的相异元素具有相异的像，称 f 为一一的（记作  1-1）。换言之，如果f(a) = f(a’) 蕴含 a = a’，称f是一一的。</p><p><strong>映上</strong> 函数f: A \to B，如果 B 的每个元素都是 A 的某个元素的像，称f: A -&gt; B 为映上的。</p><p><strong>定理3.1</strong>: 函数f:A \to B是可逆的，当且仅当f既是一一的，又是映上的。</p><p>如果函数f: A \to B既是一一的，又是映上的，则称f为A与B之间的一个一一对应。</p><p>一一的函数又称为 <em>单射</em>，映上又称为 <em>满射</em>，一一对应称为 <em>双射</em>。</p><h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><p>一个双射的函数 σ: X → X 被称为 X 上的置换。X上的置换的合成与逆，及 X 上的恒等函数也是 X 上的置换。</p><h2 id="数学函数、指数函数、对数函数"><a href="#数学函数、指数函数、对数函数" class="headerlink" title="数学函数、指数函数、对数函数"></a>数学函数、指数函数、对数函数</h2><h3 id="上、下取整函数"><a href="#上、下取整函数" class="headerlink" title="上、下取整函数"></a>上、下取整函数</h3><p>x的下取整，表示小于x的最大整数(floor)</p><p>x的上取整，表示大于x的最小整数(ceil)</p><h3 id="取整函数和绝对值函数"><a href="#取整函数和绝对值函数" class="headerlink" title="取整函数和绝对值函数"></a>取整函数和绝对值函数</h3><p><strong>取整函数</strong> 设x为任意实数，x的取整函数，记作LNT(x)，由删去小数点后的部分将x变为一个整数。</p><p><strong>绝对值</strong> 字数x的绝对值记作ABS(x) 或 |x|，定义为 x 或 -x 中的较大者。</p><h3 id="余数函数与模算术"><a href="#余数函数与模算术" class="headerlink" title="余数函数与模算术"></a>余数函数与模算术</h3><p>设k为任意整数，M为一个正整数，则<br>$$<br>k \pmod{M}<br>$$</p><p>（读作k模M）为以M除k的整数余数。即，k(mod M)是唯一的整数r满足：<br>$$<br>k = Mq + r , 0 &lt;= r &lt;  M<br>$$</p><p>mod术语也用于数学中的同余关系，定义如下：<br>$$<br>a \equiv b \pmod{M} 当且仅当 M 整除 b - a<br>$$</p><p>其中M称为模，而 a \equiv b(mod M) 读作“a与b模M同余”。以下的同余形式将常常用到。<br>$$<br>0 \equiv M  \pmod M, a \pm M \equiv a\pmod{M}<br>$$</p><h3 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h3><h3 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h3><p>对数是与指数相关的函数，设b为正整数，任意正数x的以b为底的对数记作</p><p>$$<br>\log_{b} x<br>$$</p><p>表示可以得到x的b的指数，即：<br>$$<br>y = \log_{b} x, b^y = x<br>$$</p><p><strong>常用对数</strong> 以10为底的对数, \log_{10} x, \log x, \lg  x<br><strong>自然对数</strong> 以e为底的对数, \log_{e} x, \ln  x<br><strong>二进制对数</strong> 以2为底的对数, \log_{2} x</p><h4 id="指数函数与对数函数的关系"><a href="#指数函数与对数函数的关系" class="headerlink" title="指数函数与对数函数的关系"></a>指数函数与对数函数的关系</h4><p>指数函数与对数函数之间是互逆关系：<br>$$<br>f(x) = b^x, g(x) = \log_{b} x<br>$$</p><p>他们在图上是关于线性函数 h(x) = x (y = x)对称。所以：</p><p>g(c) &lt; h(c) &lt; f(c)</p><h2 id="序列、集合的指标类"><a href="#序列、集合的指标类" class="headerlink" title="序列、集合的指标类"></a>序列、集合的指标类</h2><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>从正整数的集合 N = { 1, 2, 3, … } 到另一个集合 A 的函数。用 a_n 表示整数 n 的像，于是序列通常表示为：</p><p>a_1, a_2, a_3, … 或 {a_n: n \in N}， 或简记为 { a_n }</p><p>有时也以非负整数的集合 { 0, 1, 2, … } 而非 N 作为序列的定义域。在这一情况下，我们说 n 从 0 开始而不是从 1 开始。</p><p><strong>列表</strong> 集合A上的有限序列是一个从 { 1, 2, …, m } 到A的函数，通常表示为：</p><p>a_1, a_2, …, a_m</p><p>这样的<em>有限</em>序列有时也称为一个 列表 或 m-元组。</p><h3 id="求和记号与求和"><a href="#求和记号与求和" class="headerlink" title="求和记号与求和"></a>求和记号与求和</h3><p>考虑一个序列 a_1, a_2, a_3, …，则和</p><p>a_1 + a_2 + … + a_n 与 a_m + a_{m+1} + … + a_n</p><p>将分别记作：</p><p>$$<br>\sum_{j = 1}^{n} a_j, \sum_{j = m}^{n} a_j<br>$$</p><p>在上术表达式中，字母j称为<em>哑指标</em>或<em>哑变量</em>。</p><h3 id="集合的指标类"><a href="#集合的指标类" class="headerlink" title="集合的指标类"></a>集合的指标类</h3><p>设I为任意非空集合，并设 S 为集族，从 I 到 S 的指标函数为一个函数f: I \to S。对于任意的 i \in I，记A_i表示其 像f(i)。</p><p>于是指标函数 f 通常表示为：</p><p>{A_i: i \in I} 或简记为 {A_i}</p><p>集合 I 称为指标集，I 的元素称为指标。<br>如果 f 为一一的 和 映上的，我们就说 S 可以由 I 标出。</p><p>集合的指标类的并与交定义为：<br>$$<br>\cup_{i \in I} A_i = {x: x \in A，对于某i \in I}</p><p>\cap_{i \in I} A_i = {x: x \in A，对所有i \in I}<br>$$</p><p>如果I为有限集，则这恰好是先前定义的并和交。如果I是 N（自然数集），可以分别定义并与交为：</p><p>$$<br>A_1 \cup A_2 \cup \ldots, A_1 \cap \A_2 \cap \ldots<br>$$</p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p><strong>递归定义</strong>  如果一个函数的定义与其自身有关，则称该函数是递归定义的。<br>为了避免循环定义，函数的递归需要满足以下两个性质：</p><ol>  <li>必须存在一个称为<em>基准值</em>的叙述，不与函数自身相关。</li>  <li>在每一个时刻，函数都与自身相关，但函数的描述必须封闭于基准值。</li></ol><p>具备这两个性质的递归函数称为<em>良好定义</em>的。</p><h3 id="阶乘函数"><a href="#阶乘函数" class="headerlink" title="阶乘函数"></a>阶乘函数</h3><p>从 1 到 n 的所有正整数的积称为“n阶乘”，通常记作n!，即：</p><p>n! = 1 * 2 * 3 … (n - 2) (n - 1) n</p><p><strong>定义3.2 阶乘函数</strong></p><pre><code>1. 如果 n = 0，则 n! = 12. 如果 n &gt; 0，则 n!= n * (n - 1)!</code></pre><h3 id="水平数"><a href="#水平数" class="headerlink" title="水平数"></a>水平数</h3><p>  设P为一个用来确定f(X)的过程或者递归式，其中f为递归函数，X为输入值。<br>将P的每一步操作联系一个<em>水平数</em>。P的原始操作步骤规定为水平1；由于递归介入，P的每一时刻的操作的水平数都比其递归代入的水平数增加1。<br>递归的深度即获得f(X)的P的最大操作水平数。</p><h3 id="Fibonacci序列"><a href="#Fibonacci序列" class="headerlink" title="Fibonacci序列"></a>Fibonacci序列</h3><p>Fibonacci序列（通常记作F_0, F_1, F_2，…）如下：</p><p>$$<br>0, 1, 1, 2, 3, 5, 8, 13, 21, 24, 55, …<br>$$</p><p>即F_0 = 0, F_1 = 1，以后每一项都是其前面两项的和。</p><p><strong>定义3.3(Fibonacci序列)</strong><br> 1. 如果 n = 0 或者 n = 1，则 F_n = n<br> 2.  如果 n &gt; 1，则F_n = F_{n-2} + F_{n-1}</p><h3 id="Ackermann函数"><a href="#Ackermann函数" class="headerlink" title="Ackermann函数"></a>Ackermann函数</h3><p><strong>定义3.4(Ackermann函数)</strong><br> 1. 如果 m = 0，则 A(m, n) = n + 1<br> 2.  如果 m != 0 但是 n = 0， 则 A(m, n) = A(m - 1, n)<br> 3. 如果 m != 0 且 n != 0, 则 A(m,  n) = A(m - 1, A(m, n - 1))</p><p>(条件2 经过递归之后，得到的值为1；条件3的情况较为复杂。)</p><h3 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h3><p>两个集合A与B称为是 <em>对等</em> 的，或 <em>具有同样多的元素</em>，或 <em>具有相同的基数</em>，记作A \simeq  B。如果存在一一对应 f: A \to B。</p><p>集合A称为<em>有限的</em>，如果对于某正整数n，A 与集合 { 1, 2, …, n }  具有相同的基数。<br>如果一个集合不是有限的，就称之为<em>无限</em>的。</p><p>我们将基数简单地看做一种分配给集合的符号，两个集合被分配相同的符号，当且仅当它们具有相同的基数。<br>集合A的基数通常记作 |A| 或 n(A)，或  card(A)。</p><p>有限集的基数符号是自然（数）的，空集的基数为0；集合 {1, 2, …, n} 的基数为n。<br>于是 |A| = n 当且仅当 A 与 {1, 2,  …, n} 具有相同的基数，即A含有n个元素。</p><p>正整数集N的基数为 \aleph_0（读作aleph 0）。<br>于是card(A) = \aleph_0 当且仅当 A 与 <em>N</em>  具有相同的基数。<br>-  具有基数 \aleph_0 的集合称为<em>可数</em>的或<em>无限可数</em>的。有限集和可数集都称为可数的。</p><p><strong>定理3.2</strong></p><p>可数集的可数并仍然是可数的。</p><p>如果A_1, A_2, …都是可数的，则并集<br>$$<br>A_1 \cup A_2 \cup A_3 \cup  \ldots<br>$$<br>也是可数的。</p><p><strong>定理3.3</strong> 从 0 到 1 的所有字数的集合 I 是不可数的。</p><h2 id="基数与不等式"><a href="#基数与不等式" class="headerlink" title="基数与不等式"></a>基数与不等式</h2><p>对于任意集合A与B，定义：<br>$$<br>|A| \leq |B|，如果存在一一对应函数 f： A \to B<br>$$</p><p>同样地：</p><p>$$<br>|A| \leq |B| \land |A| \neq |B| \implies |A| &lt; |B|<br>$$</p><p><strong>定理3.4 (Cantor)</strong></p><p>对于任意集合A，有<br>$$<br>|A| &lt; |Power(A)|<br>$$<br>（其中，Power(A)为A的幂集，即A的全体子集族）。</p><p><strong>定理3.5 (Schroeder-Bernstein)</strong></p><p>对于集合A和B：<br>$$<br>|A| \leq |B| \land |B| \leq |A| \implies |A| = |B|<br>$$</p><h2 id="算法与函数"><a href="#算法与函数" class="headerlink" title="算法与函数"></a>算法与函数</h2><p>算法M是求解一个特定问题的有限个良好定义的相继步骤的列表。</p><p>通常可以有不止一种方法求f(X)。获得f(X)的算法M的选择依赖于算法的“效率”和“复杂性”。</p><h2 id="算法的复杂性"><a href="#算法的复杂性" class="headerlink" title="算法的复杂性"></a>算法的复杂性</h2><p>算法的复杂性是算法效率的衡量标准。</p><p>假设 M 是一种算法，并设 n 为输入数据的规模。实施M所占用的时间和空间是衡量该算法之效率的两个主要指标。<br>时间由“键盘操作”次数衡量。</p><p>比如：</p><pre><code>1. 对于排序和查找，对 比较次数 计数2. 在计算中，对乘法计数而忽略加法</code></pre><p>键盘操作的定义前提是其他操作时间大大小于或 最多与键盘操作时间成比例。<br>空间由实施该算法所需的最大内存来衡量。</p><p>算法 M 的复杂性是一个函数  f(n)，它对于输入数据的规模n给出运行该算法所需时间与所需存储空间。<br>执行一个算法所需存储空间通常就是数据规模的倍数。<br>因此，除非特殊情况，“复杂性”将指运行算法的时间。</p><p>求 复杂性函数f(n) 在复杂性理论中研究最多的两种情况是：</p><pre><code>1. 最坏情况 对于任何可能的输入，f(n)的最大值2. 平均情况 f(n)的期望值</code></pre><h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><p>给定一个包含n个元素的线性数组DATA，和一个特定的信息ITEM，<br>在数组DATA中求出ITEM的位置LOC，或者传送某个信息，比如LOC = 0  表示ITEM不出现DATA中。<br>线性查找算法解决这个问题的途径是将ITEM与DATA中的元素一个一个地进行比较，直到求出LOC为止。</p><p>线性查找算法的复杂性由ITEM与DATA[K]之间的比较数字C给出。<br>C(n)的最坏情况和平均情况如下：</p><pre><code>1. **最坏情况** C(n) = n；2. **平均情况** C(n) = (n + 1) / 2</code></pre><h3 id="增长率与大O记号"><a href="#增长率与大O记号" class="headerlink" title="增长率与大O记号"></a>增长率与大O记号</h3><p>  假定M是一个算法，并设n为输入数据的大小，显示M的复杂性f(n)随着n的增长而增长。通常我们需要考察的是f(n)的增长率。<br>常常由f(n)与某标准函数相比较而得。假如：<br>$$<br>\log_{2}  n, n, n \log_{2} n, n^2, n^3, 2^n<br>$$</p><p>等等，都可被用作为标准函数。<br>（对数函数 \log_2 n 增长最慢，而指数函数 2^n 增长最快）</p><p><strong>定义</strong> 设f(x)与g(x)为定义于R或者R的子集上的任意两个函数，我们说“f(x)与g(x)同阶”，记作：</p><p>$$<br>f(x) = O(g(x))<br>$$</p><p>如果存在字数 k 和正常如C使得对于所有的x &gt; k有：</p><p>$$<br>|f(x)| \leq C|g(x)|<br>$$</p><p>同样地，当f(x) - h(x) = O(g(x))时，记：</p><p>$$<br>f(x) = h(x) + O(g(x))<br>$$</p><h3 id="常见算法的复杂性"><a href="#常见算法的复杂性" class="headerlink" title="常见算法的复杂性"></a>常见算法的复杂性</h3><p>计算机科学中一些著名的查找和排序算法的复杂性</p><ol>  <li>线性查找：O(n)</li>  <li>二叉查找：O(\log n)</li>  <li>冒泡排序：O(n^2)</li>  <li>归并排序：O(n \log n)<h1 id="附录-2"><a href="#附录-2" class="headerlink" title="附录"></a>附录    </h1>  </li></ol><h2 id="术语-2"><a href="#术语-2" class="headerlink" title="术语"></a>术语</h2><ul>  <li>函数 function<ul>      <li>定义域 domain</li>      <li>上域 codomain, target set</li>      <li>值域 range</li>      <li>像 image</li>      <li>变量 variable</li>      <li>自变量 independent variable</li>      <li>因变量 dependent variable</li>    </ul>  </li>  <li>函数的图 graph of function</li>  <li>复合函数 composition function</li>  <li>一一 one-to-one</li>  <li>单射 injective</li>  <li>映上 onto</li>  <li>满射 surjective</li>  <li>可逆 invertible</li>  <li>一一对应 one-to-one correspondence</li>  <li>双射 bijectice</li>  <li>置换 permutation</li>  <li>恒等函数 identity function</li>  <li>数学函数 mathematical function<ul>      <li>上、下取整函数 floor and ceiling function</li>      <li>实数转整数函数 interger function</li>      <li>绝对值函数 absolute value function</li>      <li>取余函数 remainder function</li>      <li>同余函数 modular arithmetic</li>      <li>指数函数 exponential function</li>      <li>对数函数 logarithmic function<ul>          <li>常用对数 common logarithm</li>          <li>自然对数 natural logarithm</li>          <li>二进制对数 binary logarithm</li>        </ul>      </li>    </ul>  </li>  <li>求和 sums</li>  <li>求和记号 summation symbol</li>  <li>哑变量 dummy index, dummy variable</li>  <li>序列 seqeunce<ul>      <li>有限序列 finite sequence</li>      <li>列表 list</li>      <li>m-元组 m-tuple</li>    </ul>  </li>  <li>集合的指标类 indexed classes of sets<ul>      <li>指标函数 indexing function</li>      <li>指标集 indexing set</li>      <li>指标 index</li>    </ul>  </li>  <li>递归函数 recursively defined function<ul>      <li>基准值 base value</li>      <li>良好定义 well-defined</li>      <li>阶乘函数 factorial function</li>      <li>水平数 level number</li>      <li>Fibonacci 序列 Fibonacci Sequence</li>      <li>Ackermann 函数 Ackermann Function</li>    </ul>  </li>  <li>基数 cardinality<ul>      <li>对等 equipotent</li>      <li>可数 denumerable</li>      <li>无限可数 countably infinite</li>      <li>可数 countable</li>      <li>有限集 finite set</li>      <li>可数集 countable set</li>      <li>不等式 inequality</li>      <li>基数 cardinal numbers</li>    </ul>  </li>  <li>算法 algorithm</li>  <li>多项式求值 polynomial evaluation</li>  <li>多项式直接求值法 direct method</li>  <li>多项式Horner求值法（综合除法）Horner’s Method, Synthetic Division</li>  <li>最大公约数 greatest common divisor</li>  <li>最大公约数 直接求值法 Direct Method</li>  <li>最大公约数 带余除法 Euclidean Algorithm</li>  <li>算法的复杂性 complexity of algorithms</li>  <li>线性查找 linear search</li>  <li>worst case</li>  <li>average case</li>  <li>增长率 rate of growth</li>  <li>大O记号 Big O Notation</li>  <li>函数同阶 f is of order g</li></ul><h3 id="exercise-1"><a href="#exercise-1" class="headerlink" title="exercise"></a>exercise</h3><p>ackermann.h</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#ifndef _ACKERMANN_H</span><br><span class="line">#define _ACKERMANN_H</span><br><span class="line"></span><br><span class="line">int ackermann(unsigned int m, unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">  if (m == 0)</span><br><span class="line">    return n + 1;</span><br><span class="line">  if (n == 0)</span><br><span class="line">    return ackermann(m - 1, n);</span><br><span class="line"></span><br><span class="line">  return ackermann(m - 1, ackermann(m, n - 1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre>      </td>    </tr>  </table></figure><p>test.c</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;ackermann.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%d\n&quot;, ackermann(16, 19));</span><br><span class="line">  // 16, 19</span><br><span class="line">  // 运行时间长，最后结果 20</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="exercise-tex"><a href="#exercise-tex" class="headerlink" title="exercise.tex"></a>exercise.tex</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">  \usepackage&#123;amsmath&#125;</span><br><span class="line">  \usepackage&#123;amssymb&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item Consider permutaion</span><br><span class="line">  $\sigma = \bigl(\begin&#123;smallmatrix&#125;</span><br><span class="line">    1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\ 3 &amp; 6 &amp; 4 &amp; 5 &amp; 1 &amp; 2</span><br><span class="line">    \end&#123;smallmatrix&#125; \bigr)$</span><br><span class="line">  and $\tau = \bigl(\begin&#123;smallmatrix&#125;</span><br><span class="line">    1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\ 2 &amp; 4 &amp; 6 &amp; 5 &amp; 3 &amp; 1</span><br><span class="line">    \end&#123;smallmatrix&#125; \bigr)$ in $S_6$.</span><br><span class="line"></span><br><span class="line">    Find: i. composition $\tau \circ \sigma$, ii. $\sigma^&#123;-1&#125;$.</span><br><span class="line"></span><br><span class="line">    \item Consider functions $f: A\to B$ and $g: B\to C$. Prove the following:</span><br><span class="line"></span><br><span class="line">    a. If $f$ and $g$ are one-to-one, then $g\circ f$ is one-to-one.</span><br><span class="line"></span><br><span class="line">    b. If $f$ and $g$ are onto functions, then $g\circ f$ is an onto function.</span><br><span class="line"></span><br><span class="line">    \item Prove the following generalization of DeMorgan&apos;s law: For any class of sets $\&#123;A_i\&#125;$ we have</span><br><span class="line">    $$</span><br><span class="line">    (\cup_i A_i)^\mathsf&#123;c&#125; = \cap_i A_i^\mathsf&#123;c&#125;</span><br><span class="line">    $$</span><br><span class="line"></span><br><span class="line">    \item Show that the set $\textbf&#123;Z&#125;$ of integers has cardinality $\aleph_0$.</span><br><span class="line"></span><br><span class="line">    \item Let $A_1, A_2, \cdots$ be a countable number of finite sets.</span><br><span class="line">    Prove that the union $S = \cup_i S_i$ is countable.</span><br><span class="line"></span><br><span class="line">    \item Prove: A countable union of countable sets is countable.</span><br><span class="line"></span><br><span class="line">    \item Prove: The set $\textbf&#123;I&#125;$ of all real numbers between 0 and 1 inclusive is uncountable.</span><br><span class="line"></span><br><span class="line">    \item For any $n \in \textbf&#123;N&#125;$, let $D_n = (0, 1/n)$, the open iterval from $0$ to $1/n$. Find:</span><br><span class="line"></span><br><span class="line">    i. $D_3 \cup D_4$, ii. $D_3 \cup D_20$, iii. $D_s \cup D_t$, iv. $D_s \cup D_t$</span><br><span class="line"></span><br><span class="line">    \item Suppose $P(n) = a_0 + a_1 n + a_2 n^2 + \cdots + a_m n^m$ has degree $m$. Prove $P(n) = O(n^m)$</span><br><span class="line"></span><br><span class="line">    \item Prove: $|A| &lt; |\textrm&#123;Power&#125;(A)|$ (where $\textrm&#123;Power&#125;(A)$ is the power set of $A$).</span><br><span class="line"></span><br><span class="line">    \item Prove the following equivalent formulation of the Schroeder-Bernstein Theorem:</span><br><span class="line"></span><br><span class="line">    Suppose $X\supseteq Y \supseteq X_1$ and $X\simeq X_1$, then $X\simeq Y$.</span><br><span class="line"></span><br><span class="line">    \item Prove: Suppose $f: A \to B$ and $g: B \to A$ satisfy $g\circ f = 1_A$. Then $f$ is one-to-one and $g$ is onto.</span><br><span class="line"></span><br><span class="line">    \item Prove: A function $f: A\to B$ is invertible if and only if $f$ is both one-to-one and onto.</span><br><span class="line"></span><br><span class="line">    \item Prove: Suppose $f: A\to B$ is invertible with inverse function $f^&#123;-1&#125;: B\to A$.</span><br><span class="line">    Then $f^&#123;-1&#125;\circ f = 1_A$ and $f\circ f^&#123;-1&#125; = 1_B$.</span><br><span class="line"></span><br><span class="line">    \item Suppose $f: A\to B$ is one-to-one and $g: A\to B$ is onto. Let $x$ be a subset of $A$.</span><br><span class="line"></span><br><span class="line">    i. Show $f 1_x$, the restriction of $f$ to $x$, is one-to-one.</span><br><span class="line"></span><br><span class="line">    ii. Show $g 1_x$, need not be onto.</span><br><span class="line"></span><br><span class="line">    \item For each $n \in N$, consider the open interval $A_n = (0, 1/n) = \&#123;x | 0 &lt; x &lt; 1/n\&#125;$. Find:</span><br><span class="line"></span><br><span class="line">    a. $A_2 \cup A_8$; c. $\cup(A_i | i \in J)$; e. $\cup(A_i | i \in K)$;</span><br><span class="line"></span><br><span class="line">    b. $A_3 \cap A_7$; d. $\cap(A_i | i \in J)$; f. $\cap(A_i | i \in K)$;</span><br><span class="line"></span><br><span class="line">    where $J$ is a finite subset of $\textbf&#123;N&#125;$ and $K$ is an infinite subset of $\textbf&#123;N&#125;$.</span><br><span class="line"></span><br><span class="line">    \item Consider an indexed class of sets $\&#123;A_i | i \in I\&#125;$, a set $\textbf&#123;B&#125;$ and an index $i_0$ in $\textbf&#123;I&#125;$.</span><br><span class="line"></span><br><span class="line">    Prove: a. $B\cap (\cup_i A_i) = \cup_i(B\cap A_i)$;</span><br><span class="line">    b. $\cap(A_i | i \in I)\subseteq A_&#123;i_0&#125; \subseteq \cup (A_i | i \in I)$</span><br><span class="line"></span><br><span class="line">    \item Prove:</span><br><span class="line"></span><br><span class="line">    a. Every infinite set $A$ contains a denumerable subset $D$.</span><br><span class="line"></span><br><span class="line">    b. Each subset of a denumerable set is finite or denumerable.</span><br><span class="line"></span><br><span class="line">    c. If $A$ and $B$ are denumerable, then $A\times B$ is denumerable.</span><br><span class="line"></span><br><span class="line">    d. The set $\textbf&#123;Q&#125;$ of rational numbers is denumerable.</span><br><span class="line"></span><br><span class="line">    \item Prove: a. $|A\times B| = |B\times A|$;</span><br><span class="line">    b. $A\subseteq B \implies |A| \leq |B|$;</span><br><span class="line">    c. $|A| = |B| \implies |P(A)| = |P(B)|$.</span><br><span class="line"></span><br><span class="line">    \item Prove: The set $P$ of all polynomial $p(x) = a_0 + a_1 x + \cdots + a_m x^m $</span><br><span class="line">    with integral coefficients(that is, where $a_0, a_1, \cdots, a_m$ are integers) is denumerable.</span><br><span class="line">  \end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>      </td>    </tr>  </table></figure><h1 id="逻辑与命题演算"><a href="#逻辑与命题演算" class="headerlink" title="逻辑与命题演算"></a>逻辑与命题演算</h1><h2 id="要点难点"><a href="#要点难点" class="headerlink" title="要点难点"></a>要点难点</h2><ul>  <li>命题表达式与真值表</li>  <li>逻辑等价</li>  <li>论证与命题函数</li></ul><h2 id="命题与复合命题"><a href="#命题与复合命题" class="headerlink" title="命题与复合命题"></a>命题与复合命题</h2><h3 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h3><p><strong>命题</strong>（或<strong>陈述</strong>）是一个说明性语句，它只能是真或假，不可能两者同时成立。</p><h2 id="复合命题"><a href="#复合命题" class="headerlink" title="复合命题"></a>复合命题</h2><p><strong>复合命题</strong> 由<em>子命题</em>及它们之间的各种联系组成的命题称为复合命题。</p><p><strong>原子命题</strong> 不能被分解为更简单的命题（非复合命题）称为原子命题</p><h2 id="基本逻辑运算"><a href="#基本逻辑运算" class="headerlink" title="基本逻辑运算"></a>基本逻辑运算</h2><p><strong>合取联结</strong></p><p>任何两个命题可以用术语“与”联合而成一个复合命题，叫做这两个原始命题的合取联结。记作：</p><p>$$<br>p \land q<br>$$</p><p>读作“p与q”，表示p与q的合取联结。</p><p><strong>定义4.1</strong> 如果p与q均为真，则p \land q 为真；否则 p \land q为假。</p><p><strong>析取联结</strong></p><p>任何两个命题可以用术语“或”联合而成一个复合命题，叫做这两个原始命题的析取联结。记作：</p><p>$$<br>p \lor q<br>$$</p><p>读作“p 或 q”，表示p 与 q的析取联结。</p><p><strong>定义4.2</strong> 如果p与q均为假，则 p \lor q 为假；否则p \lor q为真。</p><h3 id="否定联结-lnot-p"><a href="#否定联结-lnot-p" class="headerlink" title="否定联结, \lnot p"></a>否定联结,  \lnot p</h3><p>给定任一命题p，都可以通过在p前面添加“不是”或“假”或在p前面插入“非”，得到另一个命题，称为p的否定联结，记作：</p><p>$$<br>\lnot p<br>$$</p><p>读作“非p”，表示p的否定联结。</p><p><strong>定义4.3</strong> 如果p为真，则 \lnot p 为假；如果p为假，则 \lnot p 为真。</p><h2 id="命题与真值表"><a href="#命题与真值表" class="headerlink" title="命题与真值表"></a>命题与真值表</h2><p><strong>命题表达式</strong></p><p>设 P(p, q, …)为一个由取值为真(T)或假(F)的逻辑变量p, q, … 以及逻辑联结 \land, \lor, \lnot  构成的表达式。<br>这样的表达式P(p, q, …)称为一个命题。</p><p><strong>逻辑联结的规定优先级</strong> 规定：</p><p>$$<br>\lnot 优先于 \land 优先于 \lor<br>$$</p><h3 id="构造真值表的另一种方法"><a href="#构造真值表的另一种方法" class="headerlink" title="构造真值表的另一种方法"></a>构造真值表的另一种方法</h3><h2 id="永真命题与永假命题"><a href="#永真命题与永假命题" class="headerlink" title="永真命题与永假命题"></a>永真命题与永假命题</h2><p><strong>永真命题</strong> 对于变量的任意值，都为真的命题。</p><p><strong>永假命题</strong> 对于变量的任意做，都为假的命题。</p><p><strong>定理4.1（代入原理）</strong> 若P(p, q, …)是永真命题，<br>则对任意命题P_1, P_2, …, 命题P(P_1,  P_2, …)仍然是永真命题。</p><h2 id="逻辑等价"><a href="#逻辑等价" class="headerlink" title="逻辑等价"></a>逻辑等价</h2><p>两个命题P(p, q, …) 与 Q(p, q,  …)如果具有<em>相同的真值表</em>，则称为<em>逻辑等价</em>的，或简称为<em>等价</em>或<em>相等</em>，记作：</p><p>$$<br>P(p, q, …) \equiv Q(p, q, ..)<br>$$</p><p>例如：<br>$$<br>\lnot (p \land q) \equiv \lnot p \land \lnot q<br>$$</p><h2 id="命题代数"><a href="#命题代数" class="headerlink" title="命题代数"></a>命题代数</h2><p><strong>定理4.2</strong> 命题满足如下定律：</p><pre><code>1. 幂等律</code></pre><p>$$<br> p \lor p \equiv p<br>$$<br>$$<br> p \land p \equiv p<br>$$</p><pre><code>2. 结合律</code></pre><p>$$<br> (p \lor q) \lor r \equiv p lor (q \lor r)<br>$$<br>$$<br> (p \land q)  \and r \equiv p \land (q \land r)<br>$$</p><pre><code>3. 交换律</code></pre><p>$$<br> p \lor q \equiv q \lor p<br>$$<br>$$<br> p \land q \equiv q \land  p<br>$$</p><pre><code>4. 分配律</code></pre><p>$$<br> p \lor (q \land r) \equiv (p \lor q) \and (p \lor r)<br>$$<br>$$<br> p  \land (q \lor r) \equiv (p \land q) \lor (p \land r)<br>$$</p><pre><code>5. 同一律</code></pre><p>$$<br> p \land T \equiv p, p \lor F \equiv p<br>$$<br>$$<br> p \lor T \equiv  T, p \land F \equiv F<br>$$</p><pre><code>6. 互补律</code></pre><p>$$<br> p \lor \lnot p \equiv T, p \land \lnot p \equiv F<br>$$<br>$$<br>  \lnot T \equiv F, \lnot F \equiv T<br>$$</p><pre><code>7. 对合律</code></pre><p>$$<br> \lnot \lnot p \equiv p<br>$$</p><pre><code>8. DeMorgan律</code></pre><p>$$<br> \lnot(p \lor q) \equiv \lnot p \land \lnot q<br>$$<br>$$<br> \lnot(p  \land q) \equiv \lnot p \lor lnot q<br>$$</p><h2 id="条件语句与双条件语句"><a href="#条件语句与双条件语句" class="headerlink" title="条件语句与双条件语句"></a>条件语句与双条件语句</h2><p><strong>条件语句</strong> 具有形式“如果p则q”的语句称为条件语句。记作：</p><p>$$<br>p \implies q<br>$$</p><p>常读作“p蕴含q”或者“仅当q时有p”。</p><p><strong>真值表</strong></p><table>  <thead>    <tr>      <th>p</th>      <th>q</th>      <th>p \implies q</th>    </tr>  </thead>  <tbody>    <tr>      <td>T</td>      <td>T</td>      <td>T</td>    </tr>    <tr>      <td>T</td>      <td>F</td>      <td>F</td>    </tr>    <tr>      <td>F</td>      <td>T</td>      <td>T</td>    </tr>    <tr>      <td>F</td>      <td>F</td>      <td>T</td>    </tr>  </tbody></table><p>（为何 (F, F) = T ？）</p><p><strong>双条件语句</strong> 具有形式“p当且仅当q”的语句称为双条件语句。记作：<br>$$<br>p \iff q<br>$$</p><table>  <thead>    <tr>      <th>p</th>      <th>q</th>      <th>p \iff q</th>    </tr>  </thead>  <tbody>    <tr>      <td>T</td>      <td>T</td>      <td>T</td>    </tr>    <tr>      <td>T</td>      <td>F</td>      <td>F</td>    </tr>    <tr>      <td>F</td>      <td>T</td>      <td>F</td>    </tr>    <tr>      <td>F</td>      <td>F</td>      <td>T</td>    </tr>    <tr>      <td>## 论证</td>      <td></td>      <td></td>    </tr>  </tbody></table><p>论证是一个断言，是从称为<em>前提</em>的给定命题集合 P_1, P_2, …,  P_n推出称为<em>结论</em>的另一个命题Q的过程。<br>这样的论证记作：<br>$$<br>P_1, P_2, …, P_n \vdash  Q<br>$$</p><p><strong>定义4.4</strong> 有效论证</p><p>一个论证P_1，P_2，…，P_n \vdash Q 称为有效的，如果前提 P_1，P_2，…，P_n 为真则 Q 为真。</p><p>无效的论证称为<em>谬误</em>。</p><p><strong>拆分律</strong></p><p>$$<br>p, p \implies q \vdash q<br>$$</p><p><strong>定理4.3</strong> 论证 (P_1, P_2, …, P_n)\vdash Q 有效当且仅当命题 (P_1, P_2, …,  P_n) \implies Q 是一个永真命题。</p><h3 id="三段论律"><a href="#三段论律" class="headerlink" title="三段论律"></a>三段论律</h3><p>$$<br>p \implies q, q \implies r \vdash p \implies r<br>$$</p><p>即  $$<br>[(p \implies q) \land (q \implies r)] \implies (p \implies  r)<br>$$<br>是一个永真命题。</p><h2 id="逻辑蕴含"><a href="#逻辑蕴含" class="headerlink" title="逻辑蕴含"></a>逻辑蕴含</h2><p>称命题 P(p, q, …) 逻辑蕴含命题Q(p, q, …)记作</p><p>$$<br>P(p, q, …) \implies Q(p, q, …)<br>$$</p><p>即若 P(p, q, …)为真，必有 Q(p, q, …)为真。</p><p><strong>定理4.4</strong> 对论任意的命题P(p, q, …)与Q(p, q, …)下列三个陈述等价：</p><ol>  <li>P(p, q, …)逻辑蕴含 Q(p, q, …)</li>  <li>论证 P(p, q, …) \vdash Q(p, q, …)有效</li>  <li>命题P(p, q, …) \implies Q(p, q, …) 是一个永真命题</li></ol><h2 id="命题函数，量词"><a href="#命题函数，量词" class="headerlink" title="命题函数，量词"></a>命题函数，量词</h2><p>设A为一个给定集合，定义于A上的一个命题函数（或称为<em>开放语句</em>或<em>开放条件</em>）是一个表达式</p><p>$$<br>p(x)<br>$$</p><p>满足对每个a \in A，p(a) 为真或为假，即以俚语的a \in A 向x赋值时，p(x)都成为一个陈述（具有其真值）。</p><p>集合A称为p(x)的定义域，而A中所有使得p(a)为真的元素的集合T_p称为p(x)的真集。换句话说，</p><p>$$<br>T_p = {x: x \in A, p(x) 为真} 或 T_p = {x: p(x)}<br>$$</p><p>当A为数的集合时，条件p(x)通常是一个关于变量x的等式或不等式方程。</p><h3 id="全称量词"><a href="#全称量词" class="headerlink" title="全称量词"></a>全称量词</h3><p>设p(x)为定义于集合A上的命题函数，考虑表达式：<br>$$<br>(\forall x \in A) p(x)<br>$$</p><p>读作“对A中的每个x，p(x)为真语句”。</p><p>符号\forall 读作“对所有”或“对每个”，称为<strong>全称量词</strong>。  以上表达式等价于：<br>$$<br>T_p = {x: x \in A, p(x) } = A<br>$$</p><p>即 p(x) 的真集是整个A。</p><h3 id="存在量词"><a href="#存在量词" class="headerlink" title="存在量词"></a>存在量词</h3><p>设p(x)为定义于集合A上的一个命题函数，考虑表达式</p><p>$$<br>(\exists x \in A)p(x)<br>$$</p><p>读作“在A中存在x使得p(x)为真语句”。</p><p>记号\exists 读作“存在”，或“对某个”，或“对于至少一个”。叫做<strong>存在量词</strong>。</p><p>以上陈述等价于：</p><p>$$<br>T_p = {x: x \in A, p(x)} \neq \emptyset<br>$$</p><p>即p(x)的真集非空。特别地：</p><p> Q_2: 如果{x: p(x)} \neq \emptyset，则 \exists x, p(x)为真；否则\exists x, p(x)为假。</p><h2 id="量词语句的否定"><a href="#量词语句的否定" class="headerlink" title="量词语句的否定"></a>量词语句的否定</h2><p><strong>定理4.5（DeMorgan）</strong><br>$$<br>\lnot (\forall x \in A)p(x) \equiv  (\exists x \in A)\lnot p(x)<br>$$<br>即以下两个语句等价：</p><ol>  <li>对所有的a \in A，p(a)为真是不对的。</li>  <li>存在 a \in A，使得p(a)为假。</li></ol><p><strong>定理4.6（DeMorgan）</strong><br>$$<br>\lnot(\exists x \in A)p(x) \equiv  (\forall x \in A) \lnot p(x)<br>$$<br>即以下两个语句等价：</p><ol>  <li>对某个a \in A，p(a)为真 是不对的</li>  <li>所有a \in A，p(a)为假</li></ol><p><strong>反例</strong></p><p>存在元素 x_0，使得p(x_0)为假，x_0 称为 \forall x, p(x)的一个反例。</p><h3 id="含有多个变量的命题函数"><a href="#含有多个变量的命题函数" class="headerlink" title="含有多个变量的命题函数"></a>含有多个变量的命题函数</h3><p><strong>基本原理</strong> 对其每个变量冠以量词后的命题函数为一个语句并且具有真值。</p><p>$$<br>\forall x \exists y, p(x,y)<br>$$</p><p>或</p><p>$$<br>\exists x \exists y \exists z, p(x, y, z)<br>$$<br>为具有真值的语句。</p><h3 id="多变量的否定量词语句"><a href="#多变量的否定量词语句" class="headerlink" title="多变量的否定量词语句"></a>多变量的否定量词语句</h3><p>获得多变量否定量词语句的具体做法是：</p><p>将否定符号从左向右移动，同时将每个\forall 换成\exists 而将每个\exists 换成 \forall。</p><h1 id="附录-3"><a href="#附录-3" class="headerlink" title="附录"></a>附录</h1><h2 id="术语-3"><a href="#术语-3" class="headerlink" title="术语"></a>术语</h2><ul>  <li>命题</li>  <li>复合命题</li>  <li>子命题</li>  <li>原子命题</li>  <li>逻辑联结</li>  <li>合取联结</li>  <li>析取联结</li>  <li>否定联结</li>  <li>命题表达式</li>  <li>真值表</li>  <li>逻辑变量</li>  <li>永真命题</li>  <li>永假命题</li>  <li>代入原理</li>  <li>逻辑等价</li>  <li>命题代数</li>  <li>条件语句</li>  <li>双条件语句</li>  <li>论证</li>  <li>逻辑论证</li>  <li>有效论证</li>  <li>谬误</li>  <li>陈述</li>  <li>三段论</li>  <li>逻辑蕴含</li>  <li>命题函数</li>  <li>量词</li>  <li>全称量词</li>  <li>存在量词</li></ul><h3 id="exercise-tex-1"><a href="#exercise-tex-1" class="headerlink" title="exercise.tex"></a>exercise.tex</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">  \usepackage&#123;amsmath&#125;</span><br><span class="line">  \usepackage&#123;amssymb&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item Verify that the proposition $p\lor \lnot (p\land q)$ is a tautology.</span><br><span class="line"></span><br><span class="line">  \item Show that the proposition $\lnot(p \land q)$ and $\lnot p\lor \lnot q$ are logically equivalent.</span><br><span class="line"></span><br><span class="line">  \item Prove that $\lnot (p \land q)\lor (\lnot q \land q)\equiv \lnot p$.</span><br><span class="line"></span><br><span class="line">  \item Consider the conditional proposition $p\to q$. The simple propositions $q\to p, \lnot p \to \lnot q$</span><br><span class="line">  and $\lnot q \to \lnot p$ are called, respectively, the \textsl&#123;converse&#125;, \textsf&#123;inverse&#125;,</span><br><span class="line">  and \textsl&#123;contrapositive&#125; of the conditional $p \to q$. Which of these are logically equivalent to $p \to q$?</span><br><span class="line"></span><br><span class="line">  \item Show that the following argument is a fallacy: $p \to q$, $\lnot p \vdash \lnot q$.</span><br><span class="line"></span><br><span class="line">  \item Determine the validity of the following argument: $p \to q, \lnot p \vdash \lnot q$.</span><br><span class="line"></span><br><span class="line">  \item Prove the following argument is valid: $p \to \lnot q, r \to q, r\vdash \lnot p$.</span><br><span class="line"></span><br><span class="line">  \item Negate each of the following statements:</span><br><span class="line"></span><br><span class="line">  i. $\exists x\ \forall y, p(x, y)$;</span><br><span class="line">  ii. $\forall x\ \forall y, p(x, y)$;</span><br><span class="line">  iii. $\exists x\ \exists y\ \exists z, p(x, y, z)$.</span><br><span class="line"></span><br><span class="line">  \item Find the truth tables for: i. $p\lor \lnot q$; ii. $\lnot p \land \lnot q$.</span><br><span class="line">  \item Verify that the proposition $(p\land q)\land \lnot (p \lor q)$ is a contradition.</span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>      </td>    </tr>  </table></figure><h1 id="向量与矩阵"><a href="#向量与矩阵" class="headerlink" title="向量与矩阵"></a>向量与矩阵</h1><h2 id="要点难点-1"><a href="#要点难点-1" class="headerlink" title="要点难点"></a>要点难点</h2><ul>  <li>    <p>矩阵初等行变换</p>  </li>  <li>    <p>高斯消去法</p>  </li>  <li>    <p>矩阵求解n元一次方程组的解</p>    <h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2>  </li></ul><p>向量 u 是指一列数，如 a_1, a_2, …, a_n，记作</p><p>$$<br>u = (a_1, a_2, a_3)<br>$$</p><p>数a_i称为 u 的 <em>分量</em> 或 表值。</p><p>如果所有的 a_i = 0，则称 u 为一个零向量。</p><p>两个向量 u 和 v，如果分量个数相同而且对应分量相等，则称为相等的，记作 u = v。</p><h3 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h3><p><strong>向量的和</strong> 考虑任意两个分量个数相同的向量 u 和 v，比如<br>$$<br>u = (a_1, a_2,  \ldots, a_n), v = (b1, b_2, \ldots, b_n)<br>$$<br>则向量u与v的和，记作 u +  v，是将u与v的对应分量相加而得到的向量，则：<br>$$<br>u + v = (a_1 + b_1, a_2 + b_2, \ldots, a_n +  b_n)<br>$$</p><p><em>向量的数乘</em> 将数 k 乘以 u 的每一个分量得到的向量，即：<br>$$<br>ku = (ka_1, ka_2, \ldots,  ka_n)<br>$$</p><p>扩展定义：<br>$$<br>-u = -1(u), u - v = u + (-v)<br>$$</p><p>其中，-u 称为向量 u 的负向量。</p><p><strong>向积</strong> 向量u与v的 <em>点积</em> 或 <em>向积</em> 定义为<br>$$<br>u \cdot v =  a_1 b_1 + a_2 b_2 + \ldots + a_n b_n<br>$$</p><p><strong>向量的范数/向量的长度</strong> 对于向量 u，<br>$$<br>| u | = \sqrt[2]{u \cdot u} =  \sqrt{ a_1^2 + a_2^2 + \ldots + a_n^2 }<br>$$</p><h3 id="列向量、行向量"><a href="#列向量、行向量" class="headerlink" title="列向量、行向量"></a>列向量、行向量</h3><p>写成竖直格式的向量称为列向量。<br>写成水平格式的向量称为行向量。</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>矩阵是一张矩形数表，通常记作：<br>$$<br>A = \begin{bmatrix}<br>a_{11} &amp; a_{12} &amp;  \cdots &amp; a_{1n} \<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}  \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>a_{m1} &amp; a_{m2}  &amp; \cdots &amp; a_{mn} \<br>\end{bmatrix}<br>$$</p><p>其中 m 个水平排列的数表称为矩阵A的行，而n个竖直排列的数表称为列。元素a_{ij}处于第i行和第j列，称为ij表值。<br>通常将矩阵简记为 A =  [a_{ij}]。</p><p>具有m个行和n个列的矩阵称为m乘以n矩阵，记作m\times n。数偶m和n称为矩阵的型。</p><p>两个矩阵A与B称为相等的，记作A = B，如果它们的行数和解数分别相等（同型）且对应元素相等。</p><p>两个m\times n矩阵相等等价于mn个等式组，其中每一等式都对应着一个元素偶。</p><p><strong>行向量</strong> 只有一行的矩阵称为行矩阵或行向量，<br><strong>列向量</strong>  只有一列的矩阵称为列矩阵或列向量。<br><strong>零矩阵</strong> 表值全部为零的矩阵称为零矩阵，记作 0。</p><h3 id="矩阵的加法和数乘"><a href="#矩阵的加法和数乘" class="headerlink" title="矩阵的加法和数乘"></a>矩阵的加法和数乘</h3><p>设 A = [a_{ij}] 与 B = [b_{ij}] 为两个m \times n矩阵，即同型矩阵。</p><p>A与B的<strong>和</strong>记作 A + B，即：</p><p>$$<br>A + B = \begin{bmatrix}<br>a_{11} + b_{11} &amp; a_{12} + b_{12} &amp;  \cdots &amp; a_{1n} + b_{1n} \<br>a_{21} + b_{21} &amp; a_{22} + b_{22} &amp;  \cdots &amp; a_{2n} + b_{2n} \<br>\vdots &amp; \vdots &amp; \ddots &amp;  \vdots \<br>a_{m1} + b_{m1} &amp; a_{m2} + b_{m2} &amp; \cdots &amp; a_{mn} +  b_{mn} \<br>\end{bmatrix}<br>$$</p><p>数 k 与矩阵A 的 <em>积</em>，记作 k \cdot A 或 简记 kA，是将数k 乘以矩阵A的每一个元素得到的矩阵，即：</p><p>$$<br>kA = \begin{bmatrix}<br>ka_{11} &amp; ka_{12} &amp; \cdots &amp;  ka_{1n} \<br>ka_{21} &amp; ka_{22} &amp; \cdots &amp; ka_{2n} \<br>\vdots  &amp; \vdots &amp; \ddots &amp; \vdots \<br>ka_{m1} &amp; ka_{12} &amp; \cdots  &amp; ka_{mn} \<br>\end{bmatrix}<br>$$</p><p>同样可以定义：</p><p>-A = (-1)A, A - B = A + (-B)</p><p><strong>负矩阵</strong> 矩阵-A称为矩阵A的负矩阵。</p><p>不同型的矩阵的加法无法定义。</p><p><strong>定理5.1</strong> 设A，B，C为同型矩阵，k，k’为数，则：</p><ol>  <li>(A + B) + C = A + (B + C)</li>  <li>A + 0 = 0 + A</li>  <li>A + (-A) = A - A = 0</li>  <li>A + B = B + A</li>  <li>k(A + B) = kA + kB</li>  <li>(k + k’) A = kA + k’A</li>  <li>(kk’)A = k(k’A)</li>  <li>1A = A</li></ol><h2 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h2><p>矩阵A与B的乘积，记作AB。</p><p>元素个数相同的行矩阵 A = [a_i] 与 列矩阵 B = [b_i]的积 AB 定义为：</p><p>$$<br>AB = \begin{bmatrix}<br>a_1, a_2, a_3, \cdots,  a_n<br>\end{bmatrix}<br>\begin{bmatrix}<br>b_1 \<br>b_2 \<br>\vdots  \<br>b_n<br>\end{bmatrix}<br>= a_1b_1 + a_2b_2 + \cdots + a_nb_n<br>=  \sum_{k=1}^{n} a_kb_k<br>$$</p><h3 id="矩阵的乘法-1"><a href="#矩阵的乘法-1" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h3><p>设 A = [a_{ik}] 与 B = [b_{kj}]为矩阵，满足 A 的列数等于 B 的行数。<br>即 A 为 m \time p矩阵，而 B 为  p \times n 矩阵，则 A 与 B的乘积为一个 m \times n 矩阵，<br>其第ij元素为 A 的第 i 行乘以 B 的第 j 列的结果。</p><p>其中</p><p>$$<br>c_{ij}<br>= a_{i1} b_{1j} + a_{i2} b_{2j} + … + a_{ip} b_{pj}<br>=  \sum_{k=1}^{p} a_{ik}b_{kj}<br>$$</p><p><strong>定理 5.2</strong> 设 A，B，C为矩阵，并设以下乘法和加法均有定义。</p><ol>  <li>(AB)C = A(BC) (结合律)</li>  <li>A(B + C) = AB + AC (左分配律)</li>  <li>(B + C)A = BA + CA (右分配律)</li>  <li>k(AB) = (kA)B = A(kB) (k为数)</li>  <li>0A = 0, B0 = 0（0为零矩阵）</li></ol><h3 id="矩阵的乘法与线性方程组"><a href="#矩阵的乘法与线性方程组" class="headerlink" title="矩阵的乘法与线性方程组"></a>矩阵的乘法与线性方程组</h3><p>任意一个线性方程组 S 等价于一个矩阵方程：</p><p>AX = B</p><p>其中，A 为方程组的系数构成的矩阵，X 为未知数构成的列向量，而B为常数项构成的列向量。</p><p>如线性方程组<br>$$<br>x + 2y - 3z = 4,<br>5x - 6y + 8z =  9<br>$$<br>等价于<br>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp; -3 \<br>5 &amp; -6  &amp; 8 \<br>\end{bmatrix}</p><p>\begin{bmatrix}<br>x \<br>y \<br>z \<br>\end{bmatrix}</p><p>=</p><p>\begin{bmatrix}<br>4 \<br>9 \<br>\end{bmatrix}</p><p>$$</p><p>即方程组S的任一组解都是矩阵方程AX = B的解；反之亦然。</p><p>此时，称矩阵为线性方程组的<strong>增广矩阵</strong>。</p><h2 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h2><p>矩阵A的转置矩阵记作A^T，是将A的行依次写作列得到的矩阵。</p><p>如：<br>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6  \<br>\end{bmatrix}<br>=  \begin{bmatrix}<br>1 &amp; 4 \<br>2 &amp; 5 \<br>3 &amp; 6  \<br>\end{bmatrix}<br>$$</p><p><strong>定理5.3</strong> 设A，B为矩阵，k为值数，并设下列加法和乘法均为可行。</p><ol>  <li>(A + B)^T = A^T + B^T</li>  <li>(kA)^T = kA^T</li>  <li>(AB)^T = B^T A^T</li>  <li>(A^T)^T = A</li></ol><p>(注意 3.， 矩阵乘积的转置等于转置矩阵的乘积，但是乘积的次序要逆转)</p><h2 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h2><p>行数和列数相等的矩阵称为<strong>方阵</strong>。</p><p>具有n行n列的方阵称为n阶方阵，也叫做n方阵。</p><p>n阶方阵 A = [a_{ij}]的<strong>主对角线</strong> 或 简称 <strong>对角线</strong>由元素 a_{11},  a_{22}, …, a_{nn}构成。</p><p>n阶单位阵记作 I_n，或简记为I，是主对角线元素均为1，其余元素均为 0 的方阵。</p><p>特别地，对于任意方阵A，有 AI = IA = A。</p><h3 id="方阵的代数运算"><a href="#方阵的代数运算" class="headerlink" title="方阵的代数运算"></a>方阵的代数运算</h3><p>对别地，对于任意多项式<br>$$<br>f(x) = a_0 + a_1 x + a_2 x^2 + \cdots + a_n  x^n<br>$$<br>其中a_i为数，我们定义f(A)为下列矩阵<br>$$<br>f(A) = a_0I + a_1A + a_2A^2 +  \cdots + a_n A^n<br>$$</p><p>当f(A)为零矩阵时，A称为多项式f(x)的一个<em>零点</em>或<em>根</em>。</p><h2 id="可逆（非奇异矩阵）和逆矩阵"><a href="#可逆（非奇异矩阵）和逆矩阵" class="headerlink" title="可逆（非奇异矩阵）和逆矩阵"></a>可逆（非奇异矩阵）和逆矩阵</h2><p>方阵A称为可逆的（或非奇异的），如果存在矩阵B满足：</p><p>$$<br>AB = BA = I<br>$$</p><p>这样的矩阵必定是唯一存在的，且称为A的逆矩阵，记作A^-1。</p><p>显然，B是A的逆矩阵当且仅当A是B的逆矩阵。</p><p>(定理：矩阵的逆矩阵是唯一的。)</p><h3 id="行列式的一般定义"><a href="#行列式的一般定义" class="headerlink" title="行列式的一般定义"></a>行列式的一般定义</h3><p>n阶行列式的一般定义如下：</p><p>$$<br>det(A) = \sum sgn(\sigma) a_{1j_1} a_{1j_2} \cdots a_{1j_n}<br>$$</p><p>其中求和对 {1, 2, …, n} 的所有可能排列 \sigma = {j_1, j_2, …, j_n}  进行。<br>这里的sgn(\sigma)等于 + 1 或 -1，分别对应于将\sigma变成自然次序时所需作的对换次数为偶数或奇数的情形。</p><p>定理5.4 设A、B为任意的n阶方阵，则<br>$$<br>det(AB) = det(AB) \times det(B)<br>$$</p><p>定理5.5 方阵A可逆当且仅当其行列式非零。</p><h2 id="初等行变换，高斯消去法"><a href="#初等行变换，高斯消去法" class="headerlink" title="初等行变换，高斯消去法"></a>初等行变换，高斯消去法</h2><p><strong>初等行变换</strong></p><p>关于矩阵A的下列运算称为<strong>初等行变换</strong>：</p><ul>  <li>    <p>[E_1] 交换两行R_i与R_j的位置，记作“交换R_i与R_j”</p>  </li>  <li>    <p>[E_2] 以非零数k乘以R_i行的每个元素，记作“以k乘R_i”。</p>  </li>  <li>    <p>[E_3] 将R_i行的位数加到R_j行上，即以 kR_i + R_j 替换 R_j，记作“R_j加上kR_i”</p>    <p>为了避免步骤零散，将[E_2]和[E_3]合并为一步，即：</p>  </li>  <li>    <p>[E] 将R_i行的倍数加到R_j行的非零倍上，换句话说，kR_i + k’R_j 替换 R_j，其中k’ \neq 0</p>    <p>(注意：对于行变换[E_3]和[E]，实际上只有R_j产生了变化)</p>  </li></ul><p>记号： 矩阵A与B称为<strong>行等阶</strong>的，记作A~B，如果矩阵B可以由矩阵A通过初等行变换得到。</p><p><strong>阶梯矩阵</strong></p><p>矩阵称为<strong>阶梯矩阵</strong>或称为具有<strong>阶梯形</strong>，如果满足下列两个条件：</p><ol>  <li>所有的零行（如果存在）都掉于矩阵的底部</li>  <li>每个非零元素都排于该行首位非零元的右边。</li></ol><p>矩阵称为具有行标准形，如果还满足下列性质：</p><ol start="3">  <li>每个首位非零元素均为1</li>  <li>每个首位非零元素为其所在列的唯一非零元</li></ol><p>零矩阵 0 为行标准形的一个特例。n阶单位库I_n 是行标准形的另一个特例。</p><p>方阵A称为三角阵，如果其主对角线元素a_{11}, a_{22}, …,  a_{nn}皆为其首位非零元。<br>于是三角方阵为阶梯矩阵的特例。<br>单位阵为既是三角库又是行标准型的唯一特例。</p><h3 id="矩阵格式的高斯消去法"><a href="#矩阵格式的高斯消去法" class="headerlink" title="矩阵格式的高斯消去法"></a>矩阵格式的高斯消去法</h3><p>算法5.10A（向前消元） 输入任意矩阵 A = [a_{ij}]。</p><ul>  <li>第一步 求出第一个具有非零元的列，若这样的列不存在，则退出。（此时为零矩阵），否则，设j_1表示该列的列号；<br>a.    整理矩阵，使得a_{1j_1} \neq 0，即，若有必要，则交换行的次序，使得非零元出现于 j_1 列的第一行；<br>b.    以a_{1j_1}为主元，将a_{1j_1}以下的元素变为零。即，对于 i &gt; 1<ol>      <li>置 m = - a_{ij_1} / a_{1j_1}</li>      <li>将 mR_1 加到 R_i 上<br>[即以 -(a_{ij_1} / a_{1j_1})R_1 + R_i 替换 R_i]</li>    </ol>  </li>  <li>第二步 对于除第一行外的子矩阵，重复第一步。这里，设 j_2 表示在子矩阵中具有非零元的第一个列。因此在第二步结束时，<br>有 a_{2j_2}    \neq 0.</li>  <li>第三步 到 第r+1步，继续执行上述步骤，直到所得子矩阵没有非零元。</li></ul><p>算法5.10B（向后消元）输入矩阵 A = [a_{ij}] 为具有主元a_{1j_1}，a_{2j_2}，…，a_{rj_r} 的阶梯阵，</p><ul>  <li>第一步<br>a. 以 1 / a_{rj_r} 乘以最后一个非零行R，使得该主元为1<br>b. 从a_{rj_r} = 1    出发将该的主元以上元素变为零，即，对于 i = r - 1， r -2，…，1:<ol>      <li>置 m = - a_{ir_i}</li>      <li>将 mR_r 加到 R_i 上（换言之，即利用初等行变换“将 - a_{ir_i}R_r 加到 R_i 上”）</li>    </ol>  </li>  <li>第二步到第r - 1步 对于 R_{r-1}，R_{r-2}，…，R_2，重复第一步</li>  <li>第r步 以 1/a_{1j_1}乘以R_1</li></ul><p><strong>定理5.6</strong> 任意矩阵A行等价于唯一一个行标准形矩阵（称为A的行标准形）。</p><h3 id="线性方程组的矩阵解法"><a href="#线性方程组的矩阵解法" class="headerlink" title="线性方程组的矩阵解法"></a>线性方程组的矩阵解法</h3><p>考虑线性方程组S，或等价地，考虑以 M = [A,B]为增广矩阵的矩阵方程 AX = B，我们可以以对矩阵M利用高斯消去法列出线性方程组。</p><p>A步（化简） 将增广矩阵M化为阶梯矩阵。如果有一行具有形式(0,0, …, 0, b)，b \neq 0，则停止。该方程组无解。</p><p>B步（回代） 进一步将增广矩阵 M 化为其行标准形。</p><p>可以从M的标准形立即得到方程组的唯一解，或者当解不唯一时，得到解的自由变量表达式。</p><h3 id="n-times-n矩阵的逆阵"><a href="#n-times-n矩阵的逆阵" class="headerlink" title="n\times n矩阵的逆阵"></a>n\times  n矩阵的逆阵</h3><p>算法5.10C 求任意n\times n矩阵A的逆阵</p><p>第一步 构造一个 n \times 2n 矩阵 M = [A,I]，即M的左边一半为A而右边一半为单位阵I</p><p>第二步 利用初等行变换将M化为阶梯阵，如果在运算过程中在M的A部分出现零行，则停止（此时A没有逆阵）。<br>否则，A的部分将变为三角阵。</p><p>第三步 继续利用初等行变换将M化为标准形 M~[I,B]，此时M的左边A的部分已经变为I。</p><p>第四步 置 A^{-1} = B，其中B即为M的行标准形中的右边一半。</p><h2 id="布尔（零-幺）矩阵"><a href="#布尔（零-幺）矩阵" class="headerlink" title="布尔（零-幺）矩阵"></a>布尔（零-幺）矩阵</h2><p>二进制数或二进制位为符号0和1，有布尔运算规则。</p><p>设矩阵 A = [a_{ij}] 的元素为位元 0 或 1，则A称为布尔矩阵。两个布尔矩阵的布尔积除遵从通常矩阵乘法规则外，在数的运算中则采用布尔运算。</p><h1 id="附录-4"><a href="#附录-4" class="headerlink" title="附录"></a>附录</h1><ul>  <li>向量 vector<ul>      <li>纯量 scalar</li>      <li>分量 component</li>      <li>表值 entry</li>    </ul>  </li>  <li>向量运算<ul>      <li>向量的和 sum of vectors</li>      <li>向量数乘 scalar product</li>      <li>向量点乘 dot product</li>      <li>向量内积 inner product</li>      <li>向量范数 norm</li>      <li>向量长度 length</li>    </ul>  </li>  <li>零向量 zero vector</li>  <li>负向量 negative of vector</li>  <li>行向量 row vector</li>  <li>列向量 column vector</li>  <li>矩阵 matrix<ul>      <li>矩阵的行数 rows of vector</li>      <li>矩阵的列数 columns of vector</li>      <li>第i行第j列的元素 the ij entry</li>      <li>m * n 矩阵 m by n matrix</li>      <li>行矩阵 row vector, row matrix</li>      <li>列矩阵 column vector, column matrix</li>      <li>零矩阵 zero matrix</li>    </ul>  </li>  <li>矩阵运算<ul>      <li>矩阵加法 matrix addition</li>      <li>矩阵的和 sum of matrices</li>      <li>矩阵数乘 scalar multiplication</li>      <li>负矩阵 negative of matrix</li>      <li>矩阵乘法 matrix multiplication</li>      <li>矩阵的积 product of matrices</li>      <li>转置矩阵 transpose of matrix</li>    </ul>  </li>  <li>增广矩阵</li>  <li>方阵 square matrix<ul>      <li>n阶方阵</li>    </ul>  </li>  <li>多项式的零点</li>  <li>可逆矩阵 invertible matrix<ul>      <li>非奇异矩阵 nonsingular matrix</li>      <li>逆矩阵 inverse</li>    </ul>  </li>  <li>行列式 determinant</li>  <li>行列式的一般定义 general definition of determinants</li>  <li>初等行变换 elementary row operations</li>  <li>高斯消去法 Gaussian elimination</li>  <li>行等阶 echelon matrix</li>  <li>布尔矩阵 boolean matrix<ul>      <li>0-1矩阵 zero-one matrix</li>    </ul>  </li></ul><h1 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h1><h2 id="基本计数原理"><a href="#基本计数原理" class="headerlink" title="基本计数原理"></a>基本计数原理</h2><p><strong>加法原理</strong> 假设事件E能以m种方式出现，事件F能以n种方式出现，且两种事件不能同时出现，那么 E或F  能以m+n种方式出现。</p><p>推广到一般情况，假设事件E1 能以n1种方式出现，事件E2 能以n2种方式出现，……，且任意两个事件不能同时出现，<br>那么事件 E1,E2,… 之一  以 n1 + n2 + … 种方式出现。</p><p><strong>乘法原理</strong> 假设事件E能以m种方式发生，独立于事件E之外的事件F能以n种方式发生，那么 E和F的组合有以mn种方式发生。</p><p>推广到一般情况，互相独立的事件E1，E2 … 分别有 n1，n2，…种方式发生，那么所有事件依照指定顺序 有 n1 n2 n3 …种方式发生。</p><h3 id="集合论的解释"><a href="#集合论的解释" class="headerlink" title="集合论的解释"></a>集合论的解释</h3><ol>  <li><strong>加法原理</strong> 若 A 与 B 不相交，则<br>$$<br>\textrm{card}(A \cup B) =    \textrm{card}(A) + \textrm{card}(B)<br>$$</li></ol><h2 id="阶乘符号"><a href="#阶乘符号" class="headerlink" title="阶乘符号"></a>阶乘符号</h2><p>从 1 到 n（包括 1 和 n）的正整数的积记作 n! (读作n的阶乘)；即：<br>$$<br>n! = 1 * 2 * 3 * (n - 2)(n  - 1) n<br>$$</p><p>也可以定义为：</p><pre><code>1. 1!= 12. n! = n * (n - 1)!3. 0! = 1</code></pre><h2 id="二项式符号"><a href="#二项式符号" class="headerlink" title="二项式符号"></a>二项式符号</h2><p>设 r 和 n 为正整数，r &lt;= n，符号(n,r)（读作 nCr） 定义为：</p><p>$$<br>\binom{n}{r} = \frac{n (n - 1) (n - 2)\cdots (n - r + 1)}{1 \cdot 2  \cdot \cdots (r - 1) \cdot r}<br>$$</p><p>即：</p><p>$$<br>\binom{n}{r}= \frac{n!}{r! (n - r)!}<br>$$</p><p>由于 n - (n - r) = r，因此有：</p><p>$$<br>\binom{n}{n - r} = \binom{n}{r}<br>$$</p><p>亦即，<br>$$<br>a + b = n \implies \binom{n}{a} = \binom{n}{b}<br>$$</p><h3 id="二项式系数与Pascal三角形"><a href="#二项式系数与Pascal三角形" class="headerlink" title="二项式系数与Pascal三角形"></a>二项式系数与Pascal三角形</h3><p>$\binom{n}{r}$ 称为<strong>二项式系数</strong>，因为它们作为 (a + b)^n 的展开式的系数出现。特别地，可以证明：</p><p>$$<br>(a + b) ^n = \sum_{k = 0}^{n} \binom{n}{k} a^{n - k}b^k<br>$$</p><p>a + b 的相继幂的系数可以排成三角形的数表，称为Pascal三角形。Pascal形角形中的数有如下交互性质：</p><pre><code>1. 每一行的每一个数与最后一个数都是 12. 数表中的每个其他数可通过相加位于其上方的两数得到。</code></pre><p><strong>定理6.1</strong></p><p>$$<br>\binom{n+1}{r} = \binom{n}{r - 1} + \binom{n}{r}<br>$$</p><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p>n个对象以给定次序的任一安排称为这些对象（同时取出全部）的排列。n个对象中的任r个对象以给定序的任一安排称为 r-排列，或称为 n个对象的排列。</p><p>n个对象取r个的排列数记为：<br>$$<br>p(n, r), nPr, P_{nr}, P_r^n, (n)_r  $$</p><p><strong>P(n, r)公式的推导</strong></p><p><strong>定理6.2</strong></p><p>$$<br>P(n, r) = \frac{n!}{(n - r)!}<br>$$</p><p><strong>推论6.3</strong></p><p>n个对象（同时全取）的排列数为n!</p><h3 id="可重排列"><a href="#可重排列" class="headerlink" title="可重排列"></a>可重排列</h3><p>通常我们想知道可重集的排列数，可重集是指有某些元素相同的集合，用</p><p>$$<br>P(n; n_1, n_2,\cdots, n_r)<br>$$</p><p>表示n个对象的排列数。其中n_1个对象是相同的，n_2个对象是相同的，…，n_r个对象是相同的。</p><p><strong>定理6.4</strong></p><p>$$<br>P(n; n_1, n_2, \cdots, n_r) = \frac{n!}{n_1! n_2! \cdots n_r!}<br>$$</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>设有含n个对象的集合，n个对象取r个对象的组合是r个对象的不计次序的任一选取。<br>换句话说，n个对象的任一个 r-元素子集是一个r-组合。</p><p>n个对象取r个的组合数记为C(n, r)。也可以记为：</p><p>$$<br>nC_r, C_{nr}, C_r^n<br>$$</p><p><strong>C(n, r)公式</strong></p><p>由于 n 个对象取r个的任一组合确定了该组合中的对象 r! 个排列，因此有：</p><p>$$<br>P(n, r) = r!C(n, r)<br>$$</p><p><strong>定理6.5</strong></p><p>$$<br>C(n, r) = \frac{P(n, r)}{r!} = \frac{n!}{r! (n - r)!}<br>$$</p><p>因此：<br>$$<br>C(n, r) = \binom{n}{r}<br>$$</p><h2 id="鸽笼原理"><a href="#鸽笼原理" class="headerlink" title="鸽笼原理"></a>鸽笼原理</h2><p>若 n 个鸽笼被 n + 1 只或更多只鸽子占据，则至少有一个鸽笼被超过一只鸽子占据。</p><p><strong>推广的鸽笼原理</strong></p><p>若n个鸽笼被 kn + 1 只或更多只鸽子占据，k为正整数，则至少有一个鸽笼被 k+1 只或更多只鸽子占据。</p><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>设A，B为两个有限集，则</p><p>$$<br>\text{card}(A\cup B) = \text{card}(A) + \text{card}(B) - \text{card}(A  \cap B)<br>$$</p><p><strong>定理 6.6</strong> 对任意有限集A，B，C，有</p><p>$$<br>n(A\cup B \cup C) = n(A) + n(B) + n(C)</p><ul>  <li>n(A\cap B) - n(A\cap C) - n(B\cap C)</li></ul><ul>  <li>n(A\cap B \cap C)<br>$$</li></ul><p><strong>定理6.7</strong></p><p>假设A1, A2, …, Am为有限集，今Sk表示给定m个集合的所有可能的 k 个交的基数</p><p>$$<br>\text{n}(A_{i_1} \cap A_{i_2} \cap \cdots \cap A_{i_k})<br>$$</p><p>的和，则</p><p>$$<br>n(A_1 \cup A_2 \cup \cdots \cup A_m) = s_1 - s_2 + s_3 + (-1)^{m - 1}  s_m<br>$$</p><h2 id="有序划分与无序划分"><a href="#有序划分与无序划分" class="headerlink" title="有序划分与无序划分"></a>有序划分与无序划分</h2><p><strong>有序划分</strong></p><p><strong>定理6.8</strong> 设A有n个元素，n_1, n_2, …, n_r 是正整数，它们的和为n，即 n_1 + n_2 + … +  n_r = n，<br>则 A 的形如[A_1, A_2, …, A_r]的有限划分有：</p><p>$$<br>\frac{n!}{n_1! n_2! \cdots n_r!}<br>$$</p><p>个，其中 A_1 含有 n_1 个元素，A_2 含有 n_2 个元素，…,A_r 含有 n_r 个元素。</p><p><strong>无序划分</strong></p><p>在有限划分的基础上，除以组数的全排列数（即 r! ）。</p><h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h2 id="样本空间与事件"><a href="#样本空间与事件" class="headerlink" title="样本空间与事件"></a>样本空间与事件</h2><p><strong>样本空间</strong> 一个实验的所有可能的结果的集合S；</p><p><strong>样本点</strong> 特定的实验结果，即样本空间S的元素；</p><p>事件A是结果的集合，换句话说，事件A为样本空间的子集。</p><p><strong>基本事件</strong> 由单个样本点 a \in S构成的集合{a}。</p><p><strong>不可能事件</strong> 空集\emptyset；又称 <strong>零事件</strong></p><h2 id="有限概率空间"><a href="#有限概率空间" class="headerlink" title="有限概率空间"></a>有限概率空间</h2><p><strong>有限概率空间</strong> 设S为有限样本空间，S = {a_1, a_2, …,  a_n}，若对S的每个点a_i，指定一个字数p_i，<br>称为a_i的概率，且满足以下性质：</p><pre><code>1. 每个 p_i 非负，即 p_i &gt;= 0;2. 所有p_i 的和为1， 即 p_1 + p_2 + ... + p_n = 1;</code></pre><p>则称为<strong>有限概率空间</strong>，或称为<strong>概率模型</strong>。</p><p>事件A的概率记为P(A)，定义为A中点的概率之和。</p><p>单元素集 {a_i} 称为基本事件，为方便，用P(a_i)代替P({a_i})。</p><p><strong>等概率空间</strong> 每个样本点有相同的概率的有限概率空间称为等概率空间。</p><p>$$<br>\forall a_i, a_j \in S \to p_i = p_j<br>$$</p><p>特别地，若S有n个样本点，则每个点的概率为 1/n。</p><p>$$<br>P(A) = \frac{A中元素个数}{S中元素个数} = \frac{n(A)}{n(S)}<br>$$</p><p>或</p><p>$$<br>P(A) = \frac{有利于A的结果数}{全部可能结果数}<br>$$</p><p><strong>随机</strong> 术语“随机”仅限用于等概率空间。</p><h3 id="有限概率空间的定理"><a href="#有限概率空间的定理" class="headerlink" title="有限概率空间的定理"></a>有限概率空间的定理</h3><p><strong>定理7.1</strong> 定义在有限概率空间S所有事件点上的概率函数P，有如下性质：</p><ol>  <li>对每个事件A， 0 &lt;= P(A) &lt;= 1</li>  <li>P(S) = 1</li>  <li>若事件A、B相互排斥，则<br>$$<br>P(A\cup B) = P(A) + P(B)<br>$$</li></ol><p><strong>定理7.2</strong> 设A为任一事件，则 P(A^c) = 1 - P(A)</p><p><strong>定理7.3</strong> 设\emptyset为空集，A、B为任意两个事件，则</p><pre><code>1. P(\emptyset) = 02. P(A\B) = P(A) - P(A\cap B)3. A \subseteq B \implies P(A) &lt;= P(B)</code></pre><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>设E为概率空间S的一个事件，P(E) &gt; 0，在 E  已发生的条件下，事件A发生的概率。<br>即在E发生的条件下，A的<strong>条件概率</strong>，记为P(A|E)，定义如下：</p><p>$$<br>P(A|E) = \frac{P(A\cap E)}{P(E)}<br>$$</p><p>设S为等概率空间，n(A)表示事件A的元素个数，则</p><p>P(A\cap E) = \frac{n(A \cap E)}{n(S)}</p><p>P(E) = \frac{n(E)}{n(S)}</p><p>因此</p><p>P(A|E) = \frac{P(A \cap E)}{P(E)} = \frac{n(A\cap E)}{n(E)}</p><p><strong>定理7.5</strong> 设S为等概率空间，A，E为两个事件，则<br>$$<br>P(A | E) = \frac{n(A\cap  E)}{n(E)}<br>$$</p><h3 id="条件概率的乘法定理"><a href="#条件概率的乘法定理" class="headerlink" title="条件概率的乘法定理"></a>条件概率的乘法定理</h3><p><strong>定理7.6</strong> （条件概率的乘法定理） P(A \cap B) = P(A)P(B|A)</p><p>推广到多个事件 A1， A2， … Am，即：</p><p>$$<br>P(A_1 \cap A_2 \cap \cdots \cap A_m)<br>= P(A_1) \cdot P(A_2 \mid A_1)  \cdots P(A_m \mid A_1 \cap A_2 \cap \cdots \cap A_{m - 1})<br>$$</p><h2 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h2><p>  设A，B为概率空间S的两个事件，若一个事件的发生并不影响另一个事件的发生，则称它们是<strong>独立</strong>的。<br>即：若P(B)与P(B|A)相同，则B与A独立。<br>根据乘法定理，可得：</p><p>$$<br>P(A\cap B) = P(A) P(B)<br>$$</p><p><strong>定义</strong> 若P(A\cap B) = P(A) P(B)，则称事件A与B为独立的，否则称为相关的。</p><p>独立性是一个对称关系，即：</p><p>p(A\cap B) = P(A) P(B) \implies P(B|A) = P(B) \land P(A|B) = P(A)</p><h2 id="独立重复试验，二项分布"><a href="#独立重复试验，二项分布" class="headerlink" title="独立重复试验，二项分布"></a>独立重复试验，二项分布</h2><p>定义 设S为有限概率空间，称S的有限n元组构成的概率空间Sn为n个独立重复试验的空间，且n元组的概率定义为其每个分量的概率的乘积：</p><p>$$<br>P((s_1, s_2, \cdots, s_n)) = P(s_1)P(s_2)\cdots P(s_n)<br>$$</p><p><strong>两个结果的重复试验，Bernouli试验</strong></p><p>  考察只有两个结果的试验，这样的独立的重复试验称为Bernouli试验。<br>独立试验是指任何试验的结果不依赖于前一结果，我们称一个结果为<strong>成功</strong>，另一个结果为<strong>失败</strong>。</p><p>设p表示Bernouli试验中成功的概率，失败的概率为 q = 1 - p。</p><p>二项试验由一组Bernouli试验构成，符号B(n, p) 表示n个试验，且成功的概率为p的二项试验。</p><p><strong>定理7.7</strong> 在二项试验B(n, p)中，恰有k次成功的概率为：</p><p>$$<br>p(k) = P(k个成功) = \binom{n}{k} p^k q^{n - k}<br>$$</p><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p>随机变量 设S为一个实验的样本空间，随机变量X为一个法则，它对样本空间S的每个缠指定一个数值。</p><p>用R_x表示由随机变量X指定的数的集合，也称R_x为范围空间。</p><h3 id="随机变量的概率分布"><a href="#随机变量的概率分布" class="headerlink" title="随机变量的概率分布"></a>随机变量的概率分布</h3><p>设R_x = {x_1, x_2, …, x_i} 为定义在有限样本空间S上的随机变量X的范围空间，则X诱导出范围空间R_x的概率指派：</p><p>p_i = P(x_i) = P(X = x_i) = S 中像为x_i的点的概率之和。</p><p>有限偶(x_1, p_i)，…，(x_i, p_i)的集合，常用一张出表表示：</p><table>  <thead>    <tr>      <th>x1</th>      <th>x2</th>      <th>…</th>      <th>x_i</th>    </tr>  </thead>  <tbody>    <tr>      <td>p1</td>      <td>p2</td>      <td>…</td>      <td>p_i</td>    </tr>  </tbody></table><p>称为随机变量X的分布。</p><p>定理7.8 设S为概率空间，X为S上的随机变量，具有范围空间R_x = {x1, x2, …, xi}，则：<br>$$<br>p_i = P(x_i)  = \frac{S中像为x_i的点数}{S中的点数}<br>$$</p><h3 id="随机变量的期望"><a href="#随机变量的期望" class="headerlink" title="随机变量的期望"></a>随机变量的期望</h3><p>设X为随机变量，关于X的两个重要度量（参数）：X的均值，记为\mu 或 \mu_x 和 X 的标准差记为 \sigma 或 \sigma _x。</p><p>均值\mu也称为X的期望，记为E(X)。</p><p>$$<br>\mu = E(X) = x_1 p_1 + x_2 p_2 + \cdots + x_n p_n =  \sum_{x_i}{p_i}<br>$$</p><p><strong>随机变量的方差与标准差</strong></p><p>方差Var(X)与标准差\sigma：</p><p>$$<br>Var(X) = (x_1 - \mu)^2 p_1 + (x_2 - \mu)^2 p_2 + \cdots + (x_n - \mu)^2  p_n = \sum (x_i - \mu)^2 p_i<br>= E((X-\mu)^2)<br>$$</p><p>又：<br>$$<br>Var(X) = x_1^2 p_1 + x_2^2 p_2 + \cdots + x_n^2 p_n - \mu^2 =  \sum x_i^2 p_i - \mu^2 = E(X^2) - \mu^2<br>$$</p><h3 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h3><p>考虑二项试验B(n, p)，k次成功数X是一个随机变量，</p><p>定理7.9 考察二项分布B(n, p)，则：</p><pre><code>1. 期望值 E(X) = \mu = np2. 方差 Var(X) = \sigma^2 = npq3. 标准差 \sigma = \sqrt{npq}</code></pre><h1 id="附录-5"><a href="#附录-5" class="headerlink" title="附录"></a>附录</h1><h2 id="术语-4"><a href="#术语-4" class="headerlink" title="术语"></a>术语</h2><ul>  <li>样本空间 sample space</li>  <li>样本点 sample point</li>  <li>事件 event<br>(a set of sample point, or a subset of sampel space)</li>  <li>基本事件 elementary event<ul>      <li>不可能事件 impossible event</li>      <li>零事件 null vent</li>      <li>相互排斥 mutually exclusive</li>    </ul>  </li>  <li>有限概率空间 finite probability spaces</li>  <li>概率模型 probability model</li>  <li>概率 probability</li>  <li>等概率空间 equiprobable Spaces</li>  <li>随机 random</li></ul><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>难点：</p><ul>  <li>二部图</li>  <li>平面图</li>  <li>地图</li>  <li>支撑树</li>  <li>图着色</li>  <li>邻接结构的链表示</li>  <li>图算法（DFS与BFS）<ul>      <li>广度优先搜索</li>      <li>深度优先搜索</li>    </ul>  </li></ul><h2 id="链表与指针"><a href="#链表与指针" class="headerlink" title="链表与指针"></a>链表与指针</h2><p><strong>链表</strong> 数据元素的线性集。<br><strong>点</strong>  链表中的数据元素。其借助指针域给出线性序。<br>分为两个部分，一部分包含元素的信息，一部分包含后继点的地址信息。</p><p><strong>链域</strong> 点中包含链表中后继点的地址的部分，也叫<strong>后继指针域</strong>。</p><p><strong>空指针</strong> 指向无效地址的指针。通常用于指明链表的结尾。</p><h2 id="堆栈、队列、优先队列"><a href="#堆栈、队列、优先队列" class="headerlink" title="堆栈、队列、优先队列"></a>堆栈、队列、优先队列</h2><p><strong>堆栈</strong> 也称为后进先出（LIFO）系统，它是一个仅在表的称为顶的一端进行插入和删除的线性表。</p><p><strong>队列</strong> 也称为先进先出（FIFO）系统，它只能在表的称为前面的一端进行删除，而在称为后面的另一端进行插入。</p><p><strong>优先队列</strong> 新元素可以定期的插入，但是总是先删除当前具有最高优先级的元素的一个元素样。</p><h2 id="图与多重图"><a href="#图与多重图" class="headerlink" title="图与多重图"></a>图与多重图</h2><p>一个图G由两个对象构成：<br> 1. 集合V = V(G)，其元素称为G的<strong>顶点</strong>或<strong>点</strong>。  2. 集合E = E(G)，其元素为G的不同顶点的无序偶，称为G的边。</p><p>当强调G的两个部分时，用G(V,E)表示这样的图。</p><p><strong>相邻，端点</strong></p><p>若存在一个边 e = {u,  v}，则称顶点u和v为<strong>相邻</strong>的，此时u与v称为e的<strong>端点</strong>，而称e连接u和v，也称边e  <strong>关联于</strong> 它的端点u和v。</p><h3 id="多重图"><a href="#多重图" class="headerlink" title="多重图"></a>多重图</h3><p>重边：如果存在边e1 和 e2 连接相同的端点，则称为重边。</p><p>环：若边e的两个端点是同一顶点，则称e为环。</p><p>简单图：没有重边和环的图。</p><p>多重图：存在重边和环的图。</p><h2 id="顶点的度"><a href="#顶点的度" class="headerlink" title="顶点的度"></a>顶点的度</h2><p>图G中的顶点v的度 deg(v) 等于G中含有v的边的条数，即关联于v的边数。</p><p>由于计算G中顶点的度时，每条边被计数两次，于是有：</p><p><strong>定理8.1</strong> G中顶点的度之和等于G中边数的2倍。</p><p>此定理对于多重图也成立，但环对环的端点的度要算两次（即环当成是首未顶点相同的边）。</p><p><strong>奇点、偶点</strong></p><p>偶点：度是偶数的顶点。</p><p>奇点：度是奇数的顶点。</p><p>孤立点：度为0的顶点。</p><h3 id="有限图、平凡图"><a href="#有限图、平凡图" class="headerlink" title="有限图、平凡图"></a>有限图、平凡图</h3><p>有限图：若多重图的顶点数和边都是有限的，则称它为有限的。</p><p>平凡图：具有一顶点而没有边的图，称为平凡图。（即单点）</p><h2 id="子图，同构，同胚图"><a href="#子图，同构，同胚图" class="headerlink" title="子图，同构，同胚图"></a>子图，同构，同胚图</h2><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>考虑图G = G(V, E)，存在 H = H(V’, E’)，使得H的顶点和边分别包含于G的顶点和边，即:</p><p>$$<br>V’ \subseteq V \land E’ \subseteq E<br>$$</p><p>特别地：</p><pre><code>1. 若边集E&apos;包含了G中端点在H中的所有边，则称图H(V&apos;, E&apos;)为图G(V, E)的由顶点V&apos;导出的子图；2. 若v为G的一个顶点，则 G-v 记号表示 G 的从G中删去顶点v及G中含v的所有边所得到的子图。3. 若e为G的一条边，则 G-e 记号表示 从G中只删除边e所得到G的子图（顶点保留）。</code></pre><h3 id="同构图"><a href="#同构图" class="headerlink" title="同构图"></a>同构图</h3><p>对于图G(V, E)和 图G^*(V^*, E^*)，<br>如果存在一个一一对应 f: V \to V^* r使得{u,  v}为G的边当且仅当{f(u), f(v)}为G^*的边。</p><h3 id="同胚图"><a href="#同胚图" class="headerlink" title="同胚图"></a>同胚图</h3><p>若两个图是由相同的图或同构的图用另外的点剖分某个边得到一个新的图，则称为是同胚的。</p><h2 id="路、连通度"><a href="#路、连通度" class="headerlink" title="路、连通度"></a>路、连通度</h2><h3 id="路"><a href="#路" class="headerlink" title="路"></a>路</h3><p>多重图G的路是由形如：</p><p>$$$<br>v_0, e_1, v_1, e_2, v_2, …, e_{n-1}, v_{n-1}, e_n, v_n<br>$$$</p><p>的点边交替序列构成，其中每个边 e_i 含有顶点 v_{i-1} 和 v_i（它们位于序列中 e_i 的两旁）。</p><p><strong>路的长度</strong> 边数 n 称为这条路的长度。</p><p>也可以用点序列 (v_0, v_1, …, v_n) 表示路。<br>若 v_0 = v_n，则称这条路是<em>闭</em>的，否则称为 连接 v_0  到 v_n 的路。</p><p><strong>简单路</strong> 顶点都不相同的路<br><strong>迹</strong>  边互不相同的路称为迹<br><strong>圈</strong> 除了 v_0 = v_n 外，其余顶点互不相同的闭路。长度为k的圈称为 k-圈。</p><p><strong>定理8.2</strong> 存在从 顶点u 到 顶点v 的路 当且仅当 存在从 u 到 v 的简单路。</p><h3 id="连通度，连通分支"><a href="#连通度，连通分支" class="headerlink" title="连通度，连通分支"></a>连通度，连通分支</h3><p><strong>连通</strong> 如果图G的任意两点之间都存在一条路，则称为连通的。</p><p><strong>连通分支</strong> G的一个连通子图H称为G的连通分支。</p><p><strong>孤立点</strong> deg(G) = 0.孤立点本身构成一个连通分支。</p><h3 id="距离与直径"><a href="#距离与直径" class="headerlink" title="距离与直径"></a>距离与直径</h3><p><strong>距离</strong> 对于连通图G，G中顶点u与v之间的距离 d(u, v) 就是 u 与 v 之间最短路的长度。</p><p><strong>直径</strong> G为G中任两点之间距离的最大值。记为 diam(G)。</p><h3 id="割点与桥"><a href="#割点与桥" class="headerlink" title="割点与桥"></a>割点与桥</h3><p><strong>割点</strong> 设G为连通图，v 为 G 的顶点，如果 G-v 不连通，则称v为割点。<br>（G-v  为从G中删去v以及含有v的所有边得到的图）</p><p><strong>桥</strong> 设G为连通图，e 为 G 的边，如果G-e不连通，则称e为桥。<br>（G-e 为从G中删去边e所得到的图）</p><h2 id="Konigsberg桥，可旅行多重图"><a href="#Konigsberg桥，可旅行多重图" class="headerlink" title="Konigsberg桥，可旅行多重图"></a>Konigsberg桥，可旅行多重图</h2><p><strong>Euler迹</strong> 对于图G，<em>闭</em>且可旅行迹称为Euler迹。</p><p><strong>Euler图</strong> 如果G存在Euler迹，则称为Euler图。</p><p><strong>定理8.3 (Euler)</strong> 有限连通图是Euler图当且仅当其每个顶点的度数为偶数。</p><p><strong>推论8.4</strong> 两个奇点的有限连通图是可旅行的，可旅行迹可以从任一奇点开始，另一奇点结束。</p><h2 id="Hamilton图"><a href="#Hamilton图" class="headerlink" title="Hamilton图"></a>Hamilton图</h2><p>Hamilton回路 图G的一条经过每个顶点恰一次的闭路。</p><p>Hamilton图 存在Hamilton回路的图。</p><p>定理8.5 设G为n个顶点的连通图，若n &gt;= 3，且对G的每个顶点 v 有 deg(v) &gt;= n，则G为Hamilton图。</p><h2 id="标号图与赋权图"><a href="#标号图与赋权图" class="headerlink" title="标号图与赋权图"></a>标号图与赋权图</h2><p><strong>标号图</strong> 对于图G，如果它的边与/或顶点被指定一种或另一种数据，称则G为标号图。</p><p><strong>赋权图</strong>  如果标号图的每条边e都被指派一个称为e的<strong>杈</strong>或<strong>长度</strong>的非负数。</p><h2 id="完全图、正则图与二部图"><a href="#完全图、正则图与二部图" class="headerlink" title="完全图、正则图与二部图"></a>完全图、正则图与二部图</h2><p><strong>完全图</strong>  对于图G，如果G的每个顶点都与G中的每个其他顶点有边相连接，则图G称为完全图。<br>完全图必是连通的。n个顶点的完全图记为K_n。</p><p><strong>正则图</strong> 对于图G，如果G的每个顶点的度为k，则称图为k度正则的，或  k-正则的。<br>换句话说，如果每个顶点有相同的度，则图是正则的。</p><p>因为顶点的度之和为偶数，所以3-正则图必有偶数个顶点。（定理8.1）</p><p><strong>二部图</strong>  对于图G，如果它的顶点集V可以划分为两个子集M和N，使得G的每条边连接M的一个点到N的一个点，<br>完全二部图是指M的每个顶点连到N的每个顶点。这种图标记为K_{m,n}，其中m为M中的顶点数，n为N中的顶点数，<br>且为标准化，约定m  &lt;= n。</p><h2 id="树图"><a href="#树图" class="headerlink" title="树图"></a>树图</h2><p>对于图T，如果T是<em>连通</em>的，且没有<em>圈</em>，则称为树。</p><p><strong>退化树</strong> 没有边的单个顶点的树称为退化树。</p><p>对于树T，T的两点之间只有一个简单树。<br> a. 假设T中没有边 {u, v}，则对T添加边e = {u,  v}后，则T的从u到v的简单路与e构成一个圈，T不再是树；<br> b. 假设e = {u, v} 为T的一条边，并从T中删除e，则T不再连通，T不再是树；</p><p>定理8.6 设G为n &gt; 1 个顶点的图，则下列结论等价：<br> 1. G 是 树；<br> 2. G 为无圈图，且有 n - 1条边；<br>  3. G 连通，且有 n - 1 条边；</p><h3 id="支撑树"><a href="#支撑树" class="headerlink" title="支撑树"></a>支撑树</h3><p><strong>支撑树</strong> 对于连通图GG，如果G的子图T是树且包含了G的所有顶点，则T称为G的支撑树。</p><p><strong>最小支撑树</strong>  设G为连通的赋权图，则G的每个支撑树都被指定了一个T中的每个边的权之和的总权。<br>G的<strong>最小支撑树</strong>就是总权尽可能小的支撑树。</p><h4 id="求n个顶点连通赋权图的最小支撑树的算法"><a href="#求n个顶点连通赋权图的最小支撑树的算法" class="headerlink" title="求n个顶点连通赋权图的最小支撑树的算法"></a>求n个顶点连通赋权图的最小支撑树的算法</h4><p><strong>算法8.8A</strong> 输入n个顶点的连通赋权图G，<br> 1. 按权递减的序排列G的边<br> 2.  相继地依序删去未使G不连通的边，直到剩下n - 1 条边<br> 3. 退出</p><p><strong>算法8.8B(Kruskal)</strong> 输入n个顶点的连通赋权图G<br> 1. 按权的递增的序排列G的边<br> 2.  仅用G的顶点，相继依序添加不产生圈的边，直到添加了n - 1条边<br> 3. 退出</p><h2 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h2><p><strong>平面图</strong> 能够画在平面上使得它的边不相交叉的图或多重图称为平面图。（这是一个类拓扑的概念）</p><p>（树图是最基本的平面图）</p><h3 id="地图、区域"><a href="#地图、区域" class="headerlink" title="地图、区域"></a>地图、区域</h3><p><strong>地图</strong> 有限平面多重图的特定平面表示称为地图。</p><p>如果地图的基础多重图是<em>连通</em>的，则称地图是<em>连通</em>的。</p><p><strong>定理8.7</strong> 地图区域的度的和等于边数的两倍。</p><h2 id="Euler公式"><a href="#Euler公式" class="headerlink" title="Euler公式"></a>Euler公式</h2><p>对于任何连通地图的顶点数V，边数E以及区域数R：</p><p><strong>定理8.8(Euler)</strong> V - E + R = 2</p><p>（注意：前提是地图的基础图必须连通）</p><p><strong>定理8.9</strong> 设 G 为连通平面图，有p个顶点和q条边，p &gt;= 3，则 q &lt;= 3p - 6.</p><h3 id="非平面图，Kuratowski定理"><a href="#非平面图，Kuratowski定理" class="headerlink" title="非平面图，Kuratowski定理"></a>非平面图，Kuratowski定理</h3><p>定理8.10（Kuratowski） 图是非平面的当且仅当它含有同胚于 K_{3,3} 或 K_{5} 的子图。</p><h2 id="图着色"><a href="#图着色" class="headerlink" title="图着色"></a>图着色</h2><p><strong>着色</strong>  对于图G，G的顶点着色，简称着色，是给G的每个顶点指定一个颜色，使得相邻顶点有不同的颜色。<br>若存在用n种颜色的G的着色，则称G为 n-可着色的。</p><p>染色G所需的最少颜色数称为G的色数，记为：</p><p>$$<br>\chi(G)<br>$$</p><h3 id="图G着色的算法"><a href="#图G着色的算法" class="headerlink" title="图G着色的算法"></a>图G着色的算法</h3><p><strong>算法8.10</strong> (Welch-Powel) 输入一个图G</p><ol>  <li>根据<strong>度</strong>递减的次序排列G的顶点</li>  <li>给第一个顶点染第一种颜色C1，然后，依次序给与前面已染C1的点不相邻的点染C1</li>  <li>用第二种颜色对未染色的子序列重列重复2</li>  <li>用第三种颜色，第四种颜色…，重复3，直到所有的点都已染色</li>  <li>退出</li></ol><p><strong>定理8.11</strong> 对图G，下面结论等价：</p><ol>  <li>G为2-可着色的</li>  <li>G为二部图</li>  <li>G的每个圈有偶长度</li></ol><p><strong>定理8.12</strong> 任何平面图是5-可着色。</p><p><strong>四色定理（Apple和Haken）</strong> 任意平面图是4-可着色的。</p><h3 id="对偶地图与四色定理"><a href="#对偶地图与四色定理" class="headerlink" title="对偶地图与四色定理"></a>对偶地图与四色定理</h3><p>  对于地图M，若M的两个区域有公共边，则称为相邻的。对M的着色是指对M的区域的颜色指派，使得相邻的区域有不同的颜色。<br>若存在M的用n个颜色的着色，则称M是n-可着色的。</p><p>地图的着色等于个平面图的顶点着色。</p><p><strong>对偶图</strong>  对于地图M，在M的每个区域内取一个点，若邻区域有公共边，则用一条通过这条公共边的曲线连接相应的两个点，<br>这些曲线可以画得互不相交，则得到一个新的地图M*，称为M的对偶。</p><p>可以证明，M也为M*的对偶。</p><p>地图M的任意区域的着色对应对偶地图 M* 的顶点着色。因此，M是n-可着色的当且仅当对偶地图 M* 的平面图是顶点n-可着色的。</p><p><strong>四色定理（Apple和Haken）</strong> 要使任意地图M的相邻区域着不同颜色，则至多需要4种颜色。</p><h2 id="在计算机中储存图"><a href="#在计算机中储存图" class="headerlink" title="在计算机中储存图"></a>在计算机中储存图</h2><p>设图G有m个顶点n条边，<br>如果m = O(n^2)，则称图G是<strong>稠密</strong>的；<br>如果 m = O(n)或 O(n  log n)，则图G是<strong>稀疏</strong>的。</p><p><strong>序列表示</strong> 采用图的邻接矩阵A表示；当图稠密时，常用矩阵来表示。</p><p><strong>链表示</strong> 又称 <strong>邻接结构</strong>，采用邻点的链表；当图稀疏时，常采用链表表示。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>设G 为m 个顶点的图，并设顶点已排序为 v1, v2, …, vm，则图G的邻接矩阵 A = [a_ij] 就是如下<br>定义的 m * m 矩阵：</p><p>a_ij = 1 若 vi 连接到 vj，否则 0</p><p>若G为多重图，常用a_ij表示边 {vi, vj} 的数目<br>若G为赋权图，常用a_ij表示边 {vi, vj} 的权</p><h3 id="链表示"><a href="#链表示" class="headerlink" title="链表示"></a>链表示</h3><p>  当图是稀疏的情况下，或者需要动态删除、添加顶点的情况下，矩阵法有很大的限制；<br>因此需要使用一种叫<strong>邻接结构</strong>的链来表示图。</p><p>使用顶点与其邻接点（邻点）的形式来表示图G。用符号空集表示空邻接。<br>通常含有两个文件（或纪录集），一个称为点文件，另一个称为边文件。</p><ol>  <li>点文件 包含图G的顶点列表。</li>  <li>边文件 包含图G的边。</li></ol><h2 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h2><p>查找算法过程中，G的每个顶点 N 处于三种状态之一，称为N的状态（status）：</p><ol>  <li>status = 1, 准备状态，顶点N的初始状态</li>  <li>status = 2，等候状态，顶点N在等候表中，等待进行</li>  <li>status = 3，检查状态，顶点N已检查</li></ol><h3 id="深度优先查找（DFS）"><a href="#深度优先查找（DFS）" class="headerlink" title="深度优先查找（DFS）"></a>深度优先查找（DFS）</h3><p>算法8.12A（深度优先查找） 该算法从一个开始点A开始执行图G的深度优先查找</p><ol>  <li>初始化所有点到准备状态</li>  <li>从初始点A放到堆栈上，并将A的状态改为等候状态</li>  <li>重复4和5，直到堆栈空</li>  <li>取堆栈的顶点N，检查N，并置status(N) = 3，检查状态</li>  <li>检查N的每个邻点J<br>a. 若status(J) = 1 ，把J放到堆栈上，重置status(J) = 2<br>b. 若status(J) =    2，从堆栈中删去前一个J，把当前J放到堆栈上<br>c. 若status(J) = 3，略过顶点J</li>  <li>退出</li></ol><h2 id="广度优先查找（BFS）"><a href="#广度优先查找（BFS）" class="headerlink" title="广度优先查找（BFS）"></a>广度优先查找（BFS）</h2><p>算法8.12B（广度优先查找） 该算法执行图G的度度优先查找，它从一个起点A开始</p><ol>  <li>初始化所有点到准备状态</li>  <li>从初始点A放进队列，并将A的状态改为等候状态</li>  <li>重复4和5，直到堆栈空</li>  <li>移去队列的前面点 N，检查 N，并置status(N) = 3，检查状态</li>  <li>检查N的每个邻点J<br>a. 若status(J) = 1 ，把J加到队列后面，重置status(J) = 2<br>b. 若status(J)    = 2或status(J) = 3，跳过顶点J[结束步骤3循环]</li>  <li>退出</li></ol><h1 id="附录-6"><a href="#附录-6" class="headerlink" title="附录"></a>附录</h1><h2 id="术语-5"><a href="#术语-5" class="headerlink" title="术语"></a>术语</h2><ul>  <li>链表 linked list</li>  <li>点 pointer</li>  <li>链域 link field</li>  <li>空指针 null pointer</li>  <li>堆栈 stack</li>  <li>队列 queue</li>  <li>优先队列 priority queue</li>  <li>图 graph</li>  <li>顶点 vertix</li>  <li>边 edge</li>  <li>相邻 adjacent / neighbour</li>  <li>连接 connect</li>  <li>端点</li>  <li>重边 mutiple edge</li>  <li>环 loop</li>  <li>简单图 simple graph</li>  <li>多重图 multigraph</li>  <li>顶点的度 degree of a vertex<ul>      <li>奇点 odd (vertex)</li>      <li>偶点 even (vertex)</li>      <li>孤立点 isolated vertex</li>    </ul>  </li>  <li>有限图 finite graph</li>  <li>平凡图 trivial graph</li>  <li>子图 subgraph</li>  <li>同构图 isomorphic graph</li>  <li>同胚图 homeomorphic graph</li>  <li>路 path</li>  <li>闭 close</li>  <li>路的长度 length of path</li>  <li>闭路 cycle</li>  <li>简单路 simple path</li>  <li>迹 trail</li>  <li>连通度 connectivity</li>  <li>连通分支 connected component</li>  <li>距离 distance</li>  <li>直径 diameter</li>  <li>割点 cut point</li>  <li>桥 bridge</li>  <li>Konigsberg 桥</li>  <li>可旅行 traversable</li>  <li>可旅行迹 traversable trail</li>  <li>可旅行多重图 traversable multigraph</li>  <li>Hamilton图 Hamiltonian graph</li>  <li>标号图 labeled graph</li>  <li>赋权图 weighed graph</li>  <li>完全图 complete graph</li>  <li>正则图 regular graph</li>  <li>二部图 bipartite graph</li>  <li>树 tree</li>  <li>支撑树 spanning tree</li>  <li>最小支撑树 minimum spanning tree</li>  <li>平面图 planar graph</li>  <li>地图 map</li>  <li>区域 region</li>  <li>非平面图 nonplanar graph</li>  <li>应用图 utility graph</li>  <li>星图 star graph</li>  <li>着色 graph colorings</li>  <li>四色定理 Four Color Theorem</li>  <li>对偶地图 dual maps</li>  <li>邻接矩阵</li>  <li>邻接结构</li>  <li>广度优先搜索</li>  <li>深度优先搜索</li></ul><h3 id="salesmen-代码练习"><a href="#salesmen-代码练习" class="headerlink" title="salesmen 代码练习"></a>salesmen  代码练习</h3><p>table.txt</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Adams Smith</span><br><span class="line">Brown Ray</span><br><span class="line">Clark Ray</span><br><span class="line">Drew  Jones</span><br><span class="line">Evans Smith</span><br><span class="line">Farmer  Jones</span><br><span class="line">Geller  Ray</span><br><span class="line">Hill  Smith</span><br><span class="line">Infold  Ray</span><br></pre>      </td>    </tr>  </table></figure><p>salesmen.h</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#ifndef _SALEMEN_H</span><br><span class="line">#define _SALEMEN_H</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Salesman &#123;</span><br><span class="line">  string name;</span><br><span class="line">  int start_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Customer &#123;</span><br><span class="line">  string name;</span><br><span class="line">  int salesman_id;</span><br><span class="line">  int next_customer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Database &#123;</span><br><span class="line">private:</span><br><span class="line">  vector&lt;Salesman&gt; salesmen;</span><br><span class="line">  vector&lt;Customer&gt; customers;</span><br><span class="line">  bool existsCustomer(string name);</span><br><span class="line">  bool existsSalesman(string name);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  Database();</span><br><span class="line">  ~Database();</span><br><span class="line">  add (string salesman, string customer);</span><br><span class="line">  vector&lt;string&gt; findCustomers(string salesmen);</span><br><span class="line">  vector&lt;string&gt; findSalesman(string customer);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre>      </td>    </tr>  </table></figure><p>salesmen.cpp</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#include &quot;salesmen.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Database::Database() &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Database::~Database() &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool Database::existsCustomer(string name) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool Database::existsSalesman(string name) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Database::add (string salesman, string customer) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; Database::findCustomers(string salesmen) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; Database::findSalesman(string customer) &#123;</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure><p>test.cpp</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;salesmen.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; tables;</span><br><span class="line"></span><br><span class="line">    Database db = Database();</span><br><span class="line">    for (auto &amp;g: tables) &#123;</span><br><span class="line">      for (auto &amp;p: g) &#123;</span><br><span class="line">        db.add(p[0], p[1]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto res = db.findCustomers(&quot;Smith&quot;);</span><br><span class="line"></span><br><span class="line">    auto string = db.findSalesman(&quot;Clark&quot;);</span><br><span class="line">  &#125;</span><br></pre>      </td>    </tr>  </table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树是数学与计算机科学中的基本结构。有根树与二叉树很相似，但二叉树并不是有根树的特殊情形，<strong>它们是不同的数学对象</strong>。</p><h2 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h2><p>二叉树 T 定义为点的元素的有限集，使得：</p><ol>  <li>T 是空的（称为空树），或者</li>  <li>T 含有一个特别的点 R 称为 T 的根，且 T 的其余点构成不交的二叉树 T1 与 T2 的有限对；</li></ol><p>若 T 确有根 R，则两棵树 T1 与 T2 分别称为 R 的左子树 和 右子树。<br>若 T1 为非空，则它的根称为 R 的左后继；T2非空，则称为  R 的右后继。<br>没有后继的点称为<strong>终点</strong>。</p><h3 id="二叉树的图示"><a href="#二叉树的图示" class="headerlink" title="二叉树的图示"></a>二叉树的图示</h3><h3 id="相似二叉树"><a href="#相似二叉树" class="headerlink" title="相似二叉树"></a>相似二叉树</h3><p>如果二叉树 T 和 T’ 有相似的结构（形状），则称他们是<strong>相似</strong>的。</p><p>如果两棵相似的二叉树，对应的点有相同的内容，则称为是<strong>拷贝</strong>的。</p><h2 id="术语-6"><a href="#术语-6" class="headerlink" title="术语"></a>术语</h2><ul>  <li>前继</li>  <li>左后继</li>  <li>右后继</li>  <li>父</li>  <li>左子</li>  <li>右子</li>  <li>层次</li>  <li>深度</li>  <li>高度</li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>如果除去最后一层外，所有层都有最大可能的点数，且最后一层的所有点都尽可能靠左边，这样的二叉树称为 n 个点的完全树 T_n。</p><h3 id="扩充二叉树"><a href="#扩充二叉树" class="headerlink" title="扩充二叉树"></a>扩充二叉树</h3><p>如果每个点 N 有两个或者没有子节点，这样的二叉树称为扩充二叉树，又称为 2-树。</p><p>有两个子节点的点称为内点，没有子节点的点称为外点。</p><h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h2><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>前序遍历，中序遍历，后序遍历</p><h1 id="附录-7"><a href="#附录-7" class="headerlink" title="附录"></a>附录</h1><h2 id="术语-7"><a href="#术语-7" class="headerlink" title="术语"></a>术语</h2><ul>  <li>二叉树 binary tree</li>  <li>根</li>  <li>左子树</li>  <li>右子树</li>  <li>左后继</li>  <li>右后继</li>  <li>终点</li></ul><h1 id="整数的性质"><a href="#整数的性质" class="headerlink" title="整数的性质"></a>整数的性质</h1><p>难点：带余除法，同余关系，剩余类，同余式，中国剩余定理的命题</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>自然数集 N = {1, 2, 3, …}<br>整数集 Z = {…, -2, -1, 0, 1, 2, …}</p><p>加法和乘法的规律：</p><p> a. 结合律： (a + b) + c = a + (b + c), (ab)c = a(bc)<br> b. 交换律： a + b = b + a,  ab = ba<br> c. 分配律： a(b + c) = ab + ac<br> d. 单位元律： a + 0 = 0 + a = a, a * 1 =  1 * a = a<br> e. 对于任何元素a 都有加法逆元 -a，即：a + (-a) = (-a) + a = 0</p><p><strong>算术基本定理</strong> 每一个正整数n(n &gt; 1)都可以唯一地写成素数的积。</p><h2 id="序、不等式与绝对值"><a href="#序、不等式与绝对值" class="headerlink" title="序、不等式与绝对值"></a>序、不等式与绝对值</h2><p>设 a，b为整数，如果b - a的差是正的，即 b - a \in N，我们就说a小于b，记为 a &lt; b。</p><p>两则Z整数N的性质：<br>[P1] 如果a，b \in N，那么 a + b \in N，ab \in N<br>[P2] 对于任意整数a，或者a  \in N，或者 a = 0，或者 -a \in N。</p><p>序的常见记号：<br>$$<br>a &gt; b \iff b &lt; a<br>$$</p><p>$$<br>a \leq b \iff a &lt; b \lor a = b<br>$$</p><p>$$<br>a \geq b \iff a &gt; b \lor a = b<br>$$</p><h3 id="不等式的基本性质"><a href="#不等式的基本性质" class="headerlink" title="不等式的基本性质"></a>不等式的基本性质</h3><p>命题11.1 关系 \leq 在整数集Z中有下列性质：<br>$$<br>\forall a, a \leq a<br>$$<br>$$<br>a  \leq b \land b \leq a \implies a = b<br>$$<br>$$<br>a \leq b \land b \leq c  \implies a \leq c<br>$$</p><p>命题11.2（三分律） 对于任何整数 a 和 b，恰有下列关系之一被满足：</p><p>$$<br>a &lt; b, a = b, a &gt; b<br>$$</p><p>命题11.3 假定 a \leq b，c为任意整数，则：</p><p>$$<br>a + c \leq b + c<br>$$</p><p>$$<br>ab \leq bc(c &gt; 0); ac \geq bc (c &lt; 0)<br>$$</p><h3 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h3><p>整数a 的绝对值记为 | a |，通常定义为：</p><p>| a | = a (a \geq 0), -a (a &lt; 0)</p><p>因此除了a = 0外，| a | &gt; 0</p><p>命题11.4 设a，b为任意整数，则</p><p>$$<br>| a | \geq 0, a = 0 \iff | a | = 0<br>$$</p><p>$$<br>-|a| \leq a \leq |a|<br>$$</p><p>$$<br>|ab| = |a| |b|<br>$$</p><p>$$<br>|a \pm b| \leq |a| + |b|<br>$$</p><p>$$<br>| |a| - |b| | \leq |a \pm b|<br>$$</p><h2 id="数法归纳法"><a href="#数法归纳法" class="headerlink" title="数法归纳法"></a>数法归纳法</h2><p>数学归纳法原理 设S是一个正整数集合而有下列两个性质：</p><pre><code>1. 1 \in S2. 若k \in S，则 k + 1 \in S</code></pre><p>那么 S 是所有正整数构成的集合。</p><p>数学归纳法原理 设 P 是定义在整数 n &gt;= 1 上的一个命题，使得<br> 1. P(1) 成立<br> 2. 当 P(n) 成立时，P(n +  1)成立</p><h2 id="整除算法"><a href="#整除算法" class="headerlink" title="整除算法"></a>整除算法</h2><p>对于整数 a 和 b，且 b \neq 0，存在 整数 q 和 r 使得 a = bq + r (0 &lt;= r &lt;= |b|)，并且 q 和  r 是唯一的。</p><p>算法：</p><figure class="highlight c">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q = (<span class="keyword">int</span>) a/b;</span><br><span class="line">r = a - b * q;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="整除，素数"><a href="#整除，素数" class="headerlink" title="整除，素数"></a>整除，素数</h2><p>设 a，b为整数且 a \neq 0，假设存在整数c，使得 ac = b，我们就称 a 整除 b 或者 b 被 a 整除，记作：</p><p>$$<br>a \mid b<br>$$</p><p>也说 b 是 a 的倍数或 a 是 b 的因子。如果 a 不能整除 b，我们记作：</p><p>$$<br>a = \nmid b<br>$$</p><p><strong>定理11.8</strong> 设a，b，c为整数</p><ol>  <li>如果 a \mid b 且 b \mid c，则 a \mid c</li>  <li>如果 a \mid b，那么对于任一整数 x, a \mid bx</li>  <li>如果 a \mid b 且 a \mid c，则 a \mid (b + c) 且 a \mid (b - c)</li>  <li>如果 a \mid b 且 b \neq 0，则 a = \pm b或 |a| &lt; |b|</li>  <li>如果 a \mid b 且 b \mid a，则 |a| = |b| 即，a = \pm b</li>  <li>如果 a \mid 1，则 a = \pm 1</li></ol><p><strong>推论11.9</strong> 设 a \mid b 且 a \mid c，则对于任意的整数 x 和y 有 a \mid (bx +  cy)。</p><p>表达式称为 bx + cy 为b，c的线性组合。</p><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><p><strong>素数</strong> 如果一个正整数p (p &gt; 1)只有因子 \pm 1 和 \pm  p，即p有平凡因子，则称其为素数。又称质数。<br><strong>合数</strong> 如果正整数不是素数，则称其为合数。对于合数 n (n &gt;  1)，那么 n = ab，其中 1 &lt; a, b &lt; n。</p><p><strong>定理11.10</strong> 任意大于 1 的整数 都可以写成素数的积。</p><p><strong>定理11.11</strong> 没有最大的素数，即存在无限多个素数。</p><h2 id="最大公因数，带余除法"><a href="#最大公因数，带余除法" class="headerlink" title="最大公因数，带余除法"></a>最大公因数，带余除法</h2><p>设 a， b 是整数且不全为0，整数d称为a，b的公因子，如果 d \mid a 且 d \mid b。<br>注意 1 是 a 和 b的正的公因子，a  和 b 的任何公因子都不能大于 |a| 和 |b|，<br>所以存在一个最大的公因子，记为：</p><p>$$<br>\text{gcd}(a, b)<br>$$<br>称之为a，b的最大公因数。</p><p><strong>定理11.12</strong> 设 d 是形如 ax + by 的最小正整数，则 d = gcd(a, b)。</p><p><strong>定理11.13</strong> 设d = gcd(a, b)，则一定存在整数x和y，使得 d = ax + by。</p><p><strong>定理11.14</strong> 一个正整数d = gcd(a, b)当且仅当d有下列两个性质：</p><ol>  <li>d即整除a，又整除b</li>  <li>如果c既整数a又整除b，那么 c \mid d</li></ol><p>下面是最大公因数的简单性质：</p><ol>  <li>gcd(a, b) = gcd(b, a)</li>  <li>如果 x &gt; 0，那么 gcd(ax, bx) = x * gcd(a, b)</li>  <li>如果 d = gcd(a, b)，那么 gcd(a|d, b|d) = 1</li>  <li>对于任意整数x，gcd(a, b) = gcd(a, b + ax)</li></ol><h3 id="带余除法"><a href="#带余除法" class="headerlink" title="带余除法"></a>带余除法</h3><p>直接求法：<br>求gcd(a, b) ，通过列出a和b的所有因子，然后选择最大公因子来得出d。</p><p>设 n = a + b， 计算因子的个数，这种代码方法的复杂性为O(\sqrt{n})</p><p><strong>带余除法</strong> 复杂度为 O(\log{n})，可以求得最大公因数 d = gcd(a, b) 和 d = ax + by  中的 x, y。</p><p>设a和b，通过用a除以b，然后重复地用余数除以除数直到余数为0。</p><figure class="highlight c">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt;= <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">if</span> (b &lt;= <span class="number">1</span>) <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> r = a % b;</span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    a = b;</span><br><span class="line">    b = r;</span><br><span class="line">    r = a % b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 ax + by = d 的 x，y 的方法</span></span><br><span class="line"><span class="comment">// 由于在求解 d 的过程中，产生的任意值对 i, j也有 gcd(i, j) = d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此：</span></span><br><span class="line"><span class="comment">// ax + by = d</span></span><br><span class="line"><span class="comment">// ix + jy = d</span></span><br><span class="line"><span class="comment">// 求解即得x，y</span></span><br></pre>      </td>    </tr>  </table></figure><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>设 a，b 是非零整数，|ab|就是a和b的一个正的公倍数，因此存在a，b的一个最小公倍数，记为：</p><p>$$<br>\text{lcm}(a, b)<br>$$</p><p>称之为a和b的最小公倍数。</p><p><strong>定理 11.15</strong> 设a和b是非零整数，则：<br>$$<br>\text{lcm}(a, b) = \frac{| ab  |}{\text{gcd}(a, b)}<br>$$</p><h2 id="算术基本定理"><a href="#算术基本定理" class="headerlink" title="算术基本定理"></a>算术基本定理</h2><p><strong>互素</strong> 两个整数a和b称为互素，如果：<br>$$<br>\text{gcd}(a, b) =  1<br>$$<br>即，存在x和y，使得：<br>$$<br>ax + by = 1<br>$$<br>反之，如果ax + by = 1，则a，b互素。</p><p><strong>定理11.16</strong> 设gcd(a, b) = 1，a和b都整除c，则ab整除c。</p><p><strong>定理11.17</strong> 设a|bc 且 gcd(a, b) = 1，则 a|c。</p><p><strong>推论11.18</strong> 设一素数 p 整除积 ab，即 p|a 或 p|b。</p><h3 id="算术基本定理-1"><a href="#算术基本定理-1" class="headerlink" title="算术基本定理"></a>算术基本定理</h3><p>定理11.19（算术基本定理）每个整数n(n &gt; 1)都能被唯一的（不计顺序）表示成素数的积。</p><p>n的分列式中的素数一定要不同，因此把所有相等的素数结合起来，n可表示为下列形式：</p><p>$$<br>n = p_1^{m_1} p_2^{m_2} \cdots p_r^{m_r}<br>$$</p><p>式中 m_i 是正数，且 p1 &lt; p2 &lt; … &lt; pr，上式称为n的标准分解式。</p><h3 id="同余关系"><a href="#同余关系" class="headerlink" title="同余关系"></a>同余关系</h3><p>设m是一正整数，如果 m 能整除 a - b，我们说a，b 模 m 同余，记为：<br>$$<br>a \equiv b(\text{modulo}\  m), a \equiv b (\text{mod}\ m)<br>$$</p><p>整数m称为模。</p><p><strong>定理11.20</strong> 设m是一个正整数，那也：<br> 1. 对于任意整数a，有 a \equiv a (mod  m)；（自反关系）<br> 2. 如果 a \equiv b(mod m)，那么 b \equiv a(mod m)；（对称关系）<br> 3. 如果 a  \equiv b(mod m)，b\equiv c(mod m)，那么 a \equiv c(mod m)；（传递关系）。</p><p>注： 设 m 是正数，a 是任意整数，由带余除法，存在整数 q 和 r(0 &lt;= r &lt; m)，使得 a = mq + r，因此：</p><p>$$<br>mq = a - r, m \mid (a - r), a \equiv r(\text{mod} m)<br>$$</p><p>于是</p><pre><code>1. 任意整数 a 模 m 都与下列集合中唯一一个整数同余</code></pre><p>$$<br> {0, 1, 2, \cdots, m - 1}<br>$$<br> 唯一性可由m不能整除集合中的两个整数的差推得。</p><pre><code>2. 任意两个整数 a 和 b 模 m 同余，当且仅当 它们除以 m 所得余数相同。</code></pre><h3 id="剩余类"><a href="#剩余类" class="headerlink" title="剩余类"></a>剩余类</h3><p>模m同余是一个等价关系，那么它就把整数集Z分成了互不相交的等价类，我们称之为  模剩余类。<br>一个剩余类由所有的被m除余数相同的数组成，因此有m个这样的剩余类并且每一个剩余类都恰恰含有余数集中的一个整数：</p><p>{0, 1, …, m - 1}</p><p>一般地，如果每一个 a_ i 取自一个不同的剩余类，一个由 m 个整数组成的集合 {a1, a2, …, a_m } 称为 模m的完全剩余系。</p><p>因此，从 0 到 m - 1 的整数构成了一个完全剩余类。事实上，任何 m 个连续的整数都构成一个模m的完全剩余类。</p><p>记号 [x]_m 或 [x] 表示 包含 x 的模 m 的剩余类，也就是那些和 x 同余的整数，换句话说，</p><p>$$<br>[x] = {a \in Z; a \equiv x (\text{mod} m)}<br>$$</p><p><strong>同余的计算</strong></p><p>定理11.21 设 a \equiv c(mod m), b \equiv d(mod m)，那么<br> 1. a + b \equiv c + d  (mod m)<br> 2. a * b \equiv c * d (mod m)</p><p><strong>剩余类的运算</strong></p><p>模的剩余类的加法和乘法定义如下：</p><p>$$<br>[a] + [b] = [a + b], [a] * [b] = [ab]<br>$$</p><p><strong>模m的整数Z_m</strong></p><p>模m的整数记为 Z_m，指的是集合：</p><p>$$<br>Z_m = {0, 1, 2, 3, …, m - 1}<br>$$</p><p>其上加法和乘法是通过模m的运算定义的，换句话说，是剩余类上的相应运算。<br>因此：<br>Z_m 与 模m剩余类的运算没有本质的区别，因此可以通用。</p><p><strong>同余的消去律</strong></p><p>定理11.22（修正的消去律）<br>$$<br>ab \equiv ac(\text{mod}\ m)， \text{gcd}(a, m) = 1  \implies b \equiv c (\text{mod}\ m)<br>$$</p><p>定理11.23<br>$$<br>ab \equiv ac (\text{mod}\ m) \land d = \text{gcd}(a, m)  \implies b \equiv c(\text{mod}\ m/ d)<br>$$</p><p>注：设ｐ为素数，则整数 1 到 p - 1 都与 p 互素，这样通常消去律当模为素数p时满足，也就是说：<br>$$<br>ab \equiv  ac(\text{mod}\ p) \land a \not\equiv 0(\text{mod}\ p) \implies b \equiv  c(\text{mod}\ p)<br>$$<br>这样 Z_p ，模素数 p 的整数在数论上起到了特殊的作用。</p><p><strong>简化剩余系和欧拉函数</strong></p><p>与m互素的剩余类的个数即从1到m（不包括m）中与m互素的数的个数记为：<br>$$<br>\varnothing(m)<br>$$</p><p>函数O(m)称为 欧拉函数，1 到 m 中与 m 互素的整数，<br>或更一般地，任何O(m)个与m互素的不同余的整数列称为模m的简化剩余系。</p><p><strong>定理11.24</strong> 欧拉函数是可乘的，即若 a，b互素，那么：</p><p>$$<br>\varnothing(ab) = \varnothing(a)\varnothing(b)<br>$$</p><h2 id="同余式"><a href="#同余式" class="headerlink" title="同余式"></a>同余式</h2><p>一个同余多项式方程 或 称一个同余方程（关于未知数x）是如下形式的方程：<br>$$<br>a_ {n} x^n + a_ {n - 1} x ^{n -  1} + \cdots + a_ {1} x + a_ {0} \equiv 0 (\text{mod}\ m)<br>$$</p><p>这样的一个方程称为 n 次的，如果a_n \not\equiv 0 (\text{mod} 0).</p><p>设 s \equiv t(\text{mod}\ m)，那么 s 是方程的解当且仅当 t  是方程的解。<br>这样，方程的解的个数即为不同余的解的个数，即在下面集合中解的个数：<br>$$<br>{ 0 , 1, 2, \cdots, m - 1  }<br>$$</p><p>这样，方程的<strong>完全解</strong>是不同余的解的最大集合，而方程的一般解则是所有满足的解，一般解可以通过把所有m的倍数加到完全解上得到。</p><p><strong>定理11.25</strong> 如果 a 和 m 互素，那么 ax \equiv 1 (\text{mod}\ m)有唯一解，否则无解。</p><p><strong>线性同余方程</strong></p><p>考虑更一般的同余方程<br>$$<br>ax \equiv b(\text{mod}\ m), a\not\equiv 0(\text{mod}\  m)<br>$$<br><strong>定理11.26</strong> 设 a 和 m 互素，那么 ax \equiv b(\text{mod}\  m)有唯一解，另外，如果s是ax\equiv 1(\text{mod}\ m)的唯一解，那么：<br>$$<br>x = bs<br>$$<br>是 ax  \equiv b(\text{mod}\ m)的唯一解。</p><p><strong>定理11.27</strong> 设方程 ax \equiv b(\text{mod}\ m), d =\text{gcd}(a, m)</p><ol>  <li>    <p>若 d 不整除 b，则 ax \equiv b(\text{mod\ m})无解</p>  </li>  <li>    <p>若 d 整除 b，则 ax\equiv b(\text{mod}\ m)有 d 个解，它们模 m 与下列方程的唯一解同余<br>$$<br>Ax      \equiv B(\text{mod}\ M)<br>$$<br>其中，A = a/d, B = b/d，M = m/d。</p>    <p>因为gcd(A, M) = 1，所以可运用定理11.26求Ax=B(mod M)的解。</p>  </li></ol><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p><strong>定理11.28（中国剩余定理）</strong> 设有方程组(*)  $$<br>x \equiv r_1 (\text{mod}\ m_1), x \equiv r_2(\text{mod}\ m_2), \cdots, x  \equiv r_k (\text{mod}\ m_k)<br>$$</p><p>m_i 两两互素，那么方程组有一模 M = m_1 m_2 … m_k 的唯一解。</p><p><strong>命题11.29</strong> 考虑以上同余方程组(*)，设 M = m1 m2 … m_k，且<br>$$<br>M_1 =  \frac{M}{m_1}, M_2 = \frac{M}{m_2}, \cdots, M_k = \frac{M}{m_k}<br>$$</p><p>(那么每一对 m_i 和 m_j 互素)，设 s_1, s_2, …，s_k是下列还以方程的解</p><p>$$<br>M_1 x\equiv 1 (\text{mod}\ m_1), M_2 x \equiv 1(\text{mod}\ m_2),  \cdots, M_k x \equiv 1 (\text{mod}\ m_k)<br>$$</p><p>那么：<br>$$<br>x_0 = M_1 s_1 r_1 + M_2 s_2 r_2 + \cdots + M_k s_k  r_k<br>$$<br>是方程组的解。</p><h1 id="附录-8"><a href="#附录-8" class="headerlink" title="附录"></a>附录</h1><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><ul>  <li>自然数，正整数 natural numbers/ positive integers</li>  <li>整数 integers</li>  <li>序 order</li>  <li>不等式 inequalities</li>  <li>绝对值 aboslute value</li>  <li>三分律 Law of Trichotomy</li>  <li>数法归纳法 mathematical induction</li>  <li>整除 division, divide</li>  <li>素数 primes</li>  <li>因数 divisor</li>  <li>公因数 common divisor</li>  <li>最大公因数 greatest common divisor</li>  <li>最小公倍数 least common multiple</li>  <li>互素 relatively prime integers</li>  <li>算术基本定理 Fundamental Theorem of Arithmetic</li>  <li>同余关系 congruence relation</li>  <li>模 modulus</li>  <li>剩余类</li>  <li>完全剩余类</li>  <li>简化剩余系</li></ul><h1 id="代数系统"><a href="#代数系统" class="headerlink" title="代数系统"></a>代数系统</h1><h2 id="重点难点"><a href="#重点难点" class="headerlink" title="重点难点"></a>重点难点</h2><ul>  <li>同余关系</li>  <li>半群的定义</li>  <li>半群同态</li>  <li>半群的直积</li>  <li>群的定义</li>  <li>对称群<h1 id="代数系统-1"><a href="#代数系统-1" class="headerlink" title="代数系统"></a>代数系统    </h1>  </li></ul><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>设 S 是一个非空集合，集合 S 上的一个运算是 S\times S 到 S 的一个函数 *，通常记：<br>$$<br>a * b,  ab<br>$$<br>而不记为 *(a, b)。<br>集合 S 和 S 上的一个运算 * 记为 (S, *) 或当运算明确时简记为 S。</p><p><strong>注</strong> 一个从 S\times S 到 S 上的运算 * 有时称为  <strong>二元运算</strong>。<strong>一元运算</strong>是从 S 到 S 的函数。</p><h3 id="运算的性质"><a href="#运算的性质" class="headerlink" title="运算的性质"></a>运算的性质</h3><h4 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h4><p>对于集合 S 上的运算 *， 如果 S 中的任意元素 a，b，c，有：<br>$$<br>(a * b) * c = a * (b *  c)<br>$$<br>则称为<strong>可结合的</strong>或满足<strong>结合律</strong>。</p><p>一般地，如果一个运算不是可结合的，则可有许多方法构成一个积。</p><p><strong>定理</strong> 设 * 是集合 S 上的一个可结合的运算，那么任何积 a1 * a2 * …. * an  无须加括号。也就是说所有可能的积都相等。</p><h4 id="交换律"><a href="#交换律" class="headerlink" title="交换律"></a>交换律</h4><p>集合 S 上的运算 * 称为可交换的，或满足交换律，如果对于S中任意元素 a，b 有：<br>$$<br>a * b = b * a<br>$$</p><h3 id="单位元-和-逆元"><a href="#单位元-和-逆元" class="headerlink" title="单位元 和 逆元"></a>单位元  和 逆元</h3><p>如果存在 S 中的元素 e，对于 S 中的任意元素a，有：<br>$$<br>a * e = e * a = a<br>$$<br>被称为 * 的单位元。</p><p>$$<br>\exist e in S \implies \forall a in S \to a * e = e * a = a<br>$$</p><p>更一般的，对于 S 中的任意元素a，如果 e * a = a，则 e 称为左单位元；如果 a * e = a，则 e 称为右单位元。</p><p><strong>定理</strong> 设 e 是左单位元，f 是右单位元，那么 e = f。<br>（即，单位元是唯一的）</p><p><strong>逆元</strong> 设集合 S 上的运算 * 有 单位元，那么 S 中元素 a 的逆元 是元素b，满足：<br>$$<br>a * b  = b * a = e<br>$$</p><p>如果运算是可结合的，那么 a 的逆元若存在则唯一。<br>显然，如果 b 是 a 的逆元，a 也是 b 的逆元，因此逆元是一个对称关系。我们也可以说 a  和 b 互逆。</p><p><em>注</em> 如果 S 上的运算记成 a * b，a\times b, a\dot b 或 ab，则称 S  为<strong>乘法式</strong>结构，S 中元素 a 的逆记为 a^-1。<br>如果运算记为 +，则称 S  为<strong>加法式</strong>结构。在这种情况下，单位元通常记为 0，称之为<strong>零元素</strong>。a 的逆元记为  -a，且称为a的<strong>负元素</strong>。</p><h3 id="消去律"><a href="#消去律" class="headerlink" title="消去律"></a>消去律</h3><p>对于集合 S 上的运算 *，如果有：<br>$$<br>a * b = a * c \implies b = c<br>$$<br>称 S  满足<strong>左消去律</strong>。  如果有：<br>$$<br>b * a = c * a \implies b = c<br>$$<br>称 S  满足<strong>右消去律</strong>。</p><h2 id="群"><a href="#群" class="headerlink" title="群"></a>群</h2><p>设 G 是定义了二元运算（用并置表示）的非空集合，如果G满足下列的公理：</p><ul>  <li><strong>结合律</strong> 对任何元素 a，b，c \in G，有 (ab)c = a(bc)</li>  <li><strong>单位元</strong> 存在元素 e \in G，使得对于G中任一个元素a，有 ae = ea = a</li>  <li><strong>逆元</strong> 对每个元素 a \in G，存在一个元素 a^-1 \in G（a的逆元），使得 aa^-1 = a^-1    a = e</li></ul><p>则称 G 为群。</p><p>若群 G 满足交换律，即对任意的 a，b \in G，有 ab = ba，则称 G 为阿贝尔群（或 交换群）。</p><p>当二元运算如上并置定义时，称 G 为乘法群；当 G 是阿贝尔群时，运算记为 +，称 G  为加法群。<br>此时单位元记为0，称为零元素，逆元记为-a，称为负元素。</p><p>群 G 中元素的个数记为 |G|，称为 G 的阶。若其阶是有限的，称G为有限群。</p><p>如果 A 和 B 是 G 的子集，则记：<br>$$<br>AB = {ab: a\in A, b\in B} 或 A + B = {a + b:  a\in A, b\in B}<br>$$</p><h3 id="对称群-S-n"><a href="#对称群-S-n" class="headerlink" title="对称群 S_n"></a>对称群  S_n</h3><p>从集合 {1, 2, 3, …, n} 到自身的 1-1映射 称为置换，记为：<br>$$<br>\sigma =  \begin{pmatrix}<br>1 &amp; 2 &amp; 3 &amp; \cdots &amp; n \<br>j_1 &amp; j_2  &amp; j_3 &amp; \cdots &amp; j_n<br>\end{pmatrix}<br>$$<br>其中，j_i = \sigma(i)。</p><p>所有置换的集合记为 S_n，共有 n! 个元素（P(n, n) = \frac{n!}{(n - n)!} = n!）。<br>S_n 中置换的 复合**  和 <strong>逆</strong> 均在 S_n 中，并且单位函数 \epsilon 也在 S_n 中，这样 S_n  在函数复合运算下构成群，我们称之为 <strong>n阶对称群</strong>。</p><h2 id="MAP-A-PERM-A-和-AUT-A"><a href="#MAP-A-PERM-A-和-AUT-A" class="headerlink" title="MAP(A), PERM(A) 和 AUT(A)"></a>MAP(A),  PERM(A) 和 AUT(A)</h2><p>设 A 是一非空集合，所有的函数（映射）f: A \to 组成的集合 MAP(A)  在函数的复合下是半群，但它是不是群，因为有些函数没有逆元。<br>但是，所有的 A 到自身的 1-1 映射（称为“置换”）组成的 MAP(A) 的子半群  PERM(A) 在函数的复合下构成群。</p><p>设 A 含有某些几何和代数结构，那么所有 A 到自身的同构映射（称为 A 的自同态）所组成的集合 <strong>AUT(A)</strong>  在函数的复合下也构成群。</p><h2 id="子群，正规子群和同态"><a href="#子群，正规子群和同态" class="headerlink" title="子群，正规子群和同态"></a>子群，正规子群和同态</h2><p>设 H 是 群G 的一个子集，如果在 G 的运算下 H 本身也是群，那么 H 称为 G 的子群。</p><p><strong>性质</strong> 群 G 的子集 H 是 G 的子群，如果：</p><ol>  <li>单位元 e \in H</li>  <li>在 G 的运算下 H 封闭，即如果 a, b \in H，那么 a * b \in H</li>  <li>H 对逆元封闭，即如果 a \in H，那么 a_{-1} \in H</li></ol><p>每个群 G 都以 {e} 和 G 自身为其子群，G 的其他子群都称为 <strong>非平凡子群</strong>。</p><p><strong>陪集</strong></p><p>如果 H 是 G 的子群，且 a \in G，那么集合：<br>$$<br>Ha = {ha: h \in H}<br>$$</p><p>称为 H 的右陪集。<br>类似的， aH 称为 H 的左陪集。</p><p><strong>定理</strong> 设 H 是群 G 的子群，那么右陪集 Ha 构成一个 G  的划分。<br><strong>定理（拉格朗日）</strong> 设 H 是有限群 G 的子群，则 H 的阶整除 G  的阶。<br><strong>定理</strong> G 中 H 的右陪集的数目（称为 H 在 G 中的<strong>指标</strong>）等于 G 中  H 的左陪集的数目，且两者都等于 |G| 除以 |H|。</p><p><strong>正规子群</strong></p><p>如果 G 的一个子群 H，对于任意 a \in G，有 a^{-1} Ha \subseteq H，那么 H 称为正规子群。<br>等价地，H  是正规的，如果对于每个 a \in G，有 aH = Ha，即左陪集和右陪集相等。</p><p>阿贝尔群的每个子群都是正规的。</p><p><strong>定理</strong> 设 H 是群 G 的一个正规子群，那么 H 的陪集在陪集乘法<br>$$<br>(aH)(bH) =  abH<br>$$<br>下构成群。称为<strong>商群</strong>，记作 G/H。</p><p>设 G 中的运算是加法或者说 G 是加法式的，那么 G 的子群 H 的陪集形如 a + H，而且，如果 H 是 G 的正规子集，那么 H  的陪集在：<br>$$<br>(a + H) + (b + H) = (a + b) + H<br>$$<br>下形成群。</p><p>##　半群</p><p>设 S 是定义了一个运算的<strong>非空集合</strong>，若该运算是可结合的，则称 S 为半群；若该运算还有一个单位元，则称 S 为幺半群。</p><h3 id="自由半群，自由幺半群"><a href="#自由半群，自由幺半群" class="headerlink" title="自由半群，自由幺半群"></a>自由半群，自由幺半群</h3><p>设 F = F(A) 表示 A 上所有字符串在连接运算下的集合，显然对于任意串 u，v，w，串(uv)w 和  u(vw)是一样的；它们都是由u，v，w一个接一个地写成的。因此 F 是一个半群，称为 A 上的<strong>自由半群</strong>；A 的元素，称为  F 的<strong>生成元</strong>。</p><p>空序列记为 \lambda，也看做 A 上的一个串，但我们不能认为\lambda属于 自由半群 F = F(A)。<br>A 上所有的串包括  \lambda 记为 A *。于是 A * 是连接下的一个幺半群，称为 A 上的自由幺半群。</p><h3 id="子半群"><a href="#子半群" class="headerlink" title="子半群"></a>子半群</h3><p>设 A 是半群 S 的一个非空子集，如果 A 本身对于 S 上的运算是一个半群，则称 A 为 S 的一个子半群。因为 A 中的元素也是 S 的元素，A  中的元素自然满足结合行。</p><p>因此 A 是一个子半群当且仅当 其在 S 的运算下封闭。</p><h3 id="同余关系和商结构"><a href="#同余关系和商结构" class="headerlink" title="同余关系和商结构"></a>同余关系和商结构</h3><p>设 S 是一个半群，~ 是 S 上的一个等价关系。回顾等价关系，可以把集合 S 分成等价类，且用[a]表示含有集合 S 中的元素 a  的等价类，等价类的集合记为：S/~。</p><p>假设 S 上的等价关系有下面的性质：<br>$$<br>a ~ a’, b ~ b’ \implies ab ~ a’b’<br>$$</p><p>那么 ~ 称为 S 上的同余关系。而且可以定义等价类上的一个运算：<br>$$<br>[a] * [b] = [a * b], [a] [b] =  [ab]<br>$$</p><p>并且这个 S/~ 上的运算是可结合的，因此，S/~ 是一个<strong>半群</strong>。</p><p><strong>定理</strong> 设 ~ 是半群 S 上的一个同余关系，那么 ~ 的等价类 S/~ 关于运算<br>$$<br>[a] [b] =  [ab]<br>$$<br>构成一个半群。这个半群 S/~ 称为由 ~生成的商群。</p><h3 id="半群的同态"><a href="#半群的同态" class="headerlink" title="半群的同态"></a>半群的同态</h3><p>考虑两个半群(S, *) 和 (S’, *‘)，函数 f: S\to S’，称为半群同态，或简称同态，如果：<br>$$<br>f(a * b) =  f(a) *‘ f(b) 或 f(ab) = f(a)f(b)<br>$$<br>假设 f 是单射的，满射的，则 f 称为 S 与 S’ 之间的一个同构，S  和 S’ 称为同构半群，记作：<br>$$<br>S\cong S’<br>$$</p><h3 id="半群同态的基本定理"><a href="#半群同态的基本定理" class="headerlink" title="半群同态的基本定理"></a>半群同态的基本定理</h3><p><strong>定理</strong> 设 f: S\to S’ 是一个半群同态，如果 f(a) = f(b)，今 a ~ b，则</p><p>i. ~ 是S 上的同余关系；<br>ii. S/~ 同构于 f(S)；</p><h3 id="半群的积"><a href="#半群的积" class="headerlink" title="半群的积"></a>半群的积</h3><p>设 (S1, *1) 和 (S2, *2) 是两个半群，我们构造一个新半群 S = S1 \otimes S2，称为 S1 和 S2 的直积，如下：</p><ol>  <li>S 中的元素来自 S1\times S2，即 S 中的元素是有序偶 (a,b), a\in S1, b\in S2；</li>  <li>S 中的运算 * 定义为分量两两相乘，即：<br>$$<br>(a, b) * (a’, b’) = (a *_1 a’, b *_2 b’)  </li></ol><p>$$</p><p>或简记为：</p><p>$$<br>(a, b)(a’, b’) = (aa’, bb’)</p><p>$$<br>（可证明，上面的运算是可结合的。）</p><h1 id="附录-9"><a href="#附录-9" class="headerlink" title="附录"></a>附录</h1><h2 id="术语-8"><a href="#术语-8" class="headerlink" title="术语"></a>术语</h2><ul>  <li>运算 operation</li>  <li>结合律 associative law</li>  <li>交换律 commutative law</li>  <li>单位元 identity element</li>  <li>逆元 inverse</li>  <li>乘法式 multiplicatively</li>  <li>加法式 additively</li>  <li>负(元素) negative</li>  <li>消去律 cancellation law</li>  <li>左消去律 left cancellation law</li>  <li>右消去律 right cancellation law</li>  <li>半群 semigroup</li>  <li>幺半群 monoid</li>  <li>自由半群 free semigroup</li>  <li>生成元 generator</li>  <li>自由幺半群 free monoid</li>  <li>子半群 subsemigroup</li>  <li>（运算）封闭 closed</li>  <li>同余关系 congruence relation</li>  <li>商群 quotient</li>  <li>半群同态 semigroup homomorphism</li>  <li>同构 isomorphism</li>  <li>同构半群 isomorphic semigroup</li>  <li>半群的积 semigroup products</li>  <li>群 group</li>  <li>阿贝尔群 abelian group (commutative group)</li>  <li>乘法式 multiplicatively</li>  <li>加法式 additively</li>  <li>有限群 finite group</li>  <li>子群 subgroup</li>  <li>正规子群 normal subgroup</li>  <li>同态 homomorphism</li>  <li>商群 quotient group</li></ul><h5 id="operation-ts"><a href="#operation-ts" class="headerlink" title="operation.ts"></a>operation.ts</h5><p>// 使用 Typescript 的泛型来表示“运算”</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">type Op&lt;T&gt; = (a: T, b: T) =&gt; T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 四则运算</span><br><span class="line">let plus: Op&lt;number&gt; = (a, b) =&gt; a + b</span><br><span class="line">let minus: Op&lt;number&gt; = (a, b) =&gt; a - b</span><br><span class="line">let multiply: Op&lt;number&gt; = (a, b) =&gt; a * b</span><br><span class="line">let divide: Op&lt;number&gt; = (a, b) =&gt; a / b</span><br></pre>      </td>    </tr>  </table></figure><h1 id="形式语言、形式语法和自动机"><a href="#形式语言、形式语法和自动机" class="headerlink" title="形式语言、形式语法和自动机"></a>形式语言、形式语法和自动机</h1><p>难点：</p><ul>  <li>正则表达式</li>  <li>形式语言，正则语言</li>  <li>有限状态自动机</li>  <li>Kleene定理</li>  <li>Pumping引理</li>  <li>形式语法</li>  <li>形式语法的分类</li>  <li>有限状态机</li>  <li>Turing机<h1 id="形式语言、形式语法和自动机-1"><a href="#形式语言、形式语法和自动机-1" class="headerlink" title="形式语言、形式语法和自动机"></a>形式语言、形式语法和自动机    </h1>  </li></ul><h2 id="字母表，字符串，自由半群"><a href="#字母表，字符串，自由半群" class="headerlink" title="字母表，字符串，自由半群"></a>字母表，字符串，自由半群</h2><p>字母表：非空符号集合（通常记作A）</p><p>字符串：字母表元素中的有限序列（通常记作 w, u, v）</p><p>空串：没有字符的序列（通常使用希腊字母 lambda 或 epsilon表示）</p><p>A 中所有字符串的集合记为 A*（读作 A 星）</p><p>字符串长度：记作 |u| 或 l(u)，表示 字符串u 中字符的个数。l(\lambda) = 0.</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>对于字母表A中的两个字符串 u 和 v，连接 u 和 v 记作 uv，表示字符串 v 紧接着写在字符串 u 之后。</p><p>定理13.1 字母表A中的字符串的连接运算满足结合律，空串是运算中的单位元。<br>（一般地，运算的交换律不成立）</p><h3 id="子串，前缀"><a href="#子串，前缀" class="headerlink" title="子串，前缀"></a>子串，前缀</h3><p>子串：对于任意字符串 u = a1 a2 … an,任何序列 w = a_ {j} a_ {j+1} … a_k 称作u的子串。<br>前缀：子串 w =  a1 a2 … ak，以u的字符开头，称作 u 的前缀。</p><h3 id="自由半群，自由幺半群-1"><a href="#自由半群，自由幺半群-1" class="headerlink" title="自由半群，自由幺半群"></a>自由半群，自由幺半群</h3><p>自由半群：用F表示字母表A中所有非空字符串的集合，并且含有连接运算。由于连接运算满足结合律，因此F是一个<strong>半群</strong>。  称作 <em>A 的自由半群</em> 或 <em>由 A 生成的自由半群</em>。  当需要标明集合A时，A的自由半群记作 F_A。</p><p>自由幺半群：设 M = A* 是包括空串lambda在内的A中所有字符串的集合。由于lambda是连接运算的单位元，M是含幺半群，我们称  M为A上的自由幺半群。</p><p>$$<br>F_A = A^* - {\lambda}<br>$$</p><h2 id="形式语言"><a href="#形式语言" class="headerlink" title="形式语言"></a>形式语言</h2><p>形式语言：字母表 A 中的字符串的集合 称为 A 上的形式语言 L。</p><p>因此，形式语言 L 是 A* 的一个子集。</p><h3 id="形式语言的运算"><a href="#形式语言的运算" class="headerlink" title="形式语言的运算"></a>形式语言的运算</h3><p>假设 L 和 M 是 A 的形式语言，那么 L 和 M 的连接，记为 LM，是 A 上的一种形式语言，定义如下：</p><p>$$<br>LM = {uv: u \in L, v \in M}<br>$$</p><p>形式语言的幂：形式语言 L 的幂定义如下：</p><p>$$<br>L^0 = {\lambda}, L^1 = L, L^2 = LL, L^{m + 1} = L^mL(m &gt; 1)<br>$$</p><p>一元运算 L* （读作 “L星”），称作 L 的 Kleene 闭包，<br>$$<br>L^* = L^0 \cup L^1 \cup L^2 \cup  \cdots = \cup_{k = 0}^{\infty} L^k<br>$$</p><p>定理13.2 L* 的定义与 A* 一致。</p><p>此外，记号 L+ 表示：<br>$$<br>L^+ = L^* - L^0<br>$$</p><h2 id="正则表达，正则语言"><a href="#正则表达，正则语言" class="headerlink" title="正则表达，正则语言"></a>正则表达，正则语言</h2><p><strong>定义</strong> 下面每一项均为字母表A中的正则表达：</p><pre><code>1. 符号\lambda（空串） 和括号()（空表达）是正则表达；2. A中每个字母a是正则表达3. 如果r是正则表达，那么(r*)是正则表达4. 如果 r1 和 r2 是正则表达，那么 (r1 \lor r2)是正则表达；5. 如果 r1 和 r2 是正则表达，那么 (r1r2) 是正则表达；</code></pre><p> 注意： 正则表达r 是一种特殊的字符串，它用A中的字符和如下五种符号：<br>$$<br> ( ) * \lor \lambda<br>$$<br>  此外，没有其它符号用于正则表达。</p><p><strong>定义</strong> A 上的形式语言 L(r) 由正则表达 r 定义如下：<br> 1. L(\lambda) = {\lambda}  和 L(()) = \emptyset（空集）<br> 2. L(a) = a，其中 a 是 A 中的字符串<br> 3. L( r* ) =  (L(r))* ；L(r) 的 Kleen闭包<br> 4. L(r1 \lor r2) = L(r1) \cup L(r2)； 形式语言的并集<br>  5. L(r1 r2) = L(r1)L(r2) (形式语言的连接)</p><p><strong>定义</strong> 设 L 为 A 的形式语言，若存在 A 上的一正则表达式，使得 L = L(r)，则L称为 A 的正则语言。</p><h2 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h2><p>有限自动机(FSA)，或者简单地说，自动机 M，由下述五部分组成：<br> 1. 一个有限的输入集合A（字母表）<br> 2.  （内部的）一个有限状态集合S<br> 3. S 的一个子集Y（Y的元素称为接受状态, yes）<br> 4. S的初始状态s_0<br> 5.  S中的状态转移函数 F:S \times A -&gt; S</p><p>当要指明它的五部分时，自动机M被记为：<br>$$<br>M = (A, S, Y, s_0, F)<br>$$</p><p>状态转移函数：<br>对每个 a \in A，定义 f_a: S \to S；即每一个输入a可看作引起自动机 M 的状态改变。<br>F(s, a) =  f_a(s) 表示两个定义是等价的。</p><h3 id="自动机-M-的状态图"><a href="#自动机-M-的状态图" class="headerlink" title="自动机 M 的状态图"></a>自动机  M 的状态图</h3><p>自动机通常使用它的状态图 D = D(M) 来定义，而不是列出它的五个部分。状态图 D = D(M) 是如下的一种带标记的有向图。<br> 1. D(M)  的结点是 S 的状态，接受状态用双圈表示<br> 2. 在 D(M) 中，若 F(s_ j, a) = s_ k 或 f_ a(s_ j) = s_  k，则用一个标有输入a的箭头从 s_ j 指向 s_ k<br> 3. 初始状态 s_ 0 是通过一特殊的箭号表示，这个箭号终止于 s_  0，但是没有初始结点。</p><h3 id="自动机-M-决定的形式语言-L-M"><a href="#自动机-M-决定的形式语言-L-M" class="headerlink" title="自动机 M 决定的形式语言 L(M)"></a>自动机  M 决定的形式语言 L(M)</h3><p>每一个有输入字母表 A 的自动机 M 定义 A 上的一种形式语言 L(M) 如下：<br>设 w = a1 a2 … am 为A中的一字符串，则 w  确定一状态序列：</p><p>$$<br>s_0 \to s_1 \to s_2 \to \cdots \to s_m<br>$$</p><p>其中 s_0 为初始状态且 F(s_{i - 1}, a_i) = s_i(i &gt;= 1)， 换句话说，w确定了状态图 D(M)  的路径：<br>$$<br>P = (s_0, a_1, s_1, a_2, s_2, \cdots, a_m, s_m)<br>$$</p><p>如果最后状态 s_m 是 Y 中的接受状态，则说 M 识别字符串 w。<br>M 的形式语言 L(M) 为 A中被 M 接受的所有字符串的集合。</p><p>定理 13.2（Kleene） 字母表 A 上的形式语言 L 是正则的当且仅当存在一个有限自动机 M 使得 L = L(M)。</p><p>（形式语言 L 上的 * 运算 L* 有时称作 L 的 Kleene 闭包）。</p><h3 id="Pumping引理"><a href="#Pumping引理" class="headerlink" title="Pumping引理"></a>Pumping引理</h3><p>定理13.3 （Pumping引理） 假设 M 是 A 上的自动机并满足：<br> 1. M 有 k 个状态<br> 2. M 接受 A 的字符串  w，这里 |w| &gt; k<br> 那么 w = xyz，这里对每一个正整数m，w_m = xy^m z 被 m 接受。</p><h2 id="形式语法"><a href="#形式语法" class="headerlink" title="形式语法"></a>形式语法</h2><p>一个<strong>短语结构形式语法</strong>，简称形式语法G，由四个部分构成：<br> 1.  一个有限集（<strong>词汇</strong>）V；<br> 2. V 的一个子集T，T 的元素称为<strong>终结元</strong>；集合 N  = V\T 的元素称为 <strong>非终结元</strong> 或 <strong>变元</strong>；  3. 一个非终结符 S 称为<strong>起始符</strong>；  4. 一个产生式的有限集 P。产生式是一个有序偶(\alpha, \beta)，通常记作 \alpha \to \beta， 其中\alpha，\beta是  V 上的字符串；P 中的每个产生式的左端必须至少包括一个非终结元。<br> 这样的形式语法 G，记作 G = G(V, T, S, P)</p><p>除特别说明外，形式语法用下面的记法：终结元用斜体小写拉丁字母表示；非终结元用斜体大写拉丁字母表示；起始符用 S 表示；同时，V 中的字符串，即终结元 或  非终结元 的字符串用希腊字母表示，此外，将：<br>$$<br>\alpha \to \beta _1, \alpha \to \beta _2,  \cdots, \alpha \to \beta _k  $$</p><p>记作：</p><p>$$<br>\alpha \to (\beta _1, \beta _2, \cdots, \beta _k)<br>$$</p><h3 id="形式语法-G-的形式语言-L-G"><a href="#形式语法-G-的形式语言-L-G" class="headerlink" title="形式语法 G 的形式语言 L(G)"></a>形式语法  G 的形式语言 L(G)</h3><p>假设 w 和 w’ 是形式语法 G 的词汇集合 V 上的字符串，如果 w’ 能够由 w 通过使用一个产生式得到，我们写成：<br>$$<br>w  \Rightarrow w’<br>$$</p><p>即，如果存在字符串 u 和 v，使得 w = u \alpha v 且 w’ = u\beta v，并且有一个产生式 \alpha \to  \beta，我们写成：<br>$$<br>w \Rightarrow \Rightarrow w’, w^* \Rightarrow  w’<br>$$<br>如果 w’ 能够由 w 通过使用有限个产生式得到。</p><p>设 G 是一个形式语法，T 是 G 的终结元集。G 的形式语言，记作 L(G)；由初始符 S 通过以上过程得到 T  上的字符串组成，即：<br>$$<br>L(G) = { w \in T^*: s \Rightarrow\Rightarrow w }<br>$$</p><h3 id="形式语法的类型"><a href="#形式语法的类型" class="headerlink" title="形式语法的类型"></a>形式语法的类型</h3><h4 id="Noam-Chomsky分类法"><a href="#Noam-Chomsky分类法" class="headerlink" title="Noam Chomsky分类法"></a>Noam  Chomsky分类法</h4><p>形式语法根据所允许的产生式的种类来分类。<br>以下是 Noam Chomsky 提出的形式语法的分类：<br> 0.  一个零型形式语法在产生式上没有限制；<br> 1. 第一类型：如果形式语法 G 所有的产生式都是<br>$$<br> \alpha \to  \beta(|\alpha| \leq |\beta|), \alpha \to \lambda<br>$$</p><ol start="2">  <li>    <p>第二类型：如果形式语法 G 所有的产生式都是<br>$$<br>A \to \beta<br>$$<br>即其中左端是一个非终结元的形式</p>  </li>  <li>    <p>第三类型：如果形式语法 G 所有的产生式都是：</p>  </li>  <li>    <p>$$<br>A \to a, A \to aB, S \to      \lambda<br>$$<br>即左端是一个非终结元，右端是一个终结元或一个终结元后跟一个非终结元；或起始符到空串。</p>  </li></ol><p>可以看出，形式语法分类形式一个阶层组织，即第三类型的形式语法都是第二类型的；第二类型的形式语法都是第一类型的；第一类型的形式语法都是零类型形式语法。</p><h4 id="上下文相关性分类"><a href="#上下文相关性分类" class="headerlink" title="上下文相关性分类"></a>上下文相关性分类</h4><p>形式语法也可以分类成上下文有关的法语、上下文无关的语法、正则的语法：</p><ol>  <li>    <p><strong>上下文相关的语法</strong>：一个形式语法 G，如果它的产生式都是：<br>$$<br>\alpha A \alpha ‘      \to \alpha \beta \alpha ‘<br>$$<br>称它是“上下文相关的”，是因为只有当变元A 在 \alpha 与      \alpha’ 之间时，才总可以用\beta 来取代A。</p>  </li>  <li>    <p><strong>上下文无关的语法</strong>： 一个形式语法 G，如果它的产生式都是：<br>$$<br>A \to      \beta<br>$$<br>称它为“上下文无关的”，是因为无论变元A在什么位置，我们总可以用 \beta 来取代 A。</p>  </li>  <li>    <p><strong>正则的语法</strong>：一个形式语法是正则的，如果它的产生式都是这样的形式：<br>$$<br>A \to a, A \to      aB, S \to \lambda<br>$$</p>  </li></ol><p>可以看出，上下文无关的形式语法与第二类型形式语法是第个的，正则形式语法与第三类型形式语法是等价的。</p><p><strong>定理13.4</strong> 形式语言 L 能由第三类型（正则）形式语法 G 生成，当且仅当存在一个有限自动机 M 能够接受  L。<br>因此，一个形式语法是正则的，当且仅当 L = L(r)，其中r 是正则表达式；当且仅当 L = L(M)，其中 M 是有限状态自动机；当且仅当  L = L(G)，其中 G 是正则形式语法。</p><h3 id="上下文无关语法的导出树"><a href="#上下文无关语法的导出树" class="headerlink" title="上下文无关语法的导出树"></a>上下文无关语法的导出树</h3><p><strong>导出树</strong>：一个上下文无关的形式语法G，L(G) 中的字符串 w 的导出可以用有序、有根的树 T 来形象地描述，称为导出树。</p><h3 id="Backus-Naur形式"><a href="#Backus-Naur形式" class="headerlink" title="Backus-Naur形式"></a>Backus-Naur形式</h3><p>在描述上下文无关的形式语法（第二类型形式语法）的产生式时，有时也用另外一种词法，称作 Backus-Naur形式。它的特点在于：</p><pre><code>1. 不用 \to 而用 ::= ；2. 非终结元要用 &lt;&gt; 括起来；3. 所有左端有相同非终结元的产生式要合并成一句，所有的右端在 ::= 的右边列出并用短竖隔开；</code></pre><h3 id="自动机与形式语法"><a href="#自动机与形式语法" class="headerlink" title="自动机与形式语法"></a>自动机与形式语法</h3><p>正则形式语法对应有限状态自动机（FSA）。此外，还有其他形式的自动机，对应其他形式的语法。<br> 1.  <strong>Pushdown自动机</strong>：Pushdown自动机 P 与 FSA 类似，且 P  有一个辅助储存器能为它提供无限大容量的存储空间。<br> 形式语言L能被Pushdown自动机识别，当且仅当 L 是 <em>上下文无关</em>  的形式语言。<br> 2. <strong>线性有界自动机</strong>：线性有界自动机 B 比 Pushdown自动机的功能更强，这样的自动机 B  使用一种带子，这种带子是根据输入字符串 w 的字长而线性有界的。<br> 形式语言L 能被自动机B识别当且仅当 L 是 <em>上下文有关</em>  的。<br> 3. <strong>Turing自动机</strong>：Turing自动机，使用的是一种无限长的带子，它能识别由任何短语结构形式语法 G  生成的所有形式语言。 事实上，Turing自动机 M 是一系列定义可数函数的等价方法中的一种。</p><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>  有限状态机（FSM）与有限状态自动机（FSA）类似，只是FSM输出时使用一种与输入字母表不同的输出字母表。正式定义如下：<br>有限状态机（或完全序列机）M由六个部分组成：<br>  1. 一个输入符的有限集 A<br> 2. 一个内部状态的有限集 S<br> 3. 一个输出符的有限集 Z<br> 4. S 中的一个初始状态  s_0<br> 5. 一个从 S\times A 到 S 状态转移函数 f<br> 6. 一个从 S\times A 到 Z 的输出函数 g<br>  这样的一个机器 M 被记作<br>$$<br>M = M(A, S, Z, s_0, f, g)<br>$$</p><h3 id="有限状态机的状态表与状态图"><a href="#有限状态机的状态表与状态图" class="headerlink" title="有限状态机的状态表与状态图"></a>有限状态机的状态表与状态图</h3><p>描述有限状态机的方法通常有两种：一种是用表格，称作有限状态机 M 的状态表；另一种是用有标记的有向图，称作有限状态机的状态图。</p><p><strong>状态表</strong>：状态表把状态转移函数 f 与 输出函数 g 放在同一个表格内，这个表格描述了由<br>$$<br>F(s_i,  a_j) = (f(s_i, a_j), g(s_i, a_j))<br>$$<br>定义的函数<br>$$<br>F:S\times A \to S  \times Z<br>$$</p><p><strong>状态图</strong>：有限状态机 M = M(A, S, Z, s_0, f, g) 的状态图 D = D(M)  是一个有标记的有向图。D的结点是M的状态。此外，如果：<br>$$<br>F(s_i, a_j) = (s_k,  z_r)<br>$$<br>亦即：<br>$$<br>f(s_i, a_j) = s_k \land g(s_i, a_j) =  z_r<br>$$<br>那么，从 s_i 到 s_k 就有一条标着 a_j 和 z_r 的箭头。我们通常放输入符 a_j 靠近箭头的始端（靠近  s_i），输出符 z_r 靠近箭头的中心。此外，还通过另外画一条指向 s_0 的箭头来标记初始状态 s_0。</p><h3 id="输入与输出带"><a href="#输入与输出带" class="headerlink" title="输入与输出带"></a>输入与输出带</h3><p>设定给 M 一个输入符的字符串，如：<br>$$<br>u = a_1 a_2 \cdots  a_m<br>$$<br>我们设想这些符号在一条“输入带”上，机器M一个一个地读这些输入符，同时进行一系列的状态转换：<br>$$<br>V = s_0  s_1 s_2 \cdots s_m<br>$$<br>其中 s_0 是初始状态，并且把输出符的字符串<br>$$<br>w = z_1 z_2  \cdots z_m<br>$$<br>打印在一条“输出带”上。准确地说，初始状态 s_0 和输入字符串 u 通过<br>$$<br>s_i =  f(s_{i - 1}, a_i), z_i = g(s_{i - 1}, a_i)<br>$$<br>来决定字符串 v 和 w，其中 i = 1, 2,  …, m。</p><h3 id="二进制加法"><a href="#二进制加法" class="headerlink" title="二进制加法"></a>二进制加法</h3><p><strong>定理13.5</strong> 没有一种有限状态机能做二进制乘法。</p><h2 id="Godel数"><a href="#Godel数" class="headerlink" title="Gödel数"></a>Gödel数</h2><p>Gödel数：任何正整数 n (n &gt; 1)  都能唯一地（除顺序外）写成素数的乘积，把数字的有限序列进行了编码，也把在有限或可数的字母表A上的字符上的字符串进行编码。每个序列或字符串按下面规则对应的正整数，叫做  Gödel数：<br>非负整数序列 s = (n_1, n_2, …, n_k) 的Gödel数是正整数 c(s)，其中 n_i 是 c(s)  的素数分解式中 p_i 的指数，即：<br>$$<br>c(s) = p_1^{n_1} p_2^{n_2} \cdots p_k^{n_k}<br>$$</p><p>字母表 {a_0, a_1, a_2, a_3, …} 上的字符串 w 的 Gödel数 是正整数  c(w)，其中w的第i个字母的下标是c(w)的素数分解式中的 p_i 的指数。</p><p>（可以看出两种编码本质上是一样的，因为我们可以将字符串 w 看成是它的字母的下标的序列）。</p><p>定理13.6 如果字母表 A 是可数的，那么 A 上的所有形式的语言 L 都是可数的。</p><h2 id="Turing机"><a href="#Turing机" class="headerlink" title="Turing机"></a>Turing机</h2><p>基本定义</p><p>一个Turing机包括三个不交的非空集：</p><ol>  <li>一个有限带集合：<br>$$<br>A = {a_1, a_2, \cdots, a_m} \cup {B}<br>$$<br>这里 B =    a_0，是“空格”符</li>  <li>一个有限状态集：<br>$$<br>S = {s_1, s_2, \cdots, s_n} \cup {s_0} \cup {s_H, s_Y,    s_N}<br>$$<br>这里 s_0 是初始状态。另外 SH(HALT)是停止状态, SY(YES)是接受状态, SN(NO)是不接受状态。  </li>  <li>一个有向集<br>$$<br>d = {L, R, N}<br>$$<br>这里 L 表示“左”，R表示“右”，N表示“无运动”或“静止”。  </li></ol><p><strong>定义13.1</strong> <strong>表达</strong>是 A \cup S \cup d  中的元素的一个有限（可能空）序列。</p><p><strong>定义13.2</strong> <strong>带表达</strong>是只使用带集 A 中元素的表达。</p><p><strong>定义13.3</strong> 一个格局 \alpha 是这样一个形状的表达：<br>$$<br>\alpha = P s_i a_k  Q<br>$$<br>此处，P 和Q 是带表达（可能是空的）。</p><p><strong>定义13.4</strong> 设 \alpha = P s_i a_k Q 是一个格局，我们说 Turing机M 处于 s_i 状态，而  s_i 扫描字母 a_k，在线带上的表达是表达 P a_k Q，也就是没有状态符号 s_i 的 \alpha。</p><p><strong>定义13.5</strong> Turing机M是有限的五元组集合，满足：<br> 1. 没有两个五元组以相同的两个字母开始；<br>  2. 没有一个五元组是以 s_H, s_Y 或 s_N 开始；</p><p>下面是另一个等价的定义：<br><strong>定义13.6</strong> Turing机M  是一个部分函数：<br>$$<br>S\setminus{s_H, s_Y, s_N} \times A \to A \times S \times  d<br>$$<br>部分函数。简单地说，是表示 M 的定义域为<br>$$<br>S\setminus {s_H, s_Y, s_N}\times  A<br>$$<br>的子集。</p><p><strong>定义13.7</strong> 设 \alpha 和 \beta 是两个格局，我们写作：<br>$$<br>\alpha \to  \beta<br>$$<br>如果下面中任何一个成立，此外 a,b,c 是线索字母，而P 和Q是线索表达（可能是空的）：</p><ol>  <li>\alpha = Ps_i aQ, \beta = Ps_j bQ 和 M 包含着五元组 q = s_i ab s_j N；</li>  <li>\alpha = Ps_i acQ, \beta = Pbs_j cQ 和 M 包含着五元组 q = s_i abs_j R；</li>  <li>\alpha = Pcs_i aQ, \beta = Ps_j cbQ 和 M 包含着五元组 q = s_i abs_j L；</li>  <li>\alpha = Ps_i a，\beta = Pbs_jB 和 M 包含着五元组 q = s_i abs_j R；</li>  <li>\alpha = s_i aQ，\beta = s_jBbQ 和 M 包含着五元组 q = s_i abs_j L；</li></ol><p>注意，在所有五种情况中，M用b在线带中代替了 a（此外我们允许 b = a），M改变了它的状态，从s_i 到 s_j（此处我们允许s_j =  s_i），还有：</p><ol>  <li>这里M不移动</li>  <li>这里M向右移动</li>  <li>这里M向左移动</li>  <li>这里M向右移动，但是，因为 M 正扫描最右面的字母，它必须在右边加上空格符B</li>  <li>这里M向左移动，但是，因为 M 正扫描最左面的字母，它必须在左边加上空格符B</li></ol><p><strong>定义13.8</strong> 格局\alpha 是终止的，如果没有格局\beta，使得\alpha \to \beta。</p><h3 id="用Turing机计算"><a href="#用Turing机计算" class="headerlink" title="用Turing机计算"></a>用Turing机计算</h3><p><strong>定义13.9</strong> Turing机 的一个计算是一列格局 \alpha_0, \alpha_1, …, \alpha  <em>m，满足 \alpha</em>{i - 1} \to \alpha_{i} (i = 1, …, m) 以及 \alpha_m  是终止格局。<br>换句话说，一个计算是一个序列：<br>$$<br>\alpha_0 \to \alpha_1 \to \alpha_2 \to  \cdots \alpha_m<br>$$<br>这个序列不能再延续，因为 a_m 是终止的。我们用 term(\alpha)来表示以 \alpha  开始的计算的最后格局，因此，在上面的计算中，term(\alpha_0) = \alpha_m</p><h3 id="Turing机的输入"><a href="#Turing机的输入" class="headerlink" title="Turing机的输入"></a>Turing机的输入</h3><p><strong>定义13.10</strong> Turing机 M 的一个输入是一个线索表达 W。输入W的初始格局是 \alpha(W)，此处  \alpha(W) = s_0 W。</p><p><strong>定义13.11</strong> 设 M 是一个Turing机，W 是一个输入，如果有一个计算以初始格局 \alpha(W)开始，我们说  M 停止于 W 处。<br>也就是，给出一个输入W，我们能形成初始格局 \alpha(W) = s_0 W，并且应用 M  去获得一个序列：<br>$$<br>\alpha(W) \to \alpha_1 \to \alpha_2 \to  cdots<br>$$<br>两种情况可能发生：</p><ol>  <li>M 停止在 W 处，也就是说，序列在终止格局 \alpha_r处结束</li>  <li>M 在 W 处 没有停止，也就是说，序列不会结束</li></ol><h3 id="形式语法和Turing机"><a href="#形式语法和Turing机" class="headerlink" title="形式语法和Turing机"></a>形式语法和Turing机</h3><p><strong>定理13.7</strong> 形式语言 L 能被 Turing机 M 识别，当且仅当 L 是一个类型 0 的形式语言。</p><h2 id="可计算的函数"><a href="#可计算的函数" class="headerlink" title="可计算的函数"></a>可计算的函数</h2><p>用N来表示正整数的集合，记 N_0：<br>$$<br>N_0 = { 0, 1, 2, 3, \cdots }<br>$$</p><p><strong>定义13.12</strong> 每个数字 n 将通过带表达<n>表示；此处<n> = 1^{n +      1}，这样：<br>$$<br>\langle 0\rangle = 1, \langle 2\rangle = 111 = 1^3,      \langle 4\rangle = 11111 = 1^5<br>$$</n>  </n></p><p><strong>定义13.13</strong> 设E是一个表达，那么[E]将用来表示在 E 中1出现的次数，因此：<br>$$<br>[11B s_2  a_3 111Ba_4] = 5, [a_4 s_2 B a_2] = 0, [\langle n \rangle] = n + 1<br>$$</p><p><strong>定义13.14</strong> 函数 f: N_0 \to N_0 是可计算的，如果存在一个 Turing机 M 使得对每个整数 n，M  停止在<n>并且：<br>$$<br>f(n) = [term(\alpha(\langle n \rangle))]<br>$$<br>此时，说 M    计算了 f。</n></p><p><strong>定义13.8</strong> 假设 f: N_0 \to N_0，和 g: N_0 \to N_0 是可计算的，那么复合函数 h = g  * f 也是可计算的。</p><h3 id="多元函数"><a href="#多元函数" class="headerlink" title="多元函数"></a>多元函数</h3><p><strong>定义13.15</strong> 每一个 k 个整数的目录 m = (n_1, n_2, \cdots, n_k) 由带表达<m>    表示，这里：<br>$$<br>\langle m \rangle = \langle n_1 \rangle B \langle n_2    \rangle B \cdots B \langle n_k \rangle<br>$$<br>（因此， &lt;(2,0,4)&gt; =    111B1B11111 = 1^3 B 1^1 B 1^5）</m></p><p><strong>定义13.16</strong> 一个k元函数f(n_1, n_2, \cdots, n_k)  是可计算的，如果存在一个Turing机M，使得对每一个目录 m = (n_1, n_2, …, n_k)，M 停止在 <m>    处，并且：<br>$$<br>f(m) = [term(\alpha(\langle m \rangle))]<br>$$<br>那么我们说 M 可计算    f。</m></p><h1 id="附录-10"><a href="#附录-10" class="headerlink" title="附录"></a>附录</h1><h2 id="术语表-1"><a href="#术语表-1" class="headerlink" title="术语表"></a>术语表</h2><ul>  <li>字母表 alphabet</li>  <li>字符串 words</li>  <li>空串 empty word</li>  <li>连接 concatenation</li>  <li>子串 subword</li>  <li>前缀 intial segment</li>  <li>自由半群 free semigroup</li>  <li>自由幺半群 free monoid</li>  <li>形式语言 language</li>  <li>形式语言的连接 concatenation of languages</li>  <li>形式语言的幂 powers of a language</li>  <li>Kleene闭包 Kleene closure</li>  <li>正则表达 regular expression</li>  <li>正则语言 regular language</li>  <li>有限状态自动机 finite state automata (FSA)</li>  <li>Pumping引理 Pumping Lemma</li>  <li>形式语法 grammar</li>  <li>词汇 vocabulary</li>  <li>终结元 terminal</li>  <li>非终结元 non-ternimal</li>  <li>起始符 start symbol</li>  <li>产生式的有限集 finite set of productions</li>  <li>形式语法的类型 types of grammar</li>  <li>Noam Chomsky分类法</li>  <li>Type 0 grammar</li>  <li>Type 1 grammar</li>  <li>Type 2 grammar</li>  <li>Type 3 grammar</li>  <li>上下文相关语法 context-sensitive grammar</li>  <li>上下文无关语法 context-free grammar</li>  <li>正则语法 regular grammar</li>  <li>上下文无关语法的导出树 derivation trees of context-free grammars</li>  <li>自动机 automata</li>  <li>Pushdown自动机 Pushdown Automata</li>  <li>线性有界自动机 Linear Bounded Automata</li>  <li>Turing自动机 Turing Machine</li>  <li>有限状态机 finite state machine</li>  <li>状态表 State Table</li>  <li>状态图 State Diagram</li>  <li>Gödel数 Gödel numbers</li>  <li>表达 expression</li>  <li>带表达 tape expression</li>  <li>格局 picture</li>  <li>终结 terminal</li>  <li>可计算的 computable</li></ul><h1 id="有序集与格"><a href="#有序集与格" class="headerlink" title="有序集与格"></a>有序集与格</h1><p>难点：</p><ul>  <li>积集</li>  <li>积序</li>  <li>极小元素，极大元素，最小元素，最大元素</li>  <li>相容编号</li>  <li>上确界，下确界</li>  <li>格<h2 id="有限集"><a href="#有限集" class="headerlink" title="有限集"></a>有限集</h2>  </li></ul><p><strong>偏序（序关系），偏序集（有序集）</strong></p><p>假设 R 是集合 S 的一种关系，它满足下面三个性质：</p><ul>  <li>[O_1]（返身性）对任何 a \in S，有 aRa；</li>  <li>[O_2]（反对称性）若 aRb 且 bRa，则 a = b；</li>  <li>[O_3]（传递性）若aRb 且 bRc，则 aRc；</li></ul><p>则称 R 为一个 <strong>偏序</strong> 或 简称一个 <strong>序关系</strong>。带有偏序关系 R 的集合 S  叫做一个偏序集，或简称为有限集。当我们要标明 R时，记作 (S, R)。</p><p>最常见的序关系叫 <strong>常序</strong>，如在实数R的子集中正整数 N 中的 “&lt;=”  关系（读作小于等于）。由此，一个偏序关系通常记作 \precsim，即：<br>$$<br>a \precsim b<br>$$</p><p>读作“a 先于 b”。</p><p>类似的：<br>$$<br>a \prec b \iff a \precsim b \land a \neq b<br>$$<br>读作：“a 严格先于  b”。<br>$$<br>b \succsim a \iff a \precsim b<br>$$<br>读作：“b 后于 a”。<br>$$<br>b  \succ a \iff a \prec b<br>$$<br>读作“b 严格后于 a”。</p><p>此外：<br>$$<br>\not\precsim, \not\prec, \not\succsim,  \not\succ<br>$$<br>的定义是自然的。</p><p>当不产生混淆时，常用符号<br>$$<br>\leq, &lt;, &gt;,  \geq<br>$$<br>分别替代符号：<br>$$<br>\precsim, \prec, \succ, \succsim<br>$$</p><p><strong>特性</strong></p><p>对于集合 S，偏序可能有多种。</p><p>对于集合 S，如 n(S) &gt; 1，则 S 上的完全关系（S^2）不是偏序。</p><p>对于集合 S，S 上的具有对称性的关系不是偏序。</p><h3 id="对偶序"><a href="#对偶序" class="headerlink" title="对偶序"></a>对偶序</h3><p>设 \precsim 为集合 S 的任何偏序，关系 \succsim，即 a 后于 b，也是 S 的偏序，叫做对偶序。<br>显然， a\precsim  b 当且仅当 b\succsim a；因此对偶序\precsim 是 \succsim 的逆，即\precsim = \succsim^{-1}。</p><h3 id="有序子集"><a href="#有序子集" class="headerlink" title="有序子集"></a>有序子集</h3><p>设 A 为有限集 S 的一个子集，假设 a, b \in A。在 A 中定义 a\precsim b 当且仅当在 S 中有 a\precsim  b。<br>A 的这个偏序叫 A 上的<strong>诱导序</strong>，带有诱导序的子集 A 被称为 S  的<strong>有序子集</strong>。  除非特殊说明，序集 S 的任何子集被认为是 S 的有序子集。</p><h3 id="半序"><a href="#半序" class="headerlink" title="半序"></a>半序</h3><p>设定 \prec 是集合S上的一种关系，满足下面两个性质：</p><ul>  <li>[Q_1]（非返身性） 对任何 a \in A，有 a\not\prec a;</li>  <li>[Q_2]（传递性） 若 a\prec b 且 b\prec c，则a\prec c;<br> 那么，\prec 叫作 S 的半序。</li></ul><p>偏序和半序有着紧密的联系，特别地，如果 \precsim 是集合S上的偏序，则 a \prec b 意为 a \precsim b 且 a\neq  b，即\prec是S上的半序。反之，如果\prec 是 S 上的半序，则 a \precsim b 意为 a\prec b 或 a = b，即  \precsim 是 S 上的偏序。</p><h3 id="可比较性，线性序集"><a href="#可比较性，线性序集" class="headerlink" title="可比较性，线性序集"></a>可比较性，线性序集</h3><p>假设 a 和 b 是偏序集合 S 的元素，我们说 a 和 b 是可比较的，如果有：<br>$$<br>a \precsim b \lor b  \succsim a<br>$$<br>即，一个先于另一个。否则，a 和 b 是不可比较的，记作：<br>$$<br>a |  b<br>$$<br>即，既没有 a \precsim b 也没有 b \succsim a。</p><p>“偏”是用来定义偏序集 S，因为 S 的某些元素是不需要可比较的。换句话说，假设 S 的每一对元素都是可比较的，则 S 被称为  <strong>全序</strong> 或 <strong>线性序</strong>，且 S 被叫做一条链。尽管序集 S  可能不是线性序集，S的子集A仍有可能是线性序集。很明显，线性序集 S 的每一个子集一定是线性序。</p><h3 id="积集和积序"><a href="#积集和积序" class="headerlink" title="积集和积序"></a>积集和积序</h3><p>有很多方法定义所给定有序集的笛卡尔积上的序关系，下面是其中的两个方法：</p><ol>  <li>    <p><strong>积序</strong><br>设 S 和 T 是有序集，那么下面是积集 S\times T      上的一种有序关系，称为积序：<br>$$<br>(a, b) \precsim (a’, b’), a\precsim a’ \land b      \precsim b’<br>$$</p>  </li>  <li>    <p><strong>字典排序</strong><br>设 S 和 T 是线性序集，那么下面积集 S \times T      上的一种序关系，称为<strong>字典排序</strong>。      $$<br>(a, b) \precsim (a’, b’), a\prec a’ \lor (a = a’ \land b \precsim      b’)<br>$$</p>    <p>这个序能推广到 S_1 \times S_2 \times \cdots \times \S_n 上：<br>$$<br>(a_1, a_2,      \cdots, a_n) \prec (a_1’, a_2’, \cdots, a_n’)<br>$$<br>对于 i = 1, 2, …, k -      1 有 a_i = a_{i}’ 且 a_k &lt; a_k’。</p>  </li></ol><h3 id="Kleene闭包与序"><a href="#Kleene闭包与序" class="headerlink" title="Kleene闭包与序"></a>Kleene闭包与序</h3><p>设 A（非空）是一个线性序字母表，回顾A^* ，称作 A 的Kleene闭包，由A中所有字符串w构成，|w| 表示 w 的长度，因此下面是 A^*  上的两个序关系。</p><ol>  <li>    <p><strong>字母排序</strong></p>    <ul>      <li>\lambda &lt; w，\lambda是空字符串，w 是任何非空字符串；</li>      <li>设 u = au’ 和 v = bv’ 是不同的字符串，a,b \in A, u’, v’ \in A^*，那么：<br>$$<br>u        \prec v \iff a \prec b \lor (a = b \land u’ \prec v’)<br>$$</li>    </ul>  </li>  <li>    <p><strong>长度-字母序</strong><br>这里 A^* 先按长度排，再按字母涛掉，即对A*      中任何不同字符串u，v<br>$$<br>u \prec v \iff |u| &lt; |v| \lor (|u| = |v| \land      \text{alphabetical-ordered}, u \prec v)<br>$$<br>这个序也称作      <strong>自由半群序</strong>。</p>  </li></ol><h2 id="偏序集的-Hasse图"><a href="#偏序集的-Hasse图" class="headerlink" title="偏序集的 Hasse图"></a>偏序集的  Hasse图</h2><p><strong>直接前元，直接继承</strong></p><p>设 S 是一个偏序集，且a，b属于 S。如果 a &lt; b，且在 S 中没有元素介于a 与 b 之间，即不存在 c \in S，使得 a &lt; c  &lt; b，则称 a 是 b 的一个直接前元，或 b 是 a 的一个直接继元，或 b 盖住 a，记作：<br>$$<br>a \ll b<br>$$</p><p>假定 S 是有限偏序集，如果我们知道 S 中所有 a \ll b 的元素对 (a, b)，则知道 S 上的\ll 关系，S  中的序将完全清楚。<br>因为：x &lt; y 当且仅当 x \ll y 或 在S中存在元素 a_1, a_2, …,  a_m，使得：<br>$$<br>x \ll a_1 \ll a_2 \ll \cdots a_m \ll y<br>$$</p><p><strong>Hasse图</strong><br>Hasse图是有序偏序集 S 的直接图解，它的顶点是 S 的元素，当 a &lt;&lt;  b时，从a 到 b 有一个有向边。（此时，将 b 置于高于 a 的地方,然后画一条线将它们连起来；即，向上运动引起后元）。<br>因此， 在图中，从点x 到  y 有一有向路，当且仅当 x &lt; y。同样，在S的图中没有环，没有序关系是反对称的。</p><h3 id="极大元素，极小元素，最小元素和最大元素"><a href="#极大元素，极小元素，最小元素和最大元素" class="headerlink" title="极大元素，极小元素，最小元素和最大元素"></a>极大元素，极小元素，最小元素和最大元素</h3><p>设 S 为一个偏序集，a 为 S 中的一个元素，</p><p><strong>极小元素</strong>：如果 S 中没有其他元素严格先于 a。<br><strong>极大元素</strong>：如果 S  中没有其他元素严格后于 a。</p><p>（S 中可以有多于一个极小元素和极大元素；如果 S 是无限的，那么 S 可能没有极小或极大元素，即，如果 S 是有限的，那么 S  一定至少有一个极小元素和一个极大元素）</p><p><strong>最小元素</strong>：如果对于 S 中的每一个元素 x，有<br>$$<br>a \precsim x<br>$$<br>即 a  先于 S 中其他每一个元素。</p><p><strong>最大元素</strong>：如果对于 S 中的每一个元素 x，有<br>$$<br>a \succsim x<br>$$<br>即 a  后于 S 中其他每一个元素。</p><p>（S 至多有一个最小元素，它一定是极小元素；S 中至多有一个最大元素，它一定是极大元素。总的说来，甚至在 S 是有限时，S  可能既无最小元素，也无最大元素。例如当 S 中的存在多个极小元素或极大元素当且相互之间不可比较时。）</p><h2 id="相容编号"><a href="#相容编号" class="headerlink" title="相容编号"></a>相容编号</h2><p>设 S 是一个有限偏序集，对 S 中的每一个元素指派一个正整数，使得序关系能够保持。即求一个函数 f: S \to N 使得，如果 a \prec b,  那么 f(a) &lt; f(b)，这样的函数被称为 S 的相容编号。</p><p><strong>定理14.1</strong> 任何有限偏序集 A 存在相容编号。</p><h2 id="上确界-和-下确界"><a href="#上确界-和-下确界" class="headerlink" title="上确界 和 下确界"></a>上确界  和 下确界</h2><p>设 A 是偏序集 S 的一个子集，M 是 S 中的元素，<br><strong>上界</strong>：如果 M 后于 A 中的每一个元素，即 对于 A  中的每一个 x，有：<br>$$<br>x \precsim M<br>$$<br>M 叫做 A 的一个上界。</p><p><strong>上确界</strong>：如果A的一个上界先于 A 的其他每个上界，那么它叫做 A  的上确界，记为：<br>$$<br>sup(A)<br>$$<br>如果 A 含有元素 a_1, …, a _m，我们也将 sup(A)  记作：<br>$$<br>sup(a_1, \cdots, a_n)<br>$$</p><p>我们强调至多只有一个上确界sup(A)；当然 sup(A) 也可能不存在。</p><p>设 A 是偏序集 S 的一个子集，m 是 S 中的元素，<br><strong>下界</strong> 如果 m 后于 A 中的每一个元素，即 对于 A  中的每一个 x，有：<br>$$<br>x \succsim m<br>$$<br>M 叫做 A 的一个上界。</p><p><strong>下确界</strong>：如果 A 的一个下界后于 A 的其他每个下界，那么它叫做 A  的下确界，记为：<br>$$<br>inf(A)<br>$$<br>如果 A 含有元素 a_1, …, a _m，我们也将 inf(A)  记作：<br>$$<br>inf(a_1, \cdots, a_n)<br>$$</p><p>我们强调至多只有一个下确界 inf(A)；当然 inf(A) 也可能不存在。</p><p>有的书使用 最小上界 代替 上确界，写作 lub(A)；用 最大下界 代替 下确界，写作 glb(A)。</p><p>如果 A 有一个上界，我们称 A 是<strong>上有界</strong>的；如果 A 有一个下界，我们称 A  是下有界的；特别地，如果A有上界和下界，A 是有界的。</p><h2 id="同构序集"><a href="#同构序集" class="headerlink" title="同构序集"></a>同构序集</h2><p><strong>相似映射</strong> 假设 X 和 Y 是偏序集， f: X \to Y 是 A 的单射函数，如果f 保持序关系，即对于 X  中的任意元素 a 和 a’，下面两个条件成立：<br> 1. 若 a \precsim a’, 那么 f(a) \precsim f(a’)；<br> 2.  若 a || a’（不可比较），那么 f(a) || f(a’)；<br> 则 f 被叫做 X 到 Y 的相似映射。<br> （若A 和 B  是线性集，则只需要条件 1）</p><p><strong>同构</strong> 两个序集 X 和 Y 是同构的，如果存在一个保持序关系的双射 f: X \to Y，即一个同构映射  f，记作：<br>$$<br>X \simeq Y<br>$$</p><h2 id="良序集"><a href="#良序集" class="headerlink" title="良序集"></a>良序集</h2><p><strong>定义</strong> 如果序集 S 的每个一个子集都有最小元素，则 S 称为良序的。</p><h3 id="超限归纳法"><a href="#超限归纳法" class="headerlink" title="超限归纳法"></a>超限归纳法</h3><p>设 A 是一个良序集 S 的子集，并具有以下两个性质：<br> 1. a_0 \in A；<br> 2. 如果 s(a) \subseteq A，那么 a  \in A；<br> 则 A = S。<br> 此处的 a_0 是 S 中的最小元素，s(a) 称为 a 的前缀，即 S 中严格先于 a 的所有元素的集合。</p><h3 id="选择公理，良序定理"><a href="#选择公理，良序定理" class="headerlink" title="选择公理，良序定理"></a>选择公理，良序定理</h3><p><strong>选择函数</strong>：</p><p>设 { A_i : i \in I } 是一个非空的不交的集簇。<br>假设 A_i \subseteq X，函数 f: { A_i } \to X  叫做一个<strong>选择函数</strong>，如果 f(A_i) = a_i \in A_i。<br>换句话说，f 为每个集合 A_i 选择一点  a_i \in A_i。</p><p><strong>选择公理</strong> 任何一个非空集合的非空集簇都存在一个选择函数。</p><p><strong>良序定理</strong> 每一个集合 S 都能成为良序集。</p><h2 id="格"><a href="#格" class="headerlink" title="格"></a>格</h2><p>设 L 是对二元运算交 \land 和并 \lor 封闭的集合，如果对 L 中的任意元素a，b，c有：</p><ol>  <li>    <p>交换律：<br>$$<br>a \land b = b \land a, a \lor b = b \lor a<br>$$</p>  </li>  <li>    <p>结合律：<br>$$<br>(a \land b)\land c = a \land (b \land c), (a \lor b)\lor c      = a \lor (b \lor c)<br>$$</p>  </li>  <li>    <p>吸收律：<br>$$<br>a \land (a\lor b) = a, a\lor (a \land b) = a<br>$$</p>  </li></ol><p>称 L 为格。记 (L, \land, \lor) 表示格 L。</p><h3 id="对偶律-和-幂等律"><a href="#对偶律-和-幂等律" class="headerlink" title="对偶律 和 幂等律"></a>对偶律  和 幂等律</h3><p>对偶：一个格 (L, \land, \lor) 中任何一个命题的对偶命题是通过互换 \land 和 \lor 得到的。</p><p><strong>对偶原理</strong> 格 中任何一个定理的 对偶 还是 格 的一个定理。</p><p><strong>幂等律</strong> 1. a \land a = a 2. a \lor a = a</p><p>格 L 上的关系定义：<br>$$<br>a\land b = a \implies a \precsim b<br>$$</p><p>$$<br>a\lor b = b \implies a \precsim b<br>$$</p><p><strong>定理14.4</strong> 设 L 是一个格，那么：<br> 1. a \land b = a 当且仅当 a\lor b =  b；<br> 2. 关系 a \precsim b 是L的一个偏序；</p><p><strong>定理14.5</strong> 设 P 是一个偏序集使得对于任意a，b \in P，inf(a, b) 和 sup(a, b) 都存在，设  a\land b = inf(a, b), a\lor b = sup(a, b)。则 (P, \land,\ lor) 是一个格。进一步的，这个 格  推导出的偏序 与 原来的偏序 P 相同。</p><p><strong>替换定义</strong> 一个格是一个偏序集，在这个集合中，对任何一对元素 a 和 b：<br>$$<br>a \land b =  inf(a, b) 和 a \lor b = sup(a, b)<br>$$<br>都存在。</p><h3 id="子格，同构格"><a href="#子格，同构格" class="headerlink" title="子格，同构格"></a>子格，同构格</h3><p>假设 M 是格 L 的一个非空子集，</p><p>子格：若 M 本身也是一个格（关于 L 的运算），则 M 称为子格。</p><p>同构格：两个格 L 和 L’ 被认为是同构的，如果存在一个双射 f: L \to L’，使得对 L  中的任何元素a，b满足：<br>$$<br>f(a\land b) = f(a)\land f(b), f(a\lor b) = f(a) \lor  f(b)<br>$$</p><h2 id="有界格"><a href="#有界格" class="headerlink" title="有界格"></a>有界格</h2><p>一个格 L 称为有下界 0，如果对 L 中任何元素 x 都有 0 \precsim x，类似地，L 称为是有上界I，如果对 L 中任何元素 x  都有任何元素 x 都有 x \precsim I。我们说 L 是有界的，如果 L 有下界 0 和上界 I。<br>在这样的格中，对于 L  中的任意元素a，我们有下面的恒等式：<br>$$<br>a\lor I = I, a \land I = a, a \lor 0 = a, a \land  0 = 0<br>$$</p><p>对于非负整数的常序；<br>$$<br>0 &lt; 1 &lt; 2 &lt; 3 &lt; 4 &lt; \cdots<br>$$<br>有下界为  0，但没有上界。<br>全集U上所有子集构成的格 P(U) 是一个以 U 为上界，以 \emptyset 以下界的有界格。</p><p><strong>定理14.6</strong> 每一个有限格 L 都是有界的。</p><h2 id="分配格"><a href="#分配格" class="headerlink" title="分配格"></a>分配格</h2><p>对于格 L，如果对于 L 中任何元素a，b，c，成立如下定律：</p><ol>  <li>分配律<br>$$<br>a \land (b \lor c) = (a\land b)\lor (a\land c), a \lor (b    \land c) = (a \lor b)\land (a \lor c)<br>$$</li></ol><p>则称为<strong>分配格</strong>；否则，L 是非分配的。</p><p><strong>定理14.7</strong> 格 L 是非分配格当且仅当它包含一个形如下列的同构的子格。</p><p> l<br> / <br>c <br>| b<br>a /<br> \ /<br> 0</p><p>或：</p><p> l<br> / | <br>a b c<br> \ | /<br> 0</p><h3 id="并不可约元素，原子"><a href="#并不可约元素，原子" class="headerlink" title="并不可约元素，原子"></a>并不可约元素，原子</h3><p><strong>并不约元素</strong> 设 L 是一个以 0 为下界的格，对于L 中的一个元素 a，如果 a = x \lor y蕴含着 a = x  或 a = y。<br>显然，0 是并不可约的当且仅当a有唯一的直接前元。</p><p><strong>原子</strong> 0 的 直接继元 叫原子，是并不可约的。</p><p><strong>定理14.8</strong> 设 L 是一个有限分配格，则 L 中的每一个元素 a 都可以唯一（不计顺序）地写成 两两不可比的  并不可约的 元素的并。</p><h2 id="补元，有补格"><a href="#补元，有补格" class="headerlink" title="补元，有补格"></a>补元，有补格</h2><p><strong>补元</strong></p><p>设 L 是一个下界为 0，上界为 I 的有界格。a 是 L 中的一个元素，x 是 L 中的另一元素，如果：<br>$$<br>a \lor x = I,  a \land x = 0<br>$$<br>x 叫做 a 的一个补元。<br>补元不一定存在也不一定唯一。</p><p><strong>定理14.9</strong> 设 L 是一个有界的分配格，如果补元存在，那么它也是唯一的。</p><h3 id="有补格"><a href="#有补格" class="headerlink" title="有补格"></a>有补格</h3><p><strong>有补格</strong></p><p>如果格 L 是有界的，且 L 中的每一个元素都存在补元，则称 L 是有补格。</p><p><strong>定理14.10</strong> 设 L 是一个有唯一补元的有补格，那么 L 中的并不可约元素除 0 以外是它的原子。</p><p><strong>定理14.11</strong> 设 L 是一个有限的有补分配格，那么 L 中的每一个元素 a 都可以写成唯一的原子集合的并。</p><h1 id="附录-11"><a href="#附录-11" class="headerlink" title="附录"></a>附录</h1><h2 id="术语-9"><a href="#术语-9" class="headerlink" title="术语"></a>术语</h2><ul>  <li>自返性，返身性 reflexive</li>  <li>非返身性 irreflexive</li>  <li>反对称性 antisymmetric</li>  <li>传递性 transitive</li>  <li>偏序 partial order</li>  <li>序关系 order relation</li>  <li>偏序集 partially ordered set</li>  <li>有序集 ordered set, poset</li>  <li>常序 usual order</li>  <li>对偶序 dual order</li>  <li>诱导序 induced order</li>  <li>有序子集 ordered subsets</li>  <li>半序 quassi-order</li>  <li>可比较性 comparability</li>  <li>全序 totally ordered</li>  <li>线性序 linearly ordered</li>  <li>积集 product set</li>  <li>积序 product order</li>  <li>字典序 lexicographical order</li>  <li>Kleene闭包</li>  <li>字母序 alphabetical order</li>  <li>长度-字母序 short-lex order</li>  <li>直接前元 immediate predecessor</li>  <li>直接继承 immediate successor</li>  <li>盖住 cover</li>  <li>Hasse图 Hasse diagram</li>  <li>极大元素 minimal</li>  <li>极小元素 maximal</li>  <li>最小元素 first element</li>  <li>最大元素 last element</li>  <li>相容编号 consistent enumeration</li>  <li>上界 upper bound</li>  <li>上确界 supremum</li>  <li>下界 lower bound</li>  <li>下确界 infimum</li>  <li>最小上界 least upper bound</li>  <li>最大下界 greatest lower bound</li>  <li>上有界 bounded above</li>  <li>下有界 bounded below</li>  <li>有界 bounded</li>  <li>相似映射 similarity mapping</li>  <li>同构 isomorphic, similar</li>  <li>超限归纳法 transfinite induction</li>  <li>选择函数 choice function</li>  <li>选择公理 Axiom of Choice</li>  <li>良序定理 Well-Ordering Theorem</li>  <li>格 lattice<ul>      <li>交换律 Commutation law</li>      <li>结合律 Associative law</li>      <li>吸收律 Absorption law</li>      <li>对偶 dual</li>      <li>对偶律 Dulaity law</li>      <li>幂等律 Idempotent law</li>      <li>子格 sublattice</li>      <li>同构格 isomorphic lattice</li>      <li>分配格 distributive lattice</li>      <li>并不可约元素 irreducible element</li>      <li>原子 atom</li>      <li>补元 complement</li>      <li>有补格 complemented lattice</li>    </ul>  </li></ul><h3 id="examples-tex-1"><a href="#examples-tex-1" class="headerlink" title="examples.tex"></a>examples.tex</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">  \usepackage&#123;amsmath&#125;</span><br><span class="line">  \usepackage&#123;amssymb&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item For a relation $R$ on $\mathbf&#123;Z&#125;$,</span><br><span class="line">  define $aRb$ if there is postive integer $r$ such that $a = b^r$.</span><br><span class="line">  Prove that R is a partial ordering of $\mathbf&#123;Z&#125;$.</span><br><span class="line"></span><br><span class="line">  \item Prove:</span><br><span class="line">  $</span><br><span class="line">  \forall a, b \in S, a\prec b \implies (a\precsim b \land a \neq b)</span><br><span class="line">  $.</span><br><span class="line"></span><br><span class="line">  \item Prove that quassi-ordered is not symmetry: $a\prec b \implies b \not\prec a$.</span><br><span class="line"></span><br><span class="line">  \item Prove: Suppose $S$ is finite poset with $n$ elements.</span><br><span class="line">  Then there exists a consistent enumeration $f: S\to \&#123;1, 2, \cdots, n\&#125;$.</span><br><span class="line"></span><br><span class="line">  \item Give an example of a finite nonlineraly ordered set $X = (A, R)$ which is</span><br><span class="line">  isomorphic to $Y = (A, R^&#123;-1&#125;)$, the set $A$ with the inverse order.</span><br><span class="line"></span><br><span class="line">  \item Prove the Principle of Transfinite Induction:</span><br><span class="line">  Let $A$ be a subset of a well-ordered set $S$</span><br><span class="line">  with the following two properties:</span><br><span class="line"></span><br><span class="line">  i. $a_0 \in A$, ii. $s(a) \subseteq A \implies a \in A$.</span><br><span class="line"></span><br><span class="line">  Then $A = S$.</span><br><span class="line"></span><br><span class="line">  \item Let $S$ be a well-ordered set. Let $f: S\to S$ be a similarity mapping of $S$ into $S$.</span><br><span class="line">  Prove that: $\forall a \in S \implies a \precsim f(a)$.</span><br><span class="line"></span><br><span class="line">  \item Let $A$ be a well-ordered set. Let $s(A)$ denote the collection of</span><br><span class="line">  all initial segments $s(a)$ of elements $a\in A$ ordered by set inclusion.</span><br><span class="line">  Prove: $A$ is isomorphic to $s(A)$ by showing that the map $f: A\to s(A)$,</span><br><span class="line">  defined by $f(a) = s(a)$, is a similarity mapping of $A$ onto $s(A)$.</span><br><span class="line"></span><br><span class="line">  \item Write the dual of each statement:</span><br><span class="line"></span><br><span class="line">  i. $(a\land b)\lor c = (b\lor c)\land(c\lor a)$;</span><br><span class="line">  ii. $(a\land b)\lor a = a\land(b\lor a)$.</span><br><span class="line"></span><br><span class="line">  \item Prove: Let $L$ be a lattice, then:</span><br><span class="line"></span><br><span class="line">  i. $a \land b = a \iff a \lor b = b$;</span><br><span class="line"></span><br><span class="line">  ii. The relation $a\precsim b$(defined by $a\land b = a$ or $a\lor b = b$)</span><br><span class="line">  is a partial order on $L$.</span><br><span class="line"></span><br><span class="line">  \item Prove: Let $L$ be a finite distributive lattice.</span><br><span class="line">  Then every $a\in L$ can be written uniquely(except for order)</span><br><span class="line">  as the join of irredudant join irreducible elements.</span><br><span class="line"></span><br><span class="line">  \item Prove: Let $L$ be a complemented lattice with unique complements.</span><br><span class="line">  Then the join irreducible elements of $L$, other than $0$, are its atoms.</span><br><span class="line"></span><br><span class="line">  \item Give a example of an infinite lattice $L$ with finite length.</span><br><span class="line"></span><br><span class="line">  \item Show that the isomorphic relation $A\simeq B$ for ordered sets is an equivalence relation, that is:</span><br><span class="line"></span><br><span class="line">  i. for any ordered set $A$, $A\simeq A$;</span><br><span class="line"></span><br><span class="line">  ii. $A\simeq B \implies B\simeq A$;</span><br><span class="line"></span><br><span class="line">  iii. $A\simeq B \land B\simeq C \implies A\simeq C$.</span><br><span class="line"></span><br><span class="line">  \item Let $A = \&#123;a, b, c\&#125;$ be linearly ordered by $a &lt; b &lt; c$,</span><br><span class="line">  and let $\mathbf&#123;N&#125;$ have the usual order $\leq$. Prove:</span><br><span class="line"></span><br><span class="line">  i. $S = \&#123;A; \mathbf&#123;N&#125;\&#125;$ is isomorphic to $\mathbf&#123;N&#125;$;</span><br><span class="line"></span><br><span class="line">  ii. $S&apos; = \&#123;\mathbf&#123;N&#125;; A\&#125;$ is not isomorphic to $\mathbf&#123;N&#125;$.</span><br><span class="line"></span><br><span class="line">  \item Suppose $A$ and $B$ are well-ordered isomorphic sets.</span><br><span class="line">  Show that there is only one similarity mapping $f: A\to B$.</span><br><span class="line"></span><br><span class="line">  \item Let S be a well-ordered set. For any $a \in S$, the set $s(a) = \&#123;x | x\prec a\&#125;$</span><br><span class="line">  is called an \textsl&#123;initial segments&#125; of a. Show that $S$ cannot be isomorphic to one of</span><br><span class="line">  its \textsl&#123;initial segments&#125;.</span><br><span class="line"></span><br><span class="line">  \item Suppose $s(a)$ and $s(b)$ are distinct initial segments of a well-ordered set $S$.</span><br><span class="line">  Show that $s(a)$ and $s(b)$ cannot be isomorphic.</span><br><span class="line"></span><br><span class="line">  \item A lattice M is said to be \textsl&#123;modular&#125; if whenever $a \leq c$ we have the law:</span><br><span class="line">  $$</span><br><span class="line">  a \lor (b \land c) = (a \lor b) \land c</span><br><span class="line">  $$</span><br><span class="line"></span><br><span class="line">  Prove that every distributive lattice is modular.</span><br><span class="line"></span><br><span class="line">  \item Let $R$ be a ring. Let $L$ be the collection of all ideals of $R$.</span><br><span class="line">  Prove that $L$ is a bounded lattice where, for any ideals $J$ and $K$ of $R$,</span><br><span class="line">  we define: $J \lor K = J + K$ and $J \land K = J \cap K$.</span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>text.ts</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>      </td>      <td class="code">        <pre><span class="line">import productOrder from &apos;./product-order&apos;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">const ascendProductOrder = productOrder((l: number, r: number) =&gt; &#123;</span><br><span class="line">  if (l &gt; r) return 1</span><br><span class="line">  if (l &lt; r) return -1</span><br><span class="line">  return 0</span><br><span class="line">&#125;)</span><br><span class="line">const descendProductOrder = productOrder((l: number, r: number) =&gt; &#123;</span><br><span class="line">  if (l &gt; r) return -1</span><br><span class="line">  if (l &lt; r) return 1</span><br><span class="line">  return 0</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const sl = new Set([2, 3, 1, 4])</span><br><span class="line">const sr = new Set([8, 5, 7, 6])</span><br><span class="line">console.log(ascendProductOrder(sl, sr))</span><br><span class="line">console.log(descendProductOrder(sl, sr))</span><br></pre>      </td>    </tr>  </table></figure><p>product-order.ts</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line">// 求两个偏序集的积序</span><br><span class="line"></span><br><span class="line">type SortFn&lt;T&gt;         = (e1: T, e2: T) =&gt; number</span><br><span class="line">type SetSortFn&lt;T&gt;      = (set: Set&lt;T&gt;) =&gt; Array&lt;T&gt;</span><br><span class="line">type ProductSet&lt;T&gt;     = Set&lt;[T, T]&gt;</span><br><span class="line">type ProductOrderFn&lt;T&gt; = (s1: Set&lt;T&gt;, s2: Set&lt;T&gt;) =&gt; ProductSet&lt;T&gt;</span><br><span class="line"></span><br><span class="line">export default function productOrder&lt;T&gt;(</span><br><span class="line">  sortFn: SortFn&lt;T&gt;</span><br><span class="line">): ProductOrderFn&lt;T&gt; &#123;</span><br><span class="line">  const $SORT: SetSortFn&lt;T&gt; = set =&gt; Array.from(set).sort(sortFn)</span><br><span class="line"></span><br><span class="line">  return function(s1, s2) &#123;</span><br><span class="line">    let a1 = $SORT(s1),</span><br><span class="line">        a2 = $SORT(s2)</span><br><span class="line">    let set: ProductSet&lt;T&gt; = new Set()</span><br><span class="line"></span><br><span class="line">    a1.forEach(e1 =&gt; &#123;</span><br><span class="line">      a2.forEach(e2 =&gt; &#123;</span><br><span class="line">        set.add([e1, e2])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return set</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>tsconfig.json</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es6&quot;,</span><br><span class="line">    &quot;lib&quot;: [</span><br><span class="line">      &quot;es2016&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h1 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h1><p>重点难点：</p><ul>  <li>布尔代数的概念</li>  <li>子布尔代数</li>  <li>同构的布尔代数</li>  <li>布尔代数与格</li>  <li>表示定理</li></ul><h1 id="布尔代数-1"><a href="#布尔代数-1" class="headerlink" title="布尔代数"></a>布尔代数</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>设 B 是一个非空集合，具有二元运算 + 和 *，一元运算`和两个不同的元素0，1，若对于任意的 a, b, c \in B，以下公理成立，则称 B  为一个布尔代数：</p><p>交换律： a + b = b + a,<br> a * b = b * a<br>分配律： a + (b * c) = (a + b) * (a +  c),<br> a * (b + c) = (a * b) + (a * c)<br>单位元律： a + 0 = a, a * 1 = a<br>互补律：  a + a’ = 1, a * a’ = 0<br>当我们要强调其六个部分时，用(B, +, *, ‘, 0, 1)来表示一个布尔代数，称 0 为零元素，1  为单位元素，a’ 为 a 的补/</p><p>运算 +, * 与 ‘ 分别称为 和，积，与补。<br>优先级：’ 运算优先于 * 优先于 +。</p><h3 id="子代数，同构的布尔代数"><a href="#子代数，同构的布尔代数" class="headerlink" title="子代数，同构的布尔代数"></a>子代数，同构的布尔代数</h3><p>子代数：设 C 是布尔代数 B 的一个非空子集，如果 C 本身是布尔代数（相对于 B 的运算），我们说称 C 是 B 的一个子代数。<br>注意 C 是  B 的一个子代数当且仅当 C 对于 B 中的三种运算，都是封闭的。</p><p>同构：两个布尔代数 B 和 B’ 称为同构的，如果有一一对应（双射）f: B \to B’，并保持这三种运算，即使得对于 B 中任意元素 a 和  b，有：<br>$$<br>f(a + b) = f(a) + f(b), f(a * b) = f(a) * f(b), f(a’) =  f(a)’<br>$$</p><h2 id="对偶性-1"><a href="#对偶性-1" class="headerlink" title="对偶性"></a>对偶性</h2><p>在布尔代数中，任意命题的对偶是由在原命题中交换运算 + 和 *，并交换单位元 0 和 1 得到的命题。</p><p><strong>对偶原理</strong> 任何布尔代数的真命题的对偶仍是真命题。</p><h2 id="布尔代数的基本定理"><a href="#布尔代数的基本定理" class="headerlink" title="布尔代数的基本定理"></a>布尔代数的基本定理</h2><p><strong>定理15.2</strong> 设 a, b, c 是布尔代数 B 中的任意元素，</p><ol>  <li>幂等律<br>a + a = a, a * a = a</li>  <li>有界律<br>a + 1 = 1, a * 0 = 0</li>  <li>吸收律<br>a + (a * b) = a, a * (a + b) = a</li>  <li>结合律<br>(a + b) + c = a + (b + c), (a * b) * c = a * (b * c)</li></ol><p><strong>定理15.2</strong> 设 a 是布尔代数 B 中的任意元素，</p><ol>  <li>补的唯一性<br>a + x = 1 \land a * x = 0 \implies x = a’</li>  <li>对合律<br>(a’)’ = a</li>  <li>0’ = 1, 1’ = 0</li></ol><p><strong>DeMorgan律</strong></p><p>(a + b)’ = a’ * b’, (a * b)’ = a’ + b’</p><h2 id="作为格的布尔代数"><a href="#作为格的布尔代数" class="headerlink" title="作为格的布尔代数"></a>作为格的布尔代数</h2><p>由于每个布尔代数都满足结合律，交换律和吸收律，因此它是一个格。并且，+ 和 * 分别为 \lor 和 \land 运算。<br>相对这个格，对于任意元素  a \in B，a + 1 = 1 蕴含 a &lt;= 1，而 a * 0 = 0 蕴含 0 &lt;= a。于是，B 是一个有界格。<br>此外，B  也是一个分配格和有补格。反之，每个有界的，分配的，有补的格 L 也满足布尔代数的定义。</p><p><strong>替换定义</strong> 一个布尔代数 B 是一个有界的、分配的、有补的格。反之。</p><p>定理15.5 在布尔代数中，下列条件是等价的：</p><ol>  <li>a + b = b, 2. a * b = a</li>  <li>a’ + b = 1, 4. a * b’ = 0<br>这样，在布尔代数中，只要知道上列四个条件之一是正确的话，我们就可以写 a &lt;= b。  </li></ol><h2 id="表示定理"><a href="#表示定理" class="headerlink" title="表示定理"></a>表示定理</h2><p>设 B 是一个有限的布尔代数，A 是 B 的原子的集合，且 P(A) 是原子集 A 的所有子集的布尔代数。</p><p>函数 f: B \to P(A) 表示：<br>$$<br>f(x) = { a_1, a_2, \cdots, a_r }<br>$$</p><p><strong>定理15.6</strong> 映射 f: B \to P(A) 是一个同构映射。</p><p><strong>推论15.7</strong> 一个有限的布尔代数有 2^n 个元素，n 为正整数<br>因此，布尔代数至少有 2 个元素。</p><h2 id="集合的积和式"><a href="#集合的积和式" class="headerlink" title="集合的积和式"></a>集合的积和式</h2><h2 id="布尔代数的积和式"><a href="#布尔代数的积和式" class="headerlink" title="布尔代数的积和式"></a>布尔代数的积和式</h2><p><strong>定义</strong> 若布尔表达式 E 是一个基本积或是两个更多基本积的和，且这些积是互不包含的，这样的一个布尔表达式 E  被称为<strong>积和表达式</strong>。</p><p><strong>定义</strong> 设 E 是任意的布尔表达式，E 的一个<strong>积和式</strong>是一个等价的布尔积和表达式。</p><p><strong>定理</strong> 每个非零元的布尔表达式 E = E(x1, x2, …, xn)等价于唯一的完全积和表达式。</p><h2 id="极小布尔表达式，素隐项"><a href="#极小布尔表达式，素隐项" class="headerlink" title="极小布尔表达式，素隐项"></a>极小布尔表达式，素隐项</h2><h3 id="极小的积和式"><a href="#极小的积和式" class="headerlink" title="极小的积和式"></a>极小的积和式</h3><p>我们说 E 是极小的，如果没有比 E 简洁的等价的积和表达式。（可能有不止一种极小积和表达式）</p><h3 id="素隐项"><a href="#素隐项" class="headerlink" title="素隐项"></a>素隐项</h3><p>一个基本积 P 被称作一个布尔表达式 E 的素隐项，若：<br>$$<br>P + E = E<br>$$</p><p>且 P 中不包含齿条这个性质的其他基本积。</p><p><strong>定理</strong> 一个布尔表达式 E 的极小积和表达式是 E 的素隐项的和。</p><h3 id="基本积的共识"><a href="#基本积的共识" class="headerlink" title="基本积的共识"></a>基本积的共识</h3><p><strong>引理</strong> 假设 Q 是 P1 和 P2 的共识，那么<br>$$<br>P_1 + P_2 + Q = P_1 +  P_2<br>$$</p><h1 id="附录-12"><a href="#附录-12" class="headerlink" title="附录"></a>附录</h1><h2 id="术语-10"><a href="#术语-10" class="headerlink" title="术语"></a>术语</h2><ul>  <li>布尔代数 Boolean Algebra</li>  <li>交换律 commutative laws</li>  <li>分配律 distriutive laws</li>  <li>单位元律 identity laws</li>  <li>互补律 complement laws</li>  <li>零元素 zero element</li>  <li>单位元素 unit element</li>  <li>子代数 subalgebras</li>  <li>同构的布尔代数 isomorphic Boolean Algebra</li>  <li>对偶性 duality</li>  <li>幂等律 idempotent laws</li>  <li>有界律 boundedness laws</li>  <li>吸收律 absorption laws</li>  <li>结合律 associative laws</li>  <li>补的唯一性 uniqueness of complement</li>  <li>对合律 involution laws</li>  <li>DeMorgan律 DeMorgan’s laws</li>  <li>布尔代数的替换定义 alternate definition</li>  <li>表示定理 representation theorem</li></ul><h3 id="theorem-tex"><a href="#theorem-tex" class="headerlink" title="theorem.tex"></a>theorem.tex</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre>      </td>      <td class="code">        <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">  \usepackage&#123;amsmath&#125;</span><br><span class="line">  \usepackage&#123;amssymb&#125;</span><br><span class="line">  \newcommand&#123;\setcomp&#125;[1] &#123;&#123;#1&#125;^&#123;\mathsf&#123;c&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">Idempotent laws: 1. $x + x = x$; 2. $x * x = 0$.</span><br><span class="line"></span><br><span class="line">Proof 1:</span><br><span class="line"></span><br><span class="line">\begin&#123;eqnarray*&#125;</span><br><span class="line">x + x &amp; = &amp; (x + x) * 1 \\</span><br><span class="line">&amp; = &amp; (x + x) * (x + x&apos;) \\</span><br><span class="line">&amp; = &amp; x + (x * x&apos;) \\</span><br><span class="line">&amp; = &amp; x + 0 \\</span><br><span class="line">&amp; = &amp; x</span><br><span class="line">\end&#123;eqnarray*&#125;</span><br><span class="line"></span><br><span class="line">Key: $x + (x * x&apos;) = (x + x) * (x + x&apos;)$</span><br><span class="line"></span><br><span class="line">Proof 2:</span><br><span class="line"></span><br><span class="line">\begin&#123;eqnarray*&#125;</span><br><span class="line">x * x &amp; = &amp; (x * x) + 0 \\</span><br><span class="line">&amp; = &amp; (x * x) + (x * x&apos;) \\</span><br><span class="line">&amp; = &amp; x * (x + x&apos;) \\</span><br><span class="line">&amp; = &amp; x * 1 \\</span><br><span class="line">&amp; = &amp; x</span><br><span class="line">\end&#123;eqnarray*&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三大基础数学复习：离散数学&lt;/p&gt;
    
    </summary>
    
      <category term="数学基础" scheme="http://javastar.club/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数学基础" scheme="http://javastar.club/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数学基础复习</title>
    <link href="http://javastar.club/archives/83ff8e26.html"/>
    <id>http://javastar.club/archives/83ff8e26.html</id>
    <published>2019-08-05T07:00:43.000Z</published>
    <updated>2019-08-07T07:14:52.720Z</updated>
    
    <content type="html"><![CDATA[<p>三大基础数学复习</p><a id="more"></a><h1 id="一、高等数学复习"><a href="#一、高等数学复习" class="headerlink" title="一、高等数学复习"></a>一、高等数学复习</h1><h2 id="高数-上"><a href="#高数-上" class="headerlink" title="高数(上)"></a>高数(上)</h2><h3 id="第一章、函数与极限"><a href="#第一章、函数与极限" class="headerlink" title="第一章、函数与极限"></a>第一章、函数与极限</h3><ol>  <li>函数</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/1.%E5%87%BD%E6%95%B0/1%E5%87%BD%E6%95%B0_1.jpg" alt="函数与极限"></p><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/1.%E5%87%BD%E6%95%B0/1%E5%87%BD%E6%95%B0_2.jpg" alt="函数与极限"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/1.%E5%87%BD%E6%95%B0/1%E5%87%BD%E6%95%B0_3.jpg" alt="测试"></p><ol start="2">  <li>数列极限 </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/2.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/2%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/2.%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/2%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90_2.jpg" alt="测试"></p><ol start="3">  <li>函数极限</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/3.%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/3%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/3.%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/3%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/3.%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/3%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90_3.jpg" alt="测试"></p><ol start="4">  <li>无穷小和无穷大</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/4.%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7/4%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/4.%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7/4%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7_2.jpg" alt="测试"></p><ol start="5">  <li>极限的运算法则</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/5.%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/5%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/5.%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/5%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/5.%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/5%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/5.%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/5%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99_4.jpg" alt="测试"></p><ol start="6">  <li>极限存在准则 两个重要极限<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/6.%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90/6%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90_1.jpg" alt="测试">  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/6.%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90/6%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/6.%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90/6%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/6.%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90/6%E6%9E%81%E9%99%90%E5%AD%98%E5%9C%A8%E5%87%86%E5%88%99%20%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E6%9E%81%E9%99%90_4.jpg" alt="测试"></p><ol start="7">  <li>无穷小的比较</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/7.%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83/7%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/7.%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83/7%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/7.%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83/7%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83_3.jpg" alt="测试"></p><ol start="8">  <li>函数的连续型与间断点</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/8.%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E4%B8%8E%E9%97%B4%E6%96%AD%E7%82%B9/8%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E9%97%B4%E6%96%AD%E7%82%B9_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/8.%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E4%B8%8E%E9%97%B4%E6%96%AD%E7%82%B9/8%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E9%97%B4%E6%96%AD%E7%82%B9_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/8.%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E4%B8%8E%E9%97%B4%E6%96%AD%E7%82%B9/8%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7%E5%92%8C%E9%97%B4%E6%96%AD%E7%82%B9_3.jpg" alt="测试"></p><ol start="9">  <li>连续函数运算及初等函数连续性</li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/9.%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7/9%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/9.%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7/9%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7_2.jpg" alt="测试"></p><ol start="10">  <li>闭区间上连续函数的性质<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/10.%E9%97%AD%E5%8C%BA%E9%97%B4%E4%B8%8A%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8/10%E9%97%AD%E5%8C%BA%E9%97%B4%E4%B8%8A%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/10.%E9%97%AD%E5%8C%BA%E9%97%B4%E4%B8%8A%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8/10%E9%97%AD%E5%8C%BA%E9%97%B4%E4%B8%8A%E8%BF%9E%E7%BB%AD%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8_2.jpg" alt="测试">  </li></ol><h3 id="第二章、导数与微分"><a href="#第二章、导数与微分" class="headerlink" title="第二章、导数与微分"></a>第二章、导数与微分</h3><ol>  <li>    <p>导数的概念<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/1.%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/1%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/1.%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/1%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/1.%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/1%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/1.%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/1%E5%AF%BC%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5_4.jpg" alt="测试">    </p>  </li>  <li>    <p>求导法则(一)</p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/2.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%B8%80)_1.jpg" alt="测试">_  <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/2.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%B8%80)_2.jpg" alt="测试">_  <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/2.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%B8%80)_3.jpg" alt="测试">_</p><ol start="3">  <li>    <p>求导法则(二)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/3.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%BA%8C)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/3.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%BA%8C)_2.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/3.%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99(%E4%BA%8C)_3.jpg" alt="测试">_    </p>  </li>  <li>    <p>高阶导数<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/4.%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/4%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/4.%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/4%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/4.%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/4%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/4.%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/4%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0_4.jpg" alt="测试">    </p>  </li>  <li>    <p>隐函数及由参数方程确定的函数求导<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/5.%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/5%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/5.%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/5%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/5.%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/5%E9%9A%90%E5%87%BD%E6%95%B0%E5%8F%8A%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC_3.jpg" alt="测试">    </p>  </li>  <li>    <p>微分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_4.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_5.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/6.%E5%BE%AE%E5%88%86/6%E5%BE%AE%E5%88%86_6.jpg" alt="测试">    </p>  </li></ol><h3 id="第三章-微分中值定理及导数的应用"><a href="#第三章-微分中值定理及导数的应用" class="headerlink" title="第三章 微分中值定理及导数的应用"></a>第三章  微分中值定理及导数的应用</h3><ol>  <li>微分中值定理(一)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/1.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/1%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%B8%80)_1.jpg" alt="测试">_    <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/1.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/1%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%B8%80)_2.jpg" alt="测试">_  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/1.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/1%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%B8%80)_3.jpg" alt="测试">_</p><ol start="2">  <li>    <p>微分中值定理(二)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/2.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%BA%8C)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/2.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%BA%8C)_2.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/2.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%BA%8C)_3.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/2.%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86(%E4%BA%8C)_4.jpg" alt="测试">_    </p>  </li>  <li>    <p>洛必达法则<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/3.%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/3%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99_1.jpg" alt="测试">    </p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/3.%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/3%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/3.%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/3%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99_3.jpg" alt="测试"></p><ol start="4">  <li>    <p>Taylor公式<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/4.Taylor%E5%85%AC%E5%BC%8F/4%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/4.Taylor%E5%85%AC%E5%BC%8F/4%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/4.Taylor%E5%85%AC%E5%BC%8F/4%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/4.Taylor%E5%85%AC%E5%BC%8F/4%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F_4.jpg" alt="测试">    </p>  </li>  <li>    <p>函数单调性与曲线凹凸性(一)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/5.%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89/5%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7(%E4%B8%80)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/5.%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89/5%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7(%E4%B8%80)_2.jpg" alt="测试">_    </p>  </li>  <li>    <p>函数单调性与曲线凹凸性（二）<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/6.%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89/6%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7(%E4%BA%8C)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/6.%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89/6%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7(%E4%BA%8C)_2.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/6.%E5%87%BD%E6%95%B0%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89/6%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E5%87%B9%E5%87%B8%E6%80%A7(%E4%BA%8C)_3.jpg" alt="测试">_    </p>  </li>  <li>    <p>极值与最值<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/7.%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/7%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/7.%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/7%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/7.%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/7%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/7.%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/7%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC_4.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/7.%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/7%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC_5.jpg" alt="测试">    </p>  </li>  <li>    <p>函数图像描绘<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/8.%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98/8%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/8.%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98/8%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/8.%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98/8%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F%E6%8F%8F%E7%BB%98_3.jpg" alt="测试">    </p>  </li>  <li>    <p>弧微分与曲率</p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/9.%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87/9%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%8F%8A%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/9.%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87/9%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87_2.jpg" alt="测试"></p><h3 id="第四章-不定积分"><a href="#第四章-不定积分" class="headerlink" title="第四章 不定积分"></a>第四章  不定积分</h3><ol>  <li>    <p>不定积分的概念与性质<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/1.%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/1%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/1.%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/1%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/1.%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/1%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_3.jpg" alt="测试">    </p>  </li>  <li>    <p>换元积分法(一)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/2.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%B8%80)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/2.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%B8%80)_2.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/2.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%B8%80)_3.jpg" alt="测试">_    </p>  </li>  <li>    <p>换元积分法(二)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%BA%8C)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%BA%8C)_2.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%BA%8C)_3.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/3%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95(%E4%BA%8C)_4.jpg" alt="测试">_    </p>  </li>  <li>    <p>分部积分法<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_3.jpg" alt="测试">    </p>  </li></ol><h3 id="第五章、定积分"><a href="#第五章、定积分" class="headerlink" title="第五章、定积分"></a>第五章、定积分</h3><ol>  <li>    <p>定积分的概念与性质<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/1.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8%EF%BC%88%E4%B8%80%EF%BC%89/1%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/1.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8%EF%BC%88%E4%B8%80%EF%BC%89/1%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_2.jpg" alt="测试">    </p>  </li>  <li>    <p>定积分的概念与性质(二)<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/2.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8(%E4%BA%8C)_1.jpg" alt="测试">_      <img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/2.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8%EF%BC%88%E4%BA%8C%EF%BC%89/2%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8(%E4%BA%8C)_2.jpg" alt="测试">_    </p>  </li>  <li>    <p>积分基本公式<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/3%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/3%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/3.%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/3%E7%A7%AF%E5%88%86%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F_3.jpg" alt="测试">    </p>  </li>  <li>    <p>定积分的换元积分法与分部积分法<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_4.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/4.%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95/4%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E6%8D%A2%E5%85%83%E7%A7%AF%E5%88%86%E6%B3%95%E4%B8%8E%E5%88%86%E9%83%A8%E7%A7%AF%E5%88%86%E6%B3%95_5.jpg" alt="测试">    </p>  </li>  <li>    <p>反常积分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/5.%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/5%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/5.%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/5%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/5.%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/5%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/5.%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/5%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86_4.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86/5.%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/5%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86_5.jpg" alt="测试">    </p>  </li></ol><h3 id="第六章-定积分应用"><a href="#第六章-定积分应用" class="headerlink" title="第六章 定积分应用"></a>第六章  定积分应用</h3><ol>  <li>    <p>元素法<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/1.%E5%85%83%E7%B4%A0%E6%B3%95/1%E5%85%83%E7%B4%A0%E6%B3%95.jpg" alt="测试">    </p>  </li>  <li>    <p>几何应用<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/2.%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/2%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/2.%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/2%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/2.%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/2%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/2.%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/2%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_4.jpg" alt="测试">    </p>  </li>  <li>    <p>定积分在物理学上的应用<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%AE%9A%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/3.%E5%AE%9A%E7%A7%AF%E5%88%86%E5%9C%A8%E7%89%A9%E7%90%86%E5%AD%A6%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/3%E5%AE%9A%E7%A7%AF%E5%88%86%E5%9C%A8%E7%89%A9%E7%90%86%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8.jpg" alt="测试">    </p>  </li></ol><h3 id="第七章-微分方程"><a href="#第七章-微分方程" class="headerlink" title="第七章 微分方程"></a>第七章  微分方程</h3><ol>  <li>    <p>微分方程的基本概念<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/1.%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpg" alt="测试">    </p>  </li>  <li>    <p>可分离变量的微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/2.%E5%8F%AF%E5%88%86%E7%A6%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/2%E5%8F%AF%E5%88%86%E7%A6%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B.jpg" alt="测试">    </p>  </li>  <li>    <p>齐次微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/3.%E9%BD%90%E6%AC%A1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/3%E9%BD%90%E6%AC%A1%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B.jpg" alt="测试">    </p>  </li>  <li>    <p>一阶线性微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/4.%E4%B8%80%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/4%E4%B8%80%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/4.%E4%B8%80%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/4%E4%B8%80%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">    </p>  </li>  <li>    <p>可降阶的高阶微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/5.%E5%8F%AF%E9%99%8D%E9%98%B6%E7%9A%84%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/5%E5%8F%AF%E9%99%8D%E9%98%B6%E7%9A%84%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/5.%E5%8F%AF%E9%99%8D%E9%98%B6%E7%9A%84%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/5%E5%8F%AF%E9%99%8D%E9%98%B6%E7%9A%84%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">    </p>  </li>  <li>    <p>高阶线性微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/6.%E9%AB%98%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/6%E9%AB%98%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/6.%E9%AB%98%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/6%E9%AB%98%E9%98%B6%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">    </p>  </li>  <li>    <p>常系数齐次线性微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7.%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7.%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">    </p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7.%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/7%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_3.jpg" alt="测试"></p><ol start="8">  <li>常系数非齐次线性微分方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/8.%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/8%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8A%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/8.%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/8%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">  </li></ol><h2 id="高数-下"><a href="#高数-下" class="headerlink" title="高数(下)"></a>高数(下)</h2><h3 id="第八章-向量代数与空间解析几何"><a href="#第八章-向量代数与空间解析几何" class="headerlink" title="第八章 向量代数与空间解析几何"></a>第八章  向量代数与空间解析几何</h3><ol>  <li>    <p>向量及其线性运算<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/1.%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97/1%E5%90%91%E9%87%8F%E5%8F%8A%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/1.%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97/1%E5%90%91%E9%87%8F%E5%8F%8A%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/1.%E5%90%91%E9%87%8F%E5%8F%8A%E5%85%B6%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97/1%E5%90%91%E9%87%8F%E5%8F%8A%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97_3.jpg" alt="测试">    </p>  </li>  <li>    <p>向量的数量积与向量积<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/2.%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF/2%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/2.%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF/2%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/2.%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF/2%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F%E7%A7%AF%E4%B8%8E%E5%90%91%E9%87%8F%E7%A7%AF_3.jpg" alt="测试">    </p>  </li>  <li>    <p>向量应用（一）——平面及其方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/3.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B/3%E5%BA%94%E7%94%A8(%E4%B8%80)%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/3.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B/3%E5%BA%94%E7%94%A8(%E4%B8%80)%E5%B9%B3%E9%9D%A2%E5%8F%8A%E5%85%B6%E6%96%B9%E7%A8%8B_2.jpg" alt="测试">    </p>  </li>  <li>    <p>应用(二)空间直线<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/4.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF/4%E5%BA%94%E7%94%A8(%E4%BA%8C)%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/4.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF/4%E5%BA%94%E7%94%A8(%E4%BA%8C)%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/4.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF/4%E5%BA%94%E7%94%A8(%E4%BA%8C)%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF_3.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/4.%E5%90%91%E9%87%8F%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF/4%E5%BA%94%E7%94%A8(%E4%BA%8C)%E7%A9%BA%E9%97%B4%E7%9B%B4%E7%BA%BF_4.jpg" alt="测试">    </p>  </li>  <li>    <p>空间曲面及方程<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/5.%E7%A9%BA%E9%97%B4%E6%9B%B2%E9%9D%A2%E5%8F%8A%E6%96%B9%E7%A8%8B/5%E7%A9%BA%E9%97%B4%E6%9B%B2%E9%9D%A2%E5%8F%8A%E6%96%B9%E7%A8%8B.jpg" alt="测试">    </p>  </li>  <li>    <p>空间曲线及方程</p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/6.%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BF%E5%8F%8A%E6%96%B9%E7%A8%8B/6%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BF%E5%8F%8A%E6%96%B9%E7%A8%8B_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/6.%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BF%E5%8F%8A%E6%96%B9%E7%A8%8B/6%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BF%E5%8F%8A%E6%96%B9%E7%A8%8B_2.jpg" alt="测试"></p><h3 id="第九章-多元函数微分学及应用"><a href="#第九章-多元函数微分学及应用" class="headerlink" title="第九章 多元函数微分学及应用"></a>第九章  多元函数微分学及应用</h3><ol>  <li>    <p>多元函数的基本概念<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/1.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/1.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/1.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_3.jpg" alt="测试">    </p>  </li>  <li>    <p>偏导数<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/2.%E5%81%8F%E5%AF%BC%E6%95%B0/2%E5%81%8F%E5%AF%BC%E6%95%B0_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/2.%E5%81%8F%E5%AF%BC%E6%95%B0/2%E5%81%8F%E5%AF%BC%E6%95%B0_2.jpg" alt="测试">    </p>  </li>  <li>    <p>全微分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/3.%E5%85%A8%E5%BE%AE%E5%88%86/3%E5%85%A8%E5%BE%AE%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/3.%E5%85%A8%E5%BE%AE%E5%88%86/3%E5%85%A8%E5%BE%AE%E5%88%86_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/3.%E5%85%A8%E5%BE%AE%E5%88%86/3%E5%85%A8%E5%BE%AE%E5%88%86_3.jpg" alt="测试">    </p>  </li>  <li>    <p>多元复合函数求导法则<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/4.%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/4%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/4.%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/4%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/4.%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/4%E5%A4%9A%E5%85%83%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99_3.jpg" alt="测试">    </p>  </li>  <li>    <p>隐函数求导法则<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/5.%E9%9A%90%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC%E6%B3%95%E5%88%99/5%E9%9A%90%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC.jpg" alt="测试">    </p>  </li>  <li>    <p>多元函数微分学的几何应用<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/6.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E7%9A%84%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/6%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E7%9A%84%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/6.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E7%9A%84%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8/6%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E7%9A%84%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8_2.jpg" alt="测试">    </p>  </li>  <li>    <p>方向导数与梯度<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/7.%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E4%B8%8E%E6%A2%AF%E5%BA%A6/7%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E4%B8%8E%E6%A2%AF%E5%BA%A6_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/7.%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E4%B8%8E%E6%A2%AF%E5%BA%A6/7%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E4%B8%8E%E6%A2%AF%E5%BA%A6_2.jpg" alt="测试">    </p>  </li>  <li>    <p>代数应用——多元函数的极值<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/8.%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC/8%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC_1.jpg" alt="测试">    </p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6%E5%8F%8A%E5%BA%94%E7%94%A8/8.%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC/8%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E2%80%94%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC_2.jpg" alt="测试"></p><h3 id="第十章-重积分"><a href="#第十章-重积分" class="headerlink" title="第十章 重积分"></a>第十章  重积分</h3><ol>  <li>    <p>二重积分的概念和性质<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/1.%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/1%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/1.%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/1%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8_2.jpg" alt="测试">    </p>  </li>  <li>    <p>二重积分的计算法<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/2.%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%E6%B3%95/2%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%E6%B3%95_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/2.%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%E6%B3%95/2%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%E6%B3%95_2.jpg" alt="测试">    </p>  </li>  <li>    <p>三重积分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/3.%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86/3%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/3.%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86/3%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86_2.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/3.%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86/3%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86_3.jpg" alt="测试">    </p>  </li>  <li>    <p>重积分的应用<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/4.%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8/4%E9%87%8D%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E9%87%8D%E7%A7%AF%E5%88%86/4.%E9%87%8D%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8/4%E9%87%8D%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8_2.jpg" alt="测试">    </p>  </li></ol><h3 id="第十一章-曲线积分与曲面积分"><a href="#第十一章-曲线积分与曲面积分" class="headerlink" title="第十一章 曲线积分与曲面积分"></a>第十一章  曲线积分与曲面积分</h3><ol>  <li>    <p>对弧长的曲线积分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/1.%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/1%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/1.%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/1%E5%AF%B9%E5%BC%A7%E9%95%BF%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86_2.jpg" alt="测试">    </p>  </li>  <li>    <p>对坐标的曲线积分</p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/2.%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/2%E5%AF%B9%E5%9D%90%E6%A0%87%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/2.%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/2%E5%AF%B9%E5%9D%90%E6%A0%87%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86_2.jpg" alt="测试"></p><ol start="3">  <li>    <p>格林公式及应用<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/3.%E6%A0%BC%E6%9E%97%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8/3%E6%A0%BC%E6%9E%97%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/3.%E6%A0%BC%E6%9E%97%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8/3%E6%A0%BC%E6%9E%97%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8_2.jpg" alt="测试">    </p>  </li>  <li>    <p>对面积的曲面积分</p>  </li></ol><p><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/4.%E5%AF%B9%E9%9D%A2%E7%A7%AF%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/4%E5%AF%B9%E9%9D%A2%E7%A7%AF%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86.jpg" alt="测试"></p><ol start="5">  <li>    <p>对坐标的曲面积分<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/5.%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/5%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86_1.jpg" alt="测试"><br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/5.%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/5%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86_2.jpg" alt="测试">    </p>  </li>  <li>    <p>高斯公式<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/6.%E9%AB%98%E6%96%AF%E5%85%AC%E5%BC%8F/6%E9%AB%98%E6%96%AF%E5%85%AC%E5%BC%8F.jpg" alt="测试">    </p>  </li>  <li>    <p>斯托克斯公式<br><img src="https://github.com/starstarb/Postgraduate-Advanced-Mathematics/raw/master/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%20%E4%B8%8B%E5%86%8C%EF%BC%88%E5%90%8C%E6%B5%8E%E4%B8%83%E7%89%88%EF%BC%89%E6%B1%A4%E5%AE%B6%E5%87%A4%E7%B2%BE%E8%AE%B2/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/7.%E6%96%AF%E6%89%98%E5%85%8B%E6%96%AF%E5%85%AC%E5%BC%8F/7%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%AF%B9%E5%9D%90%E6%A0%87%E7%9A%84%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%96%AF%E6%89%98%E5%85%8B%E6%96%AF%E5%85%AC%E5%BC%8F.jpg" alt="测试">    </p>  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三大基础数学复习&lt;/p&gt;
    
    </summary>
    
      <category term="数学基础" scheme="http://javastar.club/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数学基础" scheme="http://javastar.club/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火算法</title>
    <link href="http://javastar.club/archives/a0d601b7.html"/>
    <id>http://javastar.club/archives/a0d601b7.html</id>
    <published>2019-08-05T03:50:24.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>SA:python语言实现</p><a id="more"></a><h3 id="模拟退火算法-SimulatedAnnealing"><a href="#模拟退火算法-SimulatedAnnealing" class="headerlink" title="模拟退火算法(SimulatedAnnealing)"></a>模拟退火算法(SimulatedAnnealing)</h3><p>是基于Monte-Carlo迭代求解策略的一种随机寻优算法,主要用于组合优化问题的求解。<br>例如：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">f(x)=x^3-60*x^2-4*x+6</span><br></pre>      </td>    </tr>  </table></figure><p>  目标：求解在0到100范围内的最小值<br>数学方法一般求导计算.如果不求导计算，可能第一反应都是穷举法，把范围内每个值都算一遍再比较大小。如果求的是整数范围，那么要算100遍，但是如果要精确到小数后8位，则要算10000000000次，即便使用计算机依然是一个庞大的运算过程。而优化问题中很多都类似于问题，无法用穷举法解出答案，我们叫这类问题为NP难问题（可查看维基百科：NP-hard）</p><p>模拟退火算法，它是一种启发式搜索算法，即按照预定的控制策略进行搜索，在搜索过程中获取的中间信息将用来改进控制策略</p><ol>  <li>模拟退火算法的原理</li></ol><p><strong>1.1概念</strong></p><p>  模拟退火算法的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。</p><p>  模拟退火算法从某一高温出发，在高温状态下计算初始解，然后以预设的邻域函数产生一个扰动量，从而得到新的状态，即模拟粒子的无序运动，比较新旧状态下的能量，即目标函数的解。如果新状态的能量小于旧状态，则状态发生转化；如果新状态的能量大于旧状态，则以一定的概率准则发生转化。当状态稳定后，便可以看作达到了当前状态的最优解，便可以开始降温，在下一个温度继续迭代，最终达到低温的稳定状态，便得到了模拟退火算法产生的结果。</p><p><strong>1.2状态空间与邻域函数</strong></p><p>  状态空间也称为搜索空间，它由经过编码的可行解的集合所组成。而邻域函数应尽可能满足产生的候选解遍布全部状态空间。其通常由产生候选解的方式和候选解产生的概率分布组成。候选解一般按照某一概率密度函数对解空间进行随机采样获得，而概率分布可以为均匀分布、正态分布、指数分布等。</p><p><strong>1.3状态转移概率（Metropolis准则)</strong></p><p>状态转移概率是指从一个状态转换成另一个状态的概率，模拟退火算法中一般采用Metropolis准则<br><strong>1.4冷却进度表</strong></p><p>冷却进度表是指从某一高温状态T向低温状态冷却时的降温函数</p><p><strong>1.5初始温度</strong></p><p>一般来说，初始温度越大，获得高质量解的几率越大，但是花费的时间也会随之增加，因此，初温的确定应该同时考虑计算效率与优化质量，常用的方法包括：</p><p>(1)均匀抽样一组状态，以各状态目标值的方差为初温。</p><p>(2)随机产生一组状态，确定各状态间的最大目标值差，然后根据差值，利用一定的函数确定初温<br><strong>1.6循环终止准则</strong></p><p>内循环终止准则：</p><p>（1）检验目标函数的均值是否稳定</p><p>（2）连续若干步的目标值变化较小</p><p>（3）按一定的步数进行抽样</p><p>外循环终止准则</p><p>（1）设置终止温度</p><p>（2）设置外循环迭代次数</p><p>（3）算法搜索到的最优值连续若干步保持不变</p><p>（4）检验系统熵是否稳定</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SA:python语言实现&lt;/p&gt;
    
    </summary>
    
      <category term="SA" scheme="http://javastar.club/categories/SA/"/>
    
    
      <category term="SA" scheme="http://javastar.club/tags/SA/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法</title>
    <link href="http://javastar.club/archives/9cfaa3ca.html"/>
    <id>http://javastar.club/archives/9cfaa3ca.html</id>
    <published>2019-08-05T03:50:13.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>GA算法：Python实现</p><a id="more"></a><h3 id="GA"><a href="#GA" class="headerlink" title="GA"></a>GA</h3><p>遗传算法（Genetic  Algorithm)和模拟退火算法一样，也是搜索启发式算法的一种，它是借鉴了自然界优胜劣汰与适者生存的思想，通过模拟自然界这一过程来搜索最优解，在机器学习、组合优化等方面有广泛的用途。</p><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>遗传算法的组成主要包括4个部分：<br>（1）编码<br>（2）适应度函数<br>（3）遗传算子（选择，交叉，变异）<br>（4）运行参数 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GA算法：Python实现&lt;/p&gt;
    
    </summary>
    
      <category term="GA" scheme="http://javastar.club/categories/GA/"/>
    
    
      <category term="GA" scheme="http://javastar.club/tags/GA/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读笔记</title>
    <link href="http://javastar.club/archives/b6ab39d1.html"/>
    <id>http://javastar.club/archives/b6ab39d1.html</id>
    <published>2019-08-02T03:46:06.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>源代码阅读：基于JDK12.0，若有不对，请指正。</p><a id="more"></a><h1 id="ArrayList源码阅读"><a href="#ArrayList源码阅读" class="headerlink" title="ArrayList源码阅读"></a>ArrayList源码阅读</h1><p><strong>ArrayList简介</strong></p><ul>  <li>    <p>ArrayList 是一个数组队列，相当于 动态数组。</p>  </li>  <li>    <p>与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable,      java.io.Serializable这些接口。</p>  </li>  <li>    <p>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p>  </li>  <li>    <p>ArrayList      实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。    </p>  </li>  <li>    <p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p>  </li>  <li>    <p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输* 。</p>  </li>  <li>    <p>      和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。    </p>  </li></ul><h3 id="ArrayList属性"><a href="#ArrayList属性" class="headerlink" title="ArrayList属性"></a>ArrayList属性</h3><p>  ArrayList属性主要就是当前数组长度size，以及存放数组的对象elementData数组，除此之外还有一个经常用到的属性就是从AbstractList继承过来的modCount属性，代表ArrayList集合的修改次数。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">//序列化ID</span><br><span class="line">    private static final long serialVersionUID = 8683452581122892189L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Default initial capacity.</span><br><span class="line">       默认初始容量=10</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Shared empty array instance used for empty instances.</span><br><span class="line">       用于空实例的共享空数组实例</span><br><span class="line">     */</span><br><span class="line">    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      Shared empty array instance used for default sized empty instances. We</span><br><span class="line">      distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class="line">      first element is added.</span><br><span class="line">      共享空数组实例，用于默认大小的空实例。</span><br><span class="line">      我们将其与上面的EMPTY_ELEMENTDATA区分开来，当添加第一个元素时，我们将了解动态数组扩大了多少容量。</span><br><span class="line">      </span><br><span class="line">     */</span><br><span class="line">    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line">      The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line">      empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">      will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line">     存储ArrayList元素的数组缓冲区。</span><br><span class="line">     ArrayList的容量是这个数组缓冲区的长度。</span><br><span class="line">     任何空的ArrayList在使用时，如果 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">     那么在添加第一个元素时扩展为DEFAULT_CAPACITY=10  容量</span><br><span class="line">     */</span><br><span class="line">    transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line">    //非私有以简化嵌套类访问，当前数据对象存放地方，当前对象不参与序列化</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The size of the ArrayList (the number of elements it contains).</span><br><span class="line">     *ArrayList的大小(它包含的元素的数量)。</span><br><span class="line">     * @serial</span><br><span class="line">     */</span><br><span class="line">    private int size;</span><br><span class="line"> /*Java中对象的序列化是指：将对象转换成以字节序列的形式来表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache(内存空间不够有可能会本地存储到硬盘)或远程调用rpc(网络传输)的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</span><br><span class="line">  只要某个类实现了Serilizable接口，这个类所有的属性和方法都会自动序列化。</span><br><span class="line">   transient</span><br><span class="line">   作用：让某些被修饰符的成员属性变量不被序列化。</span><br><span class="line">   什么时候可以使用该关键字呢？</span><br><span class="line">   1. 类中的字段值可以根据其他字段推导出来，如一个长方形类有三个属性：长、宽、面积。那么在序列化的时候，面积这个属性就没必要被序列化了。</span><br><span class="line">   2. 实际开发过程中，某些敏感信息不希望在网络中被传输，这些信息对应的变量就可以加上transient关键字。即，这个字段的生命周期仅存于调用者的内存中，而不会被写到磁盘里持久化。</span><br><span class="line">   总而言之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。*/</span><br><span class="line">    /**</span><br><span class="line">      The maximum size of array to allocate (unless necessary).</span><br><span class="line">      Some VMs reserve some header words in an array.</span><br><span class="line">      Attempts to allocate larger arrays may result in</span><br><span class="line">      OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">      要分配的数组的最大大小(除非必要)。</span><br><span class="line">      一些VM在数组中保留一些头信息。</span><br><span class="line">      尝试分配更大的数组可能会导致</span><br><span class="line">      OutOfMemoryError:请求的数组大小超过VM限制</span><br><span class="line">     */</span><br><span class="line">    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //省略了里面的方法</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="ArrayList构造函数"><a href="#ArrayList构造函数" class="headerlink" title="ArrayList构造函数"></a>ArrayList构造函数</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line">     * Constructs an empty list with the specified initial capacity.</span><br><span class="line">     </span><br><span class="line">       @param  initialCapacity  the initial capacity of the list</span><br><span class="line">       @throws IllegalArgumentException if the specified initial capacity</span><br><span class="line">             is negative</span><br><span class="line"></span><br><span class="line">构造具有指定初始容量的空列表。</span><br><span class="line">@param 参数 ：initialCapacity 列表的初始容量</span><br><span class="line">如果指定初始容量，@抛出IllegalArgumentException异常</span><br><span class="line">   带int类型的构造函数</span><br><span class="line">如果传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常，构造方法如下：</span><br><span class="line">     */</span><br><span class="line">    public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &gt; 0) &#123;</span><br><span class="line">            this.elementData = new Object[initialCapacity];</span><br><span class="line">        &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs an empty list with an initial capacity of ten.</span><br><span class="line">     构造一个初始容量为10的空列表。</span><br><span class="line">     注意：此时我们创建的ArrayList对象中的elementData中的长度是1，size是0,当进行第一次add的时候，elementData将会变成默认的长度：10.</span><br><span class="line">     无参构造函数</span><br><span class="line">     如果不传入参数，则使用默认无参构建方法创建ArrayList对象，如下：</span><br><span class="line">     */</span><br><span class="line">    public ArrayList() &#123;</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs a list containing the elements of the specified</span><br><span class="line">       collection, in the order they are returned by the collection&apos;s</span><br><span class="line">       iterator.</span><br><span class="line">     </span><br><span class="line">      @param c the collection whose elements are to be placed into this list</span><br><span class="line">      @throws NullPointerException if the specified collection is null</span><br><span class="line"></span><br><span class="line">      构造一个包含指定元素的列表</span><br><span class="line">      集合，按照顺序，它们将通过集合迭代器返回。</span><br><span class="line">     @param参数： c集合，它的元素将被放置到这个列表中</span><br><span class="line">       如果指定的集合为空，@抛出NullPointerException</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">带Collection对象的构造函数:</span><br><span class="line">1）将collection对象转换成数组，然后将数组的地址的赋给elementData。</span><br><span class="line">2）更新size的值，同时判断size的大小，如果是size等于0，直接将空对象EMPTY_ELEMENTDATA的地址赋给elementData</span><br><span class="line">3）如果size的值大于0，则执行Arrays.copyOf方法，把collection对象的内容（可以理解为深拷贝）copy到elementData中。</span><br><span class="line"></span><br><span class="line">注意：this.elementData = arg0.toArray(); 这里执行的简单赋值时浅拷贝，所以要执行Arrays.copyOf() 做深拷贝</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">    public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        if ((size = elementData.length) != 0) &#123;</span><br><span class="line"></span><br><span class="line">            // defend against c.toArray (incorrectly) not returning Object[]</span><br><span class="line">            // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)</span><br><span class="line"></span><br><span class="line">            if (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // replace with empty array.</span><br><span class="line"></span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>遇到的问题：</strong><br>？是“任意类”的意思，extends继承不多说，E是指定类型。<br>E是element  元素,用来定义泛型,可以不写,但是取值的时候要强转,用了泛型就不需要强转(强制类型转换) </p><p>首先，E是泛型。这是java 1.5以后引入的。<br>从此以后，定义一个空的ArrayList需要这样，比如我需要一个MyClass的顺序表，则：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ArrayList&lt;MyClass&gt; myList = new ArrayList&lt;MyClass&gt;();</span><br></pre>      </td>    </tr>  </table></figure><p>这是因为ArrayList类的声明是public class ArrayList<e>。</e></p><p>而此时，MyClass就是“指定类型”E了，意味着所有ArrayList类中声明的E, 换成了MyClass。</p><p>同理如果要使用public ArrayList(Collection&lt;? extends E&gt; c)来构造一个ArrayList，则：</p><p>如我有MySubClass是MyClass的子类。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Collection&lt;MyClass&gt; myCollection; //myCollection里有很多元素。</span><br><span class="line">Collection&lt;MySubClass&gt; mySubCollection; //mySubCollection里有很多元素。</span><br><span class="line">ArrayList&lt;MyClass&gt; myList = new ArrayList&lt;MyClass&gt;(myCollection);</span><br></pre>      </td>    </tr>  </table></figure><p>也可以：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ArrayList&lt;MyClass&gt; myList = new ArrayList&lt;MyClass&gt;(mySubCollection);</span><br></pre>      </td>    </tr>  </table></figure><p>意思是，凡是MyClass或者MyClass的子类的Collection均可以构造成ArrayList<myclass></myclass></p><h3 id="ArrayList的add方法"><a href="#ArrayList的add方法" class="headerlink" title="ArrayList的add方法"></a>ArrayList的add方法</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line">      This helper method split out from add(E) to keep method</span><br><span class="line">      bytecode size under 35 (the -XX:MaxInlineSize default value),</span><br><span class="line">      which helps when add(E) is called in a C1-compiled loop.</span><br><span class="line">这个helper方法从add(E)中分离出来以保留方法</span><br><span class="line">字节码大小小于35 (-XX:MaxInlineSize默认值)，</span><br><span class="line">这有助于在c1编译的循环中调用add(E)。</span><br><span class="line">     */</span><br><span class="line">    private void add(E e, Object[] elementData, int s) &#123;</span><br><span class="line">        if (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">        elementData[s] = e;</span><br><span class="line">        size = s + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      Appends the specified element to the end of this list.</span><br><span class="line">     </span><br><span class="line">      @param e element to be appended to this list</span><br><span class="line">      @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"></span><br><span class="line">      将指定的元素追加到此列表的末尾。</span><br><span class="line">      要添加到此列表中的@param e元素</span><br><span class="line">     @return &#123;@code true&#125;(由&#123;@link Collection#add&#125;指定)</span><br><span class="line">     */</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        add(e, elementData, size);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      Inserts the specified element at the specified position in this</span><br><span class="line">      list. Shifts the element currently at that position (if any) and</span><br><span class="line">      any subsequent elements to the right (adds one to their indices).</span><br><span class="line">     </span><br><span class="line">     @param index index at which the specified element is to be inserted</span><br><span class="line">     @param element element to be inserted</span><br><span class="line">     @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">     将指定元素插入其中的指定位置</span><br><span class="line">    列表。将当前位于该位置(如果有)的元素移动，并</span><br><span class="line">     右边的任何后续元素(将一个元素添加到它们的索引中)。</span><br><span class="line">    @param索引要插入指定元素的索引</span><br><span class="line">    要插入的@param元素</span><br><span class="line">     @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">     /</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        modCount++;</span><br><span class="line">        final int s;</span><br><span class="line">        Object[] elementData;</span><br><span class="line">        if ((s = size) == (elementData = this.elementData).length)</span><br><span class="line">            elementData = grow();</span><br><span class="line">        System.arraycopy(elementData, index,</span><br><span class="line">                         elementData, index + 1,</span><br><span class="line">                         s - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size = s + 1;</span><br><span class="line">    &#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源代码阅读：基于JDK12.0，若有不对，请指正。&lt;/p&gt;
    
    </summary>
    
      <category term="源代码" scheme="http://javastar.club/categories/%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="JDK" scheme="http://javastar.club/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>nginx核心知识</title>
    <link href="http://javastar.club/archives/9015eb1.html"/>
    <id>http://javastar.club/archives/9015eb1.html</id>
    <published>2019-08-01T06:07:11.000Z</published>
    <updated>2019-08-07T07:14:52.720Z</updated>
    
    <content type="html"><![CDATA[<p>nginx学习入门</p><a id="more"></a><h3 id="Nginx的三个主要应用场景"><a href="#Nginx的三个主要应用场景" class="headerlink" title="Nginx的三个主要应用场景"></a>Nginx的三个主要应用场景</h3><ul>  <li>静态资源服务：通过本地文件系统提供服务</li>  <li>反向代理服务：Nginx的强大性能、缓存、负载均衡</li>  <li>API服务：OpenResty</li></ul><h3 id="Nginx的主要优点"><a href="#Nginx的主要优点" class="headerlink" title="Nginx的主要优点"></a>Nginx的主要优点</h3><ol>  <li>高并发、高性能</li>  <li>可扩展性好</li>  <li>高可靠性</li>  <li>热部署</li>  <li>BSD许可证</li></ol><h3 id="Nginx的组成"><a href="#Nginx的组成" class="headerlink" title="Nginx的组成"></a>Nginx的组成</h3><ol>  <li>Nginx二进制可执行文件：由各模块源码编译出的一个文件</li>  <li>Nginx.conf配置文件：控制Nginx的行为</li>  <li>access.log访问日志：记录每一条http请求信息</li>  <li>error.log错误日志：定位问题</li></ol><h3 id="Nginx配置语法"><a href="#Nginx配置语法" class="headerlink" title="Nginx配置语法"></a>Nginx配置语法</h3><ol>  <li>配置文件由指令和指令块构成</li>  <li>每条指令以；分号结尾，指令与参数间以空格符号分隔。</li>  <li>使用$符号使用变量</li>  <li>使用#符号添加注释</li>  <li>指令块以{}大括号将多条指令组织在一起</li>  <li>include语句允许组合多个配置文件以提高可维护性</li>  <li>部分指令的参数支持正则表达式</li></ol><h3 id="Nginx语法示例"><a href="#Nginx语法示例" class="headerlink" title="Nginx语法示例"></a>Nginx语法示例</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">http&#123;</span><br><span class="line">include mime.types;</span><br><span class="line">upstream thwp&#123;</span><br><span class="line">server 127.0.0.1:8000;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">listen 443 http2;</span><br><span class="line">#Nginx配置语法</span><br><span class="line">limit_req_zone $binary_remote_addr Zone=one:10m rate=1r/s;</span><br><span class="line">location ~* \.(gir|jpg|jpeg)$ &#123;</span><br><span class="line">proxy_cache my_cache;</span><br><span class="line">expires 3m;proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">proxy_cache_valid 200 304 302 1d;</span><br><span class="line">proxy_pass http://javastar.club;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p><strong>时间的单位</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ms:milliseconds</span><br><span class="line">d:days</span><br><span class="line">s:seconds</span><br><span class="line">w:weeks</span><br><span class="line">m:minutes</span><br><span class="line">h:hours</span><br><span class="line">M:months,30days</span><br><span class="line">y:years,365days</span><br></pre>      </td>    </tr>  </table></figure><p><strong>空间的单位</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">    bytes</span><br><span class="line">k/K:kilobytes</span><br><span class="line">m/M:megabytes</span><br><span class="line">g/G:gigabytes</span><br></pre>      </td>    </tr>  </table></figure><h3 id="Nginx命令行"><a href="#Nginx命令行" class="headerlink" title="Nginx命令行"></a>Nginx命令行</h3><ol>  <li>格式：nginx -s reload</li>  <li>帮助：-? -h</li>  <li>使用指定的配置文件： -c</li>  <li>指定配置指令：-g</li>  <li>指定运行目录：-p</li>  <li>发送信号：-s (立刻停止服务： stop 优雅的停止服务： quit 重载配置文件： reload 重新开始记录日志文件：reopen)</li>  <li>测试配置文件是否有语法错误：-t -T</li>  <li>打印nginx的版本信息、编译信息等：-v -V</li></ol><h3 id="SSL-Secure-Sockets-Layer-TLS-Transport-Layer-Security"><a href="#SSL-Secure-Sockets-Layer-TLS-Transport-Layer-Security" class="headerlink" title="SSL(Secure Sockets Layer) TLS(Transport Layer Security)"></a>SSL(Secure  Sockets Layer) TLS(Transport Layer Security)</h3><p>  <strong>ISO/OSI模型</strong><br>应用层<br>表示层<br>会话层<br>传输层<br>网络层<br>数据链路层<br>物理层<br><strong>TCP/IP模型</strong><br>应用层<br>传输层<br>网络层<br>链路层<br><strong>TLS安全密码套件</strong></p><p>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</p><p>ECDHE:密钥交换算法<br>RSA：身份验证算法<br>AES_128_GCM:对称加密算法、强度、分组模式<br>SHA256:签名hash算法</p><h3 id="PKI公钥基础设施"><a href="#PKI公钥基础设施" class="headerlink" title="PKI公钥基础设施"></a>PKI公钥基础设施</h3><p>证书签名申请(request certificate issuance,CSR)<br>证书类型：<br>域名验证(domain  validated,DV)证书<br>组织验证(organization validated,OV)证书<br>扩展验证(extended  validation,EV)证书<br>证书链</p><h3 id="TLS通讯过程"><a href="#TLS通讯过程" class="headerlink" title="TLS通讯过程"></a>TLS通讯过程</h3><ol>  <li>验证身份</li>  <li>达成安全套件共识</li>  <li>传递密钥</li>  <li>加密通讯</li></ol><h3 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h3><p>Nginx 是一款轻量级的 Web （HTTP）服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器<br>优势：能支持高达 50,000  个并发连接数 ；支持热部署 ；很高的稳定性（抵御dos攻击）</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p> 在 unix 系统中会以 daemon （守护进程）的方式在后台运行，后台进程包含一个 master 进程和多个 worker  进程（多进程的工作方式）<br> 1、多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。</p><p>2、一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。</p><p>3、推荐设置 worker 的个数为 cpu 的核数</p><p>4、异步非阻塞 （非阻塞不会让出cpu导致切换浪费）</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>1、connection</strong></p><p>是对 tcp 连接的封装;</p><p>Nginx 通过设置 worker_connectons 来设置每个worker进程支持的最大连接数;</p><p>Nginx 能建立的最大连接数，应该是worker_connections * worker_processes;对于 HTTP  请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，而如果是 HTTP  作为反向代理来说，最大并发数量应该是worker_connections *  worker_processes/2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p><p><strong>2、request</strong></p><p>Nginx 中指 http 请求;</p><p>web服务器工作流：http 请求是典型的请求-响应类型的的网络协议，而 http  是文本协议，所以我们在分析请求行与请求头，以及输出响应行与响应头，往往是一行一行的进行处理。如果我们自己来写一个 http  服务器，通常在一个连接建立好后，客户端会发送请求过来。然后我们读取一行数据，分析出请求行中包含的 method、uri、http_version  信息。然后再一行一行处理请求头，并根据请求 method  与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。在将响应发送给客户端之后，一个完整的请求就处理完了。</p><p><strong>3、keepalive</strong></p><p>长连接: http 请求是基于 TCP 协议之上的，那么，当客户端在发起请求前，需要先与服务端建立 TCP 连接(三次握手)，当连接断开后（四次挥手）。而  http  请求是请求应答式的，如果我们能知道每个请求头与响应体的长度，那么我们是可以在一个连接上面执行多个请求的，这就是所谓的长连接，但前提条件是我们先得确定请求头与响应体的长度。对于请求来说，如果当前请求需要有body，如  POST 请求，那么 Nginx 就需要客户端在请求头中指定 content-length 来表明 body 的大小，否则返回 400  错误。也就是说，请求体的长度是确定的，那么响应体的长度呢？先来看看 http 协议中关于响应 body 长度的确定：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">对于 http1.0 协议来说，如果响应头中有 content-length 头，则以 content-length 的长度就可以知道 body 的长度了，客户端在接收 body 时，就可以依照这个长度来接收数据，接收完后，就表示这个请求完成了。而如果没有 content-length 头，则客户端会一直接收数据，直到服务端主动断开连接，才表示 body 接收完了。</span><br><span class="line">而对于 http1.1 协议来说，如果响应头中的 Transfer-encoding 为 chunked 传输，则表示 body 是流式输出，body 会被分成多个块，每块的开始会标识出当前块的长度，此时，body 不需要通过长度来指定。如果是非 chunked 传输，而且有 content-length，则按照 content-length 来接收数据。否则，如果是非 chunked，并且没有 content-length，则客户端接收数据，直到服务端主动断开连接。</span><br></pre>      </td>    </tr>  </table></figure><p>从上面，我们可以看到，除了 http1.0 不带 content-length 以及 http1.1 非 chunked 不带  content-length 外，body 的长度是可知的。此时，当服务端在输出完 body  之后，会可以考虑使用长连接。能否使用长连接，也是有条件限制的。如果客户端的请求头中的 connection为close，则表示客户端需要关掉长连接，如果为  keep-alive，则客户端需要打开长连接，如果客户端的请求中没有 connection 这个头，那么根据协议，如果是 http1.0，则默认为  close，如果是 http1.1，则默认为 keep-alive。如果结果为 keepalive，那么，Nginx 在输出完响应体后，会设置当前连接的  keepalive 属性，然后等待客户端下一次请求。当然，Nginx 不可能一直等待下去，如果客户端一直不发数据过来，岂不是一直占用这个连接？所以当  Nginx 设置了 keepalive 等待下一次的请求时，同时也会设置一个最大等待时间，这个时间是通过选项 keepalive_timeout  来配置的，如果配置为 0，则表示关掉 keepalive，此时，http 版本无论是 1.1 还是 1.0，客户端的 connection 不管是  close 还是 keepalive，都会强制为 close。</p><p>如果服务端最后的决定是 keepalive 打开，那么在响应的 http 头里面，也会包含有 connection  头域，其值是”Keep-Alive”，否则就是”Close”。如果 connection 值为 close，那么在 Nginx  响应完数据后，会主动关掉连接。所以，对于请求量比较大的 Nginx 来说，关掉 keepalive 最后会产生比较多的 time-wait 状态的  socket。一般来说，当客户端的一次访问，需要多次访问同一个 server 时，打开 keepalive  的优势非常大，比如图片服务器，通常一个网页会包含很多个图片。打开 keepalive 也会大量减少 time-wait 的数量。</p><p><strong>4、pipe</strong></p><p>http1.1 引入新特性,keepalive 的一种升华，基于长连接的，目的就是利用一个连接做多次请求;</p><p>对 pipeline 来说，客户端不必等到第一个请求处理完后，就可以马上发起第二个请求;</p><p><strong>5、linger_close</strong></p><p>延迟关闭，也就是说，当 Nginx 要关闭连接时，并非立即关闭连接，而是先关闭 tcp 连接的写，再等待一段时间后再关掉连接的读。</p><h3 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h3><p><strong>1、nginx.conf</strong></p><p>指令上下文：</p><pre><code>main: Nginx 在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。http: 与提供 http 服务相关的一些配置参数。例如：是否使用 keepalive 啊，是否使用gzip进行压缩等。server: http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server，每个 server 通过监听的地址来区分。location: http 服务中，某些特定的URL对应的一系列配置项。mail: 实现 email 相关的 SMTP/IMAP/POP3 代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。</code></pre><p>示例：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre>      </td>      <td class="code">        <pre><span class="line">worker_processes 1;      //一般设置为cpu核数</span><br><span class="line"></span><br><span class="line">error_log logs/error.log error;</span><br><span class="line">pid logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">　　worker_connections 1024;     //每个worker的最大连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">　　include mime.types;</span><br><span class="line">　　default_type application/octet-stream;</span><br><span class="line">　　sendfile on;</span><br><span class="line">　　tcp_nopush on;</span><br><span class="line">　　server_names_hash_bucket_size 128;</span><br><span class="line">　　keepalive_timeout 1800s;      //支持长连接</span><br><span class="line"></span><br><span class="line">　　client_max_body_size 0;</span><br><span class="line"></span><br><span class="line">　　proxy_connect_timeout 5s;</span><br><span class="line">　　proxy_read_timeout 1800s;</span><br><span class="line"></span><br><span class="line">　　proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">　　proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">　　proxy_set_header Host $http_host;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     upstream web_vmaxfmproxy_pool &#123; server 10.43.136.220:27430; &#125;</span><br><span class="line">     upstream web_vmaxdatacheck_pool &#123; server 10.43.136.220:27340; &#125;</span><br><span class="line"></span><br><span class="line">　　server &#123;</span><br><span class="line">　　　　listen 28888;</span><br><span class="line">           server_name web_web_pool;</span><br><span class="line">　　　　location ~ ^/web/cometd &#123;</span><br><span class="line">                     proxy_pass http://web_web_pool;</span><br><span class="line">                     proxy_http_version 1.1;</span><br><span class="line">                     proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">                     proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　     location / &#123;</span><br><span class="line">　　　　　　if ($uri ~ ^/vmaxfmproxy/)&#123; proxy_pass http://web_vmaxfmproxy_pool; break; &#125;</span><br><span class="line">　　　　　　if ($uri ~ ^/vmaxdatacheck/)&#123; proxy_pass http://web_vmaxdatacheck_pool; break; &#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　location /rdk/service &#123;</span><br><span class="line">　　　　　　proxy_pass http://localhost:5555;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　location ~ /rdk/app/(?&lt;section&gt;.*) &#123;</span><br><span class="line">　　　　　　proxy_pass http://web_rdk_server_pool/rdk_server/app/$section;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　location /web/res/web-framework/default.html &#123;</span><br><span class="line">　　　　　　rewrite /web/res/web-framework/default.html /rdk/app/portal/web/index.html permanent;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="五、nginx模块"><a href="#五、nginx模块" class="headerlink" title="五、nginx模块"></a>五、nginx模块</h3><pre><code>event module: 搭建了独立于操作系统的事件处理机制的框架，及提供了各具体事件的处理。包括 ngx_events_module， ngx_event_core_module和ngx_epoll_module 等。Nginx 具体使用何种事件处理模块，这依赖于具体的操作系统和编译选项。phase handler: 此类型的模块也被直接称为 handler 模块。主要负责处理客户端请求并产生待响应内容，比如 ngx_http_static_module 模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。output filter: 也称为 filter 模块，主要是负责对输出的内容进行处理，可以对输出进行修改。例如，可以实现对输出的所有 html 页面增加预定义的 footbar 一类的工作，或者对输出的图片的 URL 进行替换之类的工作。upstream: upstream 模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream 模块是一种特殊的 handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。load-balancer: 负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器。</code></pre><h3 id="六、nginx-请求过程"><a href="#六、nginx-请求过程" class="headerlink" title="六、nginx 请求过程"></a>六、nginx  请求过程</h3><p>所有实际上的业务处理逻辑都在 worker 进程。worker 进程中有一个函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个  Nginx 服务被停止。</p><p>worker 进程中，ngx_worker_process_cycle()函数就是这个无限循环的处理函数。在这个函数中，一个请求的简单处理流程如下：</p><pre><code>操作系统提供的机制（例如 epoll, kqueue 等）产生相关的事件。接收和处理这些事件，如是接受到数据，则产生更高层的 request 对象。处理 request 的 header 和 body。产生响应，并发送回客户端。完成 request 的处理。重新初始化定时器及其他事件。</code></pre><p>为了让大家更好的了解 Nginx 中请求处理过程，我们以 HTTP Request 为例，来做一下详细地说明。</p><p>从 Nginx 的内部来看，一个 HTTP Request 的处理过程涉及到以下几个阶段。</p><pre><code>初始化 HTTP Request（读取来自客户端的数据，生成 HTTP Request 对象，该对象含有该请求所有的信息）。处理请求头。处理请求体。如果有的话，调用与此请求（URL 或者 Location）关联的 handler。依次调用各 phase handler 进行处理。</code></pre><p>在这里，我们需要了解一下 phase handler 这个概念。phase 字面的意思，就是阶段。所以 phase handlers  也就好理解了，就是包含若干个处理阶段的一些 handler。</p><p>在每一个阶段，包含有若干个 handler，再处理到某个阶段的时候，依次调用该阶段的 handler 对 HTTP Request 进行处理。</p><p>通常情况下，一个 phase handler 对这个 request 进行处理，并产生一些输出。通常 phase handler  是与定义在配置文件中的某个 location 相关联的。</p><p>一个 phase handler 通常执行以下几项任务：</p><pre><code>获取 location 配置。产生适当的响应。发送 response header。发送 response body。</code></pre><p>当 Nginx 读取到一个 HTTP Request 的 header 的时候，Nginx  首先查找与这个请求关联的虚拟主机的配置。如果找到了这个虚拟主机的配置，那么通常情况下，这个 HTTP Request 将会经过以下几个阶段的处理（phase  handlers）：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>      </td>      <td class="code">        <pre><span class="line">NGX_HTTP_POST_READ_PHASE: 读取请求内容阶段</span><br><span class="line">NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段</span><br><span class="line">NGX_HTTP_FIND_CONFIG_PHASE: 配置查找阶段:</span><br><span class="line">NGX_HTTP_REWRITE_PHASE: Location请求地址重写阶段</span><br><span class="line">NGX_HTTP_POST_REWRITE_PHASE: 请求地址重写提交阶段</span><br><span class="line">NGX_HTTP_PREACCESS_PHASE: 访问权限检查准备阶段</span><br><span class="line">NGX_HTTP_ACCESS_PHASE: 访问权限检查阶段</span><br><span class="line">NGX_HTTP_POST_ACCESS_PHASE: 访问权限检查提交阶段</span><br><span class="line">NGX_HTTP_TRY_FILES_PHASE: 配置项 try_files 处理阶段</span><br><span class="line">NGX_HTTP_CONTENT_PHASE: 内容产生阶段</span><br><span class="line">NGX_HTTP_LOG_PHASE: 日志模块处理阶段</span><br></pre>      </td>    </tr>  </table></figure><p>在内容产生阶段，为了给一个 request 产生正确的响应，Nginx 必须把这个 request 交给一个合适的 content handler  去处理。如果这个 request 对应的 location 在配置文件中被明确指定了一个 content handler，那么Nginx 就可以通过对  location 的匹配，直接找到这个对应的 handler，并把这个 request 交给这个 content handler  去处理。这样的配置指令包括像，perl，flv，proxy_pass，mp4等。</p><p>如果一个 request 对应的 location 并没有直接有配置的 content handler，那么 Nginx 依次尝试:</p><pre><code>如果一个 location 里面有配置 random_index on，那么随机选择一个文件，发送给客户端。如果一个 location 里面有配置 index 指令，那么发送 index 指令指明的文件，给客户端。如果一个 location 里面有配置 autoindex on，那么就发送请求地址对应的服务端路径下的文件列表给客户端。如果这个 request 对应的 location 上有设置 gzip_static on，那么就查找是否有对应的.gz文件存在，有的话，就发送这个给客户端（客户端支持 gzip 的情况下）。请求的 URI 如果对应一个静态文件，static module 就发送静态文件的内容到客户端。</code></pre><p>内容产生阶段完成以后，生成的输出会被传递到 filter 模块去进行处理。filter 模块也是与 location 相关的。所有的 fiter  模块都被组织成一条链。输出会依次穿越所有的 filter，直到有一个 filter 模块的返回值表明已经处理完成。</p><p>这里列举几个常见的 filter 模块，例如：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">server-side includes。</span><br><span class="line">XSLT filtering。</span><br><span class="line">图像缩放之类的。</span><br><span class="line">gzip 压缩。</span><br></pre>      </td>    </tr>  </table></figure><p>在所有的 filter 中，有几个 filter 模块需要关注一下。按照调用的顺序依次说明如下：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">write: 写输出到客户端，实际上是写到连接对应的 socket 上。</span><br><span class="line">postpone: 这个 filter 是负责 subrequest 的，也就是子请求的。</span><br><span class="line">copy: 将一些需要复制的 buf(文件或者内存)重新复制一份然后交给剩余的 body filter 处理。</span><br></pre>      </td>    </tr>  </table></figure><h3 id="七、upstream模块"><a href="#七、upstream模块" class="headerlink" title="七、upstream模块"></a>七、upstream模块</h3><p><strong>1、upstream 模块</strong></p><p>将使 Nginx 跨越单机的限制，完成网络数据的接收、处理和转发。</p><p>数据转发功能，为 Nginx 提供了跨越单机的横向处理能力，使 Nginx  摆脱只能为终端节点提供单一功能的限制，而使它具备了网路应用级别的拆分、封装和整合的战略功能。<br>在云模型大行其道的今天，数据转发是 Nginx  有能力构建一个网络应用的关键组件。</p><p>upstream 属于 handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容，所以才称为  upstream（上游）。<br>请求并取得响应内容的整个过程已经被封装到 Nginx 内部，所以 upstream  模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。</p><p><strong>2、负载均衡模块</strong></p><p>负载均衡模块用于从upstream指令定义的后端主机列表中选取一台主机。</p><p>Nginx 先使用负载均衡模块找到一台主机，再使用 upstream 模块实现与这台主机的交互。</p><p>如果需要使用 ip hash 的负载均衡算法：</p><p>示例 :</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre>      </td>      <td class="code">        <pre><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/error.log  error;</span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;   </span><br><span class="line">    sendfile       on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line">    server_names_hash_bucket_size 128;  </span><br><span class="line">    keepalive_timeout  600s;</span><br><span class="line">    proxy_connect_timeout 5s;</span><br><span class="line">    proxy_read_timeout 600s;</span><br><span class="line">    </span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line"></span><br><span class="line">    upstream lw_web_rdk_server_pool &#123;</span><br><span class="line">         server  10.43.149.160:26180  weight=1;</span><br><span class="line"></span><br><span class="line">         server  10.43.136.220:5812  weight=1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen  26188;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        location /&#123;</span><br><span class="line">        proxy_pass  http://lw_web_rdk_server_pool;</span><br><span class="line">        proxy_redirect default;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">       listen  26185;</span><br><span class="line">       server_name localhost;</span><br><span class="line">       location /rdk/service &#123;</span><br><span class="line">                            proxy_pass http://localhost:5812;</span><br><span class="line">                    &#125;</span><br><span class="line">       location / &#123;</span><br><span class="line">        root   ../../;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h2 id="Nginx源码剖析，本次代码分析主要基于nginx-1-17-2版本"><a href="#Nginx源码剖析，本次代码分析主要基于nginx-1-17-2版本" class="headerlink" title="Nginx源码剖析，本次代码分析主要基于nginx-1.17.2版本"></a>Nginx源码剖析，本次代码分析主要基于nginx-1.17.2版本</h2><p>Nginx的源码主要分布在src/目录下，而src/目录下主要包含三部分比较重要的模块。</p><ol>  <li>    <p>core：包含了Nginx的最基础的库和框架。包括了内存池、链表、hashmap、String等常用的数据结构。</p>  </li>  <li>    <p>      event：事件模块。Nginx自己实现了事件模型。而我们所熟悉的Memcached是使用了Libevent的事件库。自己实现event会性能和效率方便更加高效。    </p>  </li>  <li>    <p>http：实现HTTP的模块。实现了HTTP的具体协议的各种模块，该部分内容量比较大。</p>  </li></ol><h3 id="Nginx架构"><a href="#Nginx架构" class="headerlink" title="Nginx架构"></a>Nginx架构</h3><p>Nginx是一款多进程的软件。Nginx启动后，会产生一个master进程和N个工作进程。其中nginx.conf中可以配置工作进程的个数：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">worker_processes  1;</span><br></pre>      </td>    </tr>  </table></figure><p>多进程模块有一个非常大的好处，就是不需要太多考虑并发锁的问题。</p><p>  Nginx的内存管理是通过内存池来实现的。Nginx的内存池的设计非常的精巧，很多场景下，我们可以将Nginx的内存池实现抽象出来改造成我们开发中的内存池。</p><h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>一般我们使用malloc/alloc/free等函数来分配和释放内存。但是直接使用这些函数会有一些弊端：</p><ol>  <li>    <p>      虽然系统自带的ptmalloc内存分配管理器，也有自己的内存优化管理方案（申请内存块以及将内存交还给系统都有自己的优化方案，具体可以研究一下ptmalloc的源码），但是直接使用malloc/alloc/free，仍然会导致内存分配的性能比较低。    </p>  </li>  <li>    <p>      频繁使用这些函数分配和释放内存，会导致内存碎片，不容易让系统直接回收内存。典型的例子就是大并发频繁分配和回收内存，会导致进程的内存产生碎片，并且不会立马被系统回收。    </p>  </li>  <li>    <p>容易产生内存泄露。</p>  </li></ol><p>使用内存池分配内存有几点好处：</p><ol>  <li>    <p>提升内存分配效率。不需要每次分配内存都执行malloc/alloc等函数。</p>  </li>  <li>    <p>让内存的管理变得更加简单。内存的分配都会在一块大的内存上，回收的时候只需要回收大块内存就能将所有的内存回收，防止了内存管理混乱和内存泄露问题。    </p>  </li></ol><h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>先看ngx_palloc.h里面的结构体定义：<br><strong>ngx_pool_t 内存池主结构</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * Nginx 内存池数据结构</span><br><span class="line"> */</span><br><span class="line">struct ngx_pool_s &#123;</span><br><span class="line">    ngx_pool_data_t       d;        /* 内存池的数据区域*/</span><br><span class="line">    size_t                max;      /* 最大每次可分配内存 */</span><br><span class="line">    ngx_pool_t           *current;  /* 指向当前的内存池指针地址。ngx_pool_t链表上最后一个缓存池结构*/</span><br><span class="line">    ngx_chain_t          *chain;    /* 缓冲区链表 */</span><br><span class="line">    ngx_pool_large_t     *large;    /* 存储大数据的链表 */</span><br><span class="line">    ngx_pool_cleanup_t   *cleanup;  /* 可自定义回调函数，清除内存块分配的内存 */</span><br><span class="line">    ngx_log_t            *log;      /* 日志 */</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>ngx_pool_data_t 数据区域结构</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">typedef struct &#123;</span><br><span class="line">    u_char               *last;  /* 内存池中未使用内存的开始节点地址 */</span><br><span class="line">    u_char               *end;   /* 内存池的结束地址 */</span><br><span class="line">    ngx_pool_t           *next;  /* 指向下一个内存池 */</span><br><span class="line">    ngx_uint_t            failed;/* 失败次数 */</span><br><span class="line">&#125; ngx_pool_data_t;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>ngx_pool_large_t 大数据块结构</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">struct ngx_pool_large_s &#123;</span><br><span class="line">    ngx_pool_large_t     *next;   /* 指向下一个存储地址 通过这个地址可以知道当前块长度 */</span><br><span class="line">    void                 *alloc;  /* 数据块指针地址 */</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>ngx_pool_cleanup_t 自定义清理回调的数据结构</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">struct ngx_pool_cleanup_s &#123;</span><br><span class="line">    ngx_pool_cleanup_pt   handler;  /* 清理的回调函数 */</span><br><span class="line">    void                 *data;     /* 指向存储的数据地址 */</span><br><span class="line">    ngx_pool_cleanup_t   *next;     /* 下一个ngx_pool_cleanup_t */</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure><ol>  <li>    <p>      Nginx的内存池会放在ngx_pool_t的数据结构上（ngx_pool_data_t用于记录内存块block的可用地址空间和内存块尾部）。当初始化分配的内存块大小不能满足需求的时候，Nginx就会调用ngx_palloc_block函数来分配一个新的内存块，通过链表的形式连接起来。    </p>  </li>  <li>    <p>      当申请的内存大于pool-&gt;max的值的时候，Nginx就会单独分配一块large的内存块，会放置在pool-&gt;large的链表结构上。    </p>  </li>  <li>    <p>pool-&gt;cleanup的链表结构主要存放需要通过回调函数清理的内存数据。（例如文件描述符）</p>  </li></ol><h3 id="创建内存池ngx-create-pool"><a href="#创建内存池ngx-create-pool" class="headerlink" title="创建内存池ngx_create_pool"></a>创建内存池ngx_create_pool</h3><p>调用ngx_create_pool这个方法就可以创建一个内存池。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 创建一个内存池</span><br><span class="line"> */</span><br><span class="line">ngx_pool_t *</span><br><span class="line">ngx_create_pool(size_t size, ngx_log_t *log) &#123;</span><br><span class="line">    ngx_pool_t *p;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 相当于分配一块内存 ngx_alloc(size, log)</span><br><span class="line">     */</span><br><span class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Nginx会分配一块大内存，其中内存头部存放ngx_pool_t本身内存池的数据结构</span><br><span class="line">     * ngx_pool_data_t  p-&gt;d 存放内存池的数据部分（适合小于p-&gt;max的内存块存储）</span><br><span class="line">     * p-&gt;large 存放大内存块列表</span><br><span class="line">     * p-&gt;cleanup 存放可以被回调函数清理的内存块（该内存块不一定会在内存池上面分配）</span><br><span class="line">     */</span><br><span class="line">    p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t); //内存开始地址，指向ngx_pool_t结构体之后数据取起始位置</span><br><span class="line">    p-&gt;d.end = (u_char *) p + size; //内存结束地址</span><br><span class="line">    p-&gt;d.next = NULL; //下一个ngx_pool_t 内存池地址</span><br><span class="line">    p-&gt;d.failed = 0; //失败次数</span><br><span class="line"> </span><br><span class="line">    size = size - sizeof(ngx_pool_t);</span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"> </span><br><span class="line">    /* 只有缓存池的父节点，才会用到下面的这些  ，子节点只挂载在p-&gt;d.next,并且只负责p-&gt;d的数据内容*/</span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = NULL;</span><br><span class="line">    p-&gt;large = NULL;</span><br><span class="line">    p-&gt;cleanup = NULL;</span><br><span class="line">    p-&gt;log = log;</span><br><span class="line"> </span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="销毁内存池ngx-destroy-pool"><a href="#销毁内存池ngx-destroy-pool" class="headerlink" title="销毁内存池ngx_destroy_pool"></a>销毁内存池ngx_destroy_pool</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 销毁内存池。</span><br><span class="line"> */</span><br><span class="line">void ngx_destroy_pool(ngx_pool_t *pool) &#123;</span><br><span class="line">    ngx_pool_t *p, *n;</span><br><span class="line">    ngx_pool_large_t *l;</span><br><span class="line">    ngx_pool_cleanup_t *c;</span><br><span class="line"> </span><br><span class="line">    /* 首先清理pool-&gt;cleanup链表 */</span><br><span class="line">    for (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        /* handler 为一个清理的回调函数 */</span><br><span class="line">        if (c-&gt;handler) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,</span><br><span class="line">                    &quot;run cleanup: %p&quot;, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 清理pool-&gt;large链表（pool-&gt;large为单独的大数据内存块）  */</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line"> </span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0, &quot;free: %p&quot;, l-&gt;alloc);</span><br><span class="line"> </span><br><span class="line">        if (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">#if (NGX_DEBUG)</span><br><span class="line"> </span><br><span class="line">    /*</span><br><span class="line">     * we could allocate the pool-&gt;log from this pool</span><br><span class="line">     * so we cannot use this log while free()ing the pool</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">    for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,</span><br><span class="line">                &quot;free: %p, unused: %uz&quot;, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line"> </span><br><span class="line">        if (n == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">    /* 对内存池的data数据区域进行释放 */</span><br><span class="line">    for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line"> </span><br><span class="line">        if (n == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="重设内存池ngx-reset-pool"><a href="#重设内存池ngx-reset-pool" class="headerlink" title="重设内存池ngx_reset_pool"></a>重设内存池ngx_reset_pool</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 重设内存池</span><br><span class="line"> */</span><br><span class="line">void ngx_reset_pool(ngx_pool_t *pool) &#123;</span><br><span class="line">    ngx_pool_t *p;</span><br><span class="line">    ngx_pool_large_t *l;</span><br><span class="line"> </span><br><span class="line">    /* 清理pool-&gt;large链表（pool-&gt;large为单独的大数据内存块）  */</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    pool-&gt;large = NULL;</span><br><span class="line"> </span><br><span class="line">    /* 循环重新设置内存池data区域的 p-&gt;d.last；data区域数据并不擦除*/</span><br><span class="line">    for (p = pool; p; p = p-&gt;d.next) &#123;</span><br><span class="line">        p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="使用内存池分配一块内存ngx-palloc和ngx-pnalloc"><a href="#使用内存池分配一块内存ngx-palloc和ngx-pnalloc" class="headerlink" title="使用内存池分配一块内存ngx_palloc和ngx_pnalloc"></a>使用内存池分配一块内存ngx_palloc和ngx_pnalloc</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 内存池分配一块内存，返回void类型指针</span><br><span class="line"> */</span><br><span class="line">void *</span><br><span class="line">ngx_palloc(ngx_pool_t *pool, size_t size) &#123;</span><br><span class="line">    u_char *m;</span><br><span class="line">    ngx_pool_t *p;</span><br><span class="line"> </span><br><span class="line">    /* 判断每次分配的内存大小，如果超出pool-&gt;max的限制，则需要走大数据内存分配策略 */</span><br><span class="line">    if (size &lt;= pool-&gt;max) &#123;</span><br><span class="line"> </span><br><span class="line">        p = pool-&gt;current;</span><br><span class="line"> </span><br><span class="line">        /*</span><br><span class="line">         * 循环读取缓存池链p-&gt;d.next的各个的ngx_pool_t节点，</span><br><span class="line">         * 如果剩余的空间可以容纳size，则返回指针地址</span><br><span class="line">         *</span><br><span class="line">         * 这边的循环，实际上最多只有4次，具体可以看ngx_palloc_block函数</span><br><span class="line">         * */</span><br><span class="line">        do &#123;</span><br><span class="line">            /* 对齐操作,会损失内存，但是提高内存使用速度 */</span><br><span class="line">            m = ngx_align_ptr(p-&gt;d.last, NGX_ALIGNMENT);</span><br><span class="line"> </span><br><span class="line">            if ((size_t)(p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">                p-&gt;d.last = m + size;</span><br><span class="line"> </span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            p = p-&gt;d.next;</span><br><span class="line"> </span><br><span class="line">        &#125; while (p);</span><br><span class="line"> </span><br><span class="line">        /* 如果没有缓存池空间没有可以容纳大小为size的内存块，则需要重新申请一个缓存池pool节点 */</span><br><span class="line">        return ngx_palloc_block(pool, size);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 走大数据分配策略 ，在pool-&gt;large链表上分配 */</span><br><span class="line">    return ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 内存池分配一块内存，返回void类型指针</span><br><span class="line"> * 不考虑对齐情况</span><br><span class="line"> */</span><br><span class="line">void *</span><br><span class="line">ngx_pnalloc(ngx_pool_t *pool, size_t size) &#123;</span><br><span class="line">    u_char *m;</span><br><span class="line">    ngx_pool_t *p;</span><br><span class="line"> </span><br><span class="line">    /* 判断每次分配的内存大小，如果超出pool-&gt;max的限制，则需要走大数据内存分配策略 */</span><br><span class="line">    if (size &lt;= pool-&gt;max) &#123;</span><br><span class="line"> </span><br><span class="line">        p = pool-&gt;current;</span><br><span class="line"> </span><br><span class="line">        /* 循环读取数据区域的各个ngx_pool_t缓存池链，如果剩余的空间可以容纳size，则返回指针地址*/</span><br><span class="line">        do &#123;</span><br><span class="line">            m = p-&gt;d.last; //分配的内存块的地址</span><br><span class="line"> </span><br><span class="line">            if ((size_t)(p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">                p-&gt;d.last = m + size;</span><br><span class="line"> </span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            p = p-&gt;d.next;</span><br><span class="line"> </span><br><span class="line">        &#125; while (p);</span><br><span class="line"> </span><br><span class="line">        /* 如果没有缓存池空间没有可以容纳大小为size的内存块，则需要重新申请一个缓存池*/</span><br><span class="line">        return ngx_palloc_block(pool, size);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 走大数据分配策略 */</span><br><span class="line">    return ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>内存分配逻辑:</strong></p><ol>  <li>    <p>分配一块内存，如果分配的内存size小于内存池的pool-&gt;max的限制，则属于小内存块分配，走小内存块分配逻辑；否则走大内存分配逻辑。    </p>  </li>  <li>    <p>      小内存分配逻辑：循环读取pool-&gt;d上的内存块，是否有足够的空间容纳需要分配的size，如果可以容纳，则直接分配内存；否则内存池需要申请新的内存块，调用ngx_palloc_block。    </p>  </li>  <li>    <p>      大内存分配逻辑：当分配的内存size大于内存池的pool-&gt;max的限制，则会直接调用ngx_palloc_large方法申请一块独立的内存块，并且将内存块挂载到pool-&gt;large的链表上进行统一管理。    </p>  </li></ol><p>ngx_palloc_block，内存池扩容：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 申请一个新的缓存池 ngx_pool_t</span><br><span class="line"> * 新的缓存池会挂载在主缓存池的 数据区域 （pool-&gt;d-&gt;next）</span><br><span class="line"> */</span><br><span class="line">static void *</span><br><span class="line">ngx_palloc_block(ngx_pool_t *pool, size_t size) &#123;</span><br><span class="line">    u_char *m;</span><br><span class="line">    size_t psize;</span><br><span class="line">    ngx_pool_t *p, *new, *current;</span><br><span class="line"> </span><br><span class="line">    psize = (size_t)(pool-&gt;d.end - (u_char *) pool);</span><br><span class="line"> </span><br><span class="line">    /* 申请新的块 */</span><br><span class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;log);</span><br><span class="line">    if (m == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    new = (ngx_pool_t *) m;</span><br><span class="line"> </span><br><span class="line">    new-&gt;d.end = m + psize;</span><br><span class="line">    new-&gt;d.next = NULL;</span><br><span class="line">    new-&gt;d.failed = 0;</span><br><span class="line"> </span><br><span class="line">    /* 分配size大小的内存块，返回m指针地址 */</span><br><span class="line">    m += sizeof(ngx_pool_data_t);</span><br><span class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">    new-&gt;d.last = m + size;</span><br><span class="line"> </span><br><span class="line">    current = pool-&gt;current;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 缓存池的pool数据结构会挂载子节点的ngx_pool_t数据结构</span><br><span class="line">     * 子节点的ngx_pool_t数据结构中只用到pool-&gt;d的结构，只保存数据</span><br><span class="line">     * 每添加一个子节点，p-&gt;d.failed就会+1，当添加超过4个子节点的时候，</span><br><span class="line">     * pool-&gt;current会指向到最新的子节点地址</span><br><span class="line">     *</span><br><span class="line">     * 这个逻辑主要是为了防止pool上的子节点过多，导致每次ngx_palloc循环pool-&gt;d.next链表</span><br><span class="line">     * 将pool-&gt;current设置成最新的子节点之后，每次最大循环4次，不会去遍历整个缓存池链表</span><br><span class="line">     */</span><br><span class="line">    for (p = current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        if (p-&gt;d.failed++ &gt; 4) &#123;</span><br><span class="line">            current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    p-&gt;d.next = new;</span><br><span class="line"> </span><br><span class="line">    /* 最终这个还是没变 */</span><br><span class="line">    pool-&gt;current = current ? current : new;</span><br><span class="line"> </span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>分配一块大内存，挂载到pool-&gt;large链表上ngx_palloc_large</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 当分配的内存块大小超出pool-&gt;max限制的时候,需要分配在pool-&gt;large上</span><br><span class="line"> */</span><br><span class="line">static void *</span><br><span class="line">ngx_palloc_large(ngx_pool_t *pool, size_t size) &#123;</span><br><span class="line">    void *p;</span><br><span class="line">    ngx_uint_t n;</span><br><span class="line">    ngx_pool_large_t *large;</span><br><span class="line"> </span><br><span class="line">    /* 分配一块新的大内存块 */</span><br><span class="line">    p = ngx_alloc(size, pool-&gt;log);</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    n = 0;</span><br><span class="line"> </span><br><span class="line">    /* 去pool-&gt;large链表上查询是否有NULL的，只在链表上往下查询3次，主要判断大数据块是否有被释放的，如果没有则只能跳出*/</span><br><span class="line">    for (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        if (large-&gt;alloc == NULL) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (n++ &gt; 3) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 分配一个ngx_pool_large_t 数据结构 */</span><br><span class="line">    large = ngx_palloc(pool, sizeof(ngx_pool_large_t));</span><br><span class="line">    if (large == NULL) &#123;</span><br><span class="line">        ngx_free(p); //如果分配失败，删除内存块</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"> </span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>大内存块的释放ngx_pfree</p><p>内存池释放需要走ngx_destroy_pool，独立大内存块的单独释放，可以走ngx_pfree方法。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 大内存块释放  pool-&gt;large</span><br><span class="line"> */</span><br><span class="line">ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p) &#123;</span><br><span class="line">    ngx_pool_large_t *l;</span><br><span class="line"> </span><br><span class="line">    /* 在pool-&gt;large链上循环搜索，并且只释放内容区域，不释放ngx_pool_large_t数据结构*/</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (p == l-&gt;alloc) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,</span><br><span class="line">                    &quot;free: %p&quot;, l-&gt;alloc);</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = NULL;</span><br><span class="line"> </span><br><span class="line">            return NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>cleanup机制 可以回调函数清理数据</p><p>  Nginx的内存池cleanup机制，设计的非常巧妙。pool-&gt;cleanup本身是一个链表，每个ngx_pool_cleanup_t的数据结构上，保存着内存数据的本身cleanup-&gt;data和回调清理函数cleanup-&gt;handler。</p><p>  通过cleanup的机制，我们就可以在内存池上保存例如文件句柄fd的资源。当我们调用ngx_destroy_pool方法销毁内存池的时候，首先会来清理pool-&gt;cleanup，并且都会执行c-&gt;handler(c-&gt;data)回调函数，用于清理资源。</p><p>Nginx的这个机制，最显著的就是让文件描述符和需要自定义清理的数据的管理变得更加简单。</p><p>分配一个cleanup结构：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 分配一个可以用于回调函数清理内存块的内存</span><br><span class="line"> * 内存块仍旧在p-&gt;d或p-&gt;large上</span><br><span class="line"> *</span><br><span class="line"> * ngx_pool_t中的cleanup字段管理着一个特殊的链表，该链表的每一项都记录着一个特殊的需要释放的资源。</span><br><span class="line"> * 对于这个链表中每个节点所包含的资源如何去释放，是自说明的。这也就提供了非常大的灵活性。</span><br><span class="line"> * 意味着，ngx_pool_t不仅仅可以管理内存，通过这个机制，也可以管理任何需要释放的资源，</span><br><span class="line"> * 例如，关闭文件，或者删除文件等等的。下面我们看一下这个链表每个节点的类型</span><br><span class="line"> *</span><br><span class="line"> * 一般分两种情况：</span><br><span class="line"> * 1. 文件描述符</span><br><span class="line"> * 2. 外部自定义回调函数可以来清理内存</span><br><span class="line"> */</span><br><span class="line">ngx_pool_cleanup_t *</span><br><span class="line">ngx_pool_cleanup_add(ngx_pool_t *p, size_t size) &#123;</span><br><span class="line">    ngx_pool_cleanup_t *c;</span><br><span class="line"> </span><br><span class="line">    /* 分配一个ngx_pool_cleanup_t */</span><br><span class="line">    c = ngx_palloc(p, sizeof(ngx_pool_cleanup_t));</span><br><span class="line">    if (c == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* 如果size !=0 从pool-&gt;d或pool-&gt;large分配一个内存块 */</span><br><span class="line">    if (size) &#123;</span><br><span class="line">        /*  */</span><br><span class="line">        c-&gt;data = ngx_palloc(p, size);</span><br><span class="line">        if (c-&gt;data == NULL) &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        c-&gt;data = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* handler为回调函数 */</span><br><span class="line">    c-&gt;handler = NULL;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"> </span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"> </span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;log, 0, &quot;add cleanup: %p&quot;, c);</span><br><span class="line"> </span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>手动清理 p-&gt;cleanup链表上的数据：（内存池销毁函数ngx_destroy_pool也会清理p-&gt;cleanup）</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 清除 p-&gt;cleanup链表上的内存块（主要是文件描述符）</span><br><span class="line"> * 回调函数：ngx_pool_cleanup_file</span><br><span class="line"> */</span><br><span class="line">void ngx_pool_run_cleanup_file(ngx_pool_t *p, ngx_fd_t fd) &#123;</span><br><span class="line">    ngx_pool_cleanup_t *c;</span><br><span class="line">    ngx_pool_cleanup_file_t *cf;</span><br><span class="line"> </span><br><span class="line">    for (c = p-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        if (c-&gt;handler == ngx_pool_cleanup_file) &#123;</span><br><span class="line"> </span><br><span class="line">            cf = c-&gt;data;</span><br><span class="line"> </span><br><span class="line">            if (cf-&gt;fd == fd) &#123;</span><br><span class="line">                c-&gt;handler(cf); /* 调用回调函数 */</span><br><span class="line">                c-&gt;handler = NULL;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>关闭文件的回调函数和删除文件的回调函数。这个是文件句柄通用的回调函数，可以放置在p-&gt;cleanup-&gt;handler上。 </p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 关闭文件回调函数</span><br><span class="line"> * ngx_pool_run_cleanup_file方法执行的时候，用了此函数作为回调函数的，都会被清理</span><br><span class="line"> */</span><br><span class="line">void ngx_pool_cleanup_file(void *data) &#123;</span><br><span class="line">    ngx_pool_cleanup_file_t *c = data;</span><br><span class="line"> </span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, c-&gt;log, 0, &quot;file cleanup: fd:%d&quot;,</span><br><span class="line">            c-&gt;fd);</span><br><span class="line"> </span><br><span class="line">    if (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno,</span><br><span class="line">                ngx_close_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 删除文件回调函数</span><br><span class="line"> */</span><br><span class="line">void ngx_pool_delete_file(void *data) &#123;</span><br><span class="line">    ngx_pool_cleanup_file_t *c = data;</span><br><span class="line"> </span><br><span class="line">    ngx_err_t err;</span><br><span class="line"> </span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, c-&gt;log, 0, &quot;file cleanup: fd:%d %s&quot;,</span><br><span class="line">            c-&gt;fd, c-&gt;name);</span><br><span class="line"> </span><br><span class="line">    if (ngx_delete_file(c-&gt;name) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        err = ngx_errno;</span><br><span class="line"> </span><br><span class="line">        if (err != NGX_ENOENT) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_CRIT, c-&gt;log, err,</span><br><span class="line">                    ngx_delete_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno,</span><br><span class="line">                ngx_close_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx学习入门&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://javastar.club/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://javastar.club/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>道家思想研究一</title>
    <link href="http://javastar.club/archives/14a6c290.html"/>
    <id>http://javastar.club/archives/14a6c290.html</id>
    <published>2019-07-31T13:01:27.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>佛学研究一</title>
    <link href="http://javastar.club/archives/bdc98c68.html"/>
    <id>http://javastar.club/archives/bdc98c68.html</id>
    <published>2019-07-31T13:01:08.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>  佛言：“人本立神，一身清明，能有所益。奉于正行，强有所观，不解本无，自见有身，因生五阴六衰之惑，反为所迷，不至正真；后解三界一切皆空，五阴悉除，三毒自灭，乃至无上正真之道。”</p><a id="more"></a><p>  布施度贪心、忍辱度嗔心、般若度痴心<br>佛家所谓修行，即是修心，只有把这心修圆满了，才能打破生死的界限。<br>物理学上指出，能量是不会消失的，只会从一种状态转换到另一种状态。从物理学角度看，几千亿年前，我们也是一颗星辰，我们体内的所有物质都是原子组成，那我们即是一颗原子的聚合体，死亡是体内无法产生电流，思考不能继续，那么我们是否依然存活，只依赖于保持脑部电流的流通？</p><h3 id="摘录句子"><a href="#摘录句子" class="headerlink" title="摘录句子"></a>摘录句子</h3><ol>  <li>浮世万千，吾爱有三。<br>日，月与卿。<br>日为朝，月为暮，<br>卿为朝朝暮暮。</li>  <li>坐亦禅行亦禅，一花一世界，一叶一如来，春来花自青，秋至叶飘零，无穷般若心自在，语默动静体自然。 无我相，无人相，无众生相，无寿者相。 </li>  <li>凡所有相，皆是虚妄。若见诸相非相，即见如来。 </li>  <li>诸法因缘生，诸法因缘灭。因缘生灭法，佛说皆是空。 </li>  <li>一切皆流，无物永驻。 </li>  <li>舍利子、色不异空、空不异色。</li>  <li>色即是空、空即是色、受想行识、亦复如是。</li>  <li>舍利子、是诸法空相、不生不灭、不垢不净、不增不减。</li>  <li>心生种种法生，心灭种种法灭。</li>  <li>我自无心于万物，何妨万物常围绕。 </li>  <li>欲知前世因，今生受者是；欲知来世果，今生作者是。</li>  <li>唯心所现，唯识所变。</li>  <li>圣人求心不求佛，愚人求佛不求心。 </li>  <li>此有故彼有，此生故彼生；此无故彼无，此灭故彼灭。 </li>  <li>心有所住，即为非住。应无所住，而生其心。 </li>  <li>爱不重不生娑婆，念不一不生净土。 </li>  <li>净心之要，无如念佛。一念相应一念佛，念念相应念念佛，佛号投于乱心，乱心不得不佛。 </li>  <li>人不如我意，是我无量；我不如人意，是我无德。 </li>  <li>人身难得，佛法难闻。人身难得今已得，佛法难闻今亦闻。此身不向今生度，更向何生度此身。 </li>  <li>世出世间思维遍，不念弥陀更念谁。 </li>  <li>念佛时，即见佛时，亦即成佛时。求生时，即往生时，亦即度生时。</li>  <li>智人除心不除境，愚人除境不除心。心既除矣，境岂实有。 </li>  <li>观身不净，观受是苦，观心无常，观法无我。 </li>  <li>千悟万悟悟不到，原来一句佛名号。 </li>  <li>梦里明明有六趣，觉后空空无大千。 </li>  <li>是心作佛，是心是佛。 </li>  <li>善恶报应，祸福相承，身自当之，无谁代者。 </li>  <li>着相修行百千劫，无相修行刹那间，若能万法尽舍却，顿悟入道须臾间。 </li>  <li>祸福无门，惟人自召 善恶之报，如影随形，积善之家，必有余庆，积不善之家，必有余殃。</li>  <li>知幻即离,不作方便,离幻即觉,亦无渐次。 </li>  <li>一切有为法，尽是因缘合和，缘起时起，缘尽还无，不外如是。 </li>  <li>缘起法身偈诸法因缘生，我说是因缘。因缘尽故灭，我作如是说。 </li>  <li>世间万物皆空。唯其空，便能包容万物。</li></ol><h2 id="《金刚经》读书笔记"><a href="#《金刚经》读书笔记" class="headerlink" title="《金刚经》读书笔记"></a>《金刚经》读书笔记</h2><p><strong>【第一品 法会因由】</strong></p><p>如是我闻。一时佛在舍卫国祇树给孤独园。与大比丘众千二百五十人俱。尔时世尊食时。着衣持钵。入舍</p><p>卫大城乞食。于其城中次第乞已。还至本处。饭食讫。收衣钵。洗足已。敷座而坐。</p><p>【解读】</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>      </td>      <td class="code">        <pre><span class="line">自然无量真空生天育地，生万物，化万灵。人类生在天地中，顶天立地，天地中枢，动物之长，万物之灵</span><br><span class="line"></span><br><span class="line">，天之骄子，继天立极，代天宣化。天不言，地不语，天地借人把道宣，人类心法由真空灵源直贯而下。</span><br><span class="line"></span><br><span class="line">原始初祖伏羲，是中华民族的文化之祖，创造文明，文教文化，后由炎黄继承。人类进化，伏羲为宗祖，</span><br><span class="line"></span><br><span class="line">在原始人类最初的野生时代，无人造物质，赤身裸休，无语言文字。自然生育人类，自然教化理法，天地</span><br><span class="line"></span><br><span class="line">生人天教化。圣祖的思想觉悟直贯真空灵源，圣由天纵万化通。自然真空天地人类万物是同体，无量虚无</span><br><span class="line"></span><br><span class="line">真空一总体。伏羲一画开天立无极。文字依此立，文化由此起。真空妙有无为理，人类法会因由始开基。</span><br><span class="line"></span><br><span class="line">继文化宗祖后，无为大法炎黄理，继祖进化宣真机、创万理，五千年文明史奠基。尧、舜、禹、汤、文、</span><br><span class="line"></span><br><span class="line">武、周公圣君先贤，后来的老子、孔子，同立真空无为理。中华民族世世代代继圣基，一脉相传兴文化，</span><br><span class="line"></span><br><span class="line">文明古国耸立在人间，始祖古老文化永流传。皇天不断无为路，人类地地代代出圣贤。大圣人生于西方，</span><br><span class="line"></span><br><span class="line">前无古，后无今。真空妙有无为理，明心法会因由倡宏遍地、人人处处亲。中古传到今，无为大法未来新</span><br><span class="line"></span><br><span class="line">。如是我闻心心相印理，无闻无说法会因由何为根？法由心源起，说法谢知音，用心闻观自心，闻我是我</span><br><span class="line"></span><br><span class="line">闻。我闻自闻法，缘起佛的心。心是如是法，印心才明心。定慧圆明理，继往开来心传心。《金刚经》真</span><br><span class="line"></span><br><span class="line">宗正教，佛传后人明心旨，遵旨照行、妙觉圆通报佛拯救天赋明命恩。释迦妙语圆音贯耳根，耳闻心受心</span><br><span class="line"></span><br><span class="line">闻心。闻心闻知佛因是自我，闻我两亡空寂默，无闻无我自佛真。如是我闻通佛义，心心相印古到今。大</span><br><span class="line"></span><br><span class="line">法弘扬，放眼宽心观未来人。</span><br></pre>      </td>    </tr>  </table></figure><p> 众生皆有命。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;
  佛言：“人本立神，一身清明，能有所益。奉于正行，强有所观，不解本无，自见有身，因生五阴六衰之惑，反为所迷，不至正真；后解三界一切皆空，五阴悉除，三毒自灭，乃至无上正真之道。”
&lt;/p&gt;
    
    </summary>
    
      <category term="生活哲学" scheme="http://javastar.club/categories/%E7%94%9F%E6%B4%BB%E5%93%B2%E5%AD%A6/"/>
    
    
      <category term="佛学" scheme="http://javastar.club/tags/%E4%BD%9B%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java密码学学习笔记</title>
    <link href="http://javastar.club/archives/13cff302.html"/>
    <id>http://javastar.club/archives/13cff302.html</id>
    <published>2019-07-31T03:28:44.000Z</published>
    <updated>2019-08-07T07:14:52.673Z</updated>
    
    <content type="html"><![CDATA[<p>Java加密与解密读书笔记</p><a id="more"></a><h3 id="密码学常用术语"><a href="#密码学常用术语" class="headerlink" title="密码学常用术语"></a>密码学常用术语</h3><p>  明文(Plaintext):指待加密信息，明文可以是文本文件、图片文件、二进制数据等。<br>密文(Ciphertext):指经过加密后的明文，密文通常以文本、二进制数据等形式存在。<br>发送者(Sender):指发送消息的人。<br>接受者(Receiver):指接收消息的人。<br>加密(Encryption):指将明文转换为密文的过程。<br>加密算法(Encryption  Algorithm)<br>加密密钥(Encryption Key)<br>密码体制(Cipher  System):由明文空间、密文空间、密钥空间、加密算法那及解密算法五部分组成。</p><h3 id="密码学分类"><a href="#密码学分类" class="headerlink" title="密码学分类"></a>密码学分类</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java加密与解密读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="密码学" scheme="http://javastar.club/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="java" scheme="http://javastar.club/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发之synchronized实现原理</title>
    <link href="http://javastar.club/archives/95e81.html"/>
    <id>http://javastar.club/archives/95e81.html</id>
    <published>2019-07-29T06:34:52.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>java并发之synchronized实现原理</p><a id="more"></a><p>造成线程安全问题的主要原因：</p><ol>  <li>存在共享数据(临界资源)</li>  <li>存在多条线程共同操作共享数据。</li></ol><p>  <strong>互斥锁</strong>，当一个共享数据被当前正在访问的线程加上互斥锁后，在同一时刻，其他线程只能处于等待状态，直到当前线程处理完毕释放该锁。</p><p>  synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者代码（主要是对方法或者代码块中存在共享数据的操作)，另外，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能）</p><h3 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h3><ul>  <li>    <p>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</p>  </li>  <li>    <p>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</p>  </li>  <li>    <p>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</p>  </li></ul><p><strong>synchronized作用于实例方法</strong></p><p>所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法，注意是实例方法不包括静态方法，如下:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class AccountingSync implements Runnable&#123;</span><br><span class="line">    //共享资源(临界资源)</span><br><span class="line">    static int i=0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * synchronized 修饰实例方法</span><br><span class="line">     */</span><br><span class="line">    public synchronized void increase()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int j=0;j&lt;1000000;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        AccountingSync instance=new AccountingSync();</span><br><span class="line">        Thread t1=new Thread(instance);</span><br><span class="line">        Thread t2=new Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 输出结果:</span><br><span class="line">     * 2000000</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>  上述代码中，我们开启两个线程操作同一个共享资源即变量i，由于i++;操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全。</p><p>  此时我们应该注意到synchronized修饰的是实例方法increase，在这样的情况下，当前线程的锁便是实例对象instance，注意Java中的线程同步锁可以是任意对象。从代码执行结果来看确实是正确的，倘若我们没有使用synchronized关键字，其最终输出结果就很可能小于2000000，这便是synchronized关键字的作用。</p><p>这里我们还需要意识到，当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized  方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，但是其他线程还是可以访问该实例对象的其他非synchronized方法，当然如果是一个线程  A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的  synchronized 方法  f2(当前对象锁是obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了，如下代码将演示出该现象</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class AccountingSyncBad implements Runnable&#123;</span><br><span class="line">    static int i=0;</span><br><span class="line">    public synchronized void increase()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int j=0;j&lt;1000000;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //new新实例</span><br><span class="line">        Thread t1=new Thread(new AccountingSyncBad());</span><br><span class="line">        //new新实例</span><br><span class="line">        Thread t2=new Thread(new AccountingSyncBad());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        //join含义:当前线程A等待thread线程终止之后才能从thread.join()返回</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>  上述代码与前面不同的是我们同时创建了两个新实例AccountingSyncBad，然后启动两个不同的线程对共享变量i进行操作，但很遗憾操作结果是1452317而不是期望结果2000000，因为上述代码犯了严重的错误，虽然我们使用synchronized修饰了increase方法，但却new了两个不同的实例对象，这也就意味着存在着两个不同的实例对象锁，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的。<br>解决这种困境的的方式是将synchronized作用于静态的increase方法，这样的话，对象锁就当前类对象，由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的。下面我们看看如何使用将synchronized作用于静态的increase方法.</p><h3 id="synchronized作用于静态方法"><a href="#synchronized作用于静态方法" class="headerlink" title="synchronized作用于静态方法"></a>synchronized作用于静态方法</h3><p>  当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态  成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态  synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态  synchronized 方法占用的锁是当前实例对象锁，看如下代码</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class AccountingSyncClass implements Runnable&#123;</span><br><span class="line">    static int i=0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 作用于静态方法,锁是当前class对象,也就是</span><br><span class="line">     * AccountingSyncClass类对应的class对象</span><br><span class="line">     */</span><br><span class="line">    public static synchronized void increase()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 非静态,访问时锁不一样不会发生互斥</span><br><span class="line">     */</span><br><span class="line">    public synchronized void increase4Obj()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int j=0;j&lt;1000000;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //new新实例</span><br><span class="line">        Thread t1=new Thread(new AccountingSyncClass());</span><br><span class="line">        //new心事了</span><br><span class="line">        Thread t2=new Thread(new AccountingSyncClass());</span><br><span class="line">        //启动线程</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>  由于synchronized关键字修饰的是静态increase方法，与修饰实例方法不同的是，其锁对象是当前类的class对象。注意代码中的increase4Obj方法是实例方法，其对象锁是当前实例对象，如果别的线程调用该方法，将不会产生互斥现象，毕竟锁对象不同，但我们应该意识到这种情况下可能会发现线程安全问题(操作了共享静态变量i)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java并发之synchronized实现原理&lt;/p&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://javastar.club/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java并发" scheme="http://javastar.club/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java基础知识补充二</title>
    <link href="http://javastar.club/archives/945dffd.html"/>
    <id>http://javastar.club/archives/945dffd.html</id>
    <published>2019-07-29T06:34:29.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础细节学习</p><a id="more"></a><h3 id="Java-8系列之重新认识HashMap"><a href="#Java-8系列之重新认识HashMap" class="headerlink" title="Java 8系列之重新认识HashMap"></a>Java  8系列之重新认识HashMap</h3><h6 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h6><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet  Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>  Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap<br>下面针对各个实现类的特点做一些说明：</p><p>(1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。  HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用  Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><p>(2)  Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><p>(3)  LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>(4)  TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p><p>  对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p><p>  通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>  搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。</p><h5 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h5><p>  从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的.<br>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p><p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[]  table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;    //用来定位数组索引位置</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   //链表的下一个node</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        public final K getKey()&#123; ... &#125;</span><br><span class="line">        public final V getValue() &#123; ... &#125;</span><br><span class="line">        public final String toString() &#123; ... &#125;</span><br><span class="line">        public final int hashCode() &#123; ... &#125;</span><br><span class="line">        public final V setValue(V newValue) &#123; ... &#125;</span><br><span class="line">        public final boolean equals(Object o) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p><p>(2)  HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">map.put(&quot;javastar&quot;,&quot;xin&quot;);</span><br></pre>      </td>    </tr>  </table></figure><p>系统将调用”javastar”这个key的hashCode()方法得到其hashCode  值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p><p>  如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[]  table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p><p>  在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">int threshold;             // 所能容纳的key-value对极限 </span><br><span class="line">    final float loadFactor;    // 负载因子</span><br><span class="line">    int modCount;  </span><br><span class="line">    int size;</span><br></pre>      </td>    </tr>  </table></figure><p>首先，Node[] table的初始化长度length(默认值是16)，Load  factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold =  length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>结合负载因子的定义公式可知，threshold就是在此Load  factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load  factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p><p>  size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p><p>  在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数.<br>Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p>  这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p><h4 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a>功能实现-方法</h4><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p><ol>  <li>确定哈希桶数组索引位置</li></ol><p>  不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p><p>方法一：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">static final int hash(Object key) &#123;   //jdk1.8 &amp; jdk1.7</span><br><span class="line">     int h;</span><br><span class="line">     // h = key.hashCode() 为第一步 取hashCode值</span><br><span class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>方法二：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">static int indexFor(int h, int length) &#123;  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span><br><span class="line">     return h &amp; (length-1);  //第三步 取模运算</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p><p>  对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length  -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp;  (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h  &gt;&gt;&gt;  16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java基础细节学习&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://javastar.club/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://javastar.club/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="http://javastar.club/archives/eea60a6a.html"/>
    <id>http://javastar.club/archives/eea60a6a.html</id>
    <published>2019-07-29T06:12:23.000Z</published>
    <updated>2019-08-07T07:14:52.720Z</updated>
    
    <content type="html"><![CDATA[<p>字典树相关习题</p><a id="more"></a><h3 id="前缀树的结构"><a href="#前缀树的结构" class="headerlink" title="前缀树的结构"></a>前缀树的结构</h3><p>Trie树，又叫字典树、前缀树（Prefix  Tree）、单词查找树或键树，是一种多叉树结构.<br>用于处理大量字符串，优点是：利用字符串的公共前缀，在存储时节约存储空间，并在查询时最大限度的减少无谓的字符串比较。</p><h3 id="字典树的作用"><a href="#字典树的作用" class="headerlink" title="字典树的作用"></a>字典树的作用</h3><ol>  <li>以最节约空间的方式存储大量字符串.且存好后是有序的</li></ol><p>因为是有序的,故而字典树不仅可用于大量字符串的存储,还可用于大量字符串的排序.</p><ol start="2">  <li>快速查询某字符串s在字典树中是否已存在,甚至出现过几次</li></ol><p>因为当字典树预处理好之后,查询字符串s在当前的出现情况的效率为strlen(s),异常高效,故而常用于搜索引擎等.</p><p>版权声明：本文为博主原创文章，转载请附上博文链接！</p><h3 id="Trie树的基本性质："><a href="#Trie树的基本性质：" class="headerlink" title="Trie树的基本性质："></a>Trie树的基本性质：</h3><ol>  <li>根节点不包含字符，除根节点以外的每一个子节点都包含一个字符。</li>  <li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>  <li>每个节点的所有子节点包含的字符互不相同。</li>  <li>从第一字符开始有连续重复的字符只占用一个节点.</li></ol><h3 id="前缀树的应用"><a href="#前缀树的应用" class="headerlink" title="前缀树的应用"></a>前缀树的应用</h3><ol>  <li>前缀匹配</li>  <li>字符串检索</li>  <li>词频统计</li>  <li>字符串排序等。</li></ol><p><strong>前缀匹配</strong><br>定义前缀树结构：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Tries&#123;</span><br><span class="line">    Boolean isTrie ;</span><br><span class="line">    HashMap&lt;Character, Tries&gt; children=new HashMap&lt;Character, Tries&gt;(); </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>上面的 isTrie 用来标记单词是否遍历完。children表示该节点的子节点。<br><strong>建立前缀树</strong></p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public static boolean insertNode(String str,Tries head)</span><br><span class="line">&#123;</span><br><span class="line">    if(str==null||str.length()==0)</span><br><span class="line">        return false;</span><br><span class="line">        //如果插入的单词为null 或者单词长度为0直接返回false，false代表该单词不是前缀树中某个单词的前缀，</span><br><span class="line">        //或者前缀树中某个单词是该单词的前缀。</span><br><span class="line">    char chs[]=str.toCharArray();</span><br><span class="line">    int i=0;</span><br><span class="line">    Tries cur=head;</span><br><span class="line">    //将字符串的每个字符插入到前缀树中</span><br><span class="line">    while(i&lt;chs.length)</span><br><span class="line">    &#123;           </span><br><span class="line">        if(!cur.children.containsKey(chs[i]))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cur.children.put(chs[i], new Tries());</span><br><span class="line">            //如果当前节点中的子树节点中不包含当前字符，新建一个子节点。</span><br><span class="line">        &#125;</span><br><span class="line">        //否则复用该节点</span><br><span class="line">        cur=cur.children.get(chs[i]);</span><br><span class="line">        if(cur.count==true)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot; trie tree&quot;);</span><br><span class="line">            return true;</span><br><span class="line">            //判断前缀树中是否有字符串为当前字符串的前缀。</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.count=true;</span><br><span class="line">    if(cur.children.size()&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot; trie tree&quot;);</span><br><span class="line">        return true;</span><br><span class="line">        //判断当前字符串是否是前缀树中某个字符的前缀。</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>前缀树的建立过程就是插入字符串的过程，同时在插入节点的时候可以判断插入的字符串是否是前缀树里面某个单词的前缀，或者前缀树中的某个单词是否是该单词的前缀。</p><ol>  <li>先将字符串转换为字符数组，然后对每个字符进行处理，如果当前节点的子节点中包含有要处理的字符字节复用。否则新建一个子节点。</li>  <li>判断是否是前缀单词的时候，有两个步骤，首先要看该字符串是否是其他字符串的前缀，还有看其他字符串是否是当前字符串的前缀。</li></ol><p>判断前缀单词的完整代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class isTrie &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Tries tries=new Tries();</span><br><span class="line">        String strs[]=&#123;&quot;abc&quot;,&quot;abd&quot;,&quot;b&quot;,&quot;abdc&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;strs.length;i++)  </span><br><span class="line">            insertNode(strs[i], tries);                 </span><br><span class="line">    &#125;</span><br><span class="line">public static boolean insertNode(String str,Tries head)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str==null||str.length()==0)</span><br><span class="line">            return false;</span><br><span class="line">        char chs[]=str.toCharArray();</span><br><span class="line">        int i=0;</span><br><span class="line">        Tries cur=head;</span><br><span class="line">        while(i&lt;chs.length)</span><br><span class="line">        &#123;           </span><br><span class="line">            if(!cur.children.containsKey(chs[i]))</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                cur.children.put(chs[i], new Tries());</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.children.get(chs[i]);</span><br><span class="line">            if(cur.count==true)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot; trie tree&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.count=true;</span><br><span class="line">        if(cur.children.size()&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot; trie tree&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Tries&#123;</span><br><span class="line">    boolean isTrie;</span><br><span class="line">    HashMap&lt;Character, Tries&gt; children=new HashMap&lt;Character, Tries&gt;(); </span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="模板代码："><a href="#模板代码：" class="headerlink" title="模板代码："></a>模板代码：</h3><ol>  <li>    <p>以数组模拟动态分配的只带增查的字典树模板</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre>          </td>          <td class="code">            <pre><span class="line">//一个只带添加字符串与查找字符串的字典树（为了效率以数组实现） </span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">int charmapping[256]; //字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] </span><br><span class="line">void init_charmapping()&#123;</span><br><span class="line">    for(int i=&apos;a&apos;;i&lt;=&apos;z&apos;;i++)&#123; //我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. </span><br><span class="line">        charmapping[i]=i-&apos;a&apos;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">const int maxn=26; //这里假设字符串中只出现26个小写字母 </span><br><span class="line">const int maxm=100000;</span><br><span class="line">struct treenode&#123;</span><br><span class="line">    bool end; //标志此节点是否是某字符串的结尾 </span><br><span class="line">    treenode* next[maxn]; </span><br><span class="line">&#125;head;</span><br><span class="line"> </span><br><span class="line">treenode memory[maxm]; //字典树所用到的数组空间</span><br><span class="line">int mallocp=0;  //模拟内存分配</span><br><span class="line"> </span><br><span class="line">void init()&#123;</span><br><span class="line">    head.end=1;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++) head.next[i]=NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">treenode* createnew()&#123;</span><br><span class="line">    treenode* newnode;</span><br><span class="line">    newnode=&amp;memory[mallocp++];</span><br><span class="line">    newnode-&gt;end=0;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++) newnode-&gt;next[i]=NULL;</span><br><span class="line">    return newnode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void update(char* s)&#123;</span><br><span class="line">    int k=0,temp;</span><br><span class="line">    treenode* t=&amp;head;</span><br><span class="line">    while(s[k])&#123;</span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        if(!t-&gt;next[temp]) t-&gt;next[temp]=createnew(); </span><br><span class="line">        t=t-&gt;next[temp];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;end=1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool search(char* s)&#123;</span><br><span class="line">    int k=0,temp;</span><br><span class="line">    treenode* t=&amp;head;</span><br><span class="line">    while(s[k])&#123;</span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        if(!t-&gt;next[temp]) return false;</span><br><span class="line">        t=t-&gt;next[temp];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t-&gt;end) return true;</span><br><span class="line">    return false; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    char x[1000];</span><br><span class="line">    char t;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        fflush(stdin);</span><br><span class="line">        scanf(&quot;%c&quot;,&amp;t);</span><br><span class="line">        if(t==&apos;q&apos;)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,&amp;x);</span><br><span class="line">            if(search(x)) printf(&quot;匹配成功！\n&quot;);</span><br><span class="line">            else printf(&quot;匹配失败！\n&quot;); </span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==&apos;u&apos;)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,&amp;x);</span><br><span class="line">            update(x);</span><br><span class="line">            printf(&quot;更新完毕！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==&apos;e&apos;)&#123;</span><br><span class="line">            printf(&quot;退出ing....\n&quot;); </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else printf(&quot;无效命令！,请重新输入！\n&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>以动态分配为实现的带增删改查的字典树模板</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre>          </td>          <td class="code">            <pre><span class="line">//一个以链表实现带删除功能允许重复字符串的字典树</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int charmapping[256]; //字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] </span><br><span class="line">void init_charmapping()&#123;</span><br><span class="line">    for(int i=&apos;a&apos;;i&lt;=&apos;z&apos;;i++)&#123; //我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. </span><br><span class="line">        charmapping[i]=i-&apos;a&apos;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">const int maxn=26; //这里假设字符串中只出现26个小写字母 </span><br><span class="line">const int maxm=100000;</span><br><span class="line">struct treenode&#123;</span><br><span class="line">    int count; //标志此节点所表示字符串在所有字符串中以前缀形式出现的总次数 </span><br><span class="line">    treenode* next[maxn]; </span><br><span class="line">&#125;head;</span><br><span class="line"> </span><br><span class="line">void init_trie()&#123;</span><br><span class="line">    head.count=1; //初始化为1包括空串并且避免树头被删 </span><br><span class="line">    for(int i=0;i&lt;maxn;i++) head.next[i]=NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">treenode* createnew()&#123; //申请一个新结点并初始化它</span><br><span class="line">    treenode* newnode;</span><br><span class="line">    newnode=(treenode*)malloc(sizeof(treenode));</span><br><span class="line">    newnode-&gt;count=0;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++) newnode-&gt;next[i]=NULL;</span><br><span class="line">    return newnode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void update(char* s,int num)&#123; //向字典树添加num个字符串s </span><br><span class="line">    int k=0,temp;</span><br><span class="line">    treenode* t=&amp;head;</span><br><span class="line">    while(s[k])&#123;</span><br><span class="line">        t-&gt;count+=num;</span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        if(!t-&gt;next[temp]) t-&gt;next[temp]=createnew(); </span><br><span class="line">        t=t-&gt;next[temp];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;count+=num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool search(char* s,int num)&#123;  //查找字典树中是否已经存在num个字符串s</span><br><span class="line">    int k=0,temp;</span><br><span class="line">    treenode* t=&amp;head;</span><br><span class="line">    while(s[k])&#123;</span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        if(!t-&gt;next[temp]||t-&gt;next[temp]-&gt;count&lt;num) return false; //根本不存在字符串s或者存在的数目小于num直接失败 </span><br><span class="line">        t=t-&gt;next[temp];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    int snum=t-&gt;count;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++) if(t-&gt;next[i]) snum-=t-&gt;next[i]-&gt;count; //这里是核心!!!结点t代表的字符串出现的次数就是总次数减去所有子节点次数和 </span><br><span class="line">    if(snum&gt;=num) return true; //如果字符串s的数目snum大于等于num </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void erase(char* s,int num)&#123;  //删除字典树中的num个字符串s并释放无用结点,删除前一定要先search是否存在 </span><br><span class="line">    int k=0,temp;</span><br><span class="line">    treenode* t=&amp;head;</span><br><span class="line">    treenode* t1; //t1后面的结点都是删除后需要被释放的 </span><br><span class="line">    head.count-=num;</span><br><span class="line">    while(s[k])&#123;</span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        t-&gt;next[temp]-&gt;count-=num;</span><br><span class="line">        if(t-&gt;next[temp]-&gt;count==0)&#123;</span><br><span class="line">            t1=t-&gt;next[temp];</span><br><span class="line">            t-&gt;next[temp]=NULL;</span><br><span class="line">            k++;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        t=t-&gt;next[temp];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(s[k])&#123; //释放无用结点 </span><br><span class="line">        temp=charmapping[s[k]];</span><br><span class="line">        t=t1-&gt;next[temp];</span><br><span class="line">        free(t1);</span><br><span class="line">        t1=t;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    free(t1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">char temp[1000];</span><br><span class="line">void printall(treenode* tnode,int pos)&#123; //递归打印字典树咯,打出了就是字典序升序的 </span><br><span class="line">    int count=tnode-&gt;count;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++) if(tnode-&gt;next[i]) count-=tnode-&gt;next[i]-&gt;count;</span><br><span class="line">    for(int i=0;i&lt;count;i++) printf(&quot;\&quot;%s\&quot;\n&quot;,temp);</span><br><span class="line">    for(int i=&apos;a&apos;;i&lt;=&apos;z&apos;;i++)&#123;</span><br><span class="line">        if(tnode-&gt;next[charmapping[i]])&#123;</span><br><span class="line">            temp[pos]=i;</span><br><span class="line">            temp[++pos]=&apos;\0&apos;;</span><br><span class="line">            printall(tnode-&gt;next[charmapping[i]],pos);</span><br><span class="line">            temp[--pos]=&apos;\0&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    init_charmapping(); //初始化映射 </span><br><span class="line">    init_trie();        //初始化字典树 </span><br><span class="line">    char x[1000];</span><br><span class="line">    char order; //命令 </span><br><span class="line">    int num;    //数目 </span><br><span class="line">    printf(&quot;q：查询\nu：插入\nd：删除\np：打印字典树\ne：退出\n&quot;);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        printf(&quot;请输入命令：&quot;);</span><br><span class="line">        fflush(stdin);</span><br><span class="line">        scanf(&quot;%c&quot;,&amp;order);</span><br><span class="line">        if(order==&apos;q&apos;)&#123;</span><br><span class="line">            printf(&quot;请输入要查找的字符串与数目：&quot;);</span><br><span class="line">            scanf(&quot;%s%d&quot;,&amp;x,&amp;num);</span><br><span class="line">            if(search(x,num)) printf(&quot;匹配成功。\n\n&quot;);</span><br><span class="line">            else printf(&quot;匹配失败，不存在%d个\&quot;%s\&quot;\n\n&quot;,num,x); </span><br><span class="line">        &#125;</span><br><span class="line">        else if(order==&apos;u&apos;)&#123;</span><br><span class="line">            printf(&quot;请输入要插入的字符串与数目：&quot;);</span><br><span class="line">            scanf(&quot;%s%d&quot;,&amp;x,&amp;num);</span><br><span class="line">            update(x,num);</span><br><span class="line">            printf(&quot;%d个\&quot;%s\&quot;已加入字典树。\n\n&quot;,num,x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(order==&apos;d&apos;)&#123;</span><br><span class="line">            printf(&quot;请输入要删除的字符串与数目：&quot;);</span><br><span class="line">            scanf(&quot;%s%d&quot;,&amp;x,&amp;num);</span><br><span class="line">            if(!search(x,num))&#123;</span><br><span class="line">                printf(&quot;树中无%d个字符串\&quot;%s\&quot;请重新键入命令！\n\n&quot;,num,x);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            erase(x,num);</span><br><span class="line">            printf(&quot;%d个\&quot;%s\&quot;已从字典树中删除。\n\n&quot;,num,x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(order==&apos;p&apos;)&#123;</span><br><span class="line">            printf(&quot;当前字典树内有如下字符串：\n&quot;);</span><br><span class="line">            temp[0]=&apos;\0&apos;;</span><br><span class="line">            printall(&amp;head,0);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(order==&apos;e&apos;)&#123;</span><br><span class="line">            printf(&quot;退出ing....\n&quot;); </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else printf(&quot;无效命令,请重新输入！\n命令q：查询是否存在字符串\n命令u：往字典树加入字符串\n命令d：删除某个字符串\n命令p：按字典序升序输出字典树\n命令e：退出程序\n\n&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h3 id="添加与搜索单词-数据结构设计"><a href="#添加与搜索单词-数据结构设计" class="headerlink" title="添加与搜索单词 - 数据结构设计"></a>添加与搜索单词  - 数据结构设计</h3><p>设计一个支持以下两种操作的数据结构：</p><p>void addWord(word)<br>bool search(word)</p><p>search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。</p><p>示例:</p><p>addWord(“bad”)<br>addWord(“dad”)<br>addWord(“mad”)<br>search(“pad”) -&gt;  false<br>search(“bad”) -&gt; true<br>search(“.ad”) -&gt; true<br>search(“b..”)  -&gt; true</p><p>说明:</p><p>你可以假设所有单词都是由小写字母 a-z 组成的。<br>链接：<a href="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/add-and-search-word-data-structure-design</a></p><p>Trie  树又称“前缀树”，它的典型应用对象是字符串，可以用于保存、统计。其特点是：用边表示字符，当走到叶子结点的时候，沿途所经过的边组成了一个字符串。其优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p><p>关于这道问题的难点是通配符 “.” 的处理，其实也不难：在遇到 “.” 的时候，使用递归方法，将该结点的每一个分支都看过去，只要有一个分支返回 true  就可以了，全部分支都走过去，都没有返回 true 的才返回 false。<br>这里要注意的是，一个结点指向孩子结点的“指针”（一般情况下多于 1  个），可以使用数组表示，也可以使用哈希表表示，如果题目中限制了测试用例“所有的输入都是由小写字母 a-z 构成的”，则可以使用数组表示。</p><p>1、一个结点指向孩子结点的“指针”们用数组表示；</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class WordDictionary &#123;</span><br><span class="line"></span><br><span class="line">    class Node &#123;</span><br><span class="line">        private Node[] next;</span><br><span class="line">        private boolean isWord;</span><br><span class="line"></span><br><span class="line">        public Node() &#123;</span><br><span class="line">            next = new Node[26];</span><br><span class="line">            isWord = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Initialize your data structure here.</span><br><span class="line">     */</span><br><span class="line">    public WordDictionary() &#123;</span><br><span class="line">        root = new Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Adds a word into the data structure.</span><br><span class="line">     */</span><br><span class="line">    public void addWord(String word) &#123;</span><br><span class="line">        int len = word.length();</span><br><span class="line">        Node curNode = root;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            char curChar = word.charAt(i);</span><br><span class="line">            Node next = curNode.next[curChar - &apos;a&apos;];</span><br><span class="line">            if (next == null) &#123;</span><br><span class="line">                curNode.next[curChar - &apos;a&apos;] = new Node();</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.next[curChar - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        if (!curNode.isWord) &#123;</span><br><span class="line">            curNode.isWord = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter.</span><br><span class="line">     */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        return match(word, root, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean match(String word, Node node, int start) &#123;</span><br><span class="line">        if (start == word.length()) &#123;</span><br><span class="line">            return node.isWord;</span><br><span class="line">        &#125;</span><br><span class="line">        char alpha = word.charAt(start);</span><br><span class="line">        if (alpha == &apos;.&apos;) &#123;</span><br><span class="line">            for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">                if (node.next[i] != null &amp;&amp; match(word, node.next[i], start + 1)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (node.next[alpha - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return match(word, node.next[alpha - &apos;a&apos;], start + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>2、一个结点指向孩子结点的“指针”们用哈希表表示。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre>      </td>      <td class="code">        <pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class WordDictionary &#123;</span><br><span class="line"></span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    private class Node &#123;</span><br><span class="line">        private boolean isWord;</span><br><span class="line">        private HashMap&lt;Character, Node&gt; next;</span><br><span class="line"></span><br><span class="line">        public Node() &#123;</span><br><span class="line">            this.next = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Initialize your data structure here.</span><br><span class="line">     */</span><br><span class="line">    public WordDictionary() &#123;</span><br><span class="line">        root = new Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Adds a word into the data structure.</span><br><span class="line">     */</span><br><span class="line">    public void addWord(String word) &#123;</span><br><span class="line">        Node curNode = root;</span><br><span class="line">        for (int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            Character c = word.charAt(i);</span><br><span class="line">            if (!curNode.next.containsKey(c)) &#123;</span><br><span class="line">                curNode.next.put(c, new Node());</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!curNode.isWord) &#123;</span><br><span class="line">            curNode.isWord = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter.</span><br><span class="line">     */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        return search(root, word, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean search(Node node, String word, int depth) &#123;</span><br><span class="line">        if (depth == word.length()) &#123;</span><br><span class="line">            // 只要能搜索到最后，就表示文本与模式匹配</span><br><span class="line">            // 这一步很容易被忽视</span><br><span class="line">            return node.isWord;</span><br><span class="line">        &#125;</span><br><span class="line">        Character c = word.charAt(depth);</span><br><span class="line">        if (c == &apos;.&apos;) &#123;</span><br><span class="line">            Set&lt;Character&gt; keys = node.next.keySet();</span><br><span class="line">            for (Character key : keys) &#123;</span><br><span class="line">                Node nextNode = node.next.get(key);</span><br><span class="line">                if (search(nextNode, word, depth + 1)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 循环都走完都没有找到，那就说明没有</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (!node.next.containsKey(c)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return search(node.next.get(c), word, depth + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WordDictionary wordDictionary = new WordDictionary();</span><br><span class="line">        wordDictionary.addWord(&quot;bad&quot;);</span><br><span class="line">        wordDictionary.addWord(&quot;dad&quot;);</span><br><span class="line">        wordDictionary.addWord(&quot;mad&quot;);</span><br><span class="line">        boolean search1 = wordDictionary.search(&quot;pad&quot;);// -&gt; false</span><br><span class="line">        System.out.println(search1);</span><br><span class="line">        boolean search2 = wordDictionary.search(&quot;bad&quot;); // -&gt; true</span><br><span class="line">        System.out.println(search2);</span><br><span class="line">        boolean search3 = wordDictionary.search(&quot;.ad&quot;); // -&gt; true</span><br><span class="line">        System.out.println(search3);</span><br><span class="line">        boolean search4 = wordDictionary.search(&quot;b..&quot;); //-&gt; true</span><br><span class="line">        System.out.println(search4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字典树相关习题&lt;/p&gt;
    
    </summary>
    
      <category term="算法刷题" scheme="http://javastar.club/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="字典树" scheme="http://javastar.club/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>深度优先搜索</title>
    <link href="http://javastar.club/archives/1857aa15.html"/>
    <id>http://javastar.club/archives/1857aa15.html</id>
    <published>2019-07-29T06:12:02.000Z</published>
    <updated>2019-08-07T07:14:52.720Z</updated>
    
    <content type="html"><![CDATA[<p>DFS</p><a id="more"></a><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><pre><code>节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。</code></pre><p>示例 1:</p><p>输入:<br> 2<br> / <br> 1 3<br>输出: true</p><p>示例 2:</p><p>输入:<br> 5<br> / <br> 1 4<br> / <br> 3 6<br>输出: false<br>解释: 输入为:  [5,1,4,null,null,3,6]。<br> 根节点的值为 5 ，但是其右子节点值为 4 。<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/validate-binary-search-tree</a><br>算法思路：</p><ol>  <li>    <p>      递归<br>首先将结点的值与上界和下界比较，然后对左右子树递归进行该过程。<br>时间复杂度：O(N)每个结点访问了一次<br>空间复杂度：O(N)整棵树<br>参考代码：    </p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>          </td>          <td class="code">            <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"> //1.递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">  public boolean help(TreeNode node, Integer lower, Integer upper) &#123;</span><br><span class="line">    if (node == null) return true;</span><br><span class="line"></span><br><span class="line">    int val = node.val;</span><br><span class="line">    if (lower != null &amp;&amp; val &lt;= lower) return false;</span><br><span class="line">    if (upper != null &amp;&amp; val &gt;= upper) return false;</span><br><span class="line"></span><br><span class="line">    if (! help(node.right, val, upper)) return false;</span><br><span class="line">    if (! help(node.left, lower, val)) return false;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">    return help(root, null, null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>迭代<br>通过使用栈，DFS比BFS快。<br>时间复杂度：O(N)每个结点访问了一次<br>空间复杂度：O(N)整棵树<br>参考代码：    </p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>          </td>          <td class="code">            <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack=new LinkedList();</span><br><span class="line">    LinkedList&lt;Integer&gt; uppers=new LinkedList();</span><br><span class="line">    LinkedList&lt;Integer&gt; lowers=new LinkedList();</span><br><span class="line">    public void update(TreeNode root,Integer lower,Integer upper)&#123;</span><br><span class="line">    stack.add(root);</span><br><span class="line">    lowers.add(lower);</span><br><span class="line">    uppers.add(upper);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        Integer lower=null,upper=null,val;</span><br><span class="line">        update(root,lower,upper);</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">        root=stack.poll();</span><br><span class="line">        lower=lowers.poll();</span><br><span class="line">        upper=uppers.poll();</span><br><span class="line">        if(root==null)continue;</span><br><span class="line">        val=root.val;</span><br><span class="line">        if(lower!=null&amp;&amp; val&lt;=lower) return false;</span><br><span class="line">        if(upper!=null&amp;&amp;val&gt;=upper)return false;</span><br><span class="line">        update(root.right,val,upper);</span><br><span class="line">        update(root.left,lower,val);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h3 id="207课程表"><a href="#207课程表" class="headerlink" title="207课程表"></a>207课程表</h3><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p>示例 1:</p><p>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p><p>示例 2:</p><p>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程  0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p><p>说明:</p><pre><code>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。</code></pre><p>提示:</p><pre><code>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。拓扑排序也可以通过 BFS 完成。</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/course-schedule" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/course-schedule</a><br>算法思路：</p><ol>  <li>拓扑排序<br>拓扑排序实际上应用的是贪心算法。贪心算法简而言之：每一步最优，全局就最优。</li></ol><p>具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，我们可以设置一个入度数组，每一轮都输出入度为 0  的结点，并移除它、修改它指向的结点的入度（−1即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。</p><p>  拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。拓扑排序还可以用于检测一个有向图是否有环。相关的概念还有  AOV 网，这里就不展开了。</p><p>算法流程：</p><p>1、在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 0 的结点放入队列。</p><p>2、只要队列非空，就从队首取出入度为 0的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减 1，在减 1  以后，如果这个被减 1 的结点的入度为 0，就继续入队。</p><p>3、当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。</p><p>思考这里为什么要使用队列？</p><p>在代码具体实现的时候，除了保存入度为 0 的队列，我们还需要两个辅助的数据结构：<br>1、邻接表：通过结点的索引，我们能够得到这个结点的后继结点；</p><p>2、入度数组：通过结点的索引，我们能够得到指向这个结点的结点个数。</p><p>这个两个数据结构在遍历题目给出的邻边以后就可以很方便地得到。</p><p>时间复杂度：O(E+V)。这里 E表示邻边的条数，V 表示结点的个数。初始化入度为 0的集合需要遍历整张图，具体做法是检查每个结点和每条边，因此复杂度为  O(E+V)，然后对该集合进行操作，又需要遍历整张图中的每个结点和每条边，复杂度也为 O(E+V)；</p><p>空间复杂度：O(V)：入度数组、邻接表的长度都是结点的个数 V，即使使用队列，队列最长的时候也不会超过 V，因此空间复杂度是 O(V)。</p><p>如果不使用队列，要想得到当前入度为 0 的结点，就得遍历一遍入度数组。使用队列即用空间换时间。</p><p>Java:</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        if(numCourses&lt;=0) return false;</span><br><span class="line">        int plen=prerequisites.length;</span><br><span class="line">        if(plen==0) return true;</span><br><span class="line">        int[] inDegree=new int[numCourses];</span><br><span class="line">        for(int[] p:prerequisites)&#123;</span><br><span class="line">        inDegree[p[0]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue=new LinkedList();</span><br><span class="line">        // 首先加入入度为 0 的结点</span><br><span class="line">        for(int i=0;i&lt;numCourses;i++)&#123;</span><br><span class="line">        if(inDegree[i]==0) queue.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 拓扑排序的结果</span><br><span class="line">        List&lt;Integer&gt; res=new ArrayList();</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">        Integer num=queue.removeFirst();</span><br><span class="line">        res.add(num);</span><br><span class="line">// 把邻边全部遍历一下</span><br><span class="line">        for(int[] p: prerequisites)&#123;</span><br><span class="line">        if(p[1]==num)&#123;</span><br><span class="line">        inDegree[p[0]]--;</span><br><span class="line">        if(inDegree[p[0]]==0)&#123;</span><br><span class="line">        queue.addLast(p[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">           // System.out.println(&quot;拓扑排序结果：&quot;);</span><br><span class="line">        // System.out.println(res);</span><br><span class="line">        return res.size()==numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><ol start="2">  <li>DFS<br>深度优先遍历</li></ol><p>这里要使用逆邻接表。其实就是检测这个有向图中有没有环，只要存在环，这些课程就不能按要求学完。</p><p>具体方法是：</p><p>第 1 步：构建逆邻接表；</p><p>第 2 步：递归处理每一个还没有被访问的结点，具体做法很简单：对于一个结点来说，先输出指向它的所有顶点，再输出自己。</p><p>第 3  步：如果这个顶点还没有被遍历过，就递归遍历它，把所有指向它的结点都输出了，再输出自己。注意：当访问一个结点的时候，应当先递归访问它的前驱结点，直至前驱结点没有前驱结点为止。<br>复杂度分析：</p><pre><code>时间复杂度：O(E+V)空间复杂度：O(V)</code></pre><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Solution &#123;</span><br><span class="line"> public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        if (numCourses &lt;= 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int plen = prerequisites.length;</span><br><span class="line">        if (plen == 0) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] marked = new int[numCourses];</span><br><span class="line"></span><br><span class="line">        // 初始化有向图 begin</span><br><span class="line">        HashSet&lt;Integer&gt;[] graph = new HashSet[numCourses];</span><br><span class="line">        for (int i = 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph[i] = new HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        // 初始化有向图 end</span><br><span class="line">        // 有向图的 key 是前驱结点，value 是后继结点的集合</span><br><span class="line">        for (int[] p : prerequisites) &#123;</span><br><span class="line">            graph[p[1]].add(p[0]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; numCourses; i++) &#123;</span><br><span class="line">            if (dfs(i, graph, marked)) &#123;</span><br><span class="line">                // 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回 false</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环</span><br><span class="line">        // 所有课程任务可以完成，应该返回 true</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注意这个 dfs 方法的语义</span><br><span class="line">     * @param i      当前访问的课程结点</span><br><span class="line">     * @param graph</span><br><span class="line">     * @param marked 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了</span><br><span class="line">     * @return true 表示图中存在环，false 表示访问过了，不用再访问了</span><br><span class="line">     */</span><br><span class="line">    private boolean dfs(int i,</span><br><span class="line">                        HashSet&lt;Integer&gt;[] graph,</span><br><span class="line">                        int[] marked) &#123;</span><br><span class="line">        // 如果访问过了，就不用再访问了</span><br><span class="line">        if (marked[i] == 1) &#123;</span><br><span class="line">            // 从正在访问中，到正在访问中，表示遇到了环</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (marked[i] == 2) &#123;</span><br><span class="line">            // 表示在访问的过程中没有遇到环，这个节点访问过了</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 走到这里，是因为初始化呢，此时 marked[i] == 0</span><br><span class="line">        // 表示正在访问中</span><br><span class="line">        marked[i] = 1;</span><br><span class="line">        // 后继结点的集合</span><br><span class="line">        HashSet&lt;Integer&gt; successorNodes = graph[i];</span><br><span class="line"></span><br><span class="line">        for (Integer successor : successorNodes) &#123;</span><br><span class="line">            if (dfs(successor, graph, marked)) &#123;</span><br><span class="line">                // 层层递归返回 true ，表示图中存在环</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span><br><span class="line">        // 状态设置为 2</span><br><span class="line">        marked[i] = 2;</span><br><span class="line">        // false 表示图中不存在环</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h3><p> 二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p>示例 1:</p><p>输入: [1,3,null,null,2]</p><p> 1<br> /<br> 3<br> <br> 2</p><p>输出: [3,1,null,null,2]</p><p> 3<br> /<br> 1<br> <br> 2</p><p>示例 2:</p><p>输入: [3,1,4,null,null,2]</p><p> 3<br> / <br>1 4<br> /<br> 2</p><p>输出: [2,1,4,null,null,3]</p><p> 2<br> / <br>1 4<br> /<br> 3</p><p>进阶:</p><pre><code>使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/recover-binary-search-tree" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/recover-binary-search-tree</a><br>算法思路：<br>因为只有两个节点错误，所以只要找出这两个节点然后交换值即可。<br>中序遍历,使用三个指针指示节点，cur为当前节点，wrong1为第一个错误节点，wrong2为找出的第二个错误节点。</p><ol>  <li>    <p>迭代<br>Java实现：</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>          </td>          <td class="code">            <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void recoverTree(TreeNode root) &#123;</span><br><span class="line">        if(root==null) return;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack=new LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode wrong1=null;</span><br><span class="line">        TreeNode wrong2=null;</span><br><span class="line">        TreeNode pre=new TreeNode(Integer.MIN_VALUE);</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        while(cur!=null||!stack.isEmpty())&#123;</span><br><span class="line">            while(cur!=null)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=stack.pop();</span><br><span class="line">            if(wrong1==null&amp;&amp;pre.val&gt;cur.val) wrong1=pre;</span><br><span class="line">            if(wrong1!=null&amp;&amp;pre.val&gt;cur.val) wrong2=cur;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp=wrong1.val;</span><br><span class="line">        wrong1.val=wrong2.val;</span><br><span class="line">        wrong2.val=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>递归 11ms</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre>          </td>          <td class="code">            <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode wrong1=null;</span><br><span class="line">        TreeNode wrong2=null;</span><br><span class="line">        TreeNode pre=new TreeNode(Integer.MIN_VALUE);</span><br><span class="line">    public void recoverTree(TreeNode root) &#123;</span><br><span class="line">         order(root);</span><br><span class="line">         int tmp=wrong1.val;</span><br><span class="line">         wrong1.val=wrong2.val;</span><br><span class="line">         wrong2.val=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    private void order(TreeNode root)&#123;</span><br><span class="line">         if(root==null) return;</span><br><span class="line">         order(root.left);</span><br><span class="line">         if(wrong1==null&amp;&amp;pre.val&gt;root.val) wrong1=pre;</span><br><span class="line">         if(wrong1!=null&amp;&amp;pre.val&gt;root.val)</span><br><span class="line">         wrong2=root;</span><br><span class="line"></span><br><span class="line">         pre=root;</span><br><span class="line">         order(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><p>输入: 1 1<br> / \ / <br> 2 3 2 3</p><pre><code>[1,2,3],   [1,2,3]</code></pre><p>输出: true</p><p>示例 2:</p><p>输入: 1 1<br> / <br> 2 2</p><pre><code>[1,2],     [1,null,2]</code></pre><p>输出: false</p><p>示例 3:</p><p>输入: 1 1<br> / \ / <br> 2 1 1 2</p><pre><code>[1,2,1],   [1,1,2]</code></pre><p>输出: false<br>链接：<a href="https://leetcode-cn.com/problems/same-tree" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/same-tree</a></p><p>算法思路：</p><ol>  <li>递归，首先判断p和q 是不是空，然后判断它们的值是否相等。<br>若以上判断通过，则递归对子节点做同样操作。</li></ol><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(p==null&amp;&amp;q==null) return true;</span><br><span class="line">        if(q==null||p==null) return false;</span><br><span class="line">        if(p.val!=q.val) return false;</span><br><span class="line">        return isSameTree(p.right,q.right)&amp;&amp;isSameTree(p.left,q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133.克隆图"></a>133.克隆图</h3><p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。</p><p>示例：</p><p><img src="https://github.com/starstarb/clouding/blob/master/leetcode/113_sample.png" alt="error"><br>输入：<br>{“$id”:”1”,”neighbors”:[{“$id”:”2”,”neighbors”:[{“$ref”:”1”},{“$id”:”3”,”neighbors”:[{“$ref”:”2”},{“$id”:”4”,”neighbors”:[{“$ref”:”3”},{“$ref”:”1”}],”val”:4}],”val”:3}],”val”:2},{“$ref”:”4”}],”val”:1}</p><p>解释：<br>节点 1 的值是 1，它有两个邻居：节点 2 和 4 。<br>节点 2 的值是 2，它有两个邻居：节点 1 和 3 。<br>节点 3  的值是 3，它有两个邻居：节点 2 和 4 。<br>节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</p><p>提示：</p><pre><code>节点数介于 1 到 100 之间。无向图是一个简单图，这意味着图中没有重复的边，也没有自环。由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。必须将给定节点的拷贝作为对克隆图的引用返回。</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/clone-graph" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/clone-graph</a></p><p>算法思路：<br>遍历整个图，记录已经访问的点，用一个字典记录</p><ol>  <li>DFS</li></ol><ol start="2">  <li>BFS</li></ol><p>参考代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line"></span><br><span class="line">    public Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Node(int _val,List&lt;Node&gt; _neighbors) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node cloneGraph(Node node) &#123;</span><br><span class="line">        Map&lt;Node,Node&gt; lookup=new HashMap&lt;&gt;();</span><br><span class="line">        return dfs(node,lookup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node dfs(Node node,Map&lt;Node,Node&gt; lookup)&#123;</span><br><span class="line">      if(node==null)return null;</span><br><span class="line">      if(lookup.containsKey(node)) return lookup.get(node);</span><br><span class="line">      Node clone=new Node(node.val,new ArrayList&lt;&gt;());</span><br><span class="line">      lookup.put(node,clone);</span><br><span class="line">      for(Node n: node.neighbors) clone.neighbors.add(dfs(n,lookup));</span><br><span class="line">      return clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node cloneGraph(Node node) &#123;</span><br><span class="line">        if (node == null) return null;</span><br><span class="line">        Map&lt;Node, Node&gt; lookup = new HashMap&lt;&gt;();</span><br><span class="line">        Node clone = new Node(node.val, new ArrayList&lt;&gt;());</span><br><span class="line">        lookup.put(node, clone);</span><br><span class="line">        Deque&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Node tmp = queue.poll();</span><br><span class="line">            for (Node n : tmp.neighbors) &#123;</span><br><span class="line">                if (!lookup.containsKey(n)) &#123;</span><br><span class="line">                    lookup.put(n, new Node(n.val, new ArrayList&lt;&gt;()));</span><br><span class="line">                    queue.offer(n);</span><br><span class="line">                &#125;</span><br><span class="line">                lookup.get(tmp).neighbors.add(lookup.get(n));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104.  二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>3</code></pre><p> / <br> 9 20<br> / <br> 15 7</p><p>返回它的最大深度 3<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p><ol>  <li>递归：<br>时间复杂度: O(N)<br>空间复杂度: O(N) 最好情况：完全平衡树：O(log(N))<figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>          </td>          <td class="code">            <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root==null) &#123;</span><br><span class="line">          return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">          int left_height=maxDepth(root.left);</span><br><span class="line">          int right_height=maxDepth(root.right);</span><br><span class="line">          return java.lang.Math.max(left_height,right_height)+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><p>DFS: 通过栈，将递归转化为迭代。  使用DFS访问每个节点，同时在每次访问时更新最大深度。<br>从包含根节点且相应深度为1的栈开始，将当前节点弹出栈并推入子节点，每一步都会更新深度。<br>时间、空间复杂度：O(N)</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">import javafx.util.Pair;</span><br><span class="line">import java.lang.Math;</span><br><span class="line">class Solution&#123;</span><br><span class="line">  public int maxDepth(TreeNode root)&#123;</span><br><span class="line">    Queue&lt;Pair&lt;TreeNode,Integer&gt;&gt; stack=new LinkedList&lt;&gt;();</span><br><span class="line">    if(root!=null)&#123;</span><br><span class="line">      stack.add(new Pair(root,1));</span><br><span class="line">    &#125;</span><br><span class="line">    int depth=0;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">      Pair&lt;TreeNode,Integer&gt; current=stack.poll();</span><br><span class="line">      root=current.getKey();</span><br><span class="line">      int current_depth=current.getValue();</span><br><span class="line">      if(root!=null)&#123;</span><br><span class="line">        depth=Math.max(depth,current_depth);</span><br><span class="line">        stack.add(new Pair(root.left,current_depth+1));</span><br><span class="line">        stack.add(new Pair(root.right,current_depth+1));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return depth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>  这里提一点，为什么在这里DFS比递归慢很多，因为测试的数据量太少，如果数据量大，选择DFS不会爆栈同时会比递归执行时间少很多，因此，以后在项目中要根据实际情况选择合适的算法。</p><h3 id="祖玛游戏"><a href="#祖玛游戏" class="headerlink" title="祖玛游戏"></a>祖玛游戏</h3><p>回忆一下祖玛游戏。现在桌上有一串球，颜色有红色(R)，黄色(Y)，蓝色(B)，绿色(G)，还有白色(W)。 现在你手里也有几个球。</p><p>  每一次，你可以从手里的球选一个，然后把这个球插入到一串球中的某个位置上（包括最左端，最右端）。接着，如果有出现三个或者三个以上颜色相同的球相连的话，就把它们移除掉。重复这一步骤直到桌上所有的球都被移除。</p><p>找到插入并可以移除掉桌上所有球所需的最少的球数。如果不能移除桌上所有的球，输出 -1 。</p><p>示例:<br>输入: “WRRBBW”, “RB”<br>输出: -1<br>解释: WRRBBW -&gt; WRR[R]BBW -&gt; WBBW  -&gt; WBB[B]W -&gt; WW （翻译者标注：手上球已经用完，桌上还剩两个球无法消除，返回-1）</p><p>输入: “WWRRBBWW”, “WRBRW”<br>输出: 2<br>解释: WWRRBBWW -&gt; WWRR[R]BBWW -&gt;  WWBBWW -&gt; WWBB[B]WW -&gt; WWWW -&gt; empty</p><p>输入:”G”, “GGGGG”<br>输出: 2<br>解释: G -&gt; G[G] -&gt; GG[G] -&gt; empty </p><p>输入: “RBYYBBRRB”, “YRBGB”<br>输出: 3<br>解释: RBYYBBRRB -&gt; RBYY[Y]BBRRB -&gt;  RBBBRRB -&gt; RRRB -&gt; B -&gt; B[B] -&gt; BB[B] -&gt; empty </p><p>标注:</p><pre><code>你可以假设桌上一开始的球中，不会有三个及三个以上颜色相同且连着的球。桌上的球不会超过20个，输入的数据中代表这些球的字符串的名字是 &quot;board&quot; 。你手中的球不会超过5个，输入的数据中代表这些球的字符串的名字是 &quot;hand&quot;。输入的两个字符串均为非空字符串，且只包含字符 &apos;R&apos;,&apos;Y&apos;,&apos;B&apos;,&apos;G&apos;,&apos;W&apos;。</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/zuma-game" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/zuma-game</a></p><p>思路：<br>题目希望我们用最少的球来消掉桌上所有的球，如果不能完全消掉，返回-1。</p><p>我们使用哈希表来统计手中每种球的个数。</p><p>  然后我们遍历桌上的球，我们找连续相同球的个数，在没有可以消除的情况下，连续的个数只能是1个或2个，然后我们用3减去连续个数，就是我们需要补充的球数以使其可以被消除，那么我们在哈希表表中看我们手中的该类型的球够不够，如果够就表示可以消除，我们在哈希表中减去需要使用掉的球数，然后将消掉的球移除。</p><p>  然后对新的字符串调用递归，如果可以成功消除，会返回一个结果，该结果加上之前需要的球数用来更新结果res，注意调用完递归要恢复哈希表的状态(backtrack)。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Solution &#123;</span><br><span class="line">    int MAXCOUNT = 6;</span><br><span class="line">    // the max balls you need will not exceed 6 since &quot;The number of balls in your hand won&apos;t exceed 5&quot;</span><br><span class="line">    public int findMinStep(String board, String hand) &#123;</span><br><span class="line">        int[] handCount = new int[26];</span><br><span class="line">        for (int i = 0; i &lt; hand.length(); i++) &#123;</span><br><span class="line">            handCount[hand.charAt(i) - &apos;A&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int result = backtrack(board + &quot;#&quot;, handCount);</span><br><span class="line">        // append a &quot;#&quot; to avoid special process while j==board.length, make the code shorter.</span><br><span class="line">        return result == MAXCOUNT ? -1 : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int backtrack(String s, int[] h) &#123;</span><br><span class="line">        s = removeConsecutive(s);</span><br><span class="line">        if (s.equals(&quot;#&quot;)) return 0;</span><br><span class="line">        int rs = MAXCOUNT, need = 0;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int j = 0 ; j &lt; s.length(); ++j) &#123;</span><br><span class="line">            if (s.charAt(j) == s.charAt(i)) continue;</span><br><span class="line">            need = 3 - (j - i);</span><br><span class="line">            //balls need to remove current consecutive balls.</span><br><span class="line">            if (h[s.charAt(i) - &apos;A&apos;] &gt;= need) &#123;</span><br><span class="line">                h[s.charAt(i) - &apos;A&apos;] -= need;</span><br><span class="line">                rs = Math.min(rs, need + backtrack(s.substring(0, i) + s.substring(j), h));</span><br><span class="line">                h[s.charAt(i) - &apos;A&apos;] += need;</span><br><span class="line">            &#125;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return rs;</span><br><span class="line">    &#125;</span><br><span class="line">    //remove consecutive balls longer than 3</span><br><span class="line">    private String removeConsecutive(String board) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (int j = 0; j &lt; board.length(); ++j) &#123;</span><br><span class="line">            if (board.charAt(j) == board.charAt(i)) continue;</span><br><span class="line">            if (j - i &gt;= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));</span><br><span class="line">            else i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>算法</strong><br>(dfs)</p><p>  我们先将手中的球用哈希表来存储一下，然后看桌上的球能否在哈希表里的球添加后消除，然后消除后递归处理剩下的。中间记录需要的球数，用来更新需要球数的最小值。如果最小值超出了手中球的个数，则无法消除。</p><p>时间复杂度分析：桌上的球不会超过20个，手中的球不会超过5个，所以时间复杂度为O(m+n).<br>C++ 代码</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string del(string board)&#123;</span><br><span class="line">        for(int i=0;i&lt;board.size();)&#123;</span><br><span class="line">            int j=i;</span><br><span class="line">            while(j&lt;board.size()&amp;&amp;board[i]==board[j])j++;</span><br><span class="line">            if(j-i&gt;=3)</span><br><span class="line">                return del(board.substr(0,i)+board.substr(j));</span><br><span class="line">            else i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        return board;</span><br><span class="line">    &#125;</span><br><span class="line">    int dfs(string board, unordered_map&lt;char,int&gt;&amp;hash)&#123;</span><br><span class="line">        board=del(board);</span><br><span class="line">        if(board.size()==0)return 0;</span><br><span class="line">        int rs=6,need=0;</span><br><span class="line">        for(int i=0;i&lt;board.size();)&#123;</span><br><span class="line">            int j=i;</span><br><span class="line">            while(j&lt;board.size()&amp;&amp;board[i]==board[j])j++;</span><br><span class="line">            need=3-(j-i);</span><br><span class="line">            if(hash[board[i]]&gt;=need)&#123;</span><br><span class="line">                hash[board[i]]-=need;</span><br><span class="line">                rs=min(rs,need+dfs(board.substr(0,i)+board.substr(j),hash));</span><br><span class="line">                hash[board[i]]+=need;</span><br><span class="line">            &#125;</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        return rs;</span><br><span class="line">    &#125;</span><br><span class="line">    int findMinStep(string board, string hand) &#123;</span><br><span class="line">        unordered_map&lt;char,int&gt;hash;</span><br><span class="line">        for(auto x:hand)hash[x]++;</span><br><span class="line">        int res=dfs(board,hash);</span><br><span class="line">        return res==6?-1:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DFS&lt;/p&gt;
    
    </summary>
    
      <category term="DFS" scheme="http://javastar.club/categories/DFS/"/>
    
    
      <category term="DFS" scheme="http://javastar.club/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="http://javastar.club/archives/59a0de58.html"/>
    <id>http://javastar.club/archives/59a0de58.html</id>
    <published>2019-07-29T06:11:44.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>树状数组</p><a id="more"></a><h3 id="区域和检索-–数组可修改"><a href="#区域和检索-–数组可修改" class="headerlink" title="区域和检索 –数组可修改"></a>区域和检索  –数组可修改</h3><p>给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。</p><p>update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。</p><p>示例:</p><p>Given nums = [1, 3, 5]</p><p>sumRange(0, 2) -&gt; 9<br>update(1, 2)<br>sumRange(0, 2) -&gt; 8</p><p>说明:</p><pre><code>数组仅可以在 update 函数下进行修改。你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。</code></pre><p>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-mutable" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/range-sum-query-mutable</a><br>算法思路：<br>方法一：<br>区域和检索的一个简单的解决方案  - RSQ(i, j) 是将数组从索引 i 迭代到 j 并对每个元素求和。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>      </td>      <td class="code">        <pre><span class="line">private int[] nums;</span><br><span class="line">public int sumRange(int i, int j) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int l = i; l &lt;= j; l++) &#123;</span><br><span class="line">        sum += data[l];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int update(int i, int val) &#123;</span><br><span class="line">    nums[i] = val;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>复杂度分析:</p><pre><code>时间复杂度：O(n)。区域和检索 O(1) 的更新查询 对于区域和检索，我们从数组中访问每个元素的时间是固定的，在最坏的情况下，我们访问 n 元素。因此，时间复杂度为 O(n)O。更新查询的时间复杂度为 O(1))。空间复杂度：O(1)</code></pre><p>方法二：sqrt 分解</p><p>其思想是将数组分割成块，块的长度为 sqrt（n）<br>​。然后我们计算每个块的和，并将其存储在辅助存储器 b 中。<br>要查询 RSQ(i,  j)，我们将添加位于内部的所有块和部分在范围[i…j] 重叠的块的总和。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre>      </td>      <td class="code">        <pre><span class="line">private int[] b;</span><br><span class="line">private int len;</span><br><span class="line">private int[] nums;</span><br><span class="line">public NumArray(int [] nums)</span><br><span class="line">&#123;</span><br><span class="line">this.nums=nums;</span><br><span class="line">double l=Math.sqrt(nums.length);</span><br><span class="line">len=(int) Math.ceil(nums.length/l);</span><br><span class="line">b=new int[len];</span><br><span class="line">for(int i=0;i&lt;nums.length;i++)</span><br><span class="line">b[i/len]+=nums[i];</span><br><span class="line">&#125;</span><br><span class="line">public int sumRange(int i,int j)&#123;</span><br><span class="line">int sum=0;</span><br><span class="line">int startBlock=i/len;</span><br><span class="line">int endBlock=j/len;</span><br><span class="line">if(startBlock==endBlock)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=i;k&lt;=j;k++)</span><br><span class="line">sum+=nums[k];</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">for(int k=i;k&lt;=(startBlock+1)*len-1;k++)</span><br><span class="line">sum+=nums[k];</span><br><span class="line">for(int k=startBlock+1;k&lt;=endBlock-1;k++)</span><br><span class="line">sum+=b[k];</span><br><span class="line">for(int k=endBlock*len;k&lt;=j;k++)</span><br><span class="line">sum+=nums[k];</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">public void update(int i,int val)</span><br><span class="line">&#123;</span><br><span class="line">int b_l=i/len;</span><br><span class="line">b[b_l] = b[b_l] - nums[i] + val;</span><br><span class="line">    nums[i] = val;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树状数组&lt;/p&gt;
    
    </summary>
    
      <category term="算法刷题" scheme="http://javastar.club/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="树状数组" scheme="http://javastar.club/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>多线程笔试题</title>
    <link href="http://javastar.club/archives/190a403c.html"/>
    <id>http://javastar.club/archives/190a403c.html</id>
    <published>2019-07-29T06:11:32.000Z</published>
    <updated>2019-08-07T07:14:52.720Z</updated>
    
    <content type="html"><![CDATA[<p>多线程面试</p><a id="more"></a><p><strong>补充基础知识：</strong></p><h3 id="线程的概述（Introduction）"><a href="#线程的概述（Introduction）" class="headerlink" title="线程的概述（Introduction）"></a>线程的概述（Introduction）</h3><p>线程是一个程序的多个执行路径，执行调度的单位，依托于进程存在。  线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。</p><p>注意：Java中的多线程是一种抢占机制而不是分时机制。抢占机制指的是有多个线程处于可运行状态，但是只允许一个线程在运行，他们通过竞争的方式抢占CPU。</p><h3 id="线程的定义（Defining）"><a href="#线程的定义（Defining）" class="headerlink" title="线程的定义（Defining）"></a>线程的定义（Defining）</h3><p> 定义一个线程（Defining a Thread）有两种方法</p><p> 1) 继承java.lang.Thread类</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/**</span><br><span class="line"> * 使用继承java.lang.Thread类的方式创建一个线程</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class ThreadTest extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写（Override）run()方法 JVM会自动调用该方法</span><br><span class="line">     */</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;I&apos;m running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>注意：重写(override)run()方法在该线程的start()方法被调用后，JVM会自动调用run方法来执行任务；<br>  但是重载（overload）run()方法，该方法和普通的成员方法一样，并不会因调用该线程的start()方法而被JVM自动运行。 例如：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">public class ThreadTest extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写（Override）run()方法 JVM会自动调用该方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;I&apos;m running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重载（Overload）run()方法 和普通的方法一样，并不会在该线程的start()方法被调用后被JVM自动运行</span><br><span class="line">     */</span><br><span class="line">    public void run(int times) &#123;</span><br><span class="line">        System.out.println(&quot;I&apos;m running!(Overload)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p><strong>注意：</strong>  不建议使用此方法定义线程，因为采用继承Thread的方式定义线程后，你不能在继承其他的类了，导致程序的可扩展性大大降低。<br> 2)  实现java.lang.Runnable接口<br>  <figure class="highlight plain">    <table>      <tr>        <td class="gutter">          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>        </td>        <td class="code">          <pre><span class="line">  /**</span><br><span class="line"> * 通过实现Runnable接口创建一个线程</span><br><span class="line"> */</span><br><span class="line">public class ThreadTest implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">            System.out.println(&quot;I&apos;m running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>        </td>      </tr>    </table>  </figure></p><h3 id="线程的启动（Starting）"><a href="#线程的启动（Starting）" class="headerlink" title="线程的启动（Starting）"></a>线程的启动（Starting）</h3><p> 任何一个线程的执行的前提都是必须有Thread class的实例存在，并且通过调用run()方法启动线程。</p><p> 1）如果线程是继承Thread类，则创建方式如下： </p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">ThreadTest1 tt = new ThreadTest1();</span><br><span class="line">tt.start();</span><br></pre>      </td>    </tr>  </table></figure><p> 2）如果是实现Runnable接口，则创建方式如下：<br>  <figure class="highlight plain">    <table>      <tr>        <td class="gutter">          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>        </td>        <td class="code">          <pre><span class="line">ThreadTest2 tt = new ThreadTest2();</span><br><span class="line">Thread t = new Thread(tt);</span><br><span class="line">t.start();</span><br></pre>        </td>      </tr>    </table>  </figure></p><h3 id="线程的状态（State）"><a href="#线程的状态（State）" class="headerlink" title="线程的状态（State）"></a>线程的状态（State）</h3><p><strong>新生状态（New)</strong>：  当一个线程的实例被创建即使用new关键字和Thread类或其子类创建一个线程对象后，此时该线程处于新生(new)状态，处于新生状态的线程有自己的内存空间，但该线程并没有运行，此时线程还不是活着的（not  alive）；</p><p><strong>就绪状态（Runnable）</strong>：  通过调用线程实例的start()方法来启动线程使线程进入就绪状态(runnable)；处于就绪状态的线程已经具备了运行条件，但还没有被分配到CPU即不一定会被立即执行，此时处于线程就绪队列，等待系统为其分配CPCU，等待状态并不是执行状态；  此时线程是活着的（alive）；</p><p><strong>运行状态（Running)</strong>：  一旦获取CPU(被JVM选中)，线程就进入运行(running)状态，线程的run()方法才开始被执行；在运行状态的线程执行自己的run()方法中的操作，直到调用其他的方法而终止、或者等待某种资源而阻塞、或者完成任务而死亡；如果在给定的时间片内没有执行结束，就会被系统给换下来回到线程的等待状态；此时线程是活着的（alive）；</p><p>  <strong>阻塞状态（Blocked）</strong>：通过调用join()、sleep()、wait()或者资源被暂用使线程处于阻塞(blocked)状态；处于Blocking状态的线程仍然是活着的（alive）</p><p>  <strong>死亡状态（Dead）</strong>：当一个线程的run()方法运行完毕或被中断或被异常退出，该线程到达死亡(dead)状态。此时可能仍然存在一个该Thread的实例对象，当该Thready已经不可能在被作为一个可被独立执行的线程对待了，线程的独立的call  stack已经被dissolved。一旦某一线程进入Dead状态，他就再也不能进入一个独立线程的生命周期了。对于一个处于Dead状态的线程调用start()方法，会出现一个运行期(runtime  exception)的异常；处于Dead状态的线程不是活着的（not alive）。</p><h3 id="线程的方法（Method）、属性（Property）"><a href="#线程的方法（Method）、属性（Property）" class="headerlink" title="线程的方法（Method）、属性（Property）"></a>线程的方法（Method）、属性（Property）</h3><ol>  <li>优先级（priority）</li></ol><p>  每个类都有自己的优先级，一般property用1-10的整数表示，默认优先级是5，优先级最高是10；优先级高的线程并不一定比优先级低的线程执行的机会高，只是执行的机率高；默认一个线程的优先级和创建他的线程优先级相同；</p><ol start="2">  <li>Thread.sleep()/sleep(long millis)</li></ol><p>  当前线程睡眠/millis的时间（millis指定睡眠时间是其最小的不执行时间，因为sleep(millis)休眠到达后，无法保证会被JVM立即调度）；sleep()是一个静态方法(static  method) ，所以他不会停止其他的线程也处于休眠状态；线程sleep()时不会失去拥有的对象锁。  作用：保持对象锁，让出CPU，调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留一定的时间给其他线程执行的机会；</p><ol start="3">  <li>    <p>Thread.yield()</p>    <p>      让出CPU的使用权，给其他线程执行机会、让同等优先权的线程运行（但并不保证当前线程会被JVM再次调度、使该线程重新进入Running状态），如果没有同等优先权的线程，那么yield()方法将不会起作用。    </p>  </li>  <li>    <p>thread.join()</p>    <p>使用该方法的线程会在此之间执行完毕后再往下继续执行。</p>  </li>  <li>    <p>object.wait()</p>    <p>当一个线程执行到wait()方法时，他就进入到一个和该对象相关的等待池(Waiting      Pool)中，同时失去了对象的机锁—暂时的，wait后还要返还对象锁。当前线程必须拥有当前对象的锁，如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常,所以wait()必须在synchronized      block中调用。</p>  </li>  <li>    <p>object.notify()/notifyAll()</p>    <p>      唤醒在当前对象等待池中等待的第一个线程/所有线程。notify()/notifyAll()也必须拥有相同对象锁，否则也会抛出IllegalMonitorStateException异常。    </p>  </li>  <li>    <p>Synchronizing Block<br>Synchronized      Block/方法控制对类成员变量的访问；Java中的每一个对象都有唯一的一个内置的锁，每个Synchronized      Block/方法只有持有调用该方法被锁定对象的锁才可以访问，否则所属线程阻塞；机锁具有独占性、一旦被一个Thread持有，其他的Thread就不能再拥有（不能访问其他同步方法），方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。    </p>  </li></ol><h3 id="按序打印"><a href="#按序打印" class="headerlink" title="按序打印"></a>按序打印</h3><p>我们提供了一个类：</p><p>public class Foo {<br> public void one() { print(“one”); }<br> public void  two() { print(“two”); }<br> public void three() { print(“three”); }<br>}</p><p>三个不同的线程将会共用一个 Foo 实例。</p><pre><code>线程 A 将会调用 one() 方法线程 B 将会调用 two() 方法线程 C 将会调用 three() 方法</code></pre><p>请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p><p>示例 1:</p><p>输入: [1,2,3]<br>输出: “onetwothree”<br>解释:<br>有三个线程会被异步启动。<br>输入 [1,2,3] 表示线程 A  将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。<br>正确的输出是  “onetwothree”。</p><p>示例 2:</p><p>输入: [1,3,2]<br>输出: “onetwothree”<br>解释:<br>输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程  B 将会调用 three() 方法，线程 C 将会调用 two() 方法。<br>正确的输出是 “onetwothree”。</p><p>注意:</p><p>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</p><p>你看到的输入格式主要是为了确保测试的全面性。<br>链接：<a href="https://leetcode-cn.com/problems/print-in-order" rel="external nofollow noopener noreferrer" target="_blank">https://leetcode-cn.com/problems/print-in-order</a><br>算法思路：</p><p>Java 中，我们使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除。<br>参考代码：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre>      </td>      <td class="code">        <pre><span class="line">class Foo &#123;</span><br><span class="line">private boolean firstFinished;</span><br><span class="line">private boolean secondFinished;</span><br><span class="line">private Object lock=new Object();</span><br><span class="line"></span><br><span class="line">    public Foo() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        // printFirst.run() outputs &quot;first&quot;. Do not change or remove this line.</span><br><span class="line">       </span><br><span class="line">       synchronized(lock)&#123;</span><br><span class="line">       printFirst.run();</span><br><span class="line">       firstFinished=true;</span><br><span class="line">       lock.notifyAll();</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        // printSecond.run() outputs &quot;second&quot;. Do not change or remove this line.</span><br><span class="line">        </span><br><span class="line">        synchronized(lock)&#123;</span><br><span class="line">        while(!firstFinished)&#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        printSecond.run();</span><br><span class="line">        secondFinished=true;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        // printThird.run() outputs &quot;third&quot;. Do not change or remove this line.</span><br><span class="line">        synchronized(lock)&#123;</span><br><span class="line">        while(!secondFinished)&#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        printThird.run();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程面试&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://javastar.club/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="多线程笔试" scheme="http://javastar.club/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ACM常用算法模板</title>
    <link href="http://javastar.club/archives/a95aaa1f.html"/>
    <id>http://javastar.club/archives/a95aaa1f.html</id>
    <published>2019-07-28T02:33:21.000Z</published>
    <updated>2019-08-07T07:14:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>算法模板学习</p><a id="more"></a><h4 id="文本输入输出"><a href="#文本输入输出" class="headerlink" title="文本输入输出"></a>文本输入输出</h4><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">void fre()&#123;</span><br><span class="line">freopen(&quot;C:\\Users\\Desktop\\输入文本.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">freopen(&quot;C:\\Users\\Desktop\\输出文本.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">&#125;    //注意都是双\</span><br></pre>      </td>    </tr>  </table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">Eg:1 2 2 3 4 =》 1 2 3 4 2</span><br><span class="line">int b[N];</span><br><span class="line">sort(b,b+N);</span><br><span class="line">int len = unique(b, b + n) - b;//返回的是4的位置</span><br></pre>      </td>    </tr>  </table></figure><h3 id="GCD、LCM"><a href="#GCD、LCM" class="headerlink" title="GCD、LCM"></a>GCD、LCM</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">int gcd(int a,int b)&#123;  return b?gcd(b,a%b):a;&#125;    //最大公约数 b==0</span><br><span class="line">lcm = a * b / gcd(a,b)    //最小公倍数</span><br></pre>      </td>    </tr>  </table></figure><h3 id="字符串-lt-gt-整型"><a href="#字符串-lt-gt-整型" class="headerlink" title="字符串 &lt;-&gt; 整型"></a>字符串  &lt;-&gt; 整型</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">sscanf(s,&quot;%d&quot;,&amp;n);//从字符串s中读入整数n</span><br><span class="line">sprintf(s,&quot;%d&quot;,n);//将n转换为字符串s</span><br></pre>      </td>    </tr>  </table></figure><h3 id="getchar-读入转str"><a href="#getchar-读入转str" class="headerlink" title="getchar()读入转str"></a>getchar()读入转str</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>      </td>      <td class="code">        <pre><span class="line">while ((x1[0] = getchar()) &amp;&amp; x1[0] != &apos;\n&apos;)&#123;</span><br><span class="line">int len1 = 1;</span><br><span class="line">while ((x1[len1] = getchar()) &amp;&amp; x1[len1] != &apos; &apos;)len1++;</span><br><span class="line">x1[len1] = &apos;\0&apos;;</span><br><span class="line">string s1 = x1;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="char-转Int"><a href="#char-转Int" class="headerlink" title="char[]转Int"></a>char[]转Int</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">char s[100];</span><br><span class="line">int x=atoi(s);</span><br></pre>      </td>    </tr>  </table></figure><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">(a+b)%m=(a%m)+(b%m)</span><br><span class="line">(a-b)%m=(a%m)-(b%m)  //稍微留意负数情况</span><br><span class="line">(a*b)%m=(a%m)*(b%m)</span><br><span class="line">m^n%c=(m%c)^n%c;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="求n-位数"><a href="#求n-位数" class="headerlink" title="求n!位数"></a>求n!位数</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>      </td>      <td class="code">        <pre><span class="line">for(int i=2;i&lt;=n;i++) </span><br><span class="line">    len+=log10(i*1.0);  </span><br><span class="line">ans=(int)len+1;</span><br></pre>      </td>    </tr>  </table></figure><p>斯特林公式：</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">len=0.5*log10(2*3.1415927*n)+n*log10(n/2.718281828459); </span><br><span class="line">ans=(int)len+1;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>N个方格m种颜色问有多少种染色方案：</p><p>设F(m)为在n个方格上使用m种颜色任意染色的方案数</p><p>F(m)=m^n，使用快速幂求一次F(m)的时间为O(log(n))</p><p>Ans=C(m,m)F(m)-C(m,m-1)F(m-1)+C(m,m-2)F(m-2)-C(m,m-3)F(m-3)+……</p><p>用杨辉三角预处理出C(m,n)花费O(m^2)</p><p>总时间复杂度为O(m^2+mlog(n))</p><h3 id="Log与自然对数e"><a href="#Log与自然对数e" class="headerlink" title="Log与自然对数e"></a>Log与自然对数e</h3><p>Log（x）表示ln（x） ，其他例如：log10（x） ，log2（x），用exp（x）来表示e^</p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>      </td>      <td class="code">        <pre><span class="line">long long Pow(long long a,long long n)&#123;</span><br><span class="line">long long ret=1;</span><br><span class="line">while(n)&#123;</span><br><span class="line">if(n&amp;1)ret*=a;</span><br><span class="line">a*=a;</span><br><span class="line">n&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">long long Mod_Pow(long long a,long long n,long long mod)&#123;</span><br><span class="line">long long ret=1;</span><br><span class="line">while(n)&#123;</span><br><span class="line">if(n&amp;1)ret=(ret*a)%mod;</span><br><span class="line">a=(a*a)%mod;</span><br><span class="line">n&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p> 快速幂算法——可迅速求出a^b。其主要理论依据如下：</p><p> 1，当b为偶数时，a^b可以转为a^2的b/2次方。</p><p>  2，当b为奇数时，a^b可以转为a^2的b/2次方，再乘以a。<br>而a^2的b/2次方，可以使用上述方式转为a^4的b/4次方再乘以某个数。<br>在每一次进行循环时，如果b为奇数，则a^b可以转为a^2的b/2次方乘以a。所以每一次进行a^2计算时，需要根据b是否为奇数决定是否在最终的结果上乘以a。<br>a  = a* a;此步计算完成后，则a是下一个进行平方运算的数。这样当所有的循环结束后，a就是a^k，其中k是离b最近的，且为2的整数次方的数。</p><p>利用快速幂方法可以迅速求出一个数的任意次方。再结合a* b%m=(a%m)*  (b%m)%m，只是要相乘后再取模，就可以先取模再相乘，然后再取模的规律。我们不考虑a最终会用来做什么，反正a就是用来相乘然后取模的，所以可以直接将a进行取模，然后再进行相乘。<br>同理，对于if判断中的操作也是如此：因为要相乘再取模，所以就先取模再相乘。</p><h3 id="求1到n的数的异或和O（1）"><a href="#求1到n的数的异或和O（1）" class="headerlink" title="求1到n的数的异或和O（1）"></a>求1到n的数的异或和O（1）</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">unsigned xor_n(unsigned n)&#123;</span><br><span class="line">unsigned t = n &amp; 3;</span><br><span class="line">if (t &amp; 1) return t / 2u ^ 1;   //照着打就行，u默认为unsigned int</span><br><span class="line">return t / 2u ^ n;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>给定一个凸n边形，问将其划分成三角形的方法数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line">1,1,2,5,14,42,132….</span><br><span class="line"></span><br><span class="line">h(n)=h(n-1)*(4*n-2)/(n+1)</span><br><span class="line">h(n)=C(2n,n)/(n+1)</span><br><span class="line">h(0)=1</span><br></pre>      </td>    </tr>  </table></figure><h3 id="错排公式"><a href="#错排公式" class="headerlink" title="错排公式"></a>错排公式</h3><p>给定n种颜色篮子和n种颜色球，求全放错情况数</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">D(n)=(n-1)*(D(n-2)+D(n-1))</span><br><span class="line">D(1)=0,D(2)=1</span><br></pre>      </td>    </tr>  </table></figure><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><p>（N以内有大概num=N/ln（x）个素数，N越大越准）</p><ol>  <li>    <p>简单素数打表：O(n* sqrt(n))</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>          </td>          <td class="code">            <pre><span class="line">void prim()&#123;</span><br><span class="line">int num = 0;</span><br><span class="line">for (int i = 2; i &lt; maxn; i++)&#123;</span><br><span class="line">int k = 1;</span><br><span class="line">for (int j = 2; j &lt;= (int)sqrt(i);j++)</span><br><span class="line">if (i%j == 0) &#123; k = 0; break; &#125;</span><br><span class="line">if (k) pri[num++] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>素数筛法：O(nlogn)</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>          </td>          <td class="code">            <pre><span class="line">vector&lt;int&gt; pri;</span><br><span class="line">void prim()&#123;</span><br><span class="line">vis[0] = vis[1] = true;</span><br><span class="line">for (int i = 2; i &lt; maxn; i++)</span><br><span class="line">if (!vis[i])&#123;</span><br><span class="line">pri.push_back(i);</span><br><span class="line">for (int j = i + i; j &lt; maxn; j += i)</span><br><span class="line">vis[j] = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>高效素数打表:O(n)<br>(线性筛法–欧拉 )</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>          </td>          <td class="code">            <pre><span class="line">void prim()&#123;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">int num = 0;</span><br><span class="line">for (int i = 2; i &lt;= M; ++i)&#123;</span><br><span class="line">if (!vis[i])  pri[num++] = i;   </span><br><span class="line">for (int j = 1; ((j &lt;= num) &amp;&amp; (i * pri[j] &lt;= M)); ++j)&#123;</span><br><span class="line">vis[i * pri[j]] = 1;</span><br><span class="line">if (i % pri[j] == 0) break;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;//1不是素数，最小素数为2</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol><h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>      </td>      <td class="code">        <pre><span class="line">vector&lt;int&gt; V[N]; </span><br><span class="line">void getDiv(int x, int idx) &#123; //得到的是所有种类 eg：12=》2，3</span><br><span class="line">if (x == 1) &#123;</span><br><span class="line">V[idx].push_back  (1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int len = (int)sqrt(x);</span><br><span class="line">for (int i = 2; i &lt;= (int)len; i++)</span><br><span class="line">if (x % i == 0)</span><br><span class="line">V[idx].push_back  (i), V[idx].push_back  (x / i);</span><br><span class="line">if (len * len == x)</span><br><span class="line">V[idx].pop_back();</span><br><span class="line">V[idx].push_back  (x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void fun(long long x) &#123;//得到的是所有质因数 eg：12=》2，2，3</span><br><span class="line">p.clear();</span><br><span class="line">for (long long i = 2; i &lt;=sqrt(x); i++)&#123;</span><br><span class="line">while (x%i == 0)&#123;</span><br><span class="line">p.push_back(i);</span><br><span class="line">x /= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br><span class="line">       if (x != 1) p.push_back(x);   </span><br><span class="line"> &#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="吉姆拉尔森公式"><a href="#吉姆拉尔森公式" class="headerlink" title="吉姆拉尔森公式"></a>吉姆拉尔森公式</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line">int CaculateWeekDay(int y,int m, int d)  </span><br><span class="line">&#123;  </span><br><span class="line">    if(m==1||m==2) &#123;//把一月和二月看为是上一年的十三月和十四月</span><br><span class="line">        m+=12;  </span><br><span class="line">        y--;  </span><br><span class="line">    &#125;  </span><br><span class="line">    int iWeek=(d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7;  </span><br><span class="line">    return iWeek;  </span><br><span class="line">&#125;  //给定年月日O（1）算周数</span><br></pre>      </td>    </tr>  </table></figure><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre>      </td>      <td class="code">        <pre><span class="line">/*</span><br><span class="line">**高精度，支持乘法和加法</span><br><span class="line">*/</span><br><span class="line">struct  Big_Num</span><br><span class="line">&#123;</span><br><span class="line">const  static  int   mod = 10000;//每4位数存一次</span><br><span class="line">const  static  int   DLEN = 4;</span><br><span class="line">int  num[600],  len;  </span><br><span class="line">Big_Num()</span><br><span class="line">&#123;</span><br><span class="line">memset(num, 0, sizeof(num));</span><br><span class="line">len = 1;</span><br><span class="line">&#125;</span><br><span class="line">Big_Num(int   v)</span><br><span class="line">&#123;</span><br><span class="line">memset(num, 0, sizeof(num));</span><br><span class="line">len = 0;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">num[len++] = v%mod;</span><br><span class="line">v /= mod;</span><br><span class="line">&#125; while (v);</span><br><span class="line">&#125;</span><br><span class="line">Big_Num(const char  s[])</span><br><span class="line">&#123;</span><br><span class="line">memset(num, 0, sizeof(num));</span><br><span class="line">int L = strlen(s);</span><br><span class="line">len = L / DLEN;</span><br><span class="line">if (L%DLEN)len++;</span><br><span class="line">int index = 0;</span><br><span class="line">for (int i = L - 1; i &gt;= 0; i -= DLEN)</span><br><span class="line">&#123;</span><br><span class="line">int t = 0;</span><br><span class="line">int k = i - DLEN + 1;</span><br><span class="line">if (k &lt; 0)k = 0;</span><br><span class="line">for (int j = k; j &lt;= i; j++)</span><br><span class="line">t = t * 10 + s[j] - &apos;0&apos;;</span><br><span class="line">num[index++] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Big_Num  operator +(const Big_Num &amp;b)const</span><br><span class="line">&#123;</span><br><span class="line">Big_Num  res;</span><br><span class="line">res.len = max(len, b.len);</span><br><span class="line">for (int i = 0; i &lt;= res.len; i++)</span><br><span class="line">res.num[i] = 0;</span><br><span class="line">for (int i = 0; i &lt; res.len; i++)</span><br><span class="line">&#123;</span><br><span class="line">res.num[i] += ((i &lt; len) ? num[i] : 0) + ((i &lt; b.len) ? b.num[i] : 0);</span><br><span class="line">res.num[i + 1] += res.num[i] / mod;</span><br><span class="line">res.num[i] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">if (res.num[res.len] &gt; 0)res.len++;</span><br><span class="line">return  res;</span><br><span class="line">&#125;</span><br><span class="line">Big_Num  operator *(const Big_Num &amp;b)const</span><br><span class="line">&#123;</span><br><span class="line">Big_Num  res;</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">int up = 0;</span><br><span class="line">for (int j = 0; j &lt; b.len; j++)</span><br><span class="line">&#123;</span><br><span class="line">int temp = num[i] * b.num[j] + res.num[i + j] + up;</span><br><span class="line">res.num[i + j] = temp%mod;</span><br><span class="line">up = temp / mod;</span><br><span class="line">&#125;</span><br><span class="line">if (up != 0)</span><br><span class="line">res.num[i + b.len] = up;</span><br><span class="line">&#125;</span><br><span class="line">res.len = len + b.len;</span><br><span class="line">while (res.num[res.len - 1] == 0 &amp;&amp; res.len &gt; 1)res.len--;</span><br><span class="line">return  res;</span><br><span class="line">&#125;</span><br><span class="line">void  output()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;, num[len - 1]);</span><br><span class="line">for (int i = len - 2; i &gt;= 0; i--)</span><br><span class="line">printf(&quot;%04d&quot;, num[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="完全高精度"><a href="#完全高精度" class="headerlink" title="完全高精度"></a>完全高精度</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5 + 50;</span><br><span class="line">/*</span><br><span class="line">*完全大数模板</span><br><span class="line">*输入cin&gt;&gt;a</span><br><span class="line">*输出a.print();</span><br><span class="line">*注意这个输入不能自动去掉前导0的，可以先读入到char数组，去掉前导0，再用构造函数。</span><br><span class="line">*/</span><br><span class="line">#define MAXN 9999</span><br><span class="line">#define MAXSIZE 1010</span><br><span class="line">#define DLEN 4</span><br><span class="line">class  BigNum</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int a[500];                               //可以控制大数的位数</span><br><span class="line">int  len;</span><br><span class="line">public:</span><br><span class="line">BigNum() &#123; len = 1; memset(a, 0, sizeof(a)); &#125;//构造函数</span><br><span class="line">BigNum(const   int);                      //将一个int类型的变量转化成大数</span><br><span class="line">BigNum(const   char*);                    //将一个字符串类型的变量转化为大数</span><br><span class="line">BigNum(const BigNum &amp;);                   //拷贝构造函数</span><br><span class="line">BigNum &amp;operator=(const  BigNum &amp;);       //重载赋值运算符，大数之间进行赋值运算</span><br><span class="line">friend istream&amp;   operator &gt;&gt; (istream&amp;, BigNum&amp;);//重载输入运算符</span><br><span class="line">friend ostream&amp;   operator&lt;&lt;(ostream&amp;, BigNum&amp;);//重载输出运算符</span><br><span class="line">BigNum  operator+(const  BigNum &amp;)const;  //重载加法运算符，两个大数之间的相加运算</span><br><span class="line">BigNum  operator-(const  BigNum &amp;)const;  //重载减法运算符，两个大数之间的相减运算</span><br><span class="line">BigNum  operator*(const  BigNum &amp;)const;  //重载乘法运算符，两个大数之间的相乘运算</span><br><span class="line">BigNum  operator/(const   int &amp;)const;    //重载除法运算符，大数对一个整数进行相除运算</span><br><span class="line">BigNum  operator^(const   int &amp;)const;    //大数的n次方运算</span><br><span class="line">int   operator%(const   int &amp;)const;      //大数对一个int类型的变量进行取模运算</span><br><span class="line">bool  operator&gt;(const BigNum  &amp;T)const;   //大数和另一个大数的大小比较</span><br><span class="line">bool  operator&gt;(const   int &amp;t)const;     //大数和一个int类型的变量的大小比较</span><br><span class="line">void  print();                            //输出大数</span><br><span class="line">&#125;;</span><br><span class="line">BigNum::BigNum(const   int b)   //将一个int类型的变量转化为大数</span><br><span class="line">&#123;</span><br><span class="line">int  c, d = b;</span><br><span class="line">len = 0;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">while (d&gt;MAXN)</span><br><span class="line">&#123;</span><br><span class="line">c = d - (d / (MAXN + 1))*(MAXN + 1);</span><br><span class="line">d = d / (MAXN + 1);</span><br><span class="line">a[len++] = c;</span><br><span class="line">&#125;</span><br><span class="line">a[len++] = d;</span><br><span class="line">&#125;</span><br><span class="line">BigNum::BigNum(const   char *s)  //将一个字符串类型的变量转化为大数</span><br><span class="line">&#123;</span><br><span class="line">int  t, k, index, L, i;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">L = strlen(s);</span><br><span class="line">len = L / DLEN;</span><br><span class="line">if (L%DLEN)len++;</span><br><span class="line">index = 0;</span><br><span class="line">for (i = L - 1; i &gt;= 0; i -= DLEN)</span><br><span class="line">&#123;</span><br><span class="line">t = 0;</span><br><span class="line">k = i - DLEN + 1;</span><br><span class="line">if (k&lt;0)k = 0;</span><br><span class="line">for (int j = k; j &lt;= i; j++)</span><br><span class="line">t = t * 10 + s[j] - &apos;0&apos;;</span><br><span class="line">a[index++] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BigNum::BigNum(const BigNum  &amp;T) :len(T.len)  //拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line">int  i;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">for (i = 0; i&lt;len; i++)</span><br><span class="line">a[i] = T.a[i];</span><br><span class="line">&#125;</span><br><span class="line">BigNum &amp;  BigNum::operator=(const  BigNum &amp;n)  //重载赋值运算符，大数之间赋值运算</span><br><span class="line">&#123;</span><br><span class="line">int  i;</span><br><span class="line">len = n.len;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">for (i = 0; i&lt;len; i++)</span><br><span class="line">a[i] = n.a[i];</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp;  operator &gt;&gt; (istream &amp;in, BigNum &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">char  ch[MAXSIZE * 4];</span><br><span class="line">int  i = -1;</span><br><span class="line">in &gt;&gt; ch;</span><br><span class="line">int L = strlen(ch);</span><br><span class="line">int  count = 0, sum = 0;</span><br><span class="line">for (i = L - 1; i &gt;= 0;)</span><br><span class="line">&#123;</span><br><span class="line">sum = 0;</span><br><span class="line">int  t = 1;</span><br><span class="line">for (int j = 0; j &lt; 4 &amp;&amp; i &gt;= 0; j++, i--, t *= 10)</span><br><span class="line">&#123;</span><br><span class="line">sum += (ch[i] - &apos;0&apos;)*t;</span><br><span class="line">&#125;</span><br><span class="line">b.a[count] = sum;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">b.len = count++;</span><br><span class="line">return  in;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp;  operator&lt;&lt;(ostream&amp;  out, BigNum&amp; b)  //重载输出运算符</span><br><span class="line">&#123;</span><br><span class="line">int  i;</span><br><span class="line">cout &lt;&lt; b.a[b.len - 1];</span><br><span class="line">for (i = b.len - 2; i &gt;= 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%04d&quot;, b.a[i]);</span><br><span class="line">&#125;</span><br><span class="line">return  out;</span><br><span class="line">&#125;</span><br><span class="line">BigNum  BigNum::operator+(const  BigNum &amp;T)const   //两个大数之间的相加运算</span><br><span class="line">&#123;</span><br><span class="line">BigNum t(*this);</span><br><span class="line">int  i, big;</span><br><span class="line">big = T.len&gt;len ? T.len : len;</span><br><span class="line">for (i = 0; i&lt;big; i++)</span><br><span class="line">&#123;</span><br><span class="line">t.a[i] += T.a[i];</span><br><span class="line">if (t.a[i]&gt;MAXN)</span><br><span class="line">&#123;</span><br><span class="line">t.a[i + 1]++;</span><br><span class="line">t.a[i] -= MAXN + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (t.a[big] != 0)</span><br><span class="line">t.len = big + 1;</span><br><span class="line">else  t.len = big;</span><br><span class="line">return  t;</span><br><span class="line">&#125;</span><br><span class="line">BigNum  BigNum::operator-(const  BigNum &amp;T)const  //两个大数之间的相减运算</span><br><span class="line">&#123;</span><br><span class="line">int  i, j, big;</span><br><span class="line">bool  flag;</span><br><span class="line">BigNum  t1, t2;</span><br><span class="line">if (*this&gt;T)</span><br><span class="line">&#123;</span><br><span class="line">t1 = *this;</span><br><span class="line">t2 = T;</span><br><span class="line">flag = 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">t1 = T;</span><br><span class="line">t2 = *this;</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">big = t1.len;</span><br><span class="line">for (i = 0; i&lt;big; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (t1.a[i]&lt;t2.a[i])</span><br><span class="line">&#123;</span><br><span class="line">j = i + 1;</span><br><span class="line">while (t1.a[j] == 0)</span><br><span class="line">j++;</span><br><span class="line">t1.a[j--]--;</span><br><span class="line">while (j&gt;i)</span><br><span class="line">t1.a[j--] += MAXN;</span><br><span class="line">t1.a[i] += MAXN + 1 - t2.a[i];</span><br><span class="line">&#125;</span><br><span class="line">else  t1.a[i] -= t2.a[i];</span><br><span class="line">&#125;</span><br><span class="line">t1.len = big;</span><br><span class="line">while (t1.a[len - 1] == 0 &amp;&amp; t1.len&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">t1.len--;</span><br><span class="line">big--;</span><br><span class="line">&#125;</span><br><span class="line">if (flag)</span><br><span class="line">t1.a[big - 1] = 0 - t1.a[big - 1];</span><br><span class="line">return  t1;</span><br><span class="line">&#125;</span><br><span class="line">BigNum  BigNum::operator*(const  BigNum &amp;T)const  //两个大数之间的相乘</span><br><span class="line">&#123;</span><br><span class="line">BigNum  ret;</span><br><span class="line">int  i, j, up;</span><br><span class="line">int  temp, temp1;</span><br><span class="line">for (i = 0; i&lt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">up = 0;</span><br><span class="line">for (j = 0; j&lt;T.len; j++)</span><br><span class="line">&#123;</span><br><span class="line">temp = a[i] * T.a[j] + ret.a[i + j] + up;</span><br><span class="line">if (temp&gt;MAXN)</span><br><span class="line">&#123;</span><br><span class="line">temp1 = temp - temp / (MAXN + 1)*(MAXN + 1);</span><br><span class="line">up = temp / (MAXN + 1);</span><br><span class="line">ret.a[i + j] = temp1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">up = 0;</span><br><span class="line">ret.a[i + j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (up != 0)</span><br><span class="line">ret.a[i + j] = up;</span><br><span class="line">&#125;</span><br><span class="line">ret.len = i + j;</span><br><span class="line">while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len&gt;1)ret.len--;</span><br><span class="line">return  ret;</span><br><span class="line">&#125;</span><br><span class="line">BigNum  BigNum::operator/(const    int &amp;b)const  //大数对一个整数进行相除运算</span><br><span class="line">&#123;</span><br><span class="line">BigNum  ret;</span><br><span class="line">int  i, down = 0;</span><br><span class="line">for (i = len - 1; i &gt;= 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">ret.a[i] = (a[i] + down*(MAXN + 1)) / b;</span><br><span class="line">down = a[i] + down*(MAXN + 1) - ret.a[i] * b;</span><br><span class="line">&#125;</span><br><span class="line">ret.len = len;</span><br><span class="line">while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len&gt;1)</span><br><span class="line">ret.len--;</span><br><span class="line">return  ret;</span><br><span class="line">&#125;</span><br><span class="line">int  BigNum::operator%(const    int &amp;b)const  //大数对一个 int类型的变量进行取模</span><br><span class="line">&#123;</span><br><span class="line">int  i, d = 0;</span><br><span class="line">for (i = len - 1; i &gt;= 0; i--)</span><br><span class="line">d = ((d*(MAXN + 1)) % b + a[i]) % b;</span><br><span class="line">return  d;</span><br><span class="line">&#125;</span><br><span class="line">BigNum  BigNum::operator^(const    int &amp;n)const  //大数的n次方运算</span><br><span class="line">&#123;</span><br><span class="line">BigNum  t, ret(1);</span><br><span class="line">int  i;</span><br><span class="line">if (n&lt;0)exit(-1);</span><br><span class="line">if (n == 0)return  1;</span><br><span class="line">if (n == 1)return *this;</span><br><span class="line">int  m = n;</span><br><span class="line">while (m&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">t = *this;</span><br><span class="line">for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1)</span><br><span class="line">t = t*t;</span><br><span class="line">m -= i;</span><br><span class="line">ret = ret*t;</span><br><span class="line">if (m == 1)ret = ret*(*this);</span><br><span class="line">&#125;</span><br><span class="line">return  ret;</span><br><span class="line">&#125;</span><br><span class="line">bool  BigNum::operator&gt;(const  BigNum &amp;T)const</span><br><span class="line">//大数和另一个大数的大小比较</span><br><span class="line">&#123;</span><br><span class="line">int  ln;</span><br><span class="line">if (len&gt;T.len)return  true;</span><br><span class="line">else  if (len == T.len)</span><br><span class="line">&#123;</span><br><span class="line">ln = len - 1;</span><br><span class="line">while (a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0)</span><br><span class="line">ln--;</span><br><span class="line">if (ln &gt;= 0 &amp;&amp; a[ln]&gt;T.a[ln])</span><br><span class="line">return  true;</span><br><span class="line">else</span><br><span class="line">return  false;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return  false;</span><br><span class="line">&#125;</span><br><span class="line">bool  BigNum::operator&gt;(const   int &amp;t)const  //大数和一个int类型的变量的大小比较</span><br><span class="line">&#123;</span><br><span class="line">BigNum  b(t);</span><br><span class="line">return *this&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">void  BigNum::print()   //输出大数</span><br><span class="line">&#123;</span><br><span class="line">int  i;</span><br><span class="line">printf(&quot;%d&quot;, a[len - 1]);</span><br><span class="line">for (i = len - 2; i &gt;= 0; i--)</span><br><span class="line">printf(&quot;%04d&quot;, a[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">BigNum f[110];//卡特兰数</span><br><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">f[0] = 1;</span><br><span class="line">for (int i = 1; i &lt;= 100; i++)</span><br><span class="line">f[i] = f[i - 1] * (4 * i - 2) / (i + 1);//卡特兰数递推式</span><br><span class="line">int  n;</span><br><span class="line">while (~scanf(&quot;%d&quot;, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if (n == -1)break;</span><br><span class="line">f[n].print();</span><br><span class="line">&#125;</span><br><span class="line">return  0;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="strtok和sscanf结合输入"><a href="#strtok和sscanf结合输入" class="headerlink" title="strtok和sscanf结合输入"></a>strtok和sscanf结合输入</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>      </td>      <td class="code">        <pre><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">char s[] = &quot;ab-cd:ef;gh: i-jkl;mnop;qrs-tu:vwx-y;z&quot;;</span><br><span class="line">char *delim = &quot;-: &quot;;   //分割条件字符串，目前里面有三个字符‘-’,’：’,‘  ’</span><br><span class="line">char *p;            //当目标字符串s中遇到分割条件字符时自动改写成‘\0’</span><br><span class="line">printf(&quot;%s &quot;, strtok(s, delim));</span><br><span class="line">while ((p = strtok(NULL, delim)))</span><br><span class="line">printf(&quot;%s &quot;, p);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">int a, b, c;</span><br><span class="line">char str[] = &quot;2018:7:15&quot;;</span><br><span class="line">sscanf(str, &quot;%d:%d:%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="解决爆栈，手动加栈"><a href="#解决爆栈，手动加栈" class="headerlink" title="解决爆栈，手动加栈"></a>解决爆栈，手动加栈</h3><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br></pre>      </td>      <td class="code">        <pre><span class="line">#pragma comment(linker,  &quot;/STACK:1024000000,1024000000&quot;)</span><br></pre>      </td>    </tr>  </table></figure><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><ol>  <li>优先队列 priority_queue</li></ol><p>empty()如果队列为空返回真</p><p>pop()删除对顶元素</p><p>push()加入一个元素</p><p>size()返回优先队列中拥有的元素个数</p><p>top()返回优先队列队顶元素</p><p>在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>      </td>      <td class="code">        <pre><span class="line">priority_queue&lt;int&gt;q1;//大的先出对</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;  &gt;q2; //小的先出队</span><br><span class="line">自定义比较函数：</span><br><span class="line">struct  cmp</span><br><span class="line">&#123;</span><br><span class="line">bool operator ()(int x, int  y)</span><br><span class="line">&#123;</span><br><span class="line">return x &gt; y; // x小的优先级高</span><br><span class="line">//也可以写成其他方式，如： return p[x] &gt; p[y];表示p[i]小的优先级高</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;,  cmp&gt;q;//定义方法</span><br><span class="line">//其中，第二个参数为容器类型。第三个参数为比较函数。</span><br><span class="line">结构体排序：</span><br><span class="line">struct  node</span><br><span class="line">&#123;</span><br><span class="line">int x, y;</span><br><span class="line">friend bool operator &lt; (node a, node  b)</span><br><span class="line">&#123;</span><br><span class="line">return a.x &gt; b.x; //结构体中，x小的优先级高</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;//定义方法</span><br><span class="line">//在该结构中，y为值, x为优先级。</span><br><span class="line">//通过自定义operator&lt;操作符来比较元素中的优先级。</span><br><span class="line">//在重载”&lt;”时，最好不要重载”&gt;”，可能会发生编译错误</span><br></pre>      </td>    </tr>  </table></figure><ol start="2">  <li>set 和 multiset</li></ol><p>set和 multiset用法一样，就是 multiset允许重复元素。</p><p>元素放入容器时，会按照一定的排序法则自动排序，默认是按照 less&lt;&gt;排序规则来排序。不</p><p>能修改容器里面的元素值，只能插入和删除。</p><p>自定义 int排序函数：（默认的是从小到大的，下面这个从大到小）</p><figure class="highlight plain">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>      </td>      <td class="code">        <pre><span class="line">struct classcomp  &#123;</span><br><span class="line">bool operator() (const int&amp; lhs, const int&amp; rhs)  const</span><br><span class="line">&#123;return  lhs&gt;rhs;&#125;</span><br><span class="line">&#125;;//这里有个逗号的，注意</span><br><span class="line">multiset&lt;int,classcomp&gt; fifth;</span><br><span class="line">// class as Compare</span><br><span class="line">上面这样就定义成了从大到小排列了。</span><br><span class="line">结构体自定义排序函数：</span><br><span class="line">（定义 set或者   multiset的时候定义了排序函数，定义迭代器时一样带上排序函数）</span><br><span class="line">struct  Node</span><br><span class="line">&#123;</span><br><span class="line">int  x,y;</span><br><span class="line">&#125;;</span><br><span class="line">struct classcomp//先按照 x从小到大排序，x相同则按照y从大到小排序</span><br><span class="line">&#123;</span><br><span class="line">bool  operator()(const Node &amp;a,const Node &amp;b)const</span><br><span class="line">&#123;</span><br><span class="line">if(a.x!=b.x)return  a.x&lt;b.x;</span><br><span class="line">else  return  a.y&gt;b.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; //注意这里有个逗号</span><br><span class="line">multiset&lt;Node,classcomp&gt;mt;</span><br><span class="line">multiset&lt;Node,classcomp&gt;::iterator  it;</span><br><span class="line">Multiset      //该函数是set的多重集合形式可保存eg：1 2 2 3 3 4 5</span><br><span class="line">multimap&lt;int, int&gt;a;</span><br><span class="line">int main()&#123;</span><br><span class="line">a.insert(pair&lt;int,int&gt;(1, 1));</span><br><span class="line">a.insert(pair&lt;int, int&gt;(2, 1));</span><br><span class="line">a.insert(pair&lt;int, int&gt;(1, 2));</span><br><span class="line">for (multimap&lt;int, int&gt;::iterator it = a.begin(); it != a.end(); it++)</span><br><span class="line">cout &lt;&lt; (*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>主要函数：</p><p>begin()返回指向第一个元素的迭代器</p><p>clear()清除所有元素</p><p>count()返回某个值元素的个数</p><p>empty()如果集合为空，返回 （true）</p><p>end()返回指向最后一个元素的迭代器</p><p>erase()删除集合中的元素 (参数是一个元素值，或者迭代器 )</p><p>find()返回一个指向被查找到元素的迭代器</p><p>insert()在集合中插入元素</p><p>size()集合中元素的数目</p><p>lower_bound()返回指向大于（或等于）某值的第一个元素的迭代器</p><p>upper_bound()返回大于某个值元素的迭代器</p><p>equal_range()返回集合中与给定值相等的上下限的两个迭代器</p><p>(注意对于 multiset删除操作之间删除值会把所以这个值的都删掉，删除一个要用迭代器 )</p><ol start="3">  <li>lower_bound and upper_bound</li></ol><p>lower_bound()  //在first和last中的前闭后开区间进行二分查找（故要先sort()），返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置（且a[last]不存在）</p><p>Eg: Pos= lower_bound(a,a+N,val)-a;</p><p>upper_bound() //也是前闭后开区间，且返回第一个大于val的位置，如果所有元素都小于val，则返回last的位置。</p><p>Eg: Pos= upper_bound (a,a+N,val)-a;<br>4.next_permutation and  prev_permutation</p><p>next_permutation（） //排列组合使用，eg：1 2 3 4 =》1 2 4 3 =》1 3 2 4 =》…</p><p>prev_permutation（） //和上面的相反，返回上一项结果</p><p>Eg: next_permutation（a,a+N）; //执行成功返回1，否则返回0</p><ol start="5">  <li>reverse()</li></ol><p>//可以对数组，字符串，vector等进行翻转操作123=》321</p><p>Eg： reverse(a，a+N);</p><ol start="6">  <li>    <p>Map</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>          </td>          <td class="code">            <pre><span class="line">map&lt;int, char&gt;m;</span><br><span class="line">map&lt;int, char&gt;::iterator it;</span><br><span class="line">m[8] = &apos;a&apos;;</span><br><span class="line">m[6] = &apos;b&apos;;</span><br><span class="line">m[11] = &apos;c&apos;;</span><br><span class="line">it = m.begin();</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; //输出6 b</span><br><span class="line">it = m.end(); it--;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; //输出11 c</span><br><span class="line">//map按照平衡二叉树原理类似，begin（）为最左下角（min）</span><br><span class="line">                             //end（）为最右下角（max）</span><br></pre>          </td>        </tr>      </table>    </figure>  </li>  <li>    <p>迭代器</p>    <figure class="highlight plain">      <table>        <tr>          <td class="gutter">            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>          </td>          <td class="code">            <pre><span class="line">在C++11情况下可以使用auto</span><br><span class="line">For（auto it=a.begin();it!=a.end();i++）</span><br><span class="line">任何情况都可以的</span><br><span class="line">for(vector&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)</span><br><span class="line">//注意，这里vector可以这么用，快很多：for(int i=0;i&lt;a.size();i++)  a[i]即为队列中第i个</span><br></pre>          </td>        </tr>      </table>    </figure>  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法模板学习&lt;/p&gt;
    
    </summary>
    
      <category term="算法模板" scheme="http://javastar.club/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="算法模板" scheme="http://javastar.club/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列学习计划(三)</title>
    <link href="http://javastar.club/archives/388be574.html"/>
    <id>http://javastar.club/archives/388be574.html</id>
    <published>2019-07-28T02:22:27.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>Spring系列博客学习</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring系列博客学习&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://javastar.club/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://javastar.club/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud入门基础</title>
    <link href="http://javastar.club/archives/e08dbd6c.html"/>
    <id>http://javastar.club/archives/e08dbd6c.html</id>
    <published>2019-07-28T02:21:48.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>Spring系列博客学习</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring系列博客学习&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://javastar.club/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://javastar.club/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot集成Thymeleaf</title>
    <link href="http://javastar.club/archives/5b29aca8.html"/>
    <id>http://javastar.club/archives/5b29aca8.html</id>
    <published>2019-07-28T02:21:34.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://javastar.club/archives/ae0f95e0.html"/>
    <id>http://javastar.club/archives/ae0f95e0.html</id>
    <published>2019-07-28T02:20:03.000Z</published>
    <updated>2019-08-07T07:14:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>Spring系列博客学习</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring系列博客学习&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://javastar.club/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://javastar.club/tags/Spring/"/>
    
  </entry>
  
</feed>
