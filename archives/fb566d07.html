<!DOCTYPE html>
<html>

<head>
  <meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">

  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="dns-prefetch" href="http://javastar.club">
  <title>数学基础复习:离散数学 | 星星</title>
  <meta name="viewport"
                                                                                  content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="三大基础数学复习：离散数学">
  <meta name="keywords" content="数学基础">
  <meta property="og:type" content="article">
  <meta property="og:title" content="数学基础复习:离散数学">
  <meta property="og:url" content="http://javastar.club/archives/fb566d07.html">
  <meta property="og:site_name" content="星星">
  <meta property="og:description" content="三大基础数学复习：离散数学">
  <meta property="og:locale" content="default">
  <meta property="og:updated_time" content="2019-08-07T08:23:25.086Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="数学基础复习:离散数学">
  <meta name="twitter:description" content="三大基础数学复习：离散数学">

  <link rel="alternative" href="/atom.xml" title="星星"
                                                                                  type="application/atom+xml">

  <link rel="icon" href="/img/head1.jpg">

  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">

  <style type="text/css">
    #container.show {
      background: linear-gradient(200deg, #a0cfe4, #e8c37e);
    }

  </style>

</head>

</html>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      <div class="overlay" style="background: #4d4d4d"></div>
      <div class="intrude-less">
        <header id="header" class="inner">
          <a href class="profilepic">
            <img src="/img/head.jpg" class="js-avatar">
          </a>
          <hgroup>
            <h1 class="header-author"><a href>小星星</a></h1>
          </hgroup>

          <p class="header-subtitle">We are all stardust</p>

          <nav class="header-menu">
            <ul>

              <li><a href="/">主页</a></li>

              <li><a href="/archives/index.html">归档</a></li>

              <li><a href="/categories">分类</a></li>

            </ul>
          </nav>
          <nav class="header-smart-menu">

            <a q-on="click: openSlider(e, 'innerArchive')"
                                                                                            href="javascript:void(0)">所有文章</a>

            <a q-on="click: openSlider(e, 'friends')"
                                                                                            href="javascript:void(0)">友情链</a>

            <a q-on="click: openSlider(e, 'aboutme')"
                                                                                            href="javascript:void(0)">关于我</a>

          </nav>
          <nav class="header-nav">
            <div class="social">

              <a class="github" target="_blank" href="https://github.com/starstarb/starstarb.github.io"
                                                                                              title="github"
                                                                                              rel="external nofollow noopener noreferrer"><i
                                                                                                class="icon-github"></i></a>

              <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/tu-zi-zuo-zai-ting-zi-shang"
                                                                                              title="zhihu"
                                                                                              rel="external nofollow noopener noreferrer"><i
                                                                                                class="icon-zhihu"></i></a>

              <a class="bilibili" target="_blank" href="https://space.bilibili.com/222130784" title="bilibili"
                                                                                              rel="external nofollow noopener noreferrer"><i
                                                                                                class="icon-bilibili"></i></a>

            </div>
          </nav>

        </header>
      </div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      <nav id="mobile-nav">
        <div class="overlay js-overlay" style="background: #4d4d4d"></div>
        <div class="btnctn js-mobile-btnctn">
          <div class="slider-trigger list" q-on="click: openSlider(e)"><i
                                                                                            class="icon icon-sort"></i>
          </div>
        </div>
        <div class="intrude-less">
          <header id="header" class="inner">
            <div class="profilepic">
              <img src="/img/head.jpg" class="js-avatar">
            </div>
            <hgroup>
              <h1 class="header-author js-header-author">小星星</h1>
            </hgroup>

            <p class="header-subtitle"><i class="icon icon-quo-left"></i>We are
              all
              stardust<i class="icon icon-quo-right"></i></p>

            <nav class="header-nav">
              <div class="social">

                <a class="github" target="_blank" href="https://github.com/starstarb/starstarb.github.io"
                                                                                                title="github"
                                                                                                rel="external nofollow noopener noreferrer"><i
                                                                                                  class="icon-github"></i></a>

                <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/tu-zi-zuo-zai-ting-zi-shang"
                                                                                                title="zhihu"
                                                                                                rel="external nofollow noopener noreferrer"><i
                                                                                                  class="icon-zhihu"></i></a>

                <a class="bilibili" target="_blank" href="https://space.bilibili.com/222130784" title="bilibili"
                                                                                                rel="external nofollow noopener noreferrer"><i
                                                                                                  class="icon-bilibili"></i></a>

              </div>
            </nav>

            <nav class="header-menu js-header-menu">
              <ul style="width: 70%">

                <li style="width: 33.333333333333336%"><a href="/">主页</a></li>

                <li style="width: 33.333333333333336%"><a
                                                                                                  href="/archives/index.html">归档</a>
                </li>

                <li style="width: 33.333333333333336%"><a
                                                                                                  href="/categories">分类</a>
                </li>

              </ul>
            </nav>
          </header>
        </div>
        <div class="mobile-mask" style="display:none" q-show="isShow"></div>
      </nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionheight="100" data-contentid="js-content"
                                                                                            id="myCanvas1"
                                                                                            class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-数学基础复习-1" class="article article-type-post " itemscope
                                                                                            itemprop="blogPost">
              <div class="article-inner">

                <header class="article-header">
                  <h1 class="article-title" itemprop="name">
                    数学基础复习:离散数学
                  </h1>

                  <a href="/archives/fb566d07.html"
                                                                                                  class="archive-article-date">
                    <time datetime="2019-08-06T08:32:15.000Z"
                                                                                                    itemprop="datePublished"><i
                                                                                                      class="icon-calendar icon"></i>2019-08-06</time>
                  </a>

                  <!-- 需要添加的位置 -->
                  <!-- 开始添加字数统计-->

                  <div style="margin-top:10px;">
                    <span class="post-time">
                      <span class="post-meta-item-icon">
                        <i class="fa fa-keyboard-o"></i>
                        <span class="post-meta-item-text"> 字数统计: </span>
                        <span class="post-count">41.3k字</span>
                      </span>
                    </span>

                    <span class="post-time">
                      &nbsp; | &nbsp;
                      <span class="post-meta-item-icon">
                        <i class="fa fa-hourglass-half"></i>
                        <span class="post-meta-item-text"> 阅读时长: </span>
                        <span class="post-count">176分</span>
                      </span>
                    </span>
                  </div>

                  <!-- 添加完成 -->

                  <span class="archive-article-date">
                    阅读量 <span id="busuanzi_value_page_pv"></span>
                  </span>

                </header>

                <div class="article-entry" itemprop="articleBody">

                  <p>三大基础数学复习：离散数学</p>
                  <a id="more"></a>
                  <h1 id="基本概念"><a href="#基本概念" class="headerlink"
                                                                                                    title="基本概念"></a>基本概念
                  </h1>
                  <h2 id="集合与元素"><a href="#集合与元素" class="headerlink"
                                                                                                    title="集合与元素"></a>集合与元素
                  </h2>
                  <p>集合与元素：集合是元素的全体。</p>
                  <h3 id="标记法"><a href="#标记法" class="headerlink"
                                                                                                    title="标记法"></a>标记法
                  </h3>
                  <p>集合通常使用大写字母表示，元素通常使用小写字母表示。</p>
                  <p>因此术语“p是A的元素”或等价于“p属于A”记作：<br>p ∈ A</p>
                  <h3 id="外延公理"><a href="#外延公理" class="headerlink"
                                                                                                    title="外延公理"></a>外延公理
                  </h3>
                  <p>两个集合A和B相等当且仅当其元素相同。</p>
                  <p>如果集合A与B相等，则记作 A = B，否则 A ≠ B。</p>
                  <h3 id="集合的表示"><a href="#集合的表示" class="headerlink"
                                                                                                    title="集合的表示"></a>集合的表示
                  </h3>
                  <p>集合有两种基本素方法，一是枚举元素，二是描述元素特征性质。</p>
                  <p>如：</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">V = &#123;a, e, i, o, u&#125;, 或</span><br><span class="line">V = &#123;x: x是英文字母，x是元音字母&#125;</span><br><span class="line"></span><br><span class="line">E = &#123;x: x &gt; 0, x mod 2 = 0&#125; 或</span><br><span class="line">E = &#123;2, 4, 6, 8, 10, ...&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h3 id="常用的集合及其表示"><a href="#常用的集合及其表示" class="headerlink"
                                                                                                    title="常用的集合及其表示"></a>常用的集合及其表示
                  </h3>
                  <table>
                    <thead>
                      <tr>
                        <th>符号</th>
                        <th>意义</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>N</td>
                        <td>全体正整数</td>
                      </tr>
                      <tr>
                        <td>Z</td>
                        <td>全体整数</td>
                      </tr>
                      <tr>
                        <td>Q</td>
                        <td>全体有理数</td>
                      </tr>
                      <tr>
                        <td>R</td>
                        <td>全体实数</td>
                      </tr>
                      <tr>
                        <td>C</td>
                        <td>全体复数</td>
                      </tr>
                    </tbody>
                  </table>
                  <h3 id="抽象原则"><a href="#抽象原则" class="headerlink"
                                                                                                    title="抽象原则"></a>抽象原则
                  </h3>
                  <p>给定集合U和性质P，则存在集合A恰好包含U中具有性质P的那些元素。</p>
                  <h2 id="全集与空集"><a href="#全集与空集" class="headerlink"
                                                                                                    title="全集与空集"></a>全集与空集
                  </h2>
                  <h3 id="全集"><a href="#全集" class="headerlink" title="全集"></a>全集
                  </h3>
                  <p>记号为U。</p>
                  <h3 id="空集"><a href="#空集" class="headerlink" title="空集"></a>空集
                  </h3>
                  <p>没有元素的集合；又称“零集”，记号为 ∅，或者 { }。</p>
                  <h4 id="空集的特性："><a href="#空集的特性：" class="headerlink"
                                                                                                    title="空集的特性："></a>空集的特性：
                  </h4>
                  <ul>
                    <li>∀A: A ⊆ ∅ ⇒ A = ∅</li>
                    <li>P(∅) = {∅}</li>
                    <li>card(∅) = 0</li>
                    <li>∀A: ∅ ⊆ A</li>
                    <li>∀A: A ∪ ∅ = ∅</li>
                    <li>∀A: A ∩ ∅ = ∅</li>
                    <li>∀A: A × ∅ = ∅</li>
                  </ul>
                  <h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集
                  </h2>
                  <p>如果集合A的每个元素都是集合B的元素，则称A为B的一个子集。也称A包含于B或者B包含A。记作：</p>
                  <p>A ⊆ B 或 B ⊇ A</p>
                  <p>或者A不是B的子集，即A至少有一个元素不属于B，则记作<br><code>A \nsubseteq B</code>
                    或者 <code>A
                      \not\subseteq B</code>，
                    <code>A \nsuperseteq A</code> 或者 <code>B \not\superseteq
                      A</code>。</p>
                  <h3 id="定理1-1"><a href="#定理1-1" class="headerlink"
                                                                                                    title="定理1.1"></a>定理1.1
                  </h3>
                  <ul>
                    <li>对于任意集合A, ∅ &lt;= A &lt;= U</li>
                    <li>对于任意集合A，A &lt;= A</li>
                    <li>如果A &lt;= B，且 B&lt;= C，则 A&lt;= C</li>
                    <li>A = B 当且仅当 A &lt;= B 且 B &lt;= A</li>
                  </ul>
                  <h1 id="集合的运算"><a href="#集合的运算" class="headerlink"
                                                                                                    title="集合的运算"></a>集合的运算
                  </h1>
                  <h2 id="集合的并与交"><a href="#集合的并与交" class="headerlink"
                                                                                                    title="集合的并与交"></a>集合的并与交
                  </h2>
                  <ul>
                    <li>
                      <p>属于A或者属于B的所有元素的集合，称为集合A和B的并集，记作：A∪B，即：</p>
                      <p>A∪B = {x: x ∈ A 或 x ∈ B}</p>
                    </li>
                    <li>
                      <p>属于A并且属于B的所有元素的集合，称为集合A和B的交集，记作：A∩B，即：</p>
                      <p>A∩B = {x: x ∈ A 且 x ∈ B}</p>
                      <p>如果A和B没有公共元素，则称集合A和B是不交的， A∩B = ∅。<br>此时，A与B的并集称为
                        不交的并(disjoint
                        union)。
                      </p>
                    </li>
                  </ul>
                  <h3 id="定理1-2"><a href="#定理1-2" class="headerlink"
                                                                                                    title="定理1.2"></a>定理1.2
                  </h3>
                  <p>下述语句等价：A ⊆ B，A ∩ B = A，A ∪ B = B。</p>
                  <h2 id="集合的补"><a href="#集合的补" class="headerlink"
                                                                                                    title="集合的补"></a>集合的补
                  </h2>
                  <p>所有属于全集U但不属于A的元素构成的集合：</p>
                  <p>$$<br>A^c = {x: x \in \mathbb{U}, x \not\in A }。
                    $$</p>
                  <p>也记作 A` 或者 Aᶜ。`</p>
                  <h3 id="相对补-差"><a href="#相对补-差" class="headerlink"
                                                                                                    title="相对补/差"></a>相对补/差
                  </h3>
                  <p>集合B关于集合A的相对补，或称集合A与集合B的差，记作 A\B，是由所有属于A但不属于B的元素构成的集合，即：</p>
                  <p>A\B = {x: x ∈ A, x ∉ B}。</p>
                  <p>也记作：A-B 或者 A~B。<br>（本质上：A\B = A ∩ B` 。）</p>
                  <h2 id="集合的基本积"><a href="#集合的基本积" class="headerlink"
                                                                                                    title="集合的基本积"></a>集合的基本积<a
                                                                                                    href="#fundamental-products"></a>
                  </h2>
                  <p>对于 n 个不同的集合 A1, A2, …, An, 它们的基本积是以下形式的任一集合：<br>A1* \cap
                    A2* \cap …
                    \cap An*
                    (Ai* = A 或 Ai* = A^c)</p>
                  <h2 id="对称差"><a href="#对称差" class="headerlink"
                                                                                                    title="对称差"></a>对称差
                  </h2>
                  <p>集合A和B的对称差，记作<br>$$<br>A ⊕
                    B<br>$$<br>是所有属于A或B但不同时属于A和B的元素的集合。即：</p>
                  <p>$$<br>A \oplus B = {x | (x \in A \land x \not\in B) \lor (x
                    \in B \land
                    x
                    \not\in A)}<br>$$</p>
                  <p>性质：<br>$$<br>A \oplus B = (A \cup B) \setminus (A \cap B)
                    \<br>A \oplus
                    B =
                    (A \setminus B) \cup (B \setminus A)<br>$$</p>
                  <h2 id="集合的代数运算及对偶性"><a href="#集合的代数运算及对偶性" class="headerlink"
                                                                                                    title="集合的代数运算及对偶性"></a>集合的代数运算及对偶性
                  </h2>
                  <p>定理1.3，集合满足以下表所列的规律：</p>
                  <h3 id="对偶性"><a href="#对偶性" class="headerlink"
                                                                                                    title="对偶性"></a>对偶性
                  </h3>
                  <p>
                    设E为集合代数运算的一个方程，则E的对偶E*是由将E中的并与交互换，全集与空集互换，得到的方程。<br>在集合的代数运算中，对偶原理成立。即如果一个方程E成立，则其对偶方程E*必定成立。
                  </p>
                  <h2 id="有限集及计数原理"><a href="#有限集及计数原理" class="headerlink"
                                                                                                    title="有限集及计数原理"></a>有限集及计数原理
                  </h2>
                  <p>一个集合称为有限集，如果它恰好含有m个相异的元素，其中m为某非负整数；否则，称集合为无限集。</p>
                  <p>用记号n(A)表示有限集A中元素的个数，也可以用 #(A)，|A| 或者 card(n)。</p>
                  <h3 id="引理1-4"><a href="#引理1-4" class="headerlink"
                                                                                                    title="引理1.4"></a>引理1.4
                  </h3>
                  <p>如果A，B为不交的有限集，则A∪B为有限集且</p>
                  <p>n(A ∪ B) = n(A) + n(B)。</p>
                  <h3 id="定理1-5"><a href="#定理1-5" class="headerlink"
                                                                                                    title="定理1.5"></a>定理1.5
                  </h3>
                  <p>如果A，B均为有限集，则A ∪ B和A ∩ B均为有限集，且</p>
                  <p>n(A ∪ B) = n(A) + n(B) - n(A ∩ B)。</p>
                  <h3 id="推论1-6"><a href="#推论1-6" class="headerlink"
                                                                                                    title="推论1.6"></a>推论1.6
                  </h3>
                  <p>如果A，B，C均为有限集，则A ∪ B ∪ C均为有限集，且</p>
                  <p>n(A ∪ B ∪ B) = n(A) + n(B) + n(C) - n(A ∩ B) - n(A ∩ C) -
                    n(B ∩ C) +
                    n(A ∩ B
                    ∩ C)。</p>
                  <h2 id="集族，幂集和集合的划分"><a href="#集族，幂集和集合的划分" class="headerlink"
                                                                                                    title="集族，幂集和集合的划分"></a>集族，幂集和集合的划分
                  </h2>
                  <p>集合的集合称为集类或者集族。集族中的元素（集合），称为子类或子族。</p>
                  <h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集
                  </h3>
                  <p>
                    对于给定的集合S，其所有可能子集的族，称为集合S的幂集。记作：Power(S)。如果S为有限集，则Power(S)也是有限集。并且：
                  </p>
                  <p>n(Power(S)) = 2 ^ n(S)</p>
                  <h3 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分
                  </h3>
                  <p>
                    设S是一个非集合，S的一个划分是将S剖分为一些不交叠的非空子集。即：S的一个划分是S的一族非空子集<code>{A_i}</code>，满足：<br>
                    1. S中的每个元素a属于一个A_i；<br> 2.
                    <code>{A_i}</code>中的集合互不相交，即对于两个不同的集合，
                    <code>A_i ∩
                      A_j = 0</code>。</p>
                  <p>划分中的子集叫<strong>胞腔</strong>。</p>
                  <p>$$<br>partition(S) = { A | (\forall x \in S, \exists A \to
                    x \in A)
                    \land
                    (\forall A_i, \forall A_j, A_i \neq A_j \to A_i \cap A_j =
                    \emptyset)}
                  </p>
                  <h2 id="集合运算的推广"><a href="#集合运算的推广" class="headerlink"
                                                                                                    title="集合运算的推广"></a>集合运算的推广
                  </h2>
                  <h3 id="定理1-7"><a href="#定理1-7" class="headerlink"
                                                                                                    title="定理1.7"></a>定理1.7
                  </h3>
                  <p>设 \mathscr{A} 为集族，则：<br>$$<br>[ \cup(A | A \in \mathscr{A})
                    ]^c =
                    \cap(A^c |
                    A \in \mathscr{A}) \<br>[ \cap(A | A \in \mathscr{A}) ]^c =
                    \cup(A^c | A
                    \in
                    \mathscr{A})
                    $$</p>
                  <h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink"
                                                                                                    title="数学归纳法"></a>数学归纳法
                  </h2>
                  <h3 id="数学归纳法原理I"><a href="#数学归纳法原理I" class="headerlink"
                                                                                                    title="数学归纳法原理I"></a>数学归纳法原理I
                  </h3>
                  <p>设 P 是定义于正整数集合N上的一个命题，即对N中的每个n，P(n) 或者正确或者不正确。假设P具有下列两个性质：
                  </p>
                  <pre><code>1. P(1)为真，
2. 只要P(n)为真，P(n+1)亦为真</code></pre>
                  <p>则对任意正整数，P都为真。</p>
                  <h3 id="数学归纳法原理II"><a href="#数学归纳法原理II" class="headerlink"
                                                                                                    title="数学归纳法原理II"></a>数学归纳法原理II
                  </h3>
                  <p>设P是定义于正整数N上的一个命题，使得：</p>
                  <pre><code>1. P(1)为真，
2. 当对于所有的 1 &lt;= k &lt; n，P(k) 为真时，有P(n)为真，</code></pre>
                  <p>则P对于所有的正整数为真。</p>
                  <h3 id="代码练习"><a href="#代码练习" class="headerlink"
                                                                                                    title="代码练习"></a>代码练习
                  </h3>
                  <p>example.tex</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">  \usepackage&#123;amsmath&#125;</span><br><span class="line">  \usepackage&#123;amssymb&#125;</span><br><span class="line">  \newcommand&#123;\setcomp&#125;[1] &#123;&#123;#1&#125;^&#123;\mathsf&#123;c&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item Prove $B\setminus A = B\cap \setcomp&#123;A&#125;$.</span><br><span class="line">  \item Prove the following are equivalent:</span><br><span class="line">  $A\subseteq B, A \cap B = A, A\cup B = B$.</span><br><span class="line"></span><br><span class="line">  \item Prove the Distributive Law:</span><br><span class="line">  $A\cap(B\cap C) = (A\cap B)\cup (A\cap C)$.</span><br><span class="line"></span><br><span class="line">  \item Write the dual of:</span><br><span class="line">  $</span><br><span class="line">  (\textbf&#123;U&#125; \cap A)\cup (B\cap A) = A,</span><br><span class="line">  (A\cap \textbf&#123;U&#125;)\cap (\emptyset \cup \setcomp&#123;A&#125;) = \emptyset</span><br><span class="line">  $.</span><br><span class="line"></span><br><span class="line">  \item Prove $(A\cup B)\setminus (A\cap B) = (A\setminus B)\cup (B\setminus A)$.</span><br><span class="line"></span><br><span class="line">  \item Prove:</span><br><span class="line"></span><br><span class="line">    a. $(A\cap B)\cup (A\cap \setcomp&#123;B&#125;) = A$</span><br><span class="line"></span><br><span class="line">    b. $A\cup B = (A\cap \setcomp&#123;B&#125;)\cup (\setcomp&#123;A&#125;\cap B)\cup (A\cap B)$</span><br><span class="line"></span><br><span class="line">  \item Prove $n(P(S)) = 2^&#123;n(S)&#125;$ if $S$ is a finite set.</span><br><span class="line"></span><br><span class="line">  \item Try to figure out the formula for: $n(partition(S))$.</span><br><span class="line"></span><br><span class="line">  \item Let $[A_1, A_2, \cdots, A_m]$ and $[B_1, B_2, \cdots, B_m]$ be partitions of a set S.</span><br><span class="line">  Prove the following collection is also a partition (called the \textsl&#123;cross partition&#125;) of S:</span><br><span class="line">  $$</span><br><span class="line">  P = [A_i\cap B_j | i = 1, \cdots, m, j = 1, \cdots, n]\setminus \emptyset</span><br><span class="line">  $$</span><br><span class="line"></span><br><span class="line">  \item Prove the following properties of the symmetric difference:</span><br><span class="line"></span><br><span class="line">    a. Associative Law $(A\oplus B)\oplus C = A\oplus(B \oplus C)$</span><br><span class="line"></span><br><span class="line">    b. Comutative Law $A\oplus B = B\oplus A$</span><br><span class="line"></span><br><span class="line">    c. Cancellation Law $A\oplus B = A\oplus C \implies B = C$</span><br><span class="line"></span><br><span class="line">    d. Distributive Law $A\cap (B\oplus C) = (A\cap B)\oplus (A\cap C)$</span><br><span class="line"></span><br><span class="line">  \item Consider $m$ nonempty distinct sets, $A_1, A_2, \cdots, A_m$ in a universal set $\textbf&#123;U&#125;$. Prove:</span><br><span class="line"></span><br><span class="line">    a. There are $2^m$ fundamental products of the $m$ sets.</span><br><span class="line"></span><br><span class="line">    b. Any two fundamental products are disjoint.</span><br><span class="line"></span><br><span class="line">    c. $\textbf&#123;U&#125;$ is the union of all the fundamental products.</span><br><span class="line"></span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录
                  </h1>
                  <h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>集合 set (, class, collection, family)</li>
                    <li>元素 element, member</li>
                    <li>内涵</li>
                    <li>外延</li>
                    <li>Venn图 Venn diagrams</li>
                    <li>外延公理</li>
                    <li>抽象原则</li>
                    <li>全集 universal set</li>
                    <li>空集 empty set</li>
                    <li>子集 subset<ul>
                        <li>包含 contains</li>
                        <li>包含于 be contained in</li>
                        <li>真子集 proper subset</li>
                      </ul>
                    </li>
                    <li>不交 disjoint, nonintersecting</li>
                    <li>集合的运算 set operations<ul>
                        <li>集合并 union</li>
                        <li>不交的并 disjoint union</li>
                        <li>集合交 intersection</li>
                        <li>（绝对）补 (absolute) complement</li>
                        <li>相对补 relative complement, difference</li>
                        <li>对称差 symmetric difference</li>
                        <li><a href="operations.md#fundamental-products">集合基本积
                            fundamental
                            product</a></li>
                      </ul>
                    </li>
                    <li>集合代数运算规则<ul>
                        <li>幂等律 idempotent laws</li>
                        <li>结合律 associative laws</li>
                        <li>交换律 commutative laws</li>
                        <li>分配律 distributive laws</li>
                        <li>同一律 identity laws</li>
                        <li>对合律 involution laws</li>
                        <li>互补律 complement laws</li>
                        <li>DeMorgan律 DeMorgan’s laws</li>
                      </ul>
                    </li>
                    <li>对偶性 duality</li>
                    <li>有限集 finite sets</li>
                    <li>计数原理 counting principle</li>
                    <li>集族 classes of sets</li>
                    <li>幂集 power set</li>
                    <li>集合的划分 set partitions<ul>
                        <li>胞腔 cell</li>
                      </ul>
                    </li>
                    <li>数学归纳法 mathematical induction</li>
                  </ul>
                  <h3 id="标志约定"><a href="#标志约定" class="headerlink"
                                                                                                    title="标志约定"></a>标志约定
                  </h3>
                  <p>为了方便表示集合关系，这里约束集合运算中所用到的标志。</p>
                  <table>
                    <thead>
                      <tr>
                        <th></th>
                        <th>Latex</th>
                        <th>Unicode</th>
                        <th>意义</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>equal</td>
                        <td>=</td>
                        <td>=</td>
                        <td>相等</td>
                      </tr>
                      <tr>
                        <td>not equal</td>
                        <td>\neq; \ne</td>
                        <td>≠</td>
                        <td>不相等</td>
                      </tr>
                      <tr>
                        <td>elements of</td>
                        <td>\in</td>
                        <td>∈</td>
                        <td>属于</td>
                      </tr>
                      <tr>
                        <td>not element of</td>
                        <td>\notin</td>
                        <td>∉</td>
                        <td>不属于</td>
                      </tr>
                      <tr>
                        <td>subset</td>
                        <td>\subseteq</td>
                        <td>⊆</td>
                        <td>子集</td>
                      </tr>
                      <tr>
                        <td>superset</td>
                        <td>\supseteq</td>
                        <td>⊇</td>
                        <td>父集</td>
                      </tr>
                      <tr>
                        <td>proper subset</td>
                        <td>\subset</td>
                        <td>⊂</td>
                        <td>真子集</td>
                      </tr>
                      <tr>
                        <td>proper superset</td>
                        <td>supset</td>
                        <td>⊃</td>
                        <td>真父集</td>
                      </tr>
                      <tr>
                        <td>not a subset</td>
                        <td>\not\subset</td>
                        <td>⊄</td>
                        <td></td>
                      </tr>
                      <tr>
                        <td>not a superset</td>
                        <td>\not\supset</td>
                        <td>⊅</td>
                        <td></td>
                      </tr>
                      <tr>
                        <td>for all</td>
                        <td>\forall</td>
                        <td>∀</td>
                        <td>任意</td>
                      </tr>
                      <tr>
                        <td>exist</td>
                        <td>\exists</td>
                        <td>∃</td>
                        <td>存在</td>
                      </tr>
                      <tr>
                        <td>and</td>
                        <td>\land</td>
                        <td></td>
                        <td>并</td>
                      </tr>
                      <tr>
                        <td>or</td>
                        <td>\lor</td>
                        <td></td>
                        <td>或</td>
                      </tr>
                      <tr>
                        <td>if and only if</td>
                        <td>\iff</td>
                        <td></td>
                        <td>当且仅当</td>
                      </tr>
                      <tr>
                        <td>union</td>
                        <td>\cup</td>
                        <td>∪</td>
                        <td></td>
                      </tr>
                      <tr>
                        <td>intersection</td>
                        <td>\cap</td>
                        <td>∩</td>
                        <td></td>
                      </tr>
                      <tr>
                        <td>cartesian product</td>
                        <td>\times</td>
                        <td>×</td>
                        <td>笛卡尔积</td>
                      </tr>
                      <tr>
                        <td>empty set</td>
                        <td>\emptyset; \varnothing</td>
                        <td>∅</td>
                        <td>空集</td>
                      </tr>
                    </tbody>
                  </table>
                  <p><a href="https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols" rel="external nofollow noopener noreferrer"
                                                                                                    target="_blank">LaTex
                      Symbols</a></p>
                  <h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点
                  </h2>
                  <ul>
                    <li>集簇</li>
                    <li>幂集</li>
                    <li>划分</li>
                  </ul>
                  <h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系
                  </h1>
                  <h2 id="有序偶"><a href="#有序偶" class="headerlink"
                                                                                                    title="有序偶"></a>有序偶
                  </h2>
                  <p>关系由元素的有序偶(a, b)来定义，这里a作为第一元素，b为第二元素。</p>
                  <p>特别地，(a, b) = (c, d) 当且仅当 a = c 且 b = d。</p>
                  <h3 id="使用集合定义有序偶"><a href="#使用集合定义有序偶" class="headerlink"
                                                                                                    title="使用集合定义有序偶"></a>使用集合定义有序偶
                  </h3>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">- Wiener&apos;s</span><br><span class="line">$$</span><br><span class="line">(a, b) := \&#123;\&#123;\&#123;a\&#125;, \emptyset\&#125;, \&#123;\&#123;b\&#125;\&#125;\&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">- Hausdorff</span><br><span class="line">$$</span><br><span class="line">(a, b) := \&#123;\&#123;a, 1\&#125;, \&#123;b, 2\&#125;\&#125;</span><br><span class="line">$$</span><br><span class="line">（注：此处的 1 和 2 不是数字 1 和 2，而是代表与 a 和 b 不相等的两个互不相等的元素）</span><br><span class="line"></span><br><span class="line">- Kuratowski 定义</span><br><span class="line">$$</span><br><span class="line">(a, b) = \&#123;\&#123;a\&#125;, \&#123;a, b\&#125;\&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">有序偶第一元素的定义：</span><br><span class="line">$$</span><br><span class="line">\forall Y \in p : x \in Y</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">有序偶第二元素的定义：</span><br><span class="line">$$</span><br><span class="line">(\exist Y \in p : x \in Y) \land (\forall Y_1, Y_2 \in p : Y_1 \neq Y_2 \rarrow (x \not\in Y_1 \lor x \not\in Y_2))</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">- Cantor-Frege 定义</span><br><span class="line">(a, b) := \&#123; R: aRb \&#125;</span><br><span class="line">（使用关系来定义）</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <p>此外，还有多种其它定义形式，此处不再介绍。</p>
                  <h2 id="集合的积（笛卡尔积）"><a href="#集合的积（笛卡尔积）" class="headerlink"
                                                                                                    title="集合的积（笛卡尔积）"></a>集合的积（笛卡尔积）
                  </h2>
                  <p>对于任意两个集合A，B，称所有有序偶(a, b)的集合为A，B的积或笛卡尔积，其中 a ∈ A，b ∈
                    B。<br>A，B的积记作 A ×
                    B。</p>
                  <p>A × B = {(a, b): a ∈ A 且 b ∈ B}</p>
                  <p>A × A 通常也记作 A^2。</p>
                  <p>笛卡尔积有以下性质：</p>
                  <ol>
                    <li>
                      <p>not commutative:<br>A != B -&gt; A × B != B × A<br>A ×
                        B = B × A
                        &lt;–&gt; A = B</p>
                    </li>
                    <li>
                      <p>n(A × B) = n(B × A) = n(A) n(B)</p>
                    </li>
                    <li>
                      <p>not associative:<br>(A × B) × C != A × (B × C)</p>
                    </li>
                    <li>
                      <p>A × (B ∩ C) = (A × B) ∩ (A × C)<br>A × (B ∪ C) = (A ×
                        B) ∪ (A ×
                        C)<br>A ×
                        (B \ C) = (A × B) \ (A × C)<br>(A × C)^C = (A^C × B^C) ∪
                        (A^C × B) ∪
                        (A ×
                        B^C)</p>
                    </li>
                    <li>
                      <p>(A ∩ B) × (C ∩ D) = (A × C) ∩ (B × D)</p>
                      <p>(A ∪ B) × (C ∪ D) \neq (A × C) ∪ (B × D)</p>
                      <p>(A ∪ B) × (C ∪ D) = [(A \ B) × C] ∪ [(A ∩ B) × (C ∪ D)]
                        ∪ [(B \ A)
                        × D]
                      </p>
                      <p>(A × C) \ (B × D) = [A ×(C \ D)] ∪ [(A \ B) × C]</p>
                    </li>
                    <li>
                      <p>A ⊆ B -&gt; A × C ⊆ B × C<br>A, B != ∅ -&gt; (A × B ⊆ C
                        × D
                        &lt;–&gt; A ⊆
                        C \land B ⊆ D)</p>
                    </li>
                  </ol>
                  <h3 id="笛卡尔平面"><a href="#笛卡尔平面" class="headerlink"
                                                                                                    title="笛卡尔平面"></a>笛卡尔平面
                  </h3>
                  <p>R表示实数集，R^2可以表示平面上的点的集合，R^2常称为笛卡尔平面。</p>
                  <h3 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律
                  </h3>
                  <ul>
                    <li>A × B ≠ B × A</li>
                    <li>card(A × B) = card(A) * card(B)</li>
                  </ul>
                  <h3 id="集合积的推广"><a href="#集合积的推广" class="headerlink"
                                                                                                    title="集合积的推广"></a>集合积的推广
                  </h3>
                  <p>集合积的概念可以推广到任意有限多个集合，对于任意的集合 A1, A2, …, An，<br>称全体n元有限组(a1,
                    a2, …,
                    an)的集合为 A1,
                    A2, …, An 的积，记作：</p>
                  <p>A1 × A2 × … × An 或：</p>
                  <p>$$<br>\prod_{i=1}^{i=n} A_{i}<br>$$</p>
                  <h2 id="关系-1"><a href="#关系-1" class="headerlink"
                                                                                                    title="关系"></a>关系
                  </h2>
                  <p><strong>定义</strong> 设A，B为集合，A×B的任一子集称为从A到B的一个二元关系或者简称关系。
                  </p>
                  <p>
                    假定R是从A到B的一个关系，则R是一个有序偶的集合，在每个有序偶中，第一个元素<br>来自A而第二元素来自B，即对于每一对a
                    ∈ A 和 b
                    ∈
                    B，下列两种情况恰具其一：<br> 1. (a, b) ∈ R，称 a 与 b 之间具有关系R，记作 aRb；<br>
                    2. (a, b) ∉
                    R，称 a
                    与 b 之间不具有关系R，记作 aꞦb；</p>
                  <p>如果R是集合A到自身的一个关系，即 R 是 A^2 的一个子集，则称 R 是 A 上的一个关系。</p>
                  <p>R的定义域是属于R的有序偶的第一元素的集合，而称所有第二元素的集合为R的值域。</p>
                  <h3 id="相等关系"><a href="#相等关系" class="headerlink"
                                                                                                    title="相等关系"></a>相等关系
                  </h3>
                  <p>设A为任一集合A上的一个重要关系为相等：</p>
                  <p>{(a, a): a ∈ A}</p>
                  <p>通常记作“=”。这个关系也称为集合A上的恒等或者对角线关系。记作Δ_A或简记为Δ。</p>
                  <h3 id="完全关系和空关系"><a href="#完全关系和空关系" class="headerlink"
                                                                                                    title="完全关系和空关系"></a>完全关系和空关系
                  </h3>
                  <p>设A为任一集合，则 A × A 和 ∅ 都是 A × A 的子集，因而也都是上A上的关系，分别称为完全关系和空关系。
                  </p>
                  <h2 id="逆关系"><a href="#逆关系" class="headerlink"
                                                                                                    title="逆关系"></a>逆关系
                  </h2>
                  <p>设R为从集合A到B的任意一个关系，R的逆，记作
                    R^-1，是将R中的所有有序偶逆转后的有序偶的集合，<br>是一个从B到A的关系，即：</p>
                  <p>R^-1 = {(b, a): (a, b) ∈ R}</p>
                  <h2 id="关系的图示"><a href="#关系的图示" class="headerlink"
                                                                                                    title="关系的图示"></a>关系的图示
                  </h2>
                  <p>通常，一个关系由满足某给定方程</p>
                  <p>E(x, y) = 0</p>
                  <p>的有序实数偶构成。通常将该关系与这个方程等同。<br>称E(x, y) = 0 为关系。</p>
                  <h3 id="有限集上关系的图示"><a href="#有限集上关系的图示" class="headerlink"
                                                                                                    title="有限集上关系的图示"></a>有限集上关系的图示
                  </h3>
                  <p>设A，B为有限集，下面给出图示A到B的关系R的两种方法。</p>
                  <ul>
                    <li>构造一个矩阵，以A的元素和B的元素分别标注其行与列，对于a ∈ A和b ∈
                      B，视a，b是否具有关系R，在a行和b列交叉处标上1或0.<br>这样得到的矩阵称为<strong>关系矩阵</strong>。
                    </li>
                    <li>
                      在两个不相交的碟形区域中分别写下A和B的元素，当a，b具有关系R时，则画一个从a到b的箭头。<br>这样得到的图示称为关系的<strong>箭头图</strong>。
                    </li>
                  </ul>
                  <h3 id="集上关系的有向图"><a href="#集上关系的有向图" class="headerlink"
                                                                                                    title="集上关系的有向图"></a>集上关系的有向图
                  </h3>
                  <p>
                    当R为有限集到自身的关系时，可以用另一种方法给出R的图示，先写下给定集合的元素，对于每一个元素x，如果x与元素y之间具有关系R，<br>我们就画一个自x到y的箭头，这样得到的图形称为关系的<strong>有向图</strong>。
                  </p>
                  <h2 id="关系的合成"><a href="#关系的合成" class="headerlink"
                                                                                                    title="关系的合成"></a>关系的合成
                  </h2>
                  <p>设A，B，C为集合，且R为从A到B的一个关系，S为从B到C的一个关系，即R为A ×
                    B的子集，<br>则由R和S决定了从A到C的一个关系，记作
                    R*S。定义为：</p>
                  <p>a(R * S)c 如果对于某b ∈ B 我们有aRb且bSc，</p>
                  <p>即</p>
                  <p>R * S = {(a, c): 存在 b ∈ B 使得(a, b) ∈ R且(b, c) ∈ S}</p>
                  <h3 id="关系的合成与矩阵"><a href="#关系的合成与矩阵" class="headerlink"
                                                                                                    title="关系的合成与矩阵"></a>关系的合成与矩阵
                  </h3>
                  <p>设 M_R 和 M_S 分别表示关系R和S的矩阵，则将 M_R 与 M_S，得矩阵M = M_R *
                    M_S。<br>这个矩阵中的非零元素表示其所对应的元素具有关系。</p>
                  <h3 id="定理2-1"><a href="#定理2-1" class="headerlink"
                                                                                                    title="定理2.1"></a>定理2.1
                  </h3>
                  <p>设A，B，C，D为集合，假定R为从A到B的关系，S为从B到C的关系，T为从C到D的关系，则：</p>
                  <p>(R * S) * T = R * (S * T)</p>
                  <h2 id="典型关系"><a href="#典型关系" class="headerlink"
                                                                                                    title="典型关系"></a>典型关系
                  </h2>
                  <h3 id="自反关系"><a href="#自反关系" class="headerlink"
                                                                                                    title="自反关系"></a>自反关系
                  </h3>
                  <p>集合A上的关系R称为自反的，如果对于每个a ∈ A，总有aRa，即如果对每个a ∈ A， (a, a) ∈ R.
                  </p>
                  <p>因此，如果存在a ∈ A，使得(a, a) ∉ R，则R不是自反的。</p>
                  <h3 id="对称和反对称关系"><a href="#对称和反对称关系" class="headerlink"
                                                                                                    title="对称和反对称关系"></a>对称和反对称关系
                  </h3>
                  <p><strong>对称</strong> 集合A上的关系R称为是对称的，如果由 aRb 必可推出 bRa，即只要 (a,
                    b) ∈
                    R，则(b, a) ∈
                    R。<br>于是，如果存在 a, b ∈ A，使得 (a, b) ∈ R，但 (b, a) ∉ R，则R是不对称的。
                  </p>
                  <p>常见的对称关系：垂直，平行，相等。</p>
                  <p><strong>反对称</strong> 集合A上的关系R称为是反对称的，如果aRb且bRa则必有a=b，即只要(a,
                    b), (b, a)
                    ∈ R，就有
                    a = b。<br>于是，如果存在 a，b ∈ A 使得 (a, b) 与 (b, a) 都属于 R，但 a ≠
                    b，则R是不对称的。</p>
                  <p>常见的反对称关系：大于等于，小于等于，等于，整除（对于正整数）。</p>
                  <h3 id="传递关系"><a href="#传递关系" class="headerlink"
                                                                                                    title="传递关系"></a>传递关系
                  </h3>
                  <p>集合A上的关系R称为是传递的，如果aRb 且bRc，则有aRc，即只要(a, b)，(b, c) ∈ R 就必有(a,
                    c) ∈
                    R。<br>于是，如果存在 (a, b)，(b, c) ∈ R，但(a, c) ∉ R，则 R 不是传递的。</p>
                  <h4 id="定理2-2"><a href="#定理2-2" class="headerlink"
                                                                                                    title="定理2.2"></a>定理2.2
                  </h4>
                  <p>一个关系R是传递的，当且仅当对于 n &gt;= 1 有 R^n ⊆ R。</p>
                  <h2 id="闭包性质"><a href="#闭包性质" class="headerlink"
                                                                                                    title="闭包性质"></a>闭包性质
                  </h2>
                  <p>对于给定的集合A，考虑其上所有关系构成的集族，设℘为这些关系的一个性质，比如对称或者传递等等，我们将具有 性质 P
                    的关系称为一个 P-
                    关系。<br>集合 A 上关系 R 的 P-闭包 是一个 P-关系，满足对每个包含R的 P- 关系 S 有：</p>
                  <p>R ⊆ P(R) ⊆ S</p>
                  <p>R 的闭包记作 P(R)，有的书本记作$Cl_{p}(R)$。</p>
                  <p>P(R) 即在 A 上的最小关系，使得其包含 R 和满足性质 P。亦即，在 R 上添加最小数量的有序偶，使得 R
                    有获取性质 P。</p>
                  <p>对于自反，对称，传递关系R，记：<br>$$<br>\text{reflexive}(R),
                    \text{symmetric}(R),
                    \text{transitive}(R)<br>$$<br>分别表示其闭包。</p>
                  <p>一般地，P(R) 未必存在，但是在某些条件下，P(R) 总是存在的。<br>假设 P 是一个性质，至少存在一个包含 R
                    的 P-
                    关系，而且任意 P-
                    关系的交仍然是一个 P- 关系。则可证明：</p>
                  <p>P(R) = ∩ { S: S 是 P- 关系，且 R ⊆ S }</p>
                  <h3 id="自反闭包和对称闭包"><a href="#自反闭包和对称闭包" class="headerlink"
                                                                                                    title="自反闭包和对称闭包"></a>自反闭包和对称闭包
                  </h3>
                  <p>记 Δ(A) = {(a, a): a ∈ A }</p>
                  <p><strong>定理 2.3</strong> 设 R 为集合 A 上的一个关系，则：<br> 1. R ∪ Δ(A)
                    为 R
                    的自反闭包；<br> 2.
                    R ∪ R^-1 为 R 的对称闭包；</p>
                  <h3 id="传递闭包"><a href="#传递闭包" class="headerlink"
                                                                                                    title="传递闭包"></a>传递闭包
                  </h3>
                  <p>设 R 为集合 A 上的一个关系，定义：</p>
                  <p>$$<br>R^* = \prod_{i=i}^{\infty} R^i<br>$$</p>
                  <p><strong>定理2.4</strong></p>
                  <p>R^n 是关系R的传递空包，设A为含有n个元素的有限集，则：</p>
                  <p>$$<br>R^* = R_1 \cup R_2 \cup \ldots \cup R_n<br>$$</p>
                  <p><strong>定理2.5</strong></p>
                  <p>设R为含n个元素的有限集A上的一个关系，则：<br>$$<br>transitive(R) = R \cup
                    R^2<br>$$</p>
                  <h2 id="等价关系"><a href="#等价关系" class="headerlink"
                                                                                                    title="等价关系"></a>等价关系
                  </h2>
                  <p>设 S 为非空集合，R 是 S 上的一个关系，如果 R 是自反的，对称的和传递的，则称 R 为一个等价关系；<br>即
                    S 上的关系 R
                    称为等价关系，如果 R 满足下列三条性质：</p>
                  <pre><code>1. 对每个 a ∈ S，有 aRa；
2. 如果 aRb，则 bRa；
3. 如果 aRb 且 bRc，则 aRc；</code></pre>
                  <p><strong>常见的等价关系</strong>：
                    1. 对于欧氏平面上的直线集合L，平行是L上的一个等价关系；<br>
                    对于欧氏平面上的三角形T，全等与相似均为T上的等价关系。<br> 2.
                    正整数的
                    模m同余 是一个等价关系。</p>
                  <h3 id="等价类"><a href="#等价类" class="headerlink"
                                                                                                    title="等价类"></a>等价类
                  </h3>
                  <p>集合 A 上的一个等价类 R 可以将集合 A 划分为若干个互不相交的子集，称为等价类。</p>
                  <p>对于 A 中的每个元素 a，使用 [a] 表示 a 的等价类。即：</p>
                  <p>$$<br>[a] = { b | bRa }<br>$$</p>
                  <h3 id="等价关系与集合的划分"><a href="#等价关系与集合的划分" class="headerlink"
                                                                                                    title="等价关系与集合的划分"></a>等价关系与集合的划分
                  </h3>
                  <p>假定R是集合S上的一个等价关系，对于每个 a \in R，设[a]表示与a具有关系R的S中的元素的集合，即：</p>
                  <p>[a] = {x: (a, x) \in R}</p>
                  <p>我们称[a]为元素a在S中的等价类。任意 b \in [a]称为该等价类的代表。</p>
                  <p>在关系R下，集合S的所有元素的等价类构成的集族记作S/R，即：<br>$$<br>S/R = { [a]: a \in
                    R
                    }<br>$$<br>称为S关于R的商集。商集的基本性质由下面的定理给出：</p>
                  <p><strong>定理2.6</strong> 设R是集合S上的一个等价关系，则商集S/R是S的一个划分，特别地，
                  </p>
                  <ul>
                    <li>
                      <p>对于每个a \in S，有 a \in [a]</p>
                    </li>
                    <li>
                      <p>[a] = [b]当且仅当(a, b) \in R</p>
                    </li>
                    <li>
                      <p>若[a] \neq [b]，则[a]与[b]不交</p>
                      <p>反之，给定集合S的一个划分{A_i}，则存在S上的一个等价关系R，使得A_i是关于R的等价类。</p>
                    </li>
                  </ul>
                  <h2 id="偏序关系"><a href="#偏序关系" class="headerlink"
                                                                                                    title="偏序关系"></a>偏序关系
                  </h2>
                  <p>R 为集合 S
                    上的一个关系，如果R是<em>自反</em>的，<em>反对称</em>的及<em>可传递</em>的，则R称为一个<strong>偏序</strong>。
                  </p>
                  <p>集合S与偏序关系R一起，称为一个<strong>偏序集</strong>。</p>
                  <h2 id="n元关系"><a href="#n元关系" class="headerlink"
                                                                                                    title="n元关系"></a>n元关系
                  </h2>
                  <p>n元关系，是指一个n元有序组的集合，对于任意的集合S，积集S^n
                    的子集称为S上的一个n元关系。<br>特别地，S^3的子集称为S上的三元关系。</p>
                  <h1 id="附录-1"><a href="#附录-1" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <h2 id="术语-1"><a href="#术语-1" class="headerlink"
                                                                                                    title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>
                      <p>有序偶 ordered pair</p>
                      <ul>
                        <li>有序偶的第一元素 first entry</li>
                        <li>有序偶的第二元素 second entry</li>
                      </ul>
                    </li>
                    <li>
                      <p>集合的积 product of set</p>
                    </li>
                    <li>
                      <p>集合的笛卡尔积 Cartesian product of set</p>
                    </li>
                    <li>
                      <p>关系 relation</p>
                      <ul>
                        <li>关系的定义域 domain of a relation</li>
                        <li>关系的值域 range of a relation</li>
                      </ul>
                    </li>
                    <li>
                      <p>二元组 2-tuple</p>
                    </li>
                    <li>
                      <p>n元组 n-tuple</p>
                    </li>
                    <li>
                      <p>二元关系 binary relation</p>
                    </li>
                    <li>
                      <p>n元关系 n-ary relation</p>
                    </li>
                    <li>
                      <p>逆关系 inverse relation</p>
                    </li>
                    <li>
                      <p>关系的图示 pictorial representation of relations</p>
                      <ul>
                        <li>关系矩阵 matrix of the relation</li>
                        <li>关系箭头图 arrow diagram of the relation</li>
                        <li>关系有向图</li>
                      </ul>
                    </li>
                    <li>
                      <p>关系的合成 composition of relations</p>
                    </li>
                    <li>
                      <p>典型关系 types of relations</p>
                      <ul>
                        <li>自反关系 reflexive relations</li>
                        <li>空关系 the empty relation</li>
                        <li>全关系 the universal relation</li>
                        <li>对称关系 symmetric relations</li>
                        <li>反对称关系 antisymmentric relations</li>
                        <li>传递关系 transitive relations</li>
                      </ul>
                    </li>
                    <li>
                      <p>闭包性质 closure properties</p>
                      <ul>
                        <li>自反闭包</li>
                        <li>对称闭包</li>
                        <li>对角线</li>
                        <li>恒等关系</li>
                        <li>传递闭包</li>
                      </ul>
                    </li>
                    <li>
                      <p>等价关系</p>
                    </li>
                    <li>
                      <p>偏序关系</p>
                    </li>
                    <li>
                      <p>n元关系</p>
                    </li>
                  </ul>
                  <h4 id="examples-tex"><a href="#examples-tex" class="headerlink"
                                                                                                    title="examples.tex"></a>examples.tex
                  </h4>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">1. Based on Kuratowski&apos;s definition of ordered pairs, prove that:</span><br><span class="line">$$</span><br><span class="line">(a, b) = (c, d) \iff (a = b \land c = d)</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">According to Kuratowski&apos;s definition, $(x, y) = &#123;&#123;x&#125;, &#123;x, y&#125;&#125;$.</span><br><span class="line"></span><br><span class="line">If $(a, b) = (c, d)$, then $&#123;&#123;a&#125;, &#123;a, b&#125;&#125; = &#123;&#123;c&#125;, &#123;c, d&#125;&#125;$</span><br><span class="line"></span><br><span class="line">  1. if $a = b$,</span><br><span class="line">     then $&#123;&#123;a&#125;, &#123;a, b&#125;&#125; = &#123;&#123;a&#125;, &#123;a, a&#125;&#125; = &#123;&#123;a&#125;&#125; = &#123;&#123;c&#125;, &#123;c, d&#125;&#125;$,</span><br><span class="line">     then $&#123;c&#125; = &#123;c, d&#125; = &#123;a&#125;$,</span><br><span class="line">     then $a = c = d$,</span><br><span class="line">     then $b = a = d$</span><br><span class="line">     then $a = c, b = d$</span><br><span class="line"></span><br><span class="line">  2. if $a \neq b$</span><br><span class="line">     a. if $&#123;a&#125; = &#123;c, d&#125;$,</span><br><span class="line">        then $a = c = d$, $&#123;&#123;c&#125;, &#123;c, d&#125;&#125; = &#123;&#123;a&#125;&#125;$,</span><br><span class="line">        then $&#123;&#123;a&#125;, &#123;a, b&#125;&#125; = &#123;&#123;a&#125;&#125;$,</span><br><span class="line">        then $a = b$,</span><br><span class="line">        which contradicts $a \neq b$.</span><br><span class="line">     b. the same goes for $&#123;c&#125; = &#123;a, b&#125;$</span><br><span class="line">     c. if $&#123;a&#125; = &#123;c&#125;$,</span><br><span class="line">        then $a = c$,</span><br><span class="line">        then $&#123;&#123;a&#125;, &#123;a, b&#125;&#125; = &#123;&#123;c&#125;, &#123;c, d&#125;&#125; = &#123;&#123;a&#125;, &#123;a, d&#125;&#125;$,</span><br><span class="line">        then $&#123;a, b&#125; = &#123;a, d&#125;$,</span><br><span class="line">        then $b = d$.</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h5 id="exercise"><a href="#exercise" class="headerlink"
                                                                                                    title="exercise"></a>exercise
                  </h5>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\documentclass[a4paper, 12pt]&#123;article&#125;</span><br><span class="line">\usepackage&#123;color&#125;</span><br><span class="line"></span><br><span class="line">\title&#123;Exercise&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item Prove: Let $A, B, C, D$ be sets. Suppose $R$ is a relation from $A$ to $B$,</span><br><span class="line">  $S$ is a relation from $B$ to $C$ and $T$ is a relation from $C$ to $D$.</span><br><span class="line">  Then $(R\circ S)\circ T = R\circ (S\circ T)$</span><br><span class="line"></span><br><span class="line">  \item Suppse $C$ is a collection of relations $S$ on a set $A$,</span><br><span class="line">  and let $T$ be the intersection of the relations $S$ in $C$, that is $T = \cap(S|S \in C)$.</span><br><span class="line">  Prove:</span><br><span class="line">  a. If every S is symmetric, then T is symmetric.</span><br><span class="line">  b. If every S is transitive, then T is transitive.</span><br><span class="line"></span><br><span class="line">  \item let $R$ be a relation on a set $A$, and let $P$ be a property of relations,</span><br><span class="line">  such as symmetry and transitivity. Then $P$ will be called \texsl&#123;R-closable&#125; if $P$ satisfies:</span><br><span class="line">  i. There is a \textsl&#123;P&#125;-relation S containing $R$.</span><br><span class="line">  ii. The intersection of \textsl&#123;P&#125;-relations is a \textsl&#123;P&#125;-relation.</span><br><span class="line">  a. Show that symmetry and transitivity are \texsl&#123;R-closable&#125; for any relation $R$.</span><br><span class="line">  b. Suppose $P$ is \texsl&#123;R-closable&#125;. Then $P(R)$, the \texsl&#123;P-closure&#125; of $R$,</span><br><span class="line">  is the intersection of all \texsl&#123;P&#125;-relations $S$ containing $R$, that is:</span><br><span class="line">  $$</span><br><span class="line">  P(R) = \cap(S | \textrm&#123;S is a P-relation and &#125; R \subseteq S)</span><br><span class="line">  $$</span><br><span class="line"></span><br><span class="line">  \item Consider the \textbf&#123;Z&#125; of integers and an integer $m &gt; 1$.</span><br><span class="line">  We say that $x$ is congruent to $y$ modulo $m$, written</span><br><span class="line">  $$</span><br><span class="line">  x \equiv y (mod m)</span><br><span class="line">  $$</span><br><span class="line">  if $x - y$ is divisible by $m$. Show that this defines an equivalence relation on \textbf&#123;Z&#125;.</span><br><span class="line"></span><br><span class="line">  \item Let A be a set of nonzero integers and let $\sim$ be the relation on $A\tims A$ defined by</span><br><span class="line">  $$</span><br><span class="line">  (a, b) \sim (c, d) \textrm&#123;whenever&#125; ad = bc</span><br><span class="line">  $$</span><br><span class="line">  Prove that $\sim$ is an equivalence relation.</span><br><span class="line"></span><br><span class="line">  \item Prove: Let $R$ be an equivalence relation in a set $A$. Then the quotient set $A/R$ is a partition of A.</span><br><span class="line">  Specifically,</span><br><span class="line">  i.   $\forall a \in A \to a\in [a]$</span><br><span class="line">  ii.  $[a] = [b] \iff (a, b) \in R$</span><br><span class="line">  iii. $[a] \neq [b] \to [a]\cap [b] = \emptyset$</span><br><span class="line"></span><br><span class="line">  \item Prove: Let $\textsc&#123;l&#125;$ be any collection of sets,</span><br><span class="line">  the relation of set inclusion $\subseteq$ a partial order on $\textsc&#123;l&#125;$.</span><br><span class="line"></span><br><span class="line">  \item Suppose $R$ and $S$ are relations on a set $A$, and $R$ is antisymmetric.</span><br><span class="line">  Prove that $R\cap S$ is antisymmetric.</span><br><span class="line"></span><br><span class="line">  \item Prove that if $R$ is an equivalence relation on set $A$, the $R^&#123;-1&#125;$ is also an equivalence relation on $A$.</span><br><span class="line"></span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h1 id="函数与算法"><a href="#函数与算法" class="headerlink"
                                                                                                    title="函数与算法"></a>函数与算法
                  </h1>
                  <h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数
                  </h2>
                  <p>
                    假定对于集合A中的每个元素，我们都惟一地分配集合B的一个元素与之对应，这样的分配称为从A到B的<strong>函数</strong>。
                    集合A称为此函数的<strong>定义域</strong>，集合B称为此函数的<strong>上域</strong>。
                  </p>
                  <p>通常用记号来表示函数，设f表示从A到B的函数，则记：</p>
                  <p>$$<br>f: A \to B<br>$$</p>
                  <p>诗作“f为从A到B的函数”或者“f将A映射到B”。</p>
                  <p>如果a \in
                    A，则f(a)（读作a的f像）表示由f分配给a的B中的惟一的元素，称为a在f下的<em>像值</em>，或者f在a处的值。<br>所有这些像值的集合称为f的
                    <em>值域</em> 或 <em>像</em>。
                    f: A \to 的像记作 Ran(f) 或者 Im(f) 或 f(A).</p>
                  <p>常常使用数学公式表示函数，如：<br>$$<br>f(x) = x^2, x \to x^2，y =
                    x^2<br>$$</p>
                  <p>对于最后一种记法，x称为<strong>自变量</strong>，y称为<strong>因变量</strong>。
                  </p>
                  <h3 id="函数与关系"><a href="#函数与关系" class="headerlink"
                                                                                                    title="函数与关系"></a>函数与关系
                  </h3>
                  <p>每个函数f: A \to B产生一个从A到B的关系，称为<em>f 的图</em>，定义为：<br>$$<br>图 f
                    = {(a, b):
                    a \in
                    A, b = f(a)}<br>$$</p>
                  <p>两个函数f: A \to B 与g: A \to B称为相等，记作 f = g，如果对每个a \in A，有 f(a)
                    =
                    g(a)。<br>也就是说，它们有相同的图。</p>
                  <p><strong>定义3.1</strong> 函数 f: A \to B是一个从A到B的关系（即A \times
                    B的一个子集），使得每个a
                    \in
                    A都属于f的惟一有序偶(a, b)。</p>
                  <h3 id="复合函数"><a href="#复合函数" class="headerlink"
                                                                                                    title="复合函数"></a>复合函数
                  </h3>
                  <p>考虑函数f: A \to B和 g: B \to
                    C，即f的上域就是g的定义域，由此我们可以得到一个新的从A到C的函数，称为f与g的复合函数，记作<br>g \circ
                    f，定义为：<br>$$<br>(g
                    \circ f)(a) \equiv g(f(a))<br>$$</p>
                  <p>对于任意的函数f: A \to B，有<br>$$<br>f \circ l_A = f, l_B \circ f =
                    f<br>$$</p>
                  <p>其中，l_A与l_B分别为A，B上的<strong>恒同函数</strong>。</p>
                  <h2 id="一一的、映上的与可逆的函数"><a href="#一一的、映上的与可逆的函数" class="headerlink"
                                                                                                    title="一一的、映上的与可逆的函数"></a>一一的、映上的与可逆的函数
                  </h2>
                  <p><strong>一一</strong> 函数f: A \to B，如果定义域A中的相异元素具有相异的像，称 f
                    为一一的（记作
                    1-1）。换言之，如果f(a) = f(a’) 蕴含 a = a’，称f是一一的。</p>
                  <p><strong>映上</strong> 函数f: A \to B，如果 B 的每个元素都是 A 的某个元素的像，称f:
                    A -&gt; B
                    为映上的。
                  </p>
                  <p><strong>定理3.1</strong>: 函数f:A \to B是可逆的，当且仅当f既是一一的，又是映上的。
                  </p>
                  <p>如果函数f: A \to B既是一一的，又是映上的，则称f为A与B之间的一个一一对应。</p>
                  <p>一一的函数又称为 <em>单射</em>，映上又称为 <em>满射</em>，一一对应称为 <em>双射</em>。
                  </p>
                  <h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换
                  </h2>
                  <p>一个双射的函数 σ: X → X 被称为 X 上的置换。X上的置换的合成与逆，及 X 上的恒等函数也是 X 上的置换。
                  </p>
                  <h2 id="数学函数、指数函数、对数函数"><a href="#数学函数、指数函数、对数函数" class="headerlink"
                                                                                                    title="数学函数、指数函数、对数函数"></a>数学函数、指数函数、对数函数
                  </h2>
                  <h3 id="上、下取整函数"><a href="#上、下取整函数" class="headerlink"
                                                                                                    title="上、下取整函数"></a>上、下取整函数
                  </h3>
                  <p>x的下取整，表示小于x的最大整数(floor)</p>
                  <p>x的上取整，表示大于x的最小整数(ceil)</p>
                  <h3 id="取整函数和绝对值函数"><a href="#取整函数和绝对值函数" class="headerlink"
                                                                                                    title="取整函数和绝对值函数"></a>取整函数和绝对值函数
                  </h3>
                  <p><strong>取整函数</strong>
                    设x为任意实数，x的取整函数，记作LNT(x)，由删去小数点后的部分将x变为一个整数。</p>
                  <p><strong>绝对值</strong> 字数x的绝对值记作ABS(x) 或 |x|，定义为 x 或 -x
                    中的较大者。</p>
                  <h3 id="余数函数与模算术"><a href="#余数函数与模算术" class="headerlink"
                                                                                                    title="余数函数与模算术"></a>余数函数与模算术
                  </h3>
                  <p>设k为任意整数，M为一个正整数，则<br>$$<br>k \pmod{M}<br>$$</p>
                  <p>（读作k模M）为以M除k的整数余数。即，k(mod M)是唯一的整数r满足：<br>$$<br>k = Mq + r
                    , 0 &lt;= r
                    &lt;
                    M<br>$$</p>
                  <p>mod术语也用于数学中的同余关系，定义如下：<br>$$<br>a \equiv b \pmod{M} 当且仅当 M
                    整除 b -
                    a<br>$$</p>
                  <p>其中M称为模，而 a \equiv b(mod M)
                    读作“a与b模M同余”。以下的同余形式将常常用到。<br>$$<br>0 \equiv
                    M
                    \pmod M, a \pm M \equiv a\pmod{M}<br>$$</p>
                  <h3 id="指数函数"><a href="#指数函数" class="headerlink"
                                                                                                    title="指数函数"></a>指数函数
                  </h3>
                  <h3 id="对数函数"><a href="#对数函数" class="headerlink"
                                                                                                    title="对数函数"></a>对数函数
                  </h3>
                  <p>对数是与指数相关的函数，设b为正整数，任意正数x的以b为底的对数记作</p>
                  <p>$$<br>\log_{b} x<br>$$</p>
                  <p>表示可以得到x的b的指数，即：<br>$$<br>y = \log_{b} x, b^y = x<br>$$</p>
                  <p><strong>常用对数</strong> 以10为底的对数, \log_{10} x, \log x, \lg
                    x<br><strong>自然对数</strong> 以e为底的对数, \log_{e} x, \ln
                    x<br><strong>二进制对数</strong> 以2为底的对数, \log_{2} x</p>
                  <h4 id="指数函数与对数函数的关系"><a href="#指数函数与对数函数的关系" class="headerlink"
                                                                                                    title="指数函数与对数函数的关系"></a>指数函数与对数函数的关系
                  </h4>
                  <p>指数函数与对数函数之间是互逆关系：<br>$$<br>f(x) = b^x, g(x) = \log_{b}
                    x<br>$$</p>
                  <p>他们在图上是关于线性函数 h(x) = x (y = x)对称。所以：</p>
                  <p>g(c) &lt; h(c) &lt; f(c)</p>
                  <h2 id="序列、集合的指标类"><a href="#序列、集合的指标类" class="headerlink"
                                                                                                    title="序列、集合的指标类"></a>序列、集合的指标类
                  </h2>
                  <h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列
                  </h3>
                  <p>从正整数的集合 N = { 1, 2, 3, … } 到另一个集合 A 的函数。用 a_n 表示整数 n
                    的像，于是序列通常表示为：</p>
                  <p>a_1, a_2, a_3, … 或 {a_n: n \in N}， 或简记为 { a_n }</p>
                  <p>有时也以非负整数的集合 { 0, 1, 2, … } 而非 N 作为序列的定义域。在这一情况下，我们说 n 从 0
                    开始而不是从 1 开始。
                  </p>
                  <p><strong>列表</strong> 集合A上的有限序列是一个从 { 1, 2, …, m }
                    到A的函数，通常表示为：</p>
                  <p>a_1, a_2, …, a_m</p>
                  <p>这样的<em>有限</em>序列有时也称为一个 列表 或 m-元组。</p>
                  <h3 id="求和记号与求和"><a href="#求和记号与求和" class="headerlink"
                                                                                                    title="求和记号与求和"></a>求和记号与求和
                  </h3>
                  <p>考虑一个序列 a_1, a_2, a_3, …，则和</p>
                  <p>a_1 + a_2 + … + a_n 与 a_m + a_{m+1} + … + a_n</p>
                  <p>将分别记作：</p>
                  <p>$$<br>\sum_{j = 1}^{n} a_j, \sum_{j = m}^{n} a_j<br>$$</p>
                  <p>在上术表达式中，字母j称为<em>哑指标</em>或<em>哑变量</em>。</p>
                  <h3 id="集合的指标类"><a href="#集合的指标类" class="headerlink"
                                                                                                    title="集合的指标类"></a>集合的指标类
                  </h3>
                  <p>设I为任意非空集合，并设 S 为集族，从 I 到 S 的指标函数为一个函数f: I \to S。对于任意的 i \in
                    I，记A_i表示其
                    像f(i)。
                  </p>
                  <p>于是指标函数 f 通常表示为：</p>
                  <p>{A_i: i \in I} 或简记为 {A_i}</p>
                  <p>集合 I 称为指标集，I 的元素称为指标。<br>如果 f 为一一的 和 映上的，我们就说 S 可以由 I 标出。
                  </p>
                  <p>集合的指标类的并与交定义为：<br>$$<br>\cup_{i \in I} A_i = {x: x \in
                    A，对于某i \in I}
                  </p>
                  <p>\cap_{i \in I} A_i = {x: x \in A，对所有i \in I}<br>$$</p>
                  <p>如果I为有限集，则这恰好是先前定义的并和交。如果I是 N（自然数集），可以分别定义并与交为：</p>
                  <p>$$<br>A_1 \cup A_2 \cup \ldots, A_1 \cap \A_2 \cap
                    \ldots<br>$$</p>
                  <h2 id="递归函数"><a href="#递归函数" class="headerlink"
                                                                                                    title="递归函数"></a>递归函数
                  </h2>
                  <p><strong>递归定义</strong>
                    如果一个函数的定义与其自身有关，则称该函数是递归定义的。<br>为了避免循环定义，函数的递归需要满足以下两个性质：
                  </p>
                  <ol>
                    <li>必须存在一个称为<em>基准值</em>的叙述，不与函数自身相关。</li>
                    <li>在每一个时刻，函数都与自身相关，但函数的描述必须封闭于基准值。</li>
                  </ol>
                  <p>具备这两个性质的递归函数称为<em>良好定义</em>的。</p>
                  <h3 id="阶乘函数"><a href="#阶乘函数" class="headerlink"
                                                                                                    title="阶乘函数"></a>阶乘函数
                  </h3>
                  <p>从 1 到 n 的所有正整数的积称为“n阶乘”，通常记作n!，即：</p>
                  <p>n! = 1 * 2 * 3 … (n - 2) (n - 1) n</p>
                  <p><strong>定义3.2 阶乘函数</strong></p>
                  <pre><code>1. 如果 n = 0，则 n! = 1
2. 如果 n &gt; 0，则 n!= n * (n - 1)!</code></pre>
                  <h3 id="水平数"><a href="#水平数" class="headerlink"
                                                                                                    title="水平数"></a>水平数
                  </h3>
                  <p>
                    设P为一个用来确定f(X)的过程或者递归式，其中f为递归函数，X为输入值。<br>将P的每一步操作联系一个<em>水平数</em>。P的原始操作步骤规定为水平1；由于递归介入，P的每一时刻的操作的水平数都比其递归代入的水平数增加1。<br>递归的深度即获得f(X)的P的最大操作水平数。
                  </p>
                  <h3 id="Fibonacci序列"><a href="#Fibonacci序列" class="headerlink"
                                                                                                    title="Fibonacci序列"></a>Fibonacci序列
                  </h3>
                  <p>Fibonacci序列（通常记作F_0, F_1, F_2，…）如下：</p>
                  <p>$$<br>0, 1, 1, 2, 3, 5, 8, 13, 21, 24, 55, …<br>$$</p>
                  <p>即F_0 = 0, F_1 = 1，以后每一项都是其前面两项的和。</p>
                  <p><strong>定义3.3(Fibonacci序列)</strong><br> 1. 如果 n = 0 或者 n =
                    1，则 F_n =
                    n<br> 2.
                    如果 n &gt; 1，则F_n = F_{n-2} + F_{n-1}</p>
                  <h3 id="Ackermann函数"><a href="#Ackermann函数" class="headerlink"
                                                                                                    title="Ackermann函数"></a>Ackermann函数
                  </h3>
                  <p><strong>定义3.4(Ackermann函数)</strong><br> 1. 如果 m = 0，则 A(m,
                    n) = n +
                    1<br> 2.
                    如果 m != 0 但是 n = 0， 则 A(m, n) = A(m - 1, n)<br> 3. 如果 m != 0
                    且 n != 0, 则
                    A(m,
                    n) = A(m - 1, A(m, n - 1))</p>
                  <p>(条件2 经过递归之后，得到的值为1；条件3的情况较为复杂。)</p>
                  <h3 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数
                  </h3>
                  <p>两个集合A与B称为是 <em>对等</em> 的，或 <em>具有同样多的元素</em>，或
                    <em>具有相同的基数</em>，记作A
                    \simeq
                    B。如果存在一一对应 f: A \to B。</p>
                  <p>集合A称为<em>有限的</em>，如果对于某正整数n，A 与集合 { 1, 2, …, n }
                    具有相同的基数。<br>如果一个集合不是有限的，就称之为<em>无限</em>的。</p>
                  <p>
                    我们将基数简单地看做一种分配给集合的符号，两个集合被分配相同的符号，当且仅当它们具有相同的基数。<br>集合A的基数通常记作
                    |A| 或
                    n(A)，或
                    card(A)。</p>
                  <p>有限集的基数符号是自然（数）的，空集的基数为0；集合 {1, 2, …, n} 的基数为n。<br>于是 |A| =
                    n 当且仅当 A 与
                    {1, 2,
                    …, n} 具有相同的基数，即A含有n个元素。</p>
                  <p>正整数集N的基数为 \aleph_0（读作aleph 0）。<br>于是card(A) = \aleph_0 当且仅当
                    A 与
                    <em>N</em>
                    具有相同的基数。<br>-
                    具有基数 \aleph_0
                    的集合称为<em>可数</em>的或<em>无限可数</em>的。有限集和可数集都称为可数的。</p>
                  <p><strong>定理3.2</strong></p>
                  <p>可数集的可数并仍然是可数的。</p>
                  <p>如果A_1, A_2, …都是可数的，则并集<br>$$<br>A_1 \cup A_2 \cup A_3 \cup
                    \ldots<br>$$<br>也是可数的。</p>
                  <p><strong>定理3.3</strong> 从 0 到 1 的所有字数的集合 I 是不可数的。</p>
                  <h2 id="基数与不等式"><a href="#基数与不等式" class="headerlink"
                                                                                                    title="基数与不等式"></a>基数与不等式
                  </h2>
                  <p>对于任意集合A与B，定义：<br>$$<br>|A| \leq |B|，如果存在一一对应函数 f： A \to
                    B<br>$$</p>
                  <p>同样地：</p>
                  <p>$$<br>|A| \leq |B| \land |A| \neq |B| \implies |A| &lt;
                    |B|<br>$$</p>
                  <p><strong>定理3.4 (Cantor)</strong></p>
                  <p>对于任意集合A，有<br>$$<br>|A| &lt;
                    |Power(A)|<br>$$<br>（其中，Power(A)为A的幂集，即A的全体子集族）。
                  </p>
                  <p><strong>定理3.5 (Schroeder-Bernstein)</strong></p>
                  <p>对于集合A和B：<br>$$<br>|A| \leq |B| \land |B| \leq |A| \implies
                    |A| =
                    |B|<br>$$
                  </p>
                  <h2 id="算法与函数"><a href="#算法与函数" class="headerlink"
                                                                                                    title="算法与函数"></a>算法与函数
                  </h2>
                  <p>算法M是求解一个特定问题的有限个良好定义的相继步骤的列表。</p>
                  <p>通常可以有不止一种方法求f(X)。获得f(X)的算法M的选择依赖于算法的“效率”和“复杂性”。</p>
                  <h2 id="算法的复杂性"><a href="#算法的复杂性" class="headerlink"
                                                                                                    title="算法的复杂性"></a>算法的复杂性
                  </h2>
                  <p>算法的复杂性是算法效率的衡量标准。</p>
                  <p>假设 M 是一种算法，并设 n
                    为输入数据的规模。实施M所占用的时间和空间是衡量该算法之效率的两个主要指标。<br>时间由“键盘操作”次数衡量。</p>
                  <p>比如：</p>
                  <pre><code>1. 对于排序和查找，对 比较次数 计数
2. 在计算中，对乘法计数而忽略加法</code></pre>
                  <p>键盘操作的定义前提是其他操作时间大大小于或 最多与键盘操作时间成比例。<br>空间由实施该算法所需的最大内存来衡量。
                  </p>
                  <p>算法 M 的复杂性是一个函数
                    f(n)，它对于输入数据的规模n给出运行该算法所需时间与所需存储空间。<br>执行一个算法所需存储空间通常就是数据规模的倍数。<br>因此，除非特殊情况，“复杂性”将指运行算法的时间。
                  </p>
                  <p>求 复杂性函数f(n) 在复杂性理论中研究最多的两种情况是：</p>
                  <pre><code>1. 最坏情况 对于任何可能的输入，f(n)的最大值
2. 平均情况 f(n)的期望值</code></pre>
                  <h3 id="线性查找"><a href="#线性查找" class="headerlink"
                                                                                                    title="线性查找"></a>线性查找
                  </h3>
                  <p>
                    给定一个包含n个元素的线性数组DATA，和一个特定的信息ITEM，<br>在数组DATA中求出ITEM的位置LOC，或者传送某个信息，比如LOC
                    = 0
                    表示ITEM不出现DATA中。<br>线性查找算法解决这个问题的途径是将ITEM与DATA中的元素一个一个地进行比较，直到求出LOC为止。
                  </p>
                  <p>线性查找算法的复杂性由ITEM与DATA[K]之间的比较数字C给出。<br>C(n)的最坏情况和平均情况如下：</p>
                  <pre><code>1. **最坏情况** C(n) = n；

2. **平均情况** C(n) = (n + 1) / 2</code></pre>
                  <h3 id="增长率与大O记号"><a href="#增长率与大O记号" class="headerlink"
                                                                                                    title="增长率与大O记号"></a>增长率与大O记号
                  </h3>
                  <p>
                    假定M是一个算法，并设n为输入数据的大小，显示M的复杂性f(n)随着n的增长而增长。通常我们需要考察的是f(n)的增长率。<br>常常由f(n)与某标准函数相比较而得。假如：<br>$$<br>\log_{2}
                    n, n, n \log_{2} n, n^2, n^3, 2^n<br>$$</p>
                  <p>等等，都可被用作为标准函数。<br>（对数函数 \log_2 n 增长最慢，而指数函数 2^n 增长最快）</p>
                  <p><strong>定义</strong>
                    设f(x)与g(x)为定义于R或者R的子集上的任意两个函数，我们说“f(x)与g(x)同阶”，记作：
                  </p>
                  <p>$$<br>f(x) = O(g(x))<br>$$</p>
                  <p>如果存在字数 k 和正常如C使得对于所有的x &gt; k有：</p>
                  <p>$$<br>|f(x)| \leq C|g(x)|<br>$$</p>
                  <p>同样地，当f(x) - h(x) = O(g(x))时，记：</p>
                  <p>$$<br>f(x) = h(x) + O(g(x))<br>$$</p>
                  <h3 id="常见算法的复杂性"><a href="#常见算法的复杂性" class="headerlink"
                                                                                                    title="常见算法的复杂性"></a>常见算法的复杂性
                  </h3>
                  <p>计算机科学中一些著名的查找和排序算法的复杂性</p>
                  <ol>
                    <li>线性查找：O(n)</li>
                    <li>二叉查找：O(\log n)</li>
                    <li>冒泡排序：O(n^2)</li>
                    <li>归并排序：O(n \log n)<h1 id="附录-2"><a href="#附录-2" class="headerlink"
                                                                                                        title="附录"></a>附录
                      </h1>
                    </li>
                  </ol>
                  <h2 id="术语-2"><a href="#术语-2" class="headerlink"
                                                                                                    title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>函数 function<ul>
                        <li>定义域 domain</li>
                        <li>上域 codomain, target set</li>
                        <li>值域 range</li>
                        <li>像 image</li>
                        <li>变量 variable</li>
                        <li>自变量 independent variable</li>
                        <li>因变量 dependent variable</li>
                      </ul>
                    </li>
                    <li>函数的图 graph of function</li>
                    <li>复合函数 composition function</li>
                    <li>一一 one-to-one</li>
                    <li>单射 injective</li>
                    <li>映上 onto</li>
                    <li>满射 surjective</li>
                    <li>可逆 invertible</li>
                    <li>一一对应 one-to-one correspondence</li>
                    <li>双射 bijectice</li>
                    <li>置换 permutation</li>
                    <li>恒等函数 identity function</li>
                    <li>数学函数 mathematical function<ul>
                        <li>上、下取整函数 floor and ceiling function</li>
                        <li>实数转整数函数 interger function</li>
                        <li>绝对值函数 absolute value function</li>
                        <li>取余函数 remainder function</li>
                        <li>同余函数 modular arithmetic</li>
                        <li>指数函数 exponential function</li>
                        <li>对数函数 logarithmic function<ul>
                            <li>常用对数 common logarithm</li>
                            <li>自然对数 natural logarithm</li>
                            <li>二进制对数 binary logarithm</li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li>求和 sums</li>
                    <li>求和记号 summation symbol</li>
                    <li>哑变量 dummy index, dummy variable</li>
                    <li>序列 seqeunce<ul>
                        <li>有限序列 finite sequence</li>
                        <li>列表 list</li>
                        <li>m-元组 m-tuple</li>
                      </ul>
                    </li>
                    <li>集合的指标类 indexed classes of sets<ul>
                        <li>指标函数 indexing function</li>
                        <li>指标集 indexing set</li>
                        <li>指标 index</li>
                      </ul>
                    </li>
                    <li>递归函数 recursively defined function<ul>
                        <li>基准值 base value</li>
                        <li>良好定义 well-defined</li>
                        <li>阶乘函数 factorial function</li>
                        <li>水平数 level number</li>
                        <li>Fibonacci 序列 Fibonacci Sequence</li>
                        <li>Ackermann 函数 Ackermann Function</li>
                      </ul>
                    </li>
                    <li>基数 cardinality<ul>
                        <li>对等 equipotent</li>
                        <li>可数 denumerable</li>
                        <li>无限可数 countably infinite</li>
                        <li>可数 countable</li>
                        <li>有限集 finite set</li>
                        <li>可数集 countable set</li>
                        <li>不等式 inequality</li>
                        <li>基数 cardinal numbers</li>
                      </ul>
                    </li>
                    <li>算法 algorithm</li>
                    <li>多项式求值 polynomial evaluation</li>
                    <li>多项式直接求值法 direct method</li>
                    <li>多项式Horner求值法（综合除法）Horner’s Method, Synthetic Division
                    </li>
                    <li>最大公约数 greatest common divisor</li>
                    <li>最大公约数 直接求值法 Direct Method</li>
                    <li>最大公约数 带余除法 Euclidean Algorithm</li>
                    <li>算法的复杂性 complexity of algorithms</li>
                    <li>线性查找 linear search</li>
                    <li>worst case</li>
                    <li>average case</li>
                    <li>增长率 rate of growth</li>
                    <li>大O记号 Big O Notation</li>
                    <li>函数同阶 f is of order g</li>
                  </ul>
                  <h3 id="exercise-1"><a href="#exercise-1" class="headerlink"
                                                                                                    title="exercise"></a>exercise
                  </h3>
                  <p>ackermann.h</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">#ifndef _ACKERMANN_H</span><br><span class="line">#define _ACKERMANN_H</span><br><span class="line"></span><br><span class="line">int ackermann(unsigned int m, unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">  if (m == 0)</span><br><span class="line">    return n + 1;</span><br><span class="line">  if (n == 0)</span><br><span class="line">    return ackermann(m - 1, n);</span><br><span class="line"></span><br><span class="line">  return ackermann(m - 1, ackermann(m, n - 1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <p>test.c</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;ackermann.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%d\n&quot;, ackermann(16, 19));</span><br><span class="line">  // 16, 19</span><br><span class="line">  // 运行时间长，最后结果 20</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h3 id="exercise-tex"><a href="#exercise-tex" class="headerlink"
                                                                                                    title="exercise.tex"></a>exercise.tex
                  </h3>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">  \usepackage&#123;amsmath&#125;</span><br><span class="line">  \usepackage&#123;amssymb&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item Consider permutaion</span><br><span class="line">  $\sigma = \bigl(\begin&#123;smallmatrix&#125;</span><br><span class="line">    1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\ 3 &amp; 6 &amp; 4 &amp; 5 &amp; 1 &amp; 2</span><br><span class="line">    \end&#123;smallmatrix&#125; \bigr)$</span><br><span class="line">  and $\tau = \bigl(\begin&#123;smallmatrix&#125;</span><br><span class="line">    1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\ 2 &amp; 4 &amp; 6 &amp; 5 &amp; 3 &amp; 1</span><br><span class="line">    \end&#123;smallmatrix&#125; \bigr)$ in $S_6$.</span><br><span class="line"></span><br><span class="line">    Find: i. composition $\tau \circ \sigma$, ii. $\sigma^&#123;-1&#125;$.</span><br><span class="line"></span><br><span class="line">    \item Consider functions $f: A\to B$ and $g: B\to C$. Prove the following:</span><br><span class="line"></span><br><span class="line">    a. If $f$ and $g$ are one-to-one, then $g\circ f$ is one-to-one.</span><br><span class="line"></span><br><span class="line">    b. If $f$ and $g$ are onto functions, then $g\circ f$ is an onto function.</span><br><span class="line"></span><br><span class="line">    \item Prove the following generalization of DeMorgan&apos;s law: For any class of sets $\&#123;A_i\&#125;$ we have</span><br><span class="line">    $$</span><br><span class="line">    (\cup_i A_i)^\mathsf&#123;c&#125; = \cap_i A_i^\mathsf&#123;c&#125;</span><br><span class="line">    $$</span><br><span class="line"></span><br><span class="line">    \item Show that the set $\textbf&#123;Z&#125;$ of integers has cardinality $\aleph_0$.</span><br><span class="line"></span><br><span class="line">    \item Let $A_1, A_2, \cdots$ be a countable number of finite sets.</span><br><span class="line">    Prove that the union $S = \cup_i S_i$ is countable.</span><br><span class="line"></span><br><span class="line">    \item Prove: A countable union of countable sets is countable.</span><br><span class="line"></span><br><span class="line">    \item Prove: The set $\textbf&#123;I&#125;$ of all real numbers between 0 and 1 inclusive is uncountable.</span><br><span class="line"></span><br><span class="line">    \item For any $n \in \textbf&#123;N&#125;$, let $D_n = (0, 1/n)$, the open iterval from $0$ to $1/n$. Find:</span><br><span class="line"></span><br><span class="line">    i. $D_3 \cup D_4$, ii. $D_3 \cup D_20$, iii. $D_s \cup D_t$, iv. $D_s \cup D_t$</span><br><span class="line"></span><br><span class="line">    \item Suppose $P(n) = a_0 + a_1 n + a_2 n^2 + \cdots + a_m n^m$ has degree $m$. Prove $P(n) = O(n^m)$</span><br><span class="line"></span><br><span class="line">    \item Prove: $|A| &lt; |\textrm&#123;Power&#125;(A)|$ (where $\textrm&#123;Power&#125;(A)$ is the power set of $A$).</span><br><span class="line"></span><br><span class="line">    \item Prove the following equivalent formulation of the Schroeder-Bernstein Theorem:</span><br><span class="line"></span><br><span class="line">    Suppose $X\supseteq Y \supseteq X_1$ and $X\simeq X_1$, then $X\simeq Y$.</span><br><span class="line"></span><br><span class="line">    \item Prove: Suppose $f: A \to B$ and $g: B \to A$ satisfy $g\circ f = 1_A$. Then $f$ is one-to-one and $g$ is onto.</span><br><span class="line"></span><br><span class="line">    \item Prove: A function $f: A\to B$ is invertible if and only if $f$ is both one-to-one and onto.</span><br><span class="line"></span><br><span class="line">    \item Prove: Suppose $f: A\to B$ is invertible with inverse function $f^&#123;-1&#125;: B\to A$.</span><br><span class="line">    Then $f^&#123;-1&#125;\circ f = 1_A$ and $f\circ f^&#123;-1&#125; = 1_B$.</span><br><span class="line"></span><br><span class="line">    \item Suppose $f: A\to B$ is one-to-one and $g: A\to B$ is onto. Let $x$ be a subset of $A$.</span><br><span class="line"></span><br><span class="line">    i. Show $f 1_x$, the restriction of $f$ to $x$, is one-to-one.</span><br><span class="line"></span><br><span class="line">    ii. Show $g 1_x$, need not be onto.</span><br><span class="line"></span><br><span class="line">    \item For each $n \in N$, consider the open interval $A_n = (0, 1/n) = \&#123;x | 0 &lt; x &lt; 1/n\&#125;$. Find:</span><br><span class="line"></span><br><span class="line">    a. $A_2 \cup A_8$; c. $\cup(A_i | i \in J)$; e. $\cup(A_i | i \in K)$;</span><br><span class="line"></span><br><span class="line">    b. $A_3 \cap A_7$; d. $\cap(A_i | i \in J)$; f. $\cap(A_i | i \in K)$;</span><br><span class="line"></span><br><span class="line">    where $J$ is a finite subset of $\textbf&#123;N&#125;$ and $K$ is an infinite subset of $\textbf&#123;N&#125;$.</span><br><span class="line"></span><br><span class="line">    \item Consider an indexed class of sets $\&#123;A_i | i \in I\&#125;$, a set $\textbf&#123;B&#125;$ and an index $i_0$ in $\textbf&#123;I&#125;$.</span><br><span class="line"></span><br><span class="line">    Prove: a. $B\cap (\cup_i A_i) = \cup_i(B\cap A_i)$;</span><br><span class="line">    b. $\cap(A_i | i \in I)\subseteq A_&#123;i_0&#125; \subseteq \cup (A_i | i \in I)$</span><br><span class="line"></span><br><span class="line">    \item Prove:</span><br><span class="line"></span><br><span class="line">    a. Every infinite set $A$ contains a denumerable subset $D$.</span><br><span class="line"></span><br><span class="line">    b. Each subset of a denumerable set is finite or denumerable.</span><br><span class="line"></span><br><span class="line">    c. If $A$ and $B$ are denumerable, then $A\times B$ is denumerable.</span><br><span class="line"></span><br><span class="line">    d. The set $\textbf&#123;Q&#125;$ of rational numbers is denumerable.</span><br><span class="line"></span><br><span class="line">    \item Prove: a. $|A\times B| = |B\times A|$;</span><br><span class="line">    b. $A\subseteq B \implies |A| \leq |B|$;</span><br><span class="line">    c. $|A| = |B| \implies |P(A)| = |P(B)|$.</span><br><span class="line"></span><br><span class="line">    \item Prove: The set $P$ of all polynomial $p(x) = a_0 + a_1 x + \cdots + a_m x^m $</span><br><span class="line">    with integral coefficients(that is, where $a_0, a_1, \cdots, a_m$ are integers) is denumerable.</span><br><span class="line">  \end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h1 id="逻辑与命题演算"><a href="#逻辑与命题演算" class="headerlink"
                                                                                                    title="逻辑与命题演算"></a>逻辑与命题演算
                  </h1>
                  <h2 id="要点难点"><a href="#要点难点" class="headerlink"
                                                                                                    title="要点难点"></a>要点难点
                  </h2>
                  <ul>
                    <li>命题表达式与真值表</li>
                    <li>逻辑等价</li>
                    <li>论证与命题函数</li>
                  </ul>
                  <h2 id="命题与复合命题"><a href="#命题与复合命题" class="headerlink"
                                                                                                    title="命题与复合命题"></a>命题与复合命题
                  </h2>
                  <h3 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题
                  </h3>
                  <p>
                    <strong>命题</strong>（或<strong>陈述</strong>）是一个说明性语句，它只能是真或假，不可能两者同时成立。
                  </p>
                  <h2 id="复合命题"><a href="#复合命题" class="headerlink"
                                                                                                    title="复合命题"></a>复合命题
                  </h2>
                  <p><strong>复合命题</strong> 由<em>子命题</em>及它们之间的各种联系组成的命题称为复合命题。
                  </p>
                  <p><strong>原子命题</strong> 不能被分解为更简单的命题（非复合命题）称为原子命题</p>
                  <h2 id="基本逻辑运算"><a href="#基本逻辑运算" class="headerlink"
                                                                                                    title="基本逻辑运算"></a>基本逻辑运算
                  </h2>
                  <p><strong>合取联结</strong></p>
                  <p>任何两个命题可以用术语“与”联合而成一个复合命题，叫做这两个原始命题的合取联结。记作：</p>
                  <p>$$<br>p \land q<br>$$</p>
                  <p>读作“p与q”，表示p与q的合取联结。</p>
                  <p><strong>定义4.1</strong> 如果p与q均为真，则p \land q 为真；否则 p \land
                    q为假。</p>
                  <p><strong>析取联结</strong></p>
                  <p>任何两个命题可以用术语“或”联合而成一个复合命题，叫做这两个原始命题的析取联结。记作：</p>
                  <p>$$<br>p \lor q<br>$$</p>
                  <p>读作“p 或 q”，表示p 与 q的析取联结。</p>
                  <p><strong>定义4.2</strong> 如果p与q均为假，则 p \lor q 为假；否则p \lor q为真。
                  </p>
                  <h3 id="否定联结-lnot-p"><a href="#否定联结-lnot-p" class="headerlink"
                                                                                                    title="否定联结, \lnot p"></a>否定联结,
                    \lnot p</h3>
                  <p>给定任一命题p，都可以通过在p前面添加“不是”或“假”或在p前面插入“非”，得到另一个命题，称为p的否定联结，记作：
                  </p>
                  <p>$$<br>\lnot p<br>$$</p>
                  <p>读作“非p”，表示p的否定联结。</p>
                  <p><strong>定义4.3</strong> 如果p为真，则 \lnot p 为假；如果p为假，则 \lnot p
                    为真。</p>
                  <h2 id="命题与真值表"><a href="#命题与真值表" class="headerlink"
                                                                                                    title="命题与真值表"></a>命题与真值表
                  </h2>
                  <p><strong>命题表达式</strong></p>
                  <p>设 P(p, q, …)为一个由取值为真(T)或假(F)的逻辑变量p, q, … 以及逻辑联结 \land,
                    \lor, \lnot
                    构成的表达式。<br>这样的表达式P(p, q, …)称为一个命题。</p>
                  <p><strong>逻辑联结的规定优先级</strong> 规定：</p>
                  <p>$$<br>\lnot 优先于 \land 优先于 \lor<br>$$</p>
                  <h3 id="构造真值表的另一种方法"><a href="#构造真值表的另一种方法" class="headerlink"
                                                                                                    title="构造真值表的另一种方法"></a>构造真值表的另一种方法
                  </h3>
                  <h2 id="永真命题与永假命题"><a href="#永真命题与永假命题" class="headerlink"
                                                                                                    title="永真命题与永假命题"></a>永真命题与永假命题
                  </h2>
                  <p><strong>永真命题</strong> 对于变量的任意值，都为真的命题。</p>
                  <p><strong>永假命题</strong> 对于变量的任意做，都为假的命题。</p>
                  <p><strong>定理4.1（代入原理）</strong> 若P(p, q,
                    …)是永真命题，<br>则对任意命题P_1, P_2, …,
                    命题P(P_1,
                    P_2, …)仍然是永真命题。</p>
                  <h2 id="逻辑等价"><a href="#逻辑等价" class="headerlink"
                                                                                                    title="逻辑等价"></a>逻辑等价
                  </h2>
                  <p>两个命题P(p, q, …) 与 Q(p, q,
                    …)如果具有<em>相同的真值表</em>，则称为<em>逻辑等价</em>的，或简称为<em>等价</em>或<em>相等</em>，记作：
                  </p>
                  <p>$$<br>P(p, q, …) \equiv Q(p, q, ..)<br>$$</p>
                  <p>例如：<br>$$<br>\lnot (p \land q) \equiv \lnot p \land \lnot
                    q<br>$$</p>
                  <h2 id="命题代数"><a href="#命题代数" class="headerlink"
                                                                                                    title="命题代数"></a>命题代数
                  </h2>
                  <p><strong>定理4.2</strong> 命题满足如下定律：</p>
                  <pre><code>1. 幂等律</code></pre>
                  <p>$$<br> p \lor p \equiv p<br>$$<br>$$<br> p \land p \equiv
                    p<br>$$</p>
                  <pre><code>2. 结合律</code></pre>
                  <p>$$<br> (p \lor q) \lor r \equiv p lor (q \lor
                    r)<br>$$<br>$$<br> (p
                    \land q)
                    \and r \equiv p \land (q \land r)<br>$$</p>
                  <pre><code>3. 交换律</code></pre>
                  <p>$$<br> p \lor q \equiv q \lor p<br>$$<br>$$<br> p \land q
                    \equiv q
                    \land
                    p<br>$$</p>
                  <pre><code>4. 分配律</code></pre>
                  <p>$$<br> p \lor (q \land r) \equiv (p \lor q) \and (p \lor
                    r)<br>$$<br>$$<br> p
                    \land (q \lor r) \equiv (p \land q) \lor (p \land r)<br>$$
                  </p>
                  <pre><code>5. 同一律</code></pre>
                  <p>$$<br> p \land T \equiv p, p \lor F \equiv
                    p<br>$$<br>$$<br> p \lor T
                    \equiv
                    T, p \land F \equiv F<br>$$</p>
                  <pre><code>6. 互补律</code></pre>
                  <p>$$<br> p \lor \lnot p \equiv T, p \land \lnot p \equiv
                    F<br>$$<br>$$<br>
                    \lnot T \equiv F, \lnot F \equiv T<br>$$</p>
                  <pre><code>7. 对合律</code></pre>
                  <p>$$<br> \lnot \lnot p \equiv p<br>$$</p>
                  <pre><code>8. DeMorgan律</code></pre>
                  <p>$$<br> \lnot(p \lor q) \equiv \lnot p \land \lnot
                    q<br>$$<br>$$<br>
                    \lnot(p
                    \land q) \equiv \lnot p \lor lnot q<br>$$</p>
                  <h2 id="条件语句与双条件语句"><a href="#条件语句与双条件语句" class="headerlink"
                                                                                                    title="条件语句与双条件语句"></a>条件语句与双条件语句
                  </h2>
                  <p><strong>条件语句</strong> 具有形式“如果p则q”的语句称为条件语句。记作：</p>
                  <p>$$<br>p \implies q<br>$$</p>
                  <p>常读作“p蕴含q”或者“仅当q时有p”。</p>
                  <p><strong>真值表</strong></p>
                  <table>
                    <thead>
                      <tr>
                        <th>p</th>
                        <th>q</th>
                        <th>p \implies q</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>T</td>
                        <td>T</td>
                        <td>T</td>
                      </tr>
                      <tr>
                        <td>T</td>
                        <td>F</td>
                        <td>F</td>
                      </tr>
                      <tr>
                        <td>F</td>
                        <td>T</td>
                        <td>T</td>
                      </tr>
                      <tr>
                        <td>F</td>
                        <td>F</td>
                        <td>T</td>
                      </tr>
                    </tbody>
                  </table>
                  <p>（为何 (F, F) = T ？）</p>
                  <p><strong>双条件语句</strong>
                    具有形式“p当且仅当q”的语句称为双条件语句。记作：<br>$$<br>p \iff
                    q<br>$$</p>
                  <table>
                    <thead>
                      <tr>
                        <th>p</th>
                        <th>q</th>
                        <th>p \iff q</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>T</td>
                        <td>T</td>
                        <td>T</td>
                      </tr>
                      <tr>
                        <td>T</td>
                        <td>F</td>
                        <td>F</td>
                      </tr>
                      <tr>
                        <td>F</td>
                        <td>T</td>
                        <td>F</td>
                      </tr>
                      <tr>
                        <td>F</td>
                        <td>F</td>
                        <td>T</td>
                      </tr>
                      <tr>
                        <td>## 论证</td>
                        <td></td>
                        <td></td>
                      </tr>
                    </tbody>
                  </table>
                  <p>论证是一个断言，是从称为<em>前提</em>的给定命题集合 P_1, P_2, …,
                    P_n推出称为<em>结论</em>的另一个命题Q的过程。<br>这样的论证记作：<br>$$<br>P_1, P_2,
                    …, P_n
                    \vdash
                    Q<br>$$</p>
                  <p><strong>定义4.4</strong> 有效论证</p>
                  <p>一个论证P_1，P_2，…，P_n \vdash Q 称为有效的，如果前提 P_1，P_2，…，P_n 为真则 Q
                    为真。</p>
                  <p>无效的论证称为<em>谬误</em>。</p>
                  <p><strong>拆分律</strong></p>
                  <p>$$<br>p, p \implies q \vdash q<br>$$</p>
                  <p><strong>定理4.3</strong> 论证 (P_1, P_2, …, P_n)\vdash Q
                    有效当且仅当命题 (P_1,
                    P_2, …,
                    P_n) \implies Q 是一个永真命题。</p>
                  <h3 id="三段论律"><a href="#三段论律" class="headerlink"
                                                                                                    title="三段论律"></a>三段论律
                  </h3>
                  <p>$$<br>p \implies q, q \implies r \vdash p \implies r<br>$$
                  </p>
                  <p>即
                    $$<br>[(p \implies q) \land (q \implies r)] \implies (p
                    \implies
                    r)<br>$$<br>是一个永真命题。</p>
                  <h2 id="逻辑蕴含"><a href="#逻辑蕴含" class="headerlink"
                                                                                                    title="逻辑蕴含"></a>逻辑蕴含
                  </h2>
                  <p>称命题 P(p, q, …) 逻辑蕴含命题Q(p, q, …)记作</p>
                  <p>$$<br>P(p, q, …) \implies Q(p, q, …)<br>$$</p>
                  <p>即若 P(p, q, …)为真，必有 Q(p, q, …)为真。</p>
                  <p><strong>定理4.4</strong> 对论任意的命题P(p, q, …)与Q(p, q,
                    …)下列三个陈述等价：</p>
                  <ol>
                    <li>P(p, q, …)逻辑蕴含 Q(p, q, …)</li>
                    <li>论证 P(p, q, …) \vdash Q(p, q, …)有效</li>
                    <li>命题P(p, q, …) \implies Q(p, q, …) 是一个永真命题</li>
                  </ol>
                  <h2 id="命题函数，量词"><a href="#命题函数，量词" class="headerlink"
                                                                                                    title="命题函数，量词"></a>命题函数，量词
                  </h2>
                  <p>
                    设A为一个给定集合，定义于A上的一个命题函数（或称为<em>开放语句</em>或<em>开放条件</em>）是一个表达式
                  </p>
                  <p>$$<br>p(x)<br>$$</p>
                  <p>满足对每个a \in A，p(a) 为真或为假，即以俚语的a \in A
                    向x赋值时，p(x)都成为一个陈述（具有其真值）。</p>
                  <p>集合A称为p(x)的定义域，而A中所有使得p(a)为真的元素的集合T_p称为p(x)的真集。换句话说，</p>
                  <p>$$<br>T_p = {x: x \in A, p(x) 为真} 或 T_p = {x: p(x)}<br>$$
                  </p>
                  <p>当A为数的集合时，条件p(x)通常是一个关于变量x的等式或不等式方程。</p>
                  <h3 id="全称量词"><a href="#全称量词" class="headerlink"
                                                                                                    title="全称量词"></a>全称量词
                  </h3>
                  <p>设p(x)为定义于集合A上的命题函数，考虑表达式：<br>$$<br>(\forall x \in A)
                    p(x)<br>$$</p>
                  <p>读作“对A中的每个x，p(x)为真语句”。</p>
                  <p>符号\forall 读作“对所有”或“对每个”，称为<strong>全称量词</strong>。
                    以上表达式等价于：<br>$$<br>T_p = {x: x \in A, p(x) } = A<br>$$</p>
                  <p>即 p(x) 的真集是整个A。</p>
                  <h3 id="存在量词"><a href="#存在量词" class="headerlink"
                                                                                                    title="存在量词"></a>存在量词
                  </h3>
                  <p>设p(x)为定义于集合A上的一个命题函数，考虑表达式</p>
                  <p>$$<br>(\exists x \in A)p(x)<br>$$</p>
                  <p>读作“在A中存在x使得p(x)为真语句”。</p>
                  <p>记号\exists 读作“存在”，或“对某个”，或“对于至少一个”。叫做<strong>存在量词</strong>。
                  </p>
                  <p>以上陈述等价于：</p>
                  <p>$$<br>T_p = {x: x \in A, p(x)} \neq \emptyset<br>$$</p>
                  <p>即p(x)的真集非空。特别地：</p>
                  <p> Q_2: 如果{x: p(x)} \neq \emptyset，则 \exists x,
                    p(x)为真；否则\exists x,
                    p(x)为假。</p>
                  <h2 id="量词语句的否定"><a href="#量词语句的否定" class="headerlink"
                                                                                                    title="量词语句的否定"></a>量词语句的否定
                  </h2>
                  <p><strong>定理4.5（DeMorgan）</strong><br>$$<br>\lnot (\forall x
                    \in A)p(x)
                    \equiv
                    (\exists x \in A)\lnot p(x)<br>$$<br>即以下两个语句等价：</p>
                  <ol>
                    <li>对所有的a \in A，p(a)为真是不对的。</li>
                    <li>存在 a \in A，使得p(a)为假。</li>
                  </ol>
                  <p><strong>定理4.6（DeMorgan）</strong><br>$$<br>\lnot(\exists x
                    \in A)p(x)
                    \equiv
                    (\forall x \in A) \lnot p(x)<br>$$<br>即以下两个语句等价：</p>
                  <ol>
                    <li>对某个a \in A，p(a)为真 是不对的</li>
                    <li>所有a \in A，p(a)为假</li>
                  </ol>
                  <p><strong>反例</strong></p>
                  <p>存在元素 x_0，使得p(x_0)为假，x_0 称为 \forall x, p(x)的一个反例。</p>
                  <h3 id="含有多个变量的命题函数"><a href="#含有多个变量的命题函数" class="headerlink"
                                                                                                    title="含有多个变量的命题函数"></a>含有多个变量的命题函数
                  </h3>
                  <p><strong>基本原理</strong> 对其每个变量冠以量词后的命题函数为一个语句并且具有真值。</p>
                  <p>$$<br>\forall x \exists y, p(x,y)<br>$$</p>
                  <p>或</p>
                  <p>$$<br>\exists x \exists y \exists z, p(x, y,
                    z)<br>$$<br>为具有真值的语句。</p>
                  <h3 id="多变量的否定量词语句"><a href="#多变量的否定量词语句" class="headerlink"
                                                                                                    title="多变量的否定量词语句"></a>多变量的否定量词语句
                  </h3>
                  <p>获得多变量否定量词语句的具体做法是：</p>
                  <p>将否定符号从左向右移动，同时将每个\forall 换成\exists 而将每个\exists 换成 \forall。
                  </p>
                  <h1 id="附录-3"><a href="#附录-3" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <h2 id="术语-3"><a href="#术语-3" class="headerlink"
                                                                                                    title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>命题</li>
                    <li>复合命题</li>
                    <li>子命题</li>
                    <li>原子命题</li>
                    <li>逻辑联结</li>
                    <li>合取联结</li>
                    <li>析取联结</li>
                    <li>否定联结</li>
                    <li>命题表达式</li>
                    <li>真值表</li>
                    <li>逻辑变量</li>
                    <li>永真命题</li>
                    <li>永假命题</li>
                    <li>代入原理</li>
                    <li>逻辑等价</li>
                    <li>命题代数</li>
                    <li>条件语句</li>
                    <li>双条件语句</li>
                    <li>论证</li>
                    <li>逻辑论证</li>
                    <li>有效论证</li>
                    <li>谬误</li>
                    <li>陈述</li>
                    <li>三段论</li>
                    <li>逻辑蕴含</li>
                    <li>命题函数</li>
                    <li>量词</li>
                    <li>全称量词</li>
                    <li>存在量词</li>
                  </ul>
                  <h3 id="exercise-tex-1"><a href="#exercise-tex-1" class="headerlink"
                                                                                                    title="exercise.tex"></a>exercise.tex
                  </h3>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">  \usepackage&#123;amsmath&#125;</span><br><span class="line">  \usepackage&#123;amssymb&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item Verify that the proposition $p\lor \lnot (p\land q)$ is a tautology.</span><br><span class="line"></span><br><span class="line">  \item Show that the proposition $\lnot(p \land q)$ and $\lnot p\lor \lnot q$ are logically equivalent.</span><br><span class="line"></span><br><span class="line">  \item Prove that $\lnot (p \land q)\lor (\lnot q \land q)\equiv \lnot p$.</span><br><span class="line"></span><br><span class="line">  \item Consider the conditional proposition $p\to q$. The simple propositions $q\to p, \lnot p \to \lnot q$</span><br><span class="line">  and $\lnot q \to \lnot p$ are called, respectively, the \textsl&#123;converse&#125;, \textsf&#123;inverse&#125;,</span><br><span class="line">  and \textsl&#123;contrapositive&#125; of the conditional $p \to q$. Which of these are logically equivalent to $p \to q$?</span><br><span class="line"></span><br><span class="line">  \item Show that the following argument is a fallacy: $p \to q$, $\lnot p \vdash \lnot q$.</span><br><span class="line"></span><br><span class="line">  \item Determine the validity of the following argument: $p \to q, \lnot p \vdash \lnot q$.</span><br><span class="line"></span><br><span class="line">  \item Prove the following argument is valid: $p \to \lnot q, r \to q, r\vdash \lnot p$.</span><br><span class="line"></span><br><span class="line">  \item Negate each of the following statements:</span><br><span class="line"></span><br><span class="line">  i. $\exists x\ \forall y, p(x, y)$;</span><br><span class="line">  ii. $\forall x\ \forall y, p(x, y)$;</span><br><span class="line">  iii. $\exists x\ \exists y\ \exists z, p(x, y, z)$.</span><br><span class="line"></span><br><span class="line">  \item Find the truth tables for: i. $p\lor \lnot q$; ii. $\lnot p \land \lnot q$.</span><br><span class="line">  \item Verify that the proposition $(p\land q)\land \lnot (p \lor q)$ is a contradition.</span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h1 id="向量与矩阵"><a href="#向量与矩阵" class="headerlink"
                                                                                                    title="向量与矩阵"></a>向量与矩阵
                  </h1>
                  <h2 id="要点难点-1"><a href="#要点难点-1" class="headerlink"
                                                                                                    title="要点难点"></a>要点难点
                  </h2>
                  <ul>
                    <li>
                      <p>矩阵初等行变换</p>
                    </li>
                    <li>
                      <p>高斯消去法</p>
                    </li>
                    <li>
                      <p>矩阵求解n元一次方程组的解</p>
                      <h2 id="向量"><a href="#向量" class="headerlink"
                                                                                                        title="向量"></a>向量
                      </h2>
                    </li>
                  </ul>
                  <p>向量 u 是指一列数，如 a_1, a_2, …, a_n，记作</p>
                  <p>$$<br>u = (a_1, a_2, a_3)<br>$$</p>
                  <p>数a_i称为 u 的 <em>分量</em> 或 表值。</p>
                  <p>如果所有的 a_i = 0，则称 u 为一个零向量。</p>
                  <p>两个向量 u 和 v，如果分量个数相同而且对应分量相等，则称为相等的，记作 u = v。</p>
                  <h3 id="向量的运算"><a href="#向量的运算" class="headerlink"
                                                                                                    title="向量的运算"></a>向量的运算
                  </h3>
                  <p><strong>向量的和</strong> 考虑任意两个分量个数相同的向量 u 和 v，比如<br>$$<br>u =
                    (a_1, a_2,
                    \ldots, a_n), v = (b1, b_2, \ldots,
                    b_n)<br>$$<br>则向量u与v的和，记作 u +
                    v，是将u与v的对应分量相加而得到的向量，则：<br>$$<br>u + v = (a_1 + b_1, a_2 +
                    b_2, \ldots,
                    a_n +
                    b_n)<br>$$</p>
                  <p><em>向量的数乘</em> 将数 k 乘以 u 的每一个分量得到的向量，即：<br>$$<br>ku =
                    (ka_1, ka_2,
                    \ldots,
                    ka_n)<br>$$</p>
                  <p>扩展定义：<br>$$<br>-u = -1(u), u - v = u + (-v)<br>$$</p>
                  <p>其中，-u 称为向量 u 的负向量。</p>
                  <p><strong>向积</strong> 向量u与v的 <em>点积</em> 或 <em>向积</em>
                    定义为<br>$$<br>u
                    \cdot v =
                    a_1 b_1 + a_2 b_2 + \ldots + a_n b_n<br>$$</p>
                  <p><strong>向量的范数/向量的长度</strong> 对于向量 u，<br>$$<br>| u | =
                    \sqrt[2]{u \cdot
                    u} =
                    \sqrt{ a_1^2 + a_2^2 + \ldots + a_n^2 }<br>$$</p>
                  <h3 id="列向量、行向量"><a href="#列向量、行向量" class="headerlink"
                                                                                                    title="列向量、行向量"></a>列向量、行向量
                  </h3>
                  <p>写成竖直格式的向量称为列向量。<br>写成水平格式的向量称为行向量。</p>
                  <h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵
                  </h2>
                  <p>矩阵是一张矩形数表，通常记作：<br>$$<br>A = \begin{bmatrix}<br>a_{11}
                    &amp; a_{12}
                    &amp;
                    \cdots &amp; a_{1n} \<br>a_{21} &amp; a_{22} &amp; \cdots
                    &amp; a_{2n}
                    \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots
                    \<br>a_{m1} &amp;
                    a_{m2}
                    &amp; \cdots &amp; a_{mn} \<br>\end{bmatrix}<br>$$</p>
                  <p>其中 m
                    个水平排列的数表称为矩阵A的行，而n个竖直排列的数表称为列。元素a_{ij}处于第i行和第j列，称为ij表值。<br>通常将矩阵简记为
                    A =
                    [a_{ij}]。</p>
                  <p>具有m个行和n个列的矩阵称为m乘以n矩阵，记作m\times n。数偶m和n称为矩阵的型。</p>
                  <p>两个矩阵A与B称为相等的，记作A = B，如果它们的行数和解数分别相等（同型）且对应元素相等。</p>
                  <p>两个m\times n矩阵相等等价于mn个等式组，其中每一等式都对应着一个元素偶。</p>
                  <p><strong>行向量</strong>
                    只有一行的矩阵称为行矩阵或行向量，<br><strong>列向量</strong>
                    只有一列的矩阵称为列矩阵或列向量。<br><strong>零矩阵</strong> 表值全部为零的矩阵称为零矩阵，记作
                    0。</p>
                  <h3 id="矩阵的加法和数乘"><a href="#矩阵的加法和数乘" class="headerlink"
                                                                                                    title="矩阵的加法和数乘"></a>矩阵的加法和数乘
                  </h3>
                  <p>设 A = [a_{ij}] 与 B = [b_{ij}] 为两个m \times n矩阵，即同型矩阵。</p>
                  <p>A与B的<strong>和</strong>记作 A + B，即：</p>
                  <p>$$<br>A + B = \begin{bmatrix}<br>a_{11} + b_{11} &amp;
                    a_{12} + b_{12}
                    &amp;
                    \cdots &amp; a_{1n} + b_{1n} \<br>a_{21} + b_{21} &amp;
                    a_{22} + b_{22}
                    &amp;
                    \cdots &amp; a_{2n} + b_{2n} \<br>\vdots &amp; \vdots &amp;
                    \ddots &amp;
                    \vdots \<br>a_{m1} + b_{m1} &amp; a_{m2} + b_{m2} &amp;
                    \cdots &amp;
                    a_{mn} +
                    b_{mn} \<br>\end{bmatrix}<br>$$</p>
                  <p>数 k 与矩阵A 的 <em>积</em>，记作 k \cdot A 或 简记 kA，是将数k
                    乘以矩阵A的每一个元素得到的矩阵，即：</p>
                  <p>$$<br>kA = \begin{bmatrix}<br>ka_{11} &amp; ka_{12} &amp;
                    \cdots &amp;
                    ka_{1n} \<br>ka_{21} &amp; ka_{22} &amp; \cdots &amp;
                    ka_{2n}
                    \<br>\vdots
                    &amp; \vdots &amp; \ddots &amp; \vdots \<br>ka_{m1} &amp;
                    ka_{12} &amp;
                    \cdots
                    &amp; ka_{mn} \<br>\end{bmatrix}<br>$$</p>
                  <p>同样可以定义：</p>
                  <p>-A = (-1)A, A - B = A + (-B)</p>
                  <p><strong>负矩阵</strong> 矩阵-A称为矩阵A的负矩阵。</p>
                  <p>不同型的矩阵的加法无法定义。</p>
                  <p><strong>定理5.1</strong> 设A，B，C为同型矩阵，k，k’为数，则：</p>
                  <ol>
                    <li>(A + B) + C = A + (B + C)</li>
                    <li>A + 0 = 0 + A</li>
                    <li>A + (-A) = A - A = 0</li>
                    <li>A + B = B + A</li>
                    <li>k(A + B) = kA + kB</li>
                    <li>(k + k’) A = kA + k’A</li>
                    <li>(kk’)A = k(k’A)</li>
                    <li>1A = A</li>
                  </ol>
                  <h2 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink"
                                                                                                    title="矩阵的乘法"></a>矩阵的乘法
                  </h2>
                  <p>矩阵A与B的乘积，记作AB。</p>
                  <p>元素个数相同的行矩阵 A = [a_i] 与 列矩阵 B = [b_i]的积 AB 定义为：</p>
                  <p>$$<br>AB = \begin{bmatrix}<br>a_1, a_2, a_3, \cdots,
                    a_n<br>\end{bmatrix}<br>\begin{bmatrix}<br>b_1 \<br>b_2
                    \<br>\vdots
                    \<br>b_n<br>\end{bmatrix}<br>= a_1b_1 + a_2b_2 + \cdots +
                    a_nb_n<br>=
                    \sum_{k=1}^{n} a_kb_k<br>$$</p>
                  <h3 id="矩阵的乘法-1"><a href="#矩阵的乘法-1" class="headerlink"
                                                                                                    title="矩阵的乘法"></a>矩阵的乘法
                  </h3>
                  <p>设 A = [a_{ik}] 与 B = [b_{kj}]为矩阵，满足 A 的列数等于 B 的行数。<br>即 A 为
                    m \time
                    p矩阵，而 B 为
                    p \times n 矩阵，则 A 与 B的乘积为一个 m \times n 矩阵，<br>其第ij元素为 A 的第 i
                    行乘以 B 的第 j
                    列的结果。
                  </p>
                  <p>其中</p>
                  <p>$$<br>c_{ij}<br>= a_{i1} b_{1j} + a_{i2} b_{2j} + … +
                    a_{ip}
                    b_{pj}<br>=
                    \sum_{k=1}^{p} a_{ik}b_{kj}<br>$$</p>
                  <p><strong>定理 5.2</strong> 设 A，B，C为矩阵，并设以下乘法和加法均有定义。</p>
                  <ol>
                    <li>(AB)C = A(BC) (结合律)</li>
                    <li>A(B + C) = AB + AC (左分配律)</li>
                    <li>(B + C)A = BA + CA (右分配律)</li>
                    <li>k(AB) = (kA)B = A(kB) (k为数)</li>
                    <li>0A = 0, B0 = 0（0为零矩阵）</li>
                  </ol>
                  <h3 id="矩阵的乘法与线性方程组"><a href="#矩阵的乘法与线性方程组" class="headerlink"
                                                                                                    title="矩阵的乘法与线性方程组"></a>矩阵的乘法与线性方程组
                  </h3>
                  <p>任意一个线性方程组 S 等价于一个矩阵方程：</p>
                  <p>AX = B</p>
                  <p>其中，A 为方程组的系数构成的矩阵，X 为未知数构成的列向量，而B为常数项构成的列向量。</p>
                  <p>如线性方程组<br>$$<br>x + 2y - 3z = 4,<br>5x - 6y + 8z =
                    9<br>$$<br>等价于<br>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp;
                    -3 \<br>5
                    &amp; -6
                    &amp; 8 \<br>\end{bmatrix}</p>
                  <p>\begin{bmatrix}<br>x \<br>y \<br>z \<br>\end{bmatrix}</p>
                  <p>=</p>
                  <p>\begin{bmatrix}<br>4 \<br>9 \<br>\end{bmatrix}</p>
                  <p>$$</p>
                  <p>即方程组S的任一组解都是矩阵方程AX = B的解；反之亦然。</p>
                  <p>此时，称矩阵为线性方程组的<strong>增广矩阵</strong>。</p>
                  <h2 id="转置矩阵"><a href="#转置矩阵" class="headerlink"
                                                                                                    title="转置矩阵"></a>转置矩阵
                  </h2>
                  <p>矩阵A的转置矩阵记作A^T，是将A的行依次写作列得到的矩阵。</p>
                  <p>如：<br>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 \<br>4
                    &amp; 5 &amp; 6
                    \<br>\end{bmatrix}<br>=
                    \begin{bmatrix}<br>1 &amp; 4 \<br>2 &amp; 5 \<br>3 &amp; 6
                    \<br>\end{bmatrix}<br>$$</p>
                  <p><strong>定理5.3</strong> 设A，B为矩阵，k为值数，并设下列加法和乘法均为可行。</p>
                  <ol>
                    <li>(A + B)^T = A^T + B^T</li>
                    <li>(kA)^T = kA^T</li>
                    <li>(AB)^T = B^T A^T</li>
                    <li>(A^T)^T = A</li>
                  </ol>
                  <p>(注意 3.， 矩阵乘积的转置等于转置矩阵的乘积，但是乘积的次序要逆转)</p>
                  <h2 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵
                  </h2>
                  <p>行数和列数相等的矩阵称为<strong>方阵</strong>。</p>
                  <p>具有n行n列的方阵称为n阶方阵，也叫做n方阵。</p>
                  <p>n阶方阵 A = [a_{ij}]的<strong>主对角线</strong> 或 简称
                    <strong>对角线</strong>由元素
                    a_{11},
                    a_{22}, …, a_{nn}构成。</p>
                  <p>n阶单位阵记作 I_n，或简记为I，是主对角线元素均为1，其余元素均为 0 的方阵。</p>
                  <p>特别地，对于任意方阵A，有 AI = IA = A。</p>
                  <h3 id="方阵的代数运算"><a href="#方阵的代数运算" class="headerlink"
                                                                                                    title="方阵的代数运算"></a>方阵的代数运算
                  </h3>
                  <p>对别地，对于任意多项式<br>$$<br>f(x) = a_0 + a_1 x + a_2 x^2 + \cdots
                    + a_n
                    x^n<br>$$<br>其中a_i为数，我们定义f(A)为下列矩阵<br>$$<br>f(A) = a_0I +
                    a_1A + a_2A^2
                    +
                    \cdots + a_n A^n<br>$$</p>
                  <p>当f(A)为零矩阵时，A称为多项式f(x)的一个<em>零点</em>或<em>根</em>。</p>
                  <h2 id="可逆（非奇异矩阵）和逆矩阵"><a href="#可逆（非奇异矩阵）和逆矩阵" class="headerlink"
                                                                                                    title="可逆（非奇异矩阵）和逆矩阵"></a>可逆（非奇异矩阵）和逆矩阵
                  </h2>
                  <p>方阵A称为可逆的（或非奇异的），如果存在矩阵B满足：</p>
                  <p>$$<br>AB = BA = I<br>$$</p>
                  <p>这样的矩阵必定是唯一存在的，且称为A的逆矩阵，记作A^-1。</p>
                  <p>显然，B是A的逆矩阵当且仅当A是B的逆矩阵。</p>
                  <p>(定理：矩阵的逆矩阵是唯一的。)</p>
                  <h3 id="行列式的一般定义"><a href="#行列式的一般定义" class="headerlink"
                                                                                                    title="行列式的一般定义"></a>行列式的一般定义
                  </h3>
                  <p>n阶行列式的一般定义如下：</p>
                  <p>$$<br>det(A) = \sum sgn(\sigma) a_{1j_1} a_{1j_2} \cdots
                    a_{1j_n}<br>$$
                  </p>
                  <p>其中求和对 {1, 2, …, n} 的所有可能排列 \sigma = {j_1, j_2, …, j_n}
                    进行。<br>这里的sgn(\sigma)等于 + 1 或
                    -1，分别对应于将\sigma变成自然次序时所需作的对换次数为偶数或奇数的情形。
                  </p>
                  <p>定理5.4 设A、B为任意的n阶方阵，则<br>$$<br>det(AB) = det(AB) \times
                    det(B)<br>$$</p>
                  <p>定理5.5 方阵A可逆当且仅当其行列式非零。</p>
                  <h2 id="初等行变换，高斯消去法"><a href="#初等行变换，高斯消去法" class="headerlink"
                                                                                                    title="初等行变换，高斯消去法"></a>初等行变换，高斯消去法
                  </h2>
                  <p><strong>初等行变换</strong></p>
                  <p>关于矩阵A的下列运算称为<strong>初等行变换</strong>：</p>
                  <ul>
                    <li>
                      <p>[E_1] 交换两行R_i与R_j的位置，记作“交换R_i与R_j”</p>
                    </li>
                    <li>
                      <p>[E_2] 以非零数k乘以R_i行的每个元素，记作“以k乘R_i”。</p>
                    </li>
                    <li>
                      <p>[E_3] 将R_i行的位数加到R_j行上，即以 kR_i + R_j 替换
                        R_j，记作“R_j加上kR_i”</p>
                      <p>为了避免步骤零散，将[E_2]和[E_3]合并为一步，即：</p>
                    </li>
                    <li>
                      <p>[E] 将R_i行的倍数加到R_j行的非零倍上，换句话说，kR_i + k’R_j 替换 R_j，其中k’
                        \neq 0</p>
                      <p>(注意：对于行变换[E_3]和[E]，实际上只有R_j产生了变化)</p>
                    </li>
                  </ul>
                  <p>记号：
                    矩阵A与B称为<strong>行等阶</strong>的，记作A~B，如果矩阵B可以由矩阵A通过初等行变换得到。</p>
                  <p><strong>阶梯矩阵</strong></p>
                  <p>
                    矩阵称为<strong>阶梯矩阵</strong>或称为具有<strong>阶梯形</strong>，如果满足下列两个条件：
                  </p>
                  <ol>
                    <li>所有的零行（如果存在）都掉于矩阵的底部</li>
                    <li>每个非零元素都排于该行首位非零元的右边。</li>
                  </ol>
                  <p>矩阵称为具有行标准形，如果还满足下列性质：</p>
                  <ol start="3">
                    <li>每个首位非零元素均为1</li>
                    <li>每个首位非零元素为其所在列的唯一非零元</li>
                  </ol>
                  <p>零矩阵 0 为行标准形的一个特例。n阶单位库I_n 是行标准形的另一个特例。</p>
                  <p>方阵A称为三角阵，如果其主对角线元素a_{11}, a_{22}, …,
                    a_{nn}皆为其首位非零元。<br>于是三角方阵为阶梯矩阵的特例。<br>单位阵为既是三角库又是行标准型的唯一特例。
                  </p>
                  <h3 id="矩阵格式的高斯消去法"><a href="#矩阵格式的高斯消去法" class="headerlink"
                                                                                                    title="矩阵格式的高斯消去法"></a>矩阵格式的高斯消去法
                  </h3>
                  <p>算法5.10A（向前消元） 输入任意矩阵 A = [a_{ij}]。</p>
                  <ul>
                    <li>第一步
                      求出第一个具有非零元的列，若这样的列不存在，则退出。（此时为零矩阵），否则，设j_1表示该列的列号；<br>a.
                      整理矩阵，使得a_{1j_1} \neq 0，即，若有必要，则交换行的次序，使得非零元出现于 j_1
                      列的第一行；<br>b.
                      以a_{1j_1}为主元，将a_{1j_1}以下的元素变为零。即，对于 i &gt; 1<ol>
                        <li>置 m = - a_{ij_1} / a_{1j_1}</li>
                        <li>将 mR_1 加到 R_i 上<br>[即以 -(a_{ij_1} / a_{1j_1})R_1 +
                          R_i 替换 R_i]
                        </li>
                      </ol>
                    </li>
                    <li>第二步 对于除第一行外的子矩阵，重复第一步。这里，设 j_2
                      表示在子矩阵中具有非零元的第一个列。因此在第二步结束时，<br>有
                      a_{2j_2}
                      \neq 0.</li>
                    <li>第三步 到 第r+1步，继续执行上述步骤，直到所得子矩阵没有非零元。</li>
                  </ul>
                  <p>算法5.10B（向后消元）输入矩阵 A = [a_{ij}]
                    为具有主元a_{1j_1}，a_{2j_2}，…，a_{rj_r} 的阶梯阵，
                  </p>
                  <ul>
                    <li>第一步<br>a. 以 1 / a_{rj_r} 乘以最后一个非零行R，使得该主元为1<br>b.
                      从a_{rj_r} = 1
                      出发将该的主元以上元素变为零，即，对于 i = r - 1， r -2，…，1:<ol>
                        <li>置 m = - a_{ir_i}</li>
                        <li>将 mR_r 加到 R_i 上（换言之，即利用初等行变换“将 - a_{ir_i}R_r 加到 R_i
                          上”）</li>
                      </ol>
                    </li>
                    <li>第二步到第r - 1步 对于 R_{r-1}，R_{r-2}，…，R_2，重复第一步</li>
                    <li>第r步 以 1/a_{1j_1}乘以R_1</li>
                  </ul>
                  <p><strong>定理5.6</strong> 任意矩阵A行等价于唯一一个行标准形矩阵（称为A的行标准形）。</p>
                  <h3 id="线性方程组的矩阵解法"><a href="#线性方程组的矩阵解法" class="headerlink"
                                                                                                    title="线性方程组的矩阵解法"></a>线性方程组的矩阵解法
                  </h3>
                  <p>考虑线性方程组S，或等价地，考虑以 M = [A,B]为增广矩阵的矩阵方程 AX =
                    B，我们可以以对矩阵M利用高斯消去法列出线性方程组。
                  </p>
                  <p>A步（化简） 将增广矩阵M化为阶梯矩阵。如果有一行具有形式(0,0, …, 0, b)，b \neq
                    0，则停止。该方程组无解。</p>
                  <p>B步（回代） 进一步将增广矩阵 M 化为其行标准形。</p>
                  <p>可以从M的标准形立即得到方程组的唯一解，或者当解不唯一时，得到解的自由变量表达式。</p>
                  <h3 id="n-times-n矩阵的逆阵"><a href="#n-times-n矩阵的逆阵" class="headerlink"
                                                                                                    title="n\times n矩阵的逆阵"></a>n\times
                    n矩阵的逆阵</h3>
                  <p>算法5.10C 求任意n\times n矩阵A的逆阵</p>
                  <p>第一步 构造一个 n \times 2n 矩阵 M = [A,I]，即M的左边一半为A而右边一半为单位阵I</p>
                  <p>第二步
                    利用初等行变换将M化为阶梯阵，如果在运算过程中在M的A部分出现零行，则停止（此时A没有逆阵）。<br>否则，A的部分将变为三角阵。
                  </p>
                  <p>第三步 继续利用初等行变换将M化为标准形 M~[I,B]，此时M的左边A的部分已经变为I。</p>
                  <p>第四步 置 A^{-1} = B，其中B即为M的行标准形中的右边一半。</p>
                  <h2 id="布尔（零-幺）矩阵"><a href="#布尔（零-幺）矩阵" class="headerlink"
                                                                                                    title="布尔（零-幺）矩阵"></a>布尔（零-幺）矩阵
                  </h2>
                  <p>二进制数或二进制位为符号0和1，有布尔运算规则。</p>
                  <p>设矩阵 A = [a_{ij}] 的元素为位元 0 或
                    1，则A称为布尔矩阵。两个布尔矩阵的布尔积除遵从通常矩阵乘法规则外，在数的运算中则采用布尔运算。
                  </p>
                  <h1 id="附录-4"><a href="#附录-4" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <ul>
                    <li>向量 vector<ul>
                        <li>纯量 scalar</li>
                        <li>分量 component</li>
                        <li>表值 entry</li>
                      </ul>
                    </li>
                    <li>向量运算<ul>
                        <li>向量的和 sum of vectors</li>
                        <li>向量数乘 scalar product</li>
                        <li>向量点乘 dot product</li>
                        <li>向量内积 inner product</li>
                        <li>向量范数 norm</li>
                        <li>向量长度 length</li>
                      </ul>
                    </li>
                    <li>零向量 zero vector</li>
                    <li>负向量 negative of vector</li>
                    <li>行向量 row vector</li>
                    <li>列向量 column vector</li>
                    <li>矩阵 matrix<ul>
                        <li>矩阵的行数 rows of vector</li>
                        <li>矩阵的列数 columns of vector</li>
                        <li>第i行第j列的元素 the ij entry</li>
                        <li>m * n 矩阵 m by n matrix</li>
                        <li>行矩阵 row vector, row matrix</li>
                        <li>列矩阵 column vector, column matrix</li>
                        <li>零矩阵 zero matrix</li>
                      </ul>
                    </li>
                    <li>矩阵运算<ul>
                        <li>矩阵加法 matrix addition</li>
                        <li>矩阵的和 sum of matrices</li>
                        <li>矩阵数乘 scalar multiplication</li>
                        <li>负矩阵 negative of matrix</li>
                        <li>矩阵乘法 matrix multiplication</li>
                        <li>矩阵的积 product of matrices</li>
                        <li>转置矩阵 transpose of matrix</li>
                      </ul>
                    </li>
                    <li>增广矩阵</li>
                    <li>方阵 square matrix<ul>
                        <li>n阶方阵</li>
                      </ul>
                    </li>
                    <li>多项式的零点</li>
                    <li>可逆矩阵 invertible matrix<ul>
                        <li>非奇异矩阵 nonsingular matrix</li>
                        <li>逆矩阵 inverse</li>
                      </ul>
                    </li>
                    <li>行列式 determinant</li>
                    <li>行列式的一般定义 general definition of determinants</li>
                    <li>初等行变换 elementary row operations</li>
                    <li>高斯消去法 Gaussian elimination</li>
                    <li>行等阶 echelon matrix</li>
                    <li>布尔矩阵 boolean matrix<ul>
                        <li>0-1矩阵 zero-one matrix</li>
                      </ul>
                    </li>
                  </ul>
                  <h1 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数
                  </h1>
                  <h2 id="基本计数原理"><a href="#基本计数原理" class="headerlink"
                                                                                                    title="基本计数原理"></a>基本计数原理
                  </h2>
                  <p><strong>加法原理</strong>
                    假设事件E能以m种方式出现，事件F能以n种方式出现，且两种事件不能同时出现，那么 E或F
                    能以m+n种方式出现。</p>
                  <p>推广到一般情况，假设事件E1 能以n1种方式出现，事件E2
                    能以n2种方式出现，……，且任意两个事件不能同时出现，<br>那么事件
                    E1,E2,… 之一
                    以 n1 + n2 + … 种方式出现。</p>
                  <p><strong>乘法原理</strong> 假设事件E能以m种方式发生，独立于事件E之外的事件F能以n种方式发生，那么
                    E和F的组合有以mn种方式发生。
                  </p>
                  <p>推广到一般情况，互相独立的事件E1，E2 … 分别有 n1，n2，…种方式发生，那么所有事件依照指定顺序 有 n1
                    n2 n3 …种方式发生。
                  </p>
                  <h3 id="集合论的解释"><a href="#集合论的解释" class="headerlink"
                                                                                                    title="集合论的解释"></a>集合论的解释
                  </h3>
                  <ol>
                    <li><strong>加法原理</strong> 若 A 与 B
                      不相交，则<br>$$<br>\textrm{card}(A \cup B)
                      =
                      \textrm{card}(A) + \textrm{card}(B)<br>$$</li>
                  </ol>
                  <h2 id="阶乘符号"><a href="#阶乘符号" class="headerlink"
                                                                                                    title="阶乘符号"></a>阶乘符号
                  </h2>
                  <p>从 1 到 n（包括 1 和 n）的正整数的积记作 n! (读作n的阶乘)；即：<br>$$<br>n! = 1 *
                    2 * 3 * (n -
                    2)(n
                    - 1) n<br>$$</p>
                  <p>也可以定义为：</p>
                  <pre><code>1. 1!= 1
2. n! = n * (n - 1)!
3. 0! = 1</code></pre>
                  <h2 id="二项式符号"><a href="#二项式符号" class="headerlink"
                                                                                                    title="二项式符号"></a>二项式符号
                  </h2>
                  <p>设 r 和 n 为正整数，r &lt;= n，符号(n,r)（读作 nCr） 定义为：</p>
                  <p>$$<br>\binom{n}{r} = \frac{n (n - 1) (n - 2)\cdots (n - r +
                    1)}{1 \cdot
                    2
                    \cdot \cdots (r - 1) \cdot r}<br>$$</p>
                  <p>即：</p>
                  <p>$$<br>\binom{n}{r}= \frac{n!}{r! (n - r)!}<br>$$</p>
                  <p>由于 n - (n - r) = r，因此有：</p>
                  <p>$$<br>\binom{n}{n - r} = \binom{n}{r}<br>$$</p>
                  <p>亦即，<br>$$<br>a + b = n \implies \binom{n}{a} =
                    \binom{n}{b}<br>$$</p>
                  <h3 id="二项式系数与Pascal三角形"><a href="#二项式系数与Pascal三角形" class="headerlink"
                                                                                                    title="二项式系数与Pascal三角形"></a>二项式系数与Pascal三角形
                  </h3>
                  <p>$\binom{n}{r}$ 称为<strong>二项式系数</strong>，因为它们作为 (a + b)^n
                    的展开式的系数出现。特别地，可以证明：
                  </p>
                  <p>$$<br>(a + b) ^n = \sum_{k = 0}^{n} \binom{n}{k} a^{n -
                    k}b^k<br>$$</p>
                  <p>a + b 的相继幂的系数可以排成三角形的数表，称为Pascal三角形。Pascal形角形中的数有如下交互性质：
                  </p>
                  <pre><code>1. 每一行的每一个数与最后一个数都是 1
2. 数表中的每个其他数可通过相加位于其上方的两数得到。</code></pre>
                  <p><strong>定理6.1</strong></p>
                  <p>$$<br>\binom{n+1}{r} = \binom{n}{r - 1} +
                    \binom{n}{r}<br>$$</p>
                  <h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列
                  </h2>
                  <p>n个对象以给定次序的任一安排称为这些对象（同时取出全部）的排列。n个对象中的任r个对象以给定序的任一安排称为
                    r-排列，或称为
                    n个对象的排列。</p>
                  <p>n个对象取r个的排列数记为：<br>$$<br>p(n, r), nPr, P_{nr}, P_r^n, (n)_r
                    $$</p>
                  <p><strong>P(n, r)公式的推导</strong></p>
                  <p><strong>定理6.2</strong></p>
                  <p>$$<br>P(n, r) = \frac{n!}{(n - r)!}<br>$$</p>
                  <p><strong>推论6.3</strong></p>
                  <p>n个对象（同时全取）的排列数为n!</p>
                  <h3 id="可重排列"><a href="#可重排列" class="headerlink"
                                                                                                    title="可重排列"></a>可重排列
                  </h3>
                  <p>通常我们想知道可重集的排列数，可重集是指有某些元素相同的集合，用</p>
                  <p>$$<br>P(n; n_1, n_2,\cdots, n_r)<br>$$</p>
                  <p>表示n个对象的排列数。其中n_1个对象是相同的，n_2个对象是相同的，…，n_r个对象是相同的。</p>
                  <p><strong>定理6.4</strong></p>
                  <p>$$<br>P(n; n_1, n_2, \cdots, n_r) = \frac{n!}{n_1! n_2!
                    \cdots
                    n_r!}<br>$$
                  </p>
                  <h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合
                  </h2>
                  <p>设有含n个对象的集合，n个对象取r个对象的组合是r个对象的不计次序的任一选取。<br>换句话说，n个对象的任一个
                    r-元素子集是一个r-组合。
                  </p>
                  <p>n个对象取r个的组合数记为C(n, r)。也可以记为：</p>
                  <p>$$<br>nC_r, C_{nr}, C_r^n<br>$$</p>
                  <p><strong>C(n, r)公式</strong></p>
                  <p>由于 n 个对象取r个的任一组合确定了该组合中的对象 r! 个排列，因此有：</p>
                  <p>$$<br>P(n, r) = r!C(n, r)<br>$$</p>
                  <p><strong>定理6.5</strong></p>
                  <p>$$<br>C(n, r) = \frac{P(n, r)}{r!} = \frac{n!}{r! (n -
                    r)!}<br>$$</p>
                  <p>因此：<br>$$<br>C(n, r) = \binom{n}{r}<br>$$</p>
                  <h2 id="鸽笼原理"><a href="#鸽笼原理" class="headerlink"
                                                                                                    title="鸽笼原理"></a>鸽笼原理
                  </h2>
                  <p>若 n 个鸽笼被 n + 1 只或更多只鸽子占据，则至少有一个鸽笼被超过一只鸽子占据。</p>
                  <p><strong>推广的鸽笼原理</strong></p>
                  <p>若n个鸽笼被 kn + 1 只或更多只鸽子占据，k为正整数，则至少有一个鸽笼被 k+1 只或更多只鸽子占据。</p>
                  <h2 id="容斥原理"><a href="#容斥原理" class="headerlink"
                                                                                                    title="容斥原理"></a>容斥原理
                  </h2>
                  <p>设A，B为两个有限集，则</p>
                  <p>$$<br>\text{card}(A\cup B) = \text{card}(A) +
                    \text{card}(B) -
                    \text{card}(A
                    \cap B)<br>$$</p>
                  <p><strong>定理 6.6</strong> 对任意有限集A，B，C，有</p>
                  <p>$$<br>n(A\cup B \cup C) = n(A) + n(B) + n(C)</p>
                  <ul>
                    <li>n(A\cap B) - n(A\cap C) - n(B\cap C)</li>
                  </ul>
                  <ul>
                    <li>n(A\cap B \cap C)<br>$$</li>
                  </ul>
                  <p><strong>定理6.7</strong></p>
                  <p>假设A1, A2, …, Am为有限集，今Sk表示给定m个集合的所有可能的 k 个交的基数</p>
                  <p>$$<br>\text{n}(A_{i_1} \cap A_{i_2} \cap \cdots \cap
                    A_{i_k})<br>$$</p>
                  <p>的和，则</p>
                  <p>$$<br>n(A_1 \cup A_2 \cup \cdots \cup A_m) = s_1 - s_2 +
                    s_3 + (-1)^{m
                    - 1}
                    s_m<br>$$</p>
                  <h2 id="有序划分与无序划分"><a href="#有序划分与无序划分" class="headerlink"
                                                                                                    title="有序划分与无序划分"></a>有序划分与无序划分
                  </h2>
                  <p><strong>有序划分</strong></p>
                  <p><strong>定理6.8</strong> 设A有n个元素，n_1, n_2, …, n_r
                    是正整数，它们的和为n，即 n_1 + n_2
                    + … +
                    n_r = n，<br>则 A 的形如[A_1, A_2, …, A_r]的有限划分有：</p>
                  <p>$$<br>\frac{n!}{n_1! n_2! \cdots n_r!}<br>$$</p>
                  <p>个，其中 A_1 含有 n_1 个元素，A_2 含有 n_2 个元素，…,A_r 含有 n_r 个元素。</p>
                  <p><strong>无序划分</strong></p>
                  <p>在有限划分的基础上，除以组数的全排列数（即 r! ）。</p>
                  <h1 id="概率论"><a href="#概率论" class="headerlink"
                                                                                                    title="概率论"></a>概率论
                  </h1>
                  <h2 id="样本空间与事件"><a href="#样本空间与事件" class="headerlink"
                                                                                                    title="样本空间与事件"></a>样本空间与事件
                  </h2>
                  <p><strong>样本空间</strong> 一个实验的所有可能的结果的集合S；</p>
                  <p><strong>样本点</strong> 特定的实验结果，即样本空间S的元素；</p>
                  <p>事件A是结果的集合，换句话说，事件A为样本空间的子集。</p>
                  <p><strong>基本事件</strong> 由单个样本点 a \in S构成的集合{a}。</p>
                  <p><strong>不可能事件</strong> 空集\emptyset；又称 <strong>零事件</strong>
                  </p>
                  <h2 id="有限概率空间"><a href="#有限概率空间" class="headerlink"
                                                                                                    title="有限概率空间"></a>有限概率空间
                  </h2>
                  <p><strong>有限概率空间</strong> 设S为有限样本空间，S = {a_1, a_2, …,
                    a_n}，若对S的每个点a_i，指定一个字数p_i，<br>称为a_i的概率，且满足以下性质：</p>
                  <pre><code>1. 每个 p_i 非负，即 p_i &gt;= 0;
2. 所有p_i 的和为1， 即 p_1 + p_2 + ... + p_n = 1;</code></pre>
                  <p>则称为<strong>有限概率空间</strong>，或称为<strong>概率模型</strong>。</p>
                  <p>事件A的概率记为P(A)，定义为A中点的概率之和。</p>
                  <p>单元素集 {a_i} 称为基本事件，为方便，用P(a_i)代替P({a_i})。</p>
                  <p><strong>等概率空间</strong> 每个样本点有相同的概率的有限概率空间称为等概率空间。</p>
                  <p>$$<br>\forall a_i, a_j \in S \to p_i = p_j<br>$$</p>
                  <p>特别地，若S有n个样本点，则每个点的概率为 1/n。</p>
                  <p>$$<br>P(A) = \frac{A中元素个数}{S中元素个数} =
                    \frac{n(A)}{n(S)}<br>$$</p>
                  <p>或</p>
                  <p>$$<br>P(A) = \frac{有利于A的结果数}{全部可能结果数}<br>$$</p>
                  <p><strong>随机</strong> 术语“随机”仅限用于等概率空间。</p>
                  <h3 id="有限概率空间的定理"><a href="#有限概率空间的定理" class="headerlink"
                                                                                                    title="有限概率空间的定理"></a>有限概率空间的定理
                  </h3>
                  <p><strong>定理7.1</strong> 定义在有限概率空间S所有事件点上的概率函数P，有如下性质：</p>
                  <ol>
                    <li>对每个事件A， 0 &lt;= P(A) &lt;= 1</li>
                    <li>P(S) = 1</li>
                    <li>若事件A、B相互排斥，则<br>$$<br>P(A\cup B) = P(A) + P(B)<br>$$
                    </li>
                  </ol>
                  <p><strong>定理7.2</strong> 设A为任一事件，则 P(A^c) = 1 - P(A)</p>
                  <p><strong>定理7.3</strong> 设\emptyset为空集，A、B为任意两个事件，则</p>
                  <pre><code>1. P(\emptyset) = 0
2. P(A\B) = P(A) - P(A\cap B)
3. A \subseteq B \implies P(A) &lt;= P(B)</code></pre>
                  <h2 id="条件概率"><a href="#条件概率" class="headerlink"
                                                                                                    title="条件概率"></a>条件概率
                  </h2>
                  <p>设E为概率空间S的一个事件，P(E) &gt; 0，在 E
                    已发生的条件下，事件A发生的概率。<br>即在E发生的条件下，A的<strong>条件概率</strong>，记为P(A|E)，定义如下：
                  </p>
                  <p>$$<br>P(A|E) = \frac{P(A\cap E)}{P(E)}<br>$$</p>
                  <p>设S为等概率空间，n(A)表示事件A的元素个数，则</p>
                  <p>P(A\cap E) = \frac{n(A \cap E)}{n(S)}</p>
                  <p>P(E) = \frac{n(E)}{n(S)}</p>
                  <p>因此</p>
                  <p>P(A|E) = \frac{P(A \cap E)}{P(E)} = \frac{n(A\cap E)}{n(E)}
                  </p>
                  <p><strong>定理7.5</strong> 设S为等概率空间，A，E为两个事件，则<br>$$<br>P(A |
                    E) =
                    \frac{n(A\cap
                    E)}{n(E)}<br>$$</p>
                  <h3 id="条件概率的乘法定理"><a href="#条件概率的乘法定理" class="headerlink"
                                                                                                    title="条件概率的乘法定理"></a>条件概率的乘法定理
                  </h3>
                  <p><strong>定理7.6</strong> （条件概率的乘法定理） P(A \cap B) = P(A)P(B|A)
                  </p>
                  <p>推广到多个事件 A1， A2， … Am，即：</p>
                  <p>$$<br>P(A_1 \cap A_2 \cap \cdots \cap A_m)<br>= P(A_1)
                    \cdot P(A_2 \mid
                    A_1)
                    \cdots P(A_m \mid A_1 \cap A_2 \cap \cdots \cap A_{m -
                    1})<br>$$</p>
                  <h2 id="独立事件"><a href="#独立事件" class="headerlink"
                                                                                                    title="独立事件"></a>独立事件
                  </h2>
                  <p>
                    设A，B为概率空间S的两个事件，若一个事件的发生并不影响另一个事件的发生，则称它们是<strong>独立</strong>的。<br>即：若P(B)与P(B|A)相同，则B与A独立。<br>根据乘法定理，可得：
                  </p>
                  <p>$$<br>P(A\cap B) = P(A) P(B)<br>$$</p>
                  <p><strong>定义</strong> 若P(A\cap B) = P(A)
                    P(B)，则称事件A与B为独立的，否则称为相关的。</p>
                  <p>独立性是一个对称关系，即：</p>
                  <p>p(A\cap B) = P(A) P(B) \implies P(B|A) = P(B) \land P(A|B)
                    = P(A)</p>
                  <h2 id="独立重复试验，二项分布"><a href="#独立重复试验，二项分布" class="headerlink"
                                                                                                    title="独立重复试验，二项分布"></a>独立重复试验，二项分布
                  </h2>
                  <p>定义
                    设S为有限概率空间，称S的有限n元组构成的概率空间Sn为n个独立重复试验的空间，且n元组的概率定义为其每个分量的概率的乘积：
                  </p>
                  <p>$$<br>P((s_1, s_2, \cdots, s_n)) = P(s_1)P(s_2)\cdots
                    P(s_n)<br>$$</p>
                  <p><strong>两个结果的重复试验，Bernouli试验</strong></p>
                  <p>
                    考察只有两个结果的试验，这样的独立的重复试验称为Bernouli试验。<br>独立试验是指任何试验的结果不依赖于前一结果，我们称一个结果为<strong>成功</strong>，另一个结果为<strong>失败</strong>。
                  </p>
                  <p>设p表示Bernouli试验中成功的概率，失败的概率为 q = 1 - p。</p>
                  <p>二项试验由一组Bernouli试验构成，符号B(n, p) 表示n个试验，且成功的概率为p的二项试验。</p>
                  <p><strong>定理7.7</strong> 在二项试验B(n, p)中，恰有k次成功的概率为：</p>
                  <p>$$<br>p(k) = P(k个成功) = \binom{n}{k} p^k q^{n - k}<br>$$</p>
                  <h2 id="随机变量"><a href="#随机变量" class="headerlink"
                                                                                                    title="随机变量"></a>随机变量
                  </h2>
                  <p>随机变量 设S为一个实验的样本空间，随机变量X为一个法则，它对样本空间S的每个缠指定一个数值。</p>
                  <p>用R_x表示由随机变量X指定的数的集合，也称R_x为范围空间。</p>
                  <h3 id="随机变量的概率分布"><a href="#随机变量的概率分布" class="headerlink"
                                                                                                    title="随机变量的概率分布"></a>随机变量的概率分布
                  </h3>
                  <p>设R_x = {x_1, x_2, …, x_i}
                    为定义在有限样本空间S上的随机变量X的范围空间，则X诱导出范围空间R_x的概率指派：
                  </p>
                  <p>p_i = P(x_i) = P(X = x_i) = S 中像为x_i的点的概率之和。</p>
                  <p>有限偶(x_1, p_i)，…，(x_i, p_i)的集合，常用一张出表表示：</p>
                  <table>
                    <thead>
                      <tr>
                        <th>x1</th>
                        <th>x2</th>
                        <th>…</th>
                        <th>x_i</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>p1</td>
                        <td>p2</td>
                        <td>…</td>
                        <td>p_i</td>
                      </tr>
                    </tbody>
                  </table>
                  <p>称为随机变量X的分布。</p>
                  <p>定理7.8 设S为概率空间，X为S上的随机变量，具有范围空间R_x = {x1, x2, …,
                    xi}，则：<br>$$<br>p_i =
                    P(x_i)
                    = \frac{S中像为x_i的点数}{S中的点数}<br>$$</p>
                  <h3 id="随机变量的期望"><a href="#随机变量的期望" class="headerlink"
                                                                                                    title="随机变量的期望"></a>随机变量的期望
                  </h3>
                  <p>设X为随机变量，关于X的两个重要度量（参数）：X的均值，记为\mu 或 \mu_x 和 X 的标准差记为 \sigma
                    或 \sigma
                    _x。</p>
                  <p>均值\mu也称为X的期望，记为E(X)。</p>
                  <p>$$<br>\mu = E(X) = x_1 p_1 + x_2 p_2 + \cdots + x_n p_n =
                    \sum_{x_i}{p_i}<br>$$</p>
                  <p><strong>随机变量的方差与标准差</strong></p>
                  <p>方差Var(X)与标准差\sigma：</p>
                  <p>$$<br>Var(X) = (x_1 - \mu)^2 p_1 + (x_2 - \mu)^2 p_2 +
                    \cdots + (x_n -
                    \mu)^2
                    p_n = \sum (x_i - \mu)^2 p_i<br>= E((X-\mu)^2)<br>$$</p>
                  <p>又：<br>$$<br>Var(X) = x_1^2 p_1 + x_2^2 p_2 + \cdots + x_n^2
                    p_n - \mu^2
                    =
                    \sum x_i^2 p_i - \mu^2 = E(X^2) - \mu^2<br>$$</p>
                  <h3 id="二项分布"><a href="#二项分布" class="headerlink"
                                                                                                    title="二项分布"></a>二项分布
                  </h3>
                  <p>考虑二项试验B(n, p)，k次成功数X是一个随机变量，</p>
                  <p>定理7.9 考察二项分布B(n, p)，则：</p>
                  <pre><code>1. 期望值 E(X) = \mu = np
2. 方差 Var(X) = \sigma^2 = npq
3. 标准差 \sigma = \sqrt{npq}</code></pre>
                  <h1 id="附录-5"><a href="#附录-5" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <h2 id="术语-4"><a href="#术语-4" class="headerlink"
                                                                                                    title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>样本空间 sample space</li>
                    <li>样本点 sample point</li>
                    <li>事件 event<br>(a set of sample point, or a subset of
                      sampel space)
                    </li>
                    <li>基本事件 elementary event<ul>
                        <li>不可能事件 impossible event</li>
                        <li>零事件 null vent</li>
                        <li>相互排斥 mutually exclusive</li>
                      </ul>
                    </li>
                    <li>有限概率空间 finite probability spaces</li>
                    <li>概率模型 probability model</li>
                    <li>概率 probability</li>
                    <li>等概率空间 equiprobable Spaces</li>
                    <li>随机 random</li>
                  </ul>
                  <h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论
                  </h1>
                  <p>难点：</p>
                  <ul>
                    <li>二部图</li>
                    <li>平面图</li>
                    <li>地图</li>
                    <li>支撑树</li>
                    <li>图着色</li>
                    <li>邻接结构的链表示</li>
                    <li>图算法（DFS与BFS）<ul>
                        <li>广度优先搜索</li>
                        <li>深度优先搜索</li>
                      </ul>
                    </li>
                  </ul>
                  <h2 id="链表与指针"><a href="#链表与指针" class="headerlink"
                                                                                                    title="链表与指针"></a>链表与指针
                  </h2>
                  <p><strong>链表</strong> 数据元素的线性集。<br><strong>点</strong>
                    链表中的数据元素。其借助指针域给出线性序。<br>分为两个部分，一部分包含元素的信息，一部分包含后继点的地址信息。
                  </p>
                  <p><strong>链域</strong>
                    点中包含链表中后继点的地址的部分，也叫<strong>后继指针域</strong>。</p>
                  <p><strong>空指针</strong> 指向无效地址的指针。通常用于指明链表的结尾。</p>
                  <h2 id="堆栈、队列、优先队列"><a href="#堆栈、队列、优先队列" class="headerlink"
                                                                                                    title="堆栈、队列、优先队列"></a>堆栈、队列、优先队列
                  </h2>
                  <p><strong>堆栈</strong>
                    也称为后进先出（LIFO）系统，它是一个仅在表的称为顶的一端进行插入和删除的线性表。</p>
                  <p><strong>队列</strong>
                    也称为先进先出（FIFO）系统，它只能在表的称为前面的一端进行删除，而在称为后面的另一端进行插入。
                  </p>
                  <p><strong>优先队列</strong> 新元素可以定期的插入，但是总是先删除当前具有最高优先级的元素的一个元素样。
                  </p>
                  <h2 id="图与多重图"><a href="#图与多重图" class="headerlink"
                                                                                                    title="图与多重图"></a>图与多重图
                  </h2>
                  <p>一个图G由两个对象构成：<br> 1. 集合V =
                    V(G)，其元素称为G的<strong>顶点</strong>或<strong>点</strong>。
                    2. 集合E = E(G)，其元素为G的不同顶点的无序偶，称为G的边。</p>
                  <p>当强调G的两个部分时，用G(V,E)表示这样的图。</p>
                  <p><strong>相邻，端点</strong></p>
                  <p>若存在一个边 e = {u,
                    v}，则称顶点u和v为<strong>相邻</strong>的，此时u与v称为e的<strong>端点</strong>，而称e连接u和v，也称边e
                    <strong>关联于</strong> 它的端点u和v。</p>
                  <h3 id="多重图"><a href="#多重图" class="headerlink"
                                                                                                    title="多重图"></a>多重图
                  </h3>
                  <p>重边：如果存在边e1 和 e2 连接相同的端点，则称为重边。</p>
                  <p>环：若边e的两个端点是同一顶点，则称e为环。</p>
                  <p>简单图：没有重边和环的图。</p>
                  <p>多重图：存在重边和环的图。</p>
                  <h2 id="顶点的度"><a href="#顶点的度" class="headerlink"
                                                                                                    title="顶点的度"></a>顶点的度
                  </h2>
                  <p>图G中的顶点v的度 deg(v) 等于G中含有v的边的条数，即关联于v的边数。</p>
                  <p>由于计算G中顶点的度时，每条边被计数两次，于是有：</p>
                  <p><strong>定理8.1</strong> G中顶点的度之和等于G中边数的2倍。</p>
                  <p>此定理对于多重图也成立，但环对环的端点的度要算两次（即环当成是首未顶点相同的边）。</p>
                  <p><strong>奇点、偶点</strong></p>
                  <p>偶点：度是偶数的顶点。</p>
                  <p>奇点：度是奇数的顶点。</p>
                  <p>孤立点：度为0的顶点。</p>
                  <h3 id="有限图、平凡图"><a href="#有限图、平凡图" class="headerlink"
                                                                                                    title="有限图、平凡图"></a>有限图、平凡图
                  </h3>
                  <p>有限图：若多重图的顶点数和边都是有限的，则称它为有限的。</p>
                  <p>平凡图：具有一顶点而没有边的图，称为平凡图。（即单点）</p>
                  <h2 id="子图，同构，同胚图"><a href="#子图，同构，同胚图" class="headerlink"
                                                                                                    title="子图，同构，同胚图"></a>子图，同构，同胚图
                  </h2>
                  <h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图
                  </h3>
                  <p>考虑图G = G(V, E)，存在 H = H(V’, E’)，使得H的顶点和边分别包含于G的顶点和边，即:</p>
                  <p>$$<br>V’ \subseteq V \land E’ \subseteq E<br>$$</p>
                  <p>特别地：</p>
                  <pre><code>1. 若边集E&apos;包含了G中端点在H中的所有边，则称图H(V&apos;, E&apos;)为图G(V, E)的由顶点V&apos;导出的子图；

2. 若v为G的一个顶点，则 G-v 记号表示 G 的从G中删去顶点v及G中含v的所有边所得到的子图。

3. 若e为G的一条边，则 G-e 记号表示 从G中只删除边e所得到G的子图（顶点保留）。</code></pre>
                  <h3 id="同构图"><a href="#同构图" class="headerlink"
                                                                                                    title="同构图"></a>同构图
                  </h3>
                  <p>对于图G(V, E)和 图G^*(V^*, E^*)，<br>如果存在一个一一对应 f: V \to V^*
                    r使得{u,
                    v}为G的边当且仅当{f(u), f(v)}为G^*的边。</p>
                  <h3 id="同胚图"><a href="#同胚图" class="headerlink"
                                                                                                    title="同胚图"></a>同胚图
                  </h3>
                  <p>若两个图是由相同的图或同构的图用另外的点剖分某个边得到一个新的图，则称为是同胚的。</p>
                  <h2 id="路、连通度"><a href="#路、连通度" class="headerlink"
                                                                                                    title="路、连通度"></a>路、连通度
                  </h2>
                  <h3 id="路"><a href="#路" class="headerlink" title="路"></a>路
                  </h3>
                  <p>多重图G的路是由形如：</p>
                  <p>$$$<br>v_0, e_1, v_1, e_2, v_2, …, e_{n-1}, v_{n-1}, e_n,
                    v_n<br>$$$
                  </p>
                  <p>的点边交替序列构成，其中每个边 e_i 含有顶点 v_{i-1} 和 v_i（它们位于序列中 e_i 的两旁）。
                  </p>
                  <p><strong>路的长度</strong> 边数 n 称为这条路的长度。</p>
                  <p>也可以用点序列 (v_0, v_1, …, v_n) 表示路。<br>若 v_0 =
                    v_n，则称这条路是<em>闭</em>的，否则称为
                    连接 v_0
                    到 v_n 的路。</p>
                  <p><strong>简单路</strong> 顶点都不相同的路<br><strong>迹</strong>
                    边互不相同的路称为迹<br><strong>圈</strong> 除了 v_0 = v_n
                    外，其余顶点互不相同的闭路。长度为k的圈称为
                    k-圈。</p>
                  <p><strong>定理8.2</strong> 存在从 顶点u 到 顶点v 的路 当且仅当 存在从 u 到 v
                    的简单路。</p>
                  <h3 id="连通度，连通分支"><a href="#连通度，连通分支" class="headerlink"
                                                                                                    title="连通度，连通分支"></a>连通度，连通分支
                  </h3>
                  <p><strong>连通</strong> 如果图G的任意两点之间都存在一条路，则称为连通的。</p>
                  <p><strong>连通分支</strong> G的一个连通子图H称为G的连通分支。</p>
                  <p><strong>孤立点</strong> deg(G) = 0.孤立点本身构成一个连通分支。</p>
                  <h3 id="距离与直径"><a href="#距离与直径" class="headerlink"
                                                                                                    title="距离与直径"></a>距离与直径
                  </h3>
                  <p><strong>距离</strong> 对于连通图G，G中顶点u与v之间的距离 d(u, v) 就是 u 与 v
                    之间最短路的长度。</p>
                  <p><strong>直径</strong> G为G中任两点之间距离的最大值。记为 diam(G)。</p>
                  <h3 id="割点与桥"><a href="#割点与桥" class="headerlink"
                                                                                                    title="割点与桥"></a>割点与桥
                  </h3>
                  <p><strong>割点</strong> 设G为连通图，v 为 G 的顶点，如果 G-v
                    不连通，则称v为割点。<br>（G-v
                    为从G中删去v以及含有v的所有边得到的图）</p>
                  <p><strong>桥</strong> 设G为连通图，e 为 G 的边，如果G-e不连通，则称e为桥。<br>（G-e
                    为从G中删去边e所得到的图）</p>
                  <h2 id="Konigsberg桥，可旅行多重图"><a href="#Konigsberg桥，可旅行多重图" class="headerlink"
                                                                                                    title="Konigsberg桥，可旅行多重图"></a>Konigsberg桥，可旅行多重图
                  </h2>
                  <p><strong>Euler迹</strong> 对于图G，<em>闭</em>且可旅行迹称为Euler迹。</p>
                  <p><strong>Euler图</strong> 如果G存在Euler迹，则称为Euler图。</p>
                  <p><strong>定理8.3 (Euler)</strong> 有限连通图是Euler图当且仅当其每个顶点的度数为偶数。
                  </p>
                  <p><strong>推论8.4</strong>
                    两个奇点的有限连通图是可旅行的，可旅行迹可以从任一奇点开始，另一奇点结束。</p>
                  <h2 id="Hamilton图"><a href="#Hamilton图" class="headerlink"
                                                                                                    title="Hamilton图"></a>Hamilton图
                  </h2>
                  <p>Hamilton回路 图G的一条经过每个顶点恰一次的闭路。</p>
                  <p>Hamilton图 存在Hamilton回路的图。</p>
                  <p>定理8.5 设G为n个顶点的连通图，若n &gt;= 3，且对G的每个顶点 v 有 deg(v) &gt;=
                    n，则G为Hamilton图。
                  </p>
                  <h2 id="标号图与赋权图"><a href="#标号图与赋权图" class="headerlink"
                                                                                                    title="标号图与赋权图"></a>标号图与赋权图
                  </h2>
                  <p><strong>标号图</strong> 对于图G，如果它的边与/或顶点被指定一种或另一种数据，称则G为标号图。
                  </p>
                  <p><strong>赋权图</strong>
                    如果标号图的每条边e都被指派一个称为e的<strong>杈</strong>或<strong>长度</strong>的非负数。
                  </p>
                  <h2 id="完全图、正则图与二部图"><a href="#完全图、正则图与二部图" class="headerlink"
                                                                                                    title="完全图、正则图与二部图"></a>完全图、正则图与二部图
                  </h2>
                  <p><strong>完全图</strong>
                    对于图G，如果G的每个顶点都与G中的每个其他顶点有边相连接，则图G称为完全图。<br>完全图必是连通的。n个顶点的完全图记为K_n。
                  </p>
                  <p><strong>正则图</strong> 对于图G，如果G的每个顶点的度为k，则称图为k度正则的，或
                    k-正则的。<br>换句话说，如果每个顶点有相同的度，则图是正则的。</p>
                  <p>因为顶点的度之和为偶数，所以3-正则图必有偶数个顶点。（定理8.1）</p>
                  <p><strong>二部图</strong>
                    对于图G，如果它的顶点集V可以划分为两个子集M和N，使得G的每条边连接M的一个点到N的一个点，<br>完全二部图是指M的每个顶点连到N的每个顶点。这种图标记为K_{m,n}，其中m为M中的顶点数，n为N中的顶点数，<br>且为标准化，约定m
                    &lt;= n。</p>
                  <h2 id="树图"><a href="#树图" class="headerlink" title="树图"></a>树图
                  </h2>
                  <p>对于图T，如果T是<em>连通</em>的，且没有<em>圈</em>，则称为树。</p>
                  <p><strong>退化树</strong> 没有边的单个顶点的树称为退化树。</p>
                  <p>对于树T，T的两点之间只有一个简单树。<br> a. 假设T中没有边 {u, v}，则对T添加边e = {u,
                    v}后，则T的从u到v的简单路与e构成一个圈，T不再是树；<br> b. 假设e = {u, v}
                    为T的一条边，并从T中删除e，则T不再连通，T不再是树；
                  </p>
                  <p>定理8.6 设G为n &gt; 1 个顶点的图，则下列结论等价：<br> 1. G 是 树；<br> 2. G
                    为无圈图，且有 n -
                    1条边；<br>
                    3. G 连通，且有 n - 1 条边；</p>
                  <h3 id="支撑树"><a href="#支撑树" class="headerlink"
                                                                                                    title="支撑树"></a>支撑树
                  </h3>
                  <p><strong>支撑树</strong> 对于连通图GG，如果G的子图T是树且包含了G的所有顶点，则T称为G的支撑树。
                  </p>
                  <p><strong>最小支撑树</strong>
                    设G为连通的赋权图，则G的每个支撑树都被指定了一个T中的每个边的权之和的总权。<br>G的<strong>最小支撑树</strong>就是总权尽可能小的支撑树。
                  </p>
                  <h4 id="求n个顶点连通赋权图的最小支撑树的算法"><a href="#求n个顶点连通赋权图的最小支撑树的算法" class="headerlink"
                                                                                                    title="求n个顶点连通赋权图的最小支撑树的算法"></a>求n个顶点连通赋权图的最小支撑树的算法
                  </h4>
                  <p><strong>算法8.8A</strong> 输入n个顶点的连通赋权图G，<br> 1.
                    按权递减的序排列G的边<br> 2.
                    相继地依序删去未使G不连通的边，直到剩下n - 1 条边<br> 3. 退出</p>
                  <p><strong>算法8.8B(Kruskal)</strong> 输入n个顶点的连通赋权图G<br> 1.
                    按权的递增的序排列G的边<br>
                    2.
                    仅用G的顶点，相继依序添加不产生圈的边，直到添加了n - 1条边<br> 3. 退出</p>
                  <h2 id="平面图"><a href="#平面图" class="headerlink"
                                                                                                    title="平面图"></a>平面图
                  </h2>
                  <p><strong>平面图</strong>
                    能够画在平面上使得它的边不相交叉的图或多重图称为平面图。（这是一个类拓扑的概念）</p>
                  <p>（树图是最基本的平面图）</p>
                  <h3 id="地图、区域"><a href="#地图、区域" class="headerlink"
                                                                                                    title="地图、区域"></a>地图、区域
                  </h3>
                  <p><strong>地图</strong> 有限平面多重图的特定平面表示称为地图。</p>
                  <p>如果地图的基础多重图是<em>连通</em>的，则称地图是<em>连通</em>的。</p>
                  <p><strong>定理8.7</strong> 地图区域的度的和等于边数的两倍。</p>
                  <h2 id="Euler公式"><a href="#Euler公式" class="headerlink"
                                                                                                    title="Euler公式"></a>Euler公式
                  </h2>
                  <p>对于任何连通地图的顶点数V，边数E以及区域数R：</p>
                  <p><strong>定理8.8(Euler)</strong> V - E + R = 2</p>
                  <p>（注意：前提是地图的基础图必须连通）</p>
                  <p><strong>定理8.9</strong> 设 G 为连通平面图，有p个顶点和q条边，p &gt;= 3，则 q
                    &lt;= 3p - 6.
                  </p>
                  <h3 id="非平面图，Kuratowski定理"><a href="#非平面图，Kuratowski定理" class="headerlink"
                                                                                                    title="非平面图，Kuratowski定理"></a>非平面图，Kuratowski定理
                  </h3>
                  <p>定理8.10（Kuratowski） 图是非平面的当且仅当它含有同胚于 K_{3,3} 或 K_{5} 的子图。
                  </p>
                  <h2 id="图着色"><a href="#图着色" class="headerlink"
                                                                                                    title="图着色"></a>图着色
                  </h2>
                  <p><strong>着色</strong>
                    对于图G，G的顶点着色，简称着色，是给G的每个顶点指定一个颜色，使得相邻顶点有不同的颜色。<br>若存在用n种颜色的G的着色，则称G为
                    n-可着色的。
                  </p>
                  <p>染色G所需的最少颜色数称为G的色数，记为：</p>
                  <p>$$<br>\chi(G)<br>$$</p>
                  <h3 id="图G着色的算法"><a href="#图G着色的算法" class="headerlink"
                                                                                                    title="图G着色的算法"></a>图G着色的算法
                  </h3>
                  <p><strong>算法8.10</strong> (Welch-Powel) 输入一个图G</p>
                  <ol>
                    <li>根据<strong>度</strong>递减的次序排列G的顶点</li>
                    <li>给第一个顶点染第一种颜色C1，然后，依次序给与前面已染C1的点不相邻的点染C1</li>
                    <li>用第二种颜色对未染色的子序列重列重复2</li>
                    <li>用第三种颜色，第四种颜色…，重复3，直到所有的点都已染色</li>
                    <li>退出</li>
                  </ol>
                  <p><strong>定理8.11</strong> 对图G，下面结论等价：</p>
                  <ol>
                    <li>G为2-可着色的</li>
                    <li>G为二部图</li>
                    <li>G的每个圈有偶长度</li>
                  </ol>
                  <p><strong>定理8.12</strong> 任何平面图是5-可着色。</p>
                  <p><strong>四色定理（Apple和Haken）</strong> 任意平面图是4-可着色的。</p>
                  <h3 id="对偶地图与四色定理"><a href="#对偶地图与四色定理" class="headerlink"
                                                                                                    title="对偶地图与四色定理"></a>对偶地图与四色定理
                  </h3>
                  <p>
                    对于地图M，若M的两个区域有公共边，则称为相邻的。对M的着色是指对M的区域的颜色指派，使得相邻的区域有不同的颜色。<br>若存在M的用n个颜色的着色，则称M是n-可着色的。
                  </p>
                  <p>地图的着色等于个平面图的顶点着色。</p>
                  <p><strong>对偶图</strong>
                    对于地图M，在M的每个区域内取一个点，若邻区域有公共边，则用一条通过这条公共边的曲线连接相应的两个点，<br>这些曲线可以画得互不相交，则得到一个新的地图M*，称为M的对偶。
                  </p>
                  <p>可以证明，M也为M*的对偶。</p>
                  <p>地图M的任意区域的着色对应对偶地图 M* 的顶点着色。因此，M是n-可着色的当且仅当对偶地图 M*
                    的平面图是顶点n-可着色的。</p>
                  <p><strong>四色定理（Apple和Haken）</strong>
                    要使任意地图M的相邻区域着不同颜色，则至多需要4种颜色。</p>
                  <h2 id="在计算机中储存图"><a href="#在计算机中储存图" class="headerlink"
                                                                                                    title="在计算机中储存图"></a>在计算机中储存图
                  </h2>
                  <p>设图G有m个顶点n条边，<br>如果m =
                    O(n^2)，则称图G是<strong>稠密</strong>的；<br>如果 m = O(n)或
                    O(n
                    log n)，则图G是<strong>稀疏</strong>的。</p>
                  <p><strong>序列表示</strong> 采用图的邻接矩阵A表示；当图稠密时，常用矩阵来表示。</p>
                  <p><strong>链表示</strong> 又称
                    <strong>邻接结构</strong>，采用邻点的链表；当图稀疏时，常采用链表表示。
                  </p>
                  <h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink"
                                                                                                    title="邻接矩阵"></a>邻接矩阵
                  </h3>
                  <p>设G 为m 个顶点的图，并设顶点已排序为 v1, v2, …, vm，则图G的邻接矩阵 A = [a_ij]
                    就是如下<br>定义的 m *
                    m 矩阵：
                  </p>
                  <p>a_ij = 1 若 vi 连接到 vj，否则 0</p>
                  <p>若G为多重图，常用a_ij表示边 {vi, vj} 的数目<br>若G为赋权图，常用a_ij表示边 {vi, vj}
                    的权</p>
                  <h3 id="链表示"><a href="#链表示" class="headerlink"
                                                                                                    title="链表示"></a>链表示
                  </h3>
                  <p>
                    当图是稀疏的情况下，或者需要动态删除、添加顶点的情况下，矩阵法有很大的限制；<br>因此需要使用一种叫<strong>邻接结构</strong>的链来表示图。
                  </p>
                  <p>
                    使用顶点与其邻接点（邻点）的形式来表示图G。用符号空集表示空邻接。<br>通常含有两个文件（或纪录集），一个称为点文件，另一个称为边文件。
                  </p>
                  <ol>
                    <li>点文件 包含图G的顶点列表。</li>
                    <li>边文件 包含图G的边。</li>
                  </ol>
                  <h2 id="图算法"><a href="#图算法" class="headerlink"
                                                                                                    title="图算法"></a>图算法
                  </h2>
                  <p>查找算法过程中，G的每个顶点 N 处于三种状态之一，称为N的状态（status）：</p>
                  <ol>
                    <li>status = 1, 准备状态，顶点N的初始状态</li>
                    <li>status = 2，等候状态，顶点N在等候表中，等待进行</li>
                    <li>status = 3，检查状态，顶点N已检查</li>
                  </ol>
                  <h3 id="深度优先查找（DFS）"><a href="#深度优先查找（DFS）" class="headerlink"
                                                                                                    title="深度优先查找（DFS）"></a>深度优先查找（DFS）
                  </h3>
                  <p>算法8.12A（深度优先查找） 该算法从一个开始点A开始执行图G的深度优先查找</p>
                  <ol>
                    <li>初始化所有点到准备状态</li>
                    <li>从初始点A放到堆栈上，并将A的状态改为等候状态</li>
                    <li>重复4和5，直到堆栈空</li>
                    <li>取堆栈的顶点N，检查N，并置status(N) = 3，检查状态</li>
                    <li>检查N的每个邻点J<br>a. 若status(J) = 1 ，把J放到堆栈上，重置status(J) =
                      2<br>b.
                      若status(J) =
                      2，从堆栈中删去前一个J，把当前J放到堆栈上<br>c. 若status(J) = 3，略过顶点J</li>
                    <li>退出</li>
                  </ol>
                  <h2 id="广度优先查找（BFS）"><a href="#广度优先查找（BFS）" class="headerlink"
                                                                                                    title="广度优先查找（BFS）"></a>广度优先查找（BFS）
                  </h2>
                  <p>算法8.12B（广度优先查找） 该算法执行图G的度度优先查找，它从一个起点A开始</p>
                  <ol>
                    <li>初始化所有点到准备状态</li>
                    <li>从初始点A放进队列，并将A的状态改为等候状态</li>
                    <li>重复4和5，直到堆栈空</li>
                    <li>移去队列的前面点 N，检查 N，并置status(N) = 3，检查状态</li>
                    <li>检查N的每个邻点J<br>a. 若status(J) = 1 ，把J加到队列后面，重置status(J) =
                      2<br>b.
                      若status(J)
                      = 2或status(J) = 3，跳过顶点J[结束步骤3循环]</li>
                    <li>退出</li>
                  </ol>
                  <h1 id="附录-6"><a href="#附录-6" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <h2 id="术语-5"><a href="#术语-5" class="headerlink"
                                                                                                    title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>链表 linked list</li>
                    <li>点 pointer</li>
                    <li>链域 link field</li>
                    <li>空指针 null pointer</li>
                    <li>堆栈 stack</li>
                    <li>队列 queue</li>
                    <li>优先队列 priority queue</li>
                    <li>图 graph</li>
                    <li>顶点 vertix</li>
                    <li>边 edge</li>
                    <li>相邻 adjacent / neighbour</li>
                    <li>连接 connect</li>
                    <li>端点</li>
                    <li>重边 mutiple edge</li>
                    <li>环 loop</li>
                    <li>简单图 simple graph</li>
                    <li>多重图 multigraph</li>
                    <li>顶点的度 degree of a vertex<ul>
                        <li>奇点 odd (vertex)</li>
                        <li>偶点 even (vertex)</li>
                        <li>孤立点 isolated vertex</li>
                      </ul>
                    </li>
                    <li>有限图 finite graph</li>
                    <li>平凡图 trivial graph</li>
                    <li>子图 subgraph</li>
                    <li>同构图 isomorphic graph</li>
                    <li>同胚图 homeomorphic graph</li>
                    <li>路 path</li>
                    <li>闭 close</li>
                    <li>路的长度 length of path</li>
                    <li>闭路 cycle</li>
                    <li>简单路 simple path</li>
                    <li>迹 trail</li>
                    <li>连通度 connectivity</li>
                    <li>连通分支 connected component</li>
                    <li>距离 distance</li>
                    <li>直径 diameter</li>
                    <li>割点 cut point</li>
                    <li>桥 bridge</li>
                    <li>Konigsberg 桥</li>
                    <li>可旅行 traversable</li>
                    <li>可旅行迹 traversable trail</li>
                    <li>可旅行多重图 traversable multigraph</li>
                    <li>Hamilton图 Hamiltonian graph</li>
                    <li>标号图 labeled graph</li>
                    <li>赋权图 weighed graph</li>
                    <li>完全图 complete graph</li>
                    <li>正则图 regular graph</li>
                    <li>二部图 bipartite graph</li>
                    <li>树 tree</li>
                    <li>支撑树 spanning tree</li>
                    <li>最小支撑树 minimum spanning tree</li>
                    <li>平面图 planar graph</li>
                    <li>地图 map</li>
                    <li>区域 region</li>
                    <li>非平面图 nonplanar graph</li>
                    <li>应用图 utility graph</li>
                    <li>星图 star graph</li>
                    <li>着色 graph colorings</li>
                    <li>四色定理 Four Color Theorem</li>
                    <li>对偶地图 dual maps</li>
                    <li>邻接矩阵</li>
                    <li>邻接结构</li>
                    <li>广度优先搜索</li>
                    <li>深度优先搜索</li>
                  </ul>
                  <h3 id="salesmen-代码练习"><a href="#salesmen-代码练习" class="headerlink"
                                                                                                    title="salesmen 代码练习"></a>salesmen
                    代码练习</h3>
                  <p>table.txt</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">Adams Smith</span><br><span class="line">Brown Ray</span><br><span class="line">Clark Ray</span><br><span class="line">Drew  Jones</span><br><span class="line">Evans Smith</span><br><span class="line">Farmer  Jones</span><br><span class="line">Geller  Ray</span><br><span class="line">Hill  Smith</span><br><span class="line">Infold  Ray</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <p>salesmen.h</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">#ifndef _SALEMEN_H</span><br><span class="line">#define _SALEMEN_H</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Salesman &#123;</span><br><span class="line">  string name;</span><br><span class="line">  int start_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Customer &#123;</span><br><span class="line">  string name;</span><br><span class="line">  int salesman_id;</span><br><span class="line">  int next_customer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Database &#123;</span><br><span class="line">private:</span><br><span class="line">  vector&lt;Salesman&gt; salesmen;</span><br><span class="line">  vector&lt;Customer&gt; customers;</span><br><span class="line">  bool existsCustomer(string name);</span><br><span class="line">  bool existsSalesman(string name);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  Database();</span><br><span class="line">  ~Database();</span><br><span class="line">  add (string salesman, string customer);</span><br><span class="line">  vector&lt;string&gt; findCustomers(string salesmen);</span><br><span class="line">  vector&lt;string&gt; findSalesman(string customer);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <p>salesmen.cpp</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">#include &quot;salesmen.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Database::Database() &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Database::~Database() &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool Database::existsCustomer(string name) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool Database::existsSalesman(string name) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Database::add (string salesman, string customer) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; Database::findCustomers(string salesmen) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; Database::findSalesman(string customer) &#123;</span><br><span class="line">&#125;;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <p>test.cpp</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &quot;salesmen.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; tables;</span><br><span class="line"></span><br><span class="line">    Database db = Database();</span><br><span class="line">    for (auto &amp;g: tables) &#123;</span><br><span class="line">      for (auto &amp;p: g) &#123;</span><br><span class="line">        db.add(p[0], p[1]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto res = db.findCustomers(&quot;Smith&quot;);</span><br><span class="line"></span><br><span class="line">    auto string = db.findSalesman(&quot;Clark&quot;);</span><br><span class="line">  &#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h1 id="二叉树"><a href="#二叉树" class="headerlink"
                                                                                                    title="二叉树"></a>二叉树
                  </h1>
                  <p>
                    二叉树是数学与计算机科学中的基本结构。有根树与二叉树很相似，但二叉树并不是有根树的特殊情形，<strong>它们是不同的数学对象</strong>。
                  </p>
                  <h2 id="二叉树定义"><a href="#二叉树定义" class="headerlink"
                                                                                                    title="二叉树定义"></a>二叉树定义
                  </h2>
                  <p>二叉树 T 定义为点的元素的有限集，使得：</p>
                  <ol>
                    <li>T 是空的（称为空树），或者</li>
                    <li>T 含有一个特别的点 R 称为 T 的根，且 T 的其余点构成不交的二叉树 T1 与 T2 的有限对；</li>
                  </ol>
                  <p>若 T 确有根 R，则两棵树 T1 与 T2 分别称为 R 的左子树 和 右子树。<br>若 T1
                    为非空，则它的根称为 R
                    的左后继；T2非空，则称为
                    R 的右后继。<br>没有后继的点称为<strong>终点</strong>。</p>
                  <h3 id="二叉树的图示"><a href="#二叉树的图示" class="headerlink"
                                                                                                    title="二叉树的图示"></a>二叉树的图示
                  </h3>
                  <h3 id="相似二叉树"><a href="#相似二叉树" class="headerlink"
                                                                                                    title="相似二叉树"></a>相似二叉树
                  </h3>
                  <p>如果二叉树 T 和 T’ 有相似的结构（形状），则称他们是<strong>相似</strong>的。</p>
                  <p>如果两棵相似的二叉树，对应的点有相同的内容，则称为是<strong>拷贝</strong>的。</p>
                  <h2 id="术语-6"><a href="#术语-6" class="headerlink"
                                                                                                    title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>前继</li>
                    <li>左后继</li>
                    <li>右后继</li>
                    <li>父</li>
                    <li>左子</li>
                    <li>右子</li>
                    <li>层次</li>
                    <li>深度</li>
                    <li>高度</li>
                  </ul>
                  <h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink"
                                                                                                    title="完全二叉树"></a>完全二叉树
                  </h3>
                  <p>如果除去最后一层外，所有层都有最大可能的点数，且最后一层的所有点都尽可能靠左边，这样的二叉树称为 n 个点的完全树
                    T_n。</p>
                  <h3 id="扩充二叉树"><a href="#扩充二叉树" class="headerlink"
                                                                                                    title="扩充二叉树"></a>扩充二叉树
                  </h3>
                  <p>如果每个点 N 有两个或者没有子节点，这样的二叉树称为扩充二叉树，又称为 2-树。</p>
                  <p>有两个子节点的点称为内点，没有子节点的点称为外点。</p>
                  <h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink"
                                                                                                    title="二叉树的存储"></a>二叉树的存储
                  </h2>
                  <h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink"
                                                                                                    title="遍历二叉树"></a>遍历二叉树
                  </h2>
                  <p>前序遍历，中序遍历，后序遍历</p>
                  <h1 id="附录-7"><a href="#附录-7" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <h2 id="术语-7"><a href="#术语-7" class="headerlink"
                                                                                                    title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>二叉树 binary tree</li>
                    <li>根</li>
                    <li>左子树</li>
                    <li>右子树</li>
                    <li>左后继</li>
                    <li>右后继</li>
                    <li>终点</li>
                  </ul>
                  <h1 id="整数的性质"><a href="#整数的性质" class="headerlink"
                                                                                                    title="整数的性质"></a>整数的性质
                  </h1>
                  <p>难点：带余除法，同余关系，剩余类，同余式，中国剩余定理的命题</p>
                  <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言
                  </h2>
                  <p>自然数集 N = {1, 2, 3, …}<br>整数集 Z = {…, -2, -1, 0, 1, 2, …}
                  </p>
                  <p>加法和乘法的规律：</p>
                  <p> a. 结合律： (a + b) + c = a + (b + c), (ab)c = a(bc)<br> b.
                    交换律： a + b = b
                    + a,
                    ab = ba<br> c. 分配律： a(b + c) = ab + ac<br> d. 单位元律： a + 0 =
                    0 + a = a, a
                    * 1 =
                    1 * a = a<br> e. 对于任何元素a 都有加法逆元 -a，即：a + (-a) = (-a) + a = 0
                  </p>
                  <p><strong>算术基本定理</strong> 每一个正整数n(n &gt; 1)都可以唯一地写成素数的积。</p>
                  <h2 id="序、不等式与绝对值"><a href="#序、不等式与绝对值" class="headerlink"
                                                                                                    title="序、不等式与绝对值"></a>序、不等式与绝对值
                  </h2>
                  <p>设 a，b为整数，如果b - a的差是正的，即 b - a \in N，我们就说a小于b，记为 a &lt; b。
                  </p>
                  <p>两则Z整数N的性质：<br>[P1] 如果a，b \in N，那么 a + b \in N，ab \in
                    N<br>[P2]
                    对于任意整数a，或者a
                    \in N，或者 a = 0，或者 -a \in N。</p>
                  <p>序的常见记号：<br>$$<br>a &gt; b \iff b &lt; a<br>$$</p>
                  <p>$$<br>a \leq b \iff a &lt; b \lor a = b<br>$$</p>
                  <p>$$<br>a \geq b \iff a &gt; b \lor a = b<br>$$</p>
                  <h3 id="不等式的基本性质"><a href="#不等式的基本性质" class="headerlink"
                                                                                                    title="不等式的基本性质"></a>不等式的基本性质
                  </h3>
                  <p>命题11.1 关系 \leq 在整数集Z中有下列性质：<br>$$<br>\forall a, a \leq
                    a<br>$$<br>$$<br>a
                    \leq b \land b \leq a \implies a = b<br>$$<br>$$<br>a \leq b
                    \land b
                    \leq c
                    \implies a \leq c<br>$$</p>
                  <p>命题11.2（三分律） 对于任何整数 a 和 b，恰有下列关系之一被满足：</p>
                  <p>$$<br>a &lt; b, a = b, a &gt; b<br>$$</p>
                  <p>命题11.3 假定 a \leq b，c为任意整数，则：</p>
                  <p>$$<br>a + c \leq b + c<br>$$</p>
                  <p>$$<br>ab \leq bc(c &gt; 0); ac \geq bc (c &lt; 0)<br>$$</p>
                  <h3 id="绝对值"><a href="#绝对值" class="headerlink"
                                                                                                    title="绝对值"></a>绝对值
                  </h3>
                  <p>整数a 的绝对值记为 | a |，通常定义为：</p>
                  <p>| a | = a (a \geq 0), -a (a &lt; 0)</p>
                  <p>因此除了a = 0外，| a | &gt; 0</p>
                  <p>命题11.4 设a，b为任意整数，则</p>
                  <p>$$<br>| a | \geq 0, a = 0 \iff | a | = 0<br>$$</p>
                  <p>$$<br>-|a| \leq a \leq |a|<br>$$</p>
                  <p>$$<br>|ab| = |a| |b|<br>$$</p>
                  <p>$$<br>|a \pm b| \leq |a| + |b|<br>$$</p>
                  <p>$$<br>| |a| - |b| | \leq |a \pm b|<br>$$</p>
                  <h2 id="数法归纳法"><a href="#数法归纳法" class="headerlink"
                                                                                                    title="数法归纳法"></a>数法归纳法
                  </h2>
                  <p>数学归纳法原理 设S是一个正整数集合而有下列两个性质：</p>
                  <pre><code>1. 1 \in S
2. 若k \in S，则 k + 1 \in S</code></pre>
                  <p>那么 S 是所有正整数构成的集合。</p>
                  <p>数学归纳法原理 设 P 是定义在整数 n &gt;= 1 上的一个命题，使得<br> 1. P(1) 成立<br>
                    2. 当 P(n)
                    成立时，P(n +
                    1)成立</p>
                  <h2 id="整除算法"><a href="#整除算法" class="headerlink"
                                                                                                    title="整除算法"></a>整除算法
                  </h2>
                  <p>对于整数 a 和 b，且 b \neq 0，存在 整数 q 和 r 使得 a = bq + r (0 &lt;= r
                    &lt;=
                    |b|)，并且 q 和
                    r 是唯一的。</p>
                  <p>算法：</p>
                  <figure class="highlight c">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q = (<span class="keyword">int</span>) a/b;</span><br><span class="line">r = a - b * q;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h2 id="整除，素数"><a href="#整除，素数" class="headerlink"
                                                                                                    title="整除，素数"></a>整除，素数
                  </h2>
                  <p>设 a，b为整数且 a \neq 0，假设存在整数c，使得 ac = b，我们就称 a 整除 b 或者 b 被 a
                    整除，记作：</p>
                  <p>$$<br>a \mid b<br>$$</p>
                  <p>也说 b 是 a 的倍数或 a 是 b 的因子。如果 a 不能整除 b，我们记作：</p>
                  <p>$$<br>a = \nmid b<br>$$</p>
                  <p><strong>定理11.8</strong> 设a，b，c为整数</p>
                  <ol>
                    <li>如果 a \mid b 且 b \mid c，则 a \mid c</li>
                    <li>如果 a \mid b，那么对于任一整数 x, a \mid bx</li>
                    <li>如果 a \mid b 且 a \mid c，则 a \mid (b + c) 且 a \mid (b - c)
                    </li>
                    <li>如果 a \mid b 且 b \neq 0，则 a = \pm b或 |a| &lt; |b|</li>
                    <li>如果 a \mid b 且 b \mid a，则 |a| = |b| 即，a = \pm b</li>
                    <li>如果 a \mid 1，则 a = \pm 1</li>
                  </ol>
                  <p><strong>推论11.9</strong> 设 a \mid b 且 a \mid c，则对于任意的整数 x 和y
                    有 a \mid
                    (bx +
                    cy)。</p>
                  <p>表达式称为 bx + cy 为b，c的线性组合。</p>
                  <h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数
                  </h3>
                  <p><strong>素数</strong> 如果一个正整数p (p &gt; 1)只有因子 \pm 1 和 \pm
                    p，即p有平凡因子，则称其为素数。又称质数。<br><strong>合数</strong>
                    如果正整数不是素数，则称其为合数。对于合数 n (n
                    &gt;
                    1)，那么 n = ab，其中 1 &lt; a, b &lt; n。</p>
                  <p><strong>定理11.10</strong> 任意大于 1 的整数 都可以写成素数的积。</p>
                  <p><strong>定理11.11</strong> 没有最大的素数，即存在无限多个素数。</p>
                  <h2 id="最大公因数，带余除法"><a href="#最大公因数，带余除法" class="headerlink"
                                                                                                    title="最大公因数，带余除法"></a>最大公因数，带余除法
                  </h2>
                  <p>设 a， b 是整数且不全为0，整数d称为a，b的公因子，如果 d \mid a 且 d \mid b。<br>注意
                    1 是 a 和
                    b的正的公因子，a
                    和 b 的任何公因子都不能大于 |a| 和 |b|，<br>所以存在一个最大的公因子，记为：</p>
                  <p>$$<br>\text{gcd}(a, b)<br>$$<br>称之为a，b的最大公因数。</p>
                  <p><strong>定理11.12</strong> 设 d 是形如 ax + by 的最小正整数，则 d =
                    gcd(a, b)。</p>
                  <p><strong>定理11.13</strong> 设d = gcd(a, b)，则一定存在整数x和y，使得 d =
                    ax + by。</p>
                  <p><strong>定理11.14</strong> 一个正整数d = gcd(a, b)当且仅当d有下列两个性质：
                  </p>
                  <ol>
                    <li>d即整除a，又整除b</li>
                    <li>如果c既整数a又整除b，那么 c \mid d</li>
                  </ol>
                  <p>下面是最大公因数的简单性质：</p>
                  <ol>
                    <li>gcd(a, b) = gcd(b, a)</li>
                    <li>如果 x &gt; 0，那么 gcd(ax, bx) = x * gcd(a, b)</li>
                    <li>如果 d = gcd(a, b)，那么 gcd(a|d, b|d) = 1</li>
                    <li>对于任意整数x，gcd(a, b) = gcd(a, b + ax)</li>
                  </ol>
                  <h3 id="带余除法"><a href="#带余除法" class="headerlink"
                                                                                                    title="带余除法"></a>带余除法
                  </h3>
                  <p>直接求法：<br>求gcd(a, b) ，通过列出a和b的所有因子，然后选择最大公因子来得出d。</p>
                  <p>设 n = a + b， 计算因子的个数，这种代码方法的复杂性为O(\sqrt{n})</p>
                  <p><strong>带余除法</strong> 复杂度为 O(\log{n})，可以求得最大公因数 d = gcd(a,
                    b) 和 d = ax
                    + by
                    中的 x, y。</p>
                  <p>设a和b，通过用a除以b，然后重复地用余数除以除数直到余数为0。</p>
                  <figure class="highlight c">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt;= <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">if</span> (b &lt;= <span class="number">1</span>) <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> r = a % b;</span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    a = b;</span><br><span class="line">    b = r;</span><br><span class="line">    r = a % b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 ax + by = d 的 x，y 的方法</span></span><br><span class="line"><span class="comment">// 由于在求解 d 的过程中，产生的任意值对 i, j也有 gcd(i, j) = d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此：</span></span><br><span class="line"><span class="comment">// ax + by = d</span></span><br><span class="line"><span class="comment">// ix + jy = d</span></span><br><span class="line"><span class="comment">// 求解即得x，y</span></span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink"
                                                                                                    title="最小公倍数"></a>最小公倍数
                  </h3>
                  <p>设 a，b 是非零整数，|ab|就是a和b的一个正的公倍数，因此存在a，b的一个最小公倍数，记为：</p>
                  <p>$$<br>\text{lcm}(a, b)<br>$$</p>
                  <p>称之为a和b的最小公倍数。</p>
                  <p><strong>定理 11.15</strong>
                    设a和b是非零整数，则：<br>$$<br>\text{lcm}(a, b) =
                    \frac{| ab
                    |}{\text{gcd}(a, b)}<br>$$</p>
                  <h2 id="算术基本定理"><a href="#算术基本定理" class="headerlink"
                                                                                                    title="算术基本定理"></a>算术基本定理
                  </h2>
                  <p><strong>互素</strong> 两个整数a和b称为互素，如果：<br>$$<br>\text{gcd}(a,
                    b) =
                    1<br>$$<br>即，存在x和y，使得：<br>$$<br>ax + by = 1<br>$$<br>反之，如果ax
                    + by =
                    1，则a，b互素。
                  </p>
                  <p><strong>定理11.16</strong> 设gcd(a, b) = 1，a和b都整除c，则ab整除c。</p>
                  <p><strong>定理11.17</strong> 设a|bc 且 gcd(a, b) = 1，则 a|c。</p>
                  <p><strong>推论11.18</strong> 设一素数 p 整除积 ab，即 p|a 或 p|b。</p>
                  <h3 id="算术基本定理-1"><a href="#算术基本定理-1" class="headerlink"
                                                                                                    title="算术基本定理"></a>算术基本定理
                  </h3>
                  <p>定理11.19（算术基本定理）每个整数n(n &gt; 1)都能被唯一的（不计顺序）表示成素数的积。</p>
                  <p>n的分列式中的素数一定要不同，因此把所有相等的素数结合起来，n可表示为下列形式：</p>
                  <p>$$<br>n = p_1^{m_1} p_2^{m_2} \cdots p_r^{m_r}<br>$$</p>
                  <p>式中 m_i 是正数，且 p1 &lt; p2 &lt; … &lt; pr，上式称为n的标准分解式。</p>
                  <h3 id="同余关系"><a href="#同余关系" class="headerlink"
                                                                                                    title="同余关系"></a>同余关系
                  </h3>
                  <p>设m是一正整数，如果 m 能整除 a - b，我们说a，b 模 m 同余，记为：<br>$$<br>a \equiv
                    b(\text{modulo}\
                    m), a \equiv b (\text{mod}\ m)<br>$$</p>
                  <p>整数m称为模。</p>
                  <p><strong>定理11.20</strong> 设m是一个正整数，那也：<br> 1. 对于任意整数a，有 a
                    \equiv a (mod
                    m)；（自反关系）<br> 2. 如果 a \equiv b(mod m)，那么 b \equiv a(mod
                    m)；（对称关系）<br> 3.
                    如果 a
                    \equiv b(mod m)，b\equiv c(mod m)，那么 a \equiv c(mod
                    m)；（传递关系）。</p>
                  <p>注： 设 m 是正数，a 是任意整数，由带余除法，存在整数 q 和 r(0 &lt;= r &lt; m)，使得 a
                    = mq + r，因此：
                  </p>
                  <p>$$<br>mq = a - r, m \mid (a - r), a \equiv r(\text{mod}
                    m)<br>$$</p>
                  <p>于是</p>
                  <pre><code>1. 任意整数 a 模 m 都与下列集合中唯一一个整数同余</code></pre>
                  <p>$$<br> {0, 1, 2, \cdots, m - 1}<br>$$<br>
                    唯一性可由m不能整除集合中的两个整数的差推得。</p>
                  <pre><code>2. 任意两个整数 a 和 b 模 m 同余，当且仅当 它们除以 m 所得余数相同。</code></pre>
                  <h3 id="剩余类"><a href="#剩余类" class="headerlink"
                                                                                                    title="剩余类"></a>剩余类
                  </h3>
                  <p>模m同余是一个等价关系，那么它就把整数集Z分成了互不相交的等价类，我们称之为
                    模剩余类。<br>一个剩余类由所有的被m除余数相同的数组成，因此有m个这样的剩余类并且每一个剩余类都恰恰含有余数集中的一个整数：
                  </p>
                  <p>{0, 1, …, m - 1}</p>
                  <p>一般地，如果每一个 a_ i 取自一个不同的剩余类，一个由 m 个整数组成的集合 {a1, a2, …, a_m }
                    称为 模m的完全剩余系。
                  </p>
                  <p>因此，从 0 到 m - 1 的整数构成了一个完全剩余类。事实上，任何 m 个连续的整数都构成一个模m的完全剩余类。
                  </p>
                  <p>记号 [x]_m 或 [x] 表示 包含 x 的模 m 的剩余类，也就是那些和 x 同余的整数，换句话说，</p>
                  <p>$$<br>[x] = {a \in Z; a \equiv x (\text{mod} m)}<br>$$</p>
                  <p><strong>同余的计算</strong></p>
                  <p>定理11.21 设 a \equiv c(mod m), b \equiv d(mod m)，那么<br> 1. a
                    + b \equiv c
                    + d
                    (mod m)<br> 2. a * b \equiv c * d (mod m)</p>
                  <p><strong>剩余类的运算</strong></p>
                  <p>模的剩余类的加法和乘法定义如下：</p>
                  <p>$$<br>[a] + [b] = [a + b], [a] * [b] = [ab]<br>$$</p>
                  <p><strong>模m的整数Z_m</strong></p>
                  <p>模m的整数记为 Z_m，指的是集合：</p>
                  <p>$$<br>Z_m = {0, 1, 2, 3, …, m - 1}<br>$$</p>
                  <p>其上加法和乘法是通过模m的运算定义的，换句话说，是剩余类上的相应运算。<br>因此：<br>Z_m 与
                    模m剩余类的运算没有本质的区别，因此可以通用。
                  </p>
                  <p><strong>同余的消去律</strong></p>
                  <p>定理11.22（修正的消去律）<br>$$<br>ab \equiv ac(\text{mod}\ m)，
                    \text{gcd}(a, m)
                    = 1
                    \implies b \equiv c (\text{mod}\ m)<br>$$</p>
                  <p>定理11.23<br>$$<br>ab \equiv ac (\text{mod}\ m) \land d =
                    \text{gcd}(a,
                    m)
                    \implies b \equiv c(\text{mod}\ m/ d)<br>$$</p>
                  <p>注：设ｐ为素数，则整数 1 到 p - 1 都与 p
                    互素，这样通常消去律当模为素数p时满足，也就是说：<br>$$<br>ab \equiv
                    ac(\text{mod}\ p) \land a \not\equiv 0(\text{mod}\ p)
                    \implies b \equiv
                    c(\text{mod}\ p)<br>$$<br>这样 Z_p ，模素数 p 的整数在数论上起到了特殊的作用。</p>
                  <p><strong>简化剩余系和欧拉函数</strong></p>
                  <p>
                    与m互素的剩余类的个数即从1到m（不包括m）中与m互素的数的个数记为：<br>$$<br>\varnothing(m)<br>$$
                  </p>
                  <p>函数O(m)称为 欧拉函数，1 到 m 中与 m
                    互素的整数，<br>或更一般地，任何O(m)个与m互素的不同余的整数列称为模m的简化剩余系。
                  </p>
                  <p><strong>定理11.24</strong> 欧拉函数是可乘的，即若 a，b互素，那么：</p>
                  <p>$$<br>\varnothing(ab) = \varnothing(a)\varnothing(b)<br>$$
                  </p>
                  <h2 id="同余式"><a href="#同余式" class="headerlink"
                                                                                                    title="同余式"></a>同余式
                  </h2>
                  <p>一个同余多项式方程 或 称一个同余方程（关于未知数x）是如下形式的方程：<br>$$<br>a_ {n} x^n +
                    a_ {n - 1} x
                    ^{n -
                    1} + \cdots + a_ {1} x + a_ {0} \equiv 0 (\text{mod}\
                    m)<br>$$</p>
                  <p>这样的一个方程称为 n 次的，如果a_n \not\equiv 0 (\text{mod} 0).</p>
                  <p>设 s \equiv t(\text{mod}\ m)，那么 s 是方程的解当且仅当 t
                    是方程的解。<br>这样，方程的解的个数即为不同余的解的个数，即在下面集合中解的个数：<br>$$<br>{ 0 ,
                    1, 2, \cdots,
                    m - 1
                    }<br>$$</p>
                  <p>
                    这样，方程的<strong>完全解</strong>是不同余的解的最大集合，而方程的一般解则是所有满足的解，一般解可以通过把所有m的倍数加到完全解上得到。
                  </p>
                  <p><strong>定理11.25</strong> 如果 a 和 m 互素，那么 ax \equiv 1
                    (\text{mod}\
                    m)有唯一解，否则无解。
                  </p>
                  <p><strong>线性同余方程</strong></p>
                  <p>考虑更一般的同余方程<br>$$<br>ax \equiv b(\text{mod}\ m), a\not\equiv
                    0(\text{mod}\
                    m)<br>$$<br><strong>定理11.26</strong> 设 a 和 m 互素，那么 ax \equiv
                    b(\text{mod}\
                    m)有唯一解，另外，如果s是ax\equiv 1(\text{mod}\ m)的唯一解，那么：<br>$$<br>x =
                    bs<br>$$<br>是 ax
                    \equiv b(\text{mod}\ m)的唯一解。</p>
                  <p><strong>定理11.27</strong> 设方程 ax \equiv b(\text{mod}\ m), d
                    =\text{gcd}(a, m)
                  </p>
                  <ol>
                    <li>
                      <p>若 d 不整除 b，则 ax \equiv b(\text{mod\ m})无解</p>
                    </li>
                    <li>
                      <p>若 d 整除 b，则 ax\equiv b(\text{mod}\ m)有 d 个解，它们模 m
                        与下列方程的唯一解同余<br>$$<br>Ax
                        \equiv B(\text{mod}\ M)<br>$$<br>其中，A = a/d, B = b/d，M =
                        m/d。</p>
                      <p>因为gcd(A, M) = 1，所以可运用定理11.26求Ax=B(mod M)的解。</p>
                    </li>
                  </ol>
                  <h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink"
                                                                                                    title="中国剩余定理"></a>中国剩余定理
                  </h3>
                  <p><strong>定理11.28（中国剩余定理）</strong> 设有方程组(*)
                    $$<br>x \equiv r_1 (\text{mod}\ m_1), x \equiv
                    r_2(\text{mod}\ m_2),
                    \cdots, x
                    \equiv r_k (\text{mod}\ m_k)<br>$$</p>
                  <p>m_i 两两互素，那么方程组有一模 M = m_1 m_2 … m_k 的唯一解。</p>
                  <p><strong>命题11.29</strong> 考虑以上同余方程组(*)，设 M = m1 m2 …
                    m_k，且<br>$$<br>M_1
                    =
                    \frac{M}{m_1}, M_2 = \frac{M}{m_2}, \cdots, M_k =
                    \frac{M}{m_k}<br>$$
                  </p>
                  <p>(那么每一对 m_i 和 m_j 互素)，设 s_1, s_2, …，s_k是下列还以方程的解</p>
                  <p>$$<br>M_1 x\equiv 1 (\text{mod}\ m_1), M_2 x \equiv
                    1(\text{mod}\ m_2),
                    \cdots, M_k x \equiv 1 (\text{mod}\ m_k)<br>$$</p>
                  <p>那么：<br>$$<br>x_0 = M_1 s_1 r_1 + M_2 s_2 r_2 + \cdots + M_k
                    s_k
                    r_k<br>$$<br>是方程组的解。</p>
                  <h1 id="附录-8"><a href="#附录-8" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <h2 id="术语表"><a href="#术语表" class="headerlink"
                                                                                                    title="术语表"></a>术语表
                  </h2>
                  <ul>
                    <li>自然数，正整数 natural numbers/ positive integers</li>
                    <li>整数 integers</li>
                    <li>序 order</li>
                    <li>不等式 inequalities</li>
                    <li>绝对值 aboslute value</li>
                    <li>三分律 Law of Trichotomy</li>
                    <li>数法归纳法 mathematical induction</li>
                    <li>整除 division, divide</li>
                    <li>素数 primes</li>
                    <li>因数 divisor</li>
                    <li>公因数 common divisor</li>
                    <li>最大公因数 greatest common divisor</li>
                    <li>最小公倍数 least common multiple</li>
                    <li>互素 relatively prime integers</li>
                    <li>算术基本定理 Fundamental Theorem of Arithmetic</li>
                    <li>同余关系 congruence relation</li>
                    <li>模 modulus</li>
                    <li>剩余类</li>
                    <li>完全剩余类</li>
                    <li>简化剩余系</li>
                  </ul>
                  <h1 id="代数系统"><a href="#代数系统" class="headerlink"
                                                                                                    title="代数系统"></a>代数系统
                  </h1>
                  <h2 id="重点难点"><a href="#重点难点" class="headerlink"
                                                                                                    title="重点难点"></a>重点难点
                  </h2>
                  <ul>
                    <li>同余关系</li>
                    <li>半群的定义</li>
                    <li>半群同态</li>
                    <li>半群的直积</li>
                    <li>群的定义</li>
                    <li>对称群<h1 id="代数系统-1"><a href="#代数系统-1" class="headerlink"
                                                                                                        title="代数系统"></a>代数系统
                      </h1>
                    </li>
                  </ul>
                  <h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算
                  </h2>
                  <p>设 S 是一个非空集合，集合 S 上的一个运算是 S\times S 到 S 的一个函数
                    *，通常记：<br>$$<br>a * b,
                    ab<br>$$<br>而不记为 *(a, b)。<br>集合 S 和 S 上的一个运算 * 记为 (S, *)
                    或当运算明确时简记为 S。
                  </p>
                  <p><strong>注</strong> 一个从 S\times S 到 S 上的运算 * 有时称为
                    <strong>二元运算</strong>。<strong>一元运算</strong>是从 S 到 S 的函数。</p>
                  <h3 id="运算的性质"><a href="#运算的性质" class="headerlink"
                                                                                                    title="运算的性质"></a>运算的性质
                  </h3>
                  <h4 id="结合律"><a href="#结合律" class="headerlink"
                                                                                                    title="结合律"></a>结合律
                  </h4>
                  <p>对于集合 S 上的运算 *， 如果 S 中的任意元素 a，b，c，有：<br>$$<br>(a * b) * c =
                    a * (b *
                    c)<br>$$<br>则称为<strong>可结合的</strong>或满足<strong>结合律</strong>。
                  </p>
                  <p>一般地，如果一个运算不是可结合的，则可有许多方法构成一个积。</p>
                  <p><strong>定理</strong> 设 * 是集合 S 上的一个可结合的运算，那么任何积 a1 * a2 * ….
                    * an
                    无须加括号。也就是说所有可能的积都相等。</p>
                  <h4 id="交换律"><a href="#交换律" class="headerlink"
                                                                                                    title="交换律"></a>交换律
                  </h4>
                  <p>集合 S 上的运算 * 称为可交换的，或满足交换律，如果对于S中任意元素 a，b 有：<br>$$<br>a * b
                    = b *
                    a<br>$$</p>
                  <h3 id="单位元-和-逆元"><a href="#单位元-和-逆元" class="headerlink"
                                                                                                    title="单位元 和 逆元"></a>单位元
                    和 逆元</h3>
                  <p>如果存在 S 中的元素 e，对于 S 中的任意元素a，有：<br>$$<br>a * e = e * a =
                    a<br>$$<br>被称为 *
                    的单位元。
                  </p>
                  <p>$$<br>\exist e in S \implies \forall a in S \to a * e = e *
                    a = a<br>$$
                  </p>
                  <p>更一般的，对于 S 中的任意元素a，如果 e * a = a，则 e 称为左单位元；如果 a * e = a，则 e
                    称为右单位元。</p>
                  <p><strong>定理</strong> 设 e 是左单位元，f 是右单位元，那么 e =
                    f。<br>（即，单位元是唯一的）</p>
                  <p><strong>逆元</strong> 设集合 S 上的运算 * 有 单位元，那么 S 中元素 a 的逆元
                    是元素b，满足：<br>$$<br>a * b
                    = b * a = e<br>$$</p>
                  <p>如果运算是可结合的，那么 a 的逆元若存在则唯一。<br>显然，如果 b 是 a 的逆元，a 也是 b
                    的逆元，因此逆元是一个对称关系。我们也可以说 a
                    和 b 互逆。</p>
                  <p><em>注</em> 如果 S 上的运算记成 a * b，a\times b, a\dot b 或 ab，则称 S
                    为<strong>乘法式</strong>结构，S 中元素 a 的逆记为 a^-1。<br>如果运算记为 +，则称 S
                    为<strong>加法式</strong>结构。在这种情况下，单位元通常记为
                    0，称之为<strong>零元素</strong>。a 的逆元记为
                    -a，且称为a的<strong>负元素</strong>。</p>
                  <h3 id="消去律"><a href="#消去律" class="headerlink"
                                                                                                    title="消去律"></a>消去律
                  </h3>
                  <p>对于集合 S 上的运算 *，如果有：<br>$$<br>a * b = a * c \implies b =
                    c<br>$$<br>称 S
                    满足<strong>左消去律</strong>。
                    如果有：<br>$$<br>b * a = c * a \implies b = c<br>$$<br>称 S
                    满足<strong>右消去律</strong>。</p>
                  <h2 id="群"><a href="#群" class="headerlink" title="群"></a>群
                  </h2>
                  <p>设 G 是定义了二元运算（用并置表示）的非空集合，如果G满足下列的公理：</p>
                  <ul>
                    <li><strong>结合律</strong> 对任何元素 a，b，c \in G，有 (ab)c = a(bc)
                    </li>
                    <li><strong>单位元</strong> 存在元素 e \in G，使得对于G中任一个元素a，有 ae = ea
                      = a</li>
                    <li><strong>逆元</strong> 对每个元素 a \in G，存在一个元素 a^-1 \in
                      G（a的逆元），使得 aa^-1 =
                      a^-1
                      a = e</li>
                  </ul>
                  <p>则称 G 为群。</p>
                  <p>若群 G 满足交换律，即对任意的 a，b \in G，有 ab = ba，则称 G 为阿贝尔群（或 交换群）。</p>
                  <p>当二元运算如上并置定义时，称 G 为乘法群；当 G 是阿贝尔群时，运算记为 +，称 G
                    为加法群。<br>此时单位元记为0，称为零元素，逆元记为-a，称为负元素。</p>
                  <p>群 G 中元素的个数记为 |G|，称为 G 的阶。若其阶是有限的，称G为有限群。</p>
                  <p>如果 A 和 B 是 G 的子集，则记：<br>$$<br>AB = {ab: a\in A, b\in B} 或 A
                    + B = {a +
                    b:
                    a\in A, b\in B}<br>$$</p>
                  <h3 id="对称群-S-n"><a href="#对称群-S-n" class="headerlink"
                                                                                                    title="对称群 S_n"></a>对称群
                    S_n</h3>
                  <p>从集合 {1, 2, 3, …, n} 到自身的 1-1映射 称为置换，记为：<br>$$<br>\sigma =
                    \begin{pmatrix}<br>1 &amp; 2 &amp; 3 &amp; \cdots &amp; n
                    \<br>j_1 &amp;
                    j_2
                    &amp; j_3 &amp; \cdots &amp;
                    j_n<br>\end{pmatrix}<br>$$<br>其中，j_i =
                    \sigma(i)。
                  </p>
                  <p>所有置换的集合记为 S_n，共有 n! 个元素（P(n, n) = \frac{n!}{(n - n)!} =
                    n!）。<br>S_n
                    中置换的 复合**
                    和 <strong>逆</strong> 均在 S_n 中，并且单位函数 \epsilon 也在 S_n 中，这样
                    S_n
                    在函数复合运算下构成群，我们称之为 <strong>n阶对称群</strong>。</p>
                  <h2 id="MAP-A-PERM-A-和-AUT-A"><a href="#MAP-A-PERM-A-和-AUT-A" class="headerlink"
                                                                                                    title="MAP(A), PERM(A) 和 AUT(A)"></a>MAP(A),
                    PERM(A) 和 AUT(A)</h2>
                  <p>设 A 是一非空集合，所有的函数（映射）f: A \to 组成的集合 MAP(A)
                    在函数的复合下是半群，但它是不是群，因为有些函数没有逆元。<br>但是，所有的 A 到自身的 1-1
                    映射（称为“置换”）组成的 MAP(A)
                    的子半群
                    PERM(A) 在函数的复合下构成群。</p>
                  <p>设 A 含有某些几何和代数结构，那么所有 A 到自身的同构映射（称为 A 的自同态）所组成的集合
                    <strong>AUT(A)</strong>
                    在函数的复合下也构成群。</p>
                  <h2 id="子群，正规子群和同态"><a href="#子群，正规子群和同态" class="headerlink"
                                                                                                    title="子群，正规子群和同态"></a>子群，正规子群和同态
                  </h2>
                  <p>设 H 是 群G 的一个子集，如果在 G 的运算下 H 本身也是群，那么 H 称为 G 的子群。</p>
                  <p><strong>性质</strong> 群 G 的子集 H 是 G 的子群，如果：</p>
                  <ol>
                    <li>单位元 e \in H</li>
                    <li>在 G 的运算下 H 封闭，即如果 a, b \in H，那么 a * b \in H</li>
                    <li>H 对逆元封闭，即如果 a \in H，那么 a_{-1} \in H</li>
                  </ol>
                  <p>每个群 G 都以 {e} 和 G 自身为其子群，G 的其他子群都称为 <strong>非平凡子群</strong>。
                  </p>
                  <p><strong>陪集</strong></p>
                  <p>如果 H 是 G 的子群，且 a \in G，那么集合：<br>$$<br>Ha = {ha: h \in
                    H}<br>$$</p>
                  <p>称为 H 的右陪集。<br>类似的， aH 称为 H 的左陪集。</p>
                  <p><strong>定理</strong> 设 H 是群 G 的子群，那么右陪集 Ha 构成一个 G
                    的划分。<br><strong>定理（拉格朗日）</strong> 设 H 是有限群 G 的子群，则 H 的阶整除 G
                    的阶。<br><strong>定理</strong> G 中 H 的右陪集的数目（称为 H 在 G
                    中的<strong>指标</strong>）等于 G 中
                    H 的左陪集的数目，且两者都等于 |G| 除以 |H|。</p>
                  <p><strong>正规子群</strong></p>
                  <p>如果 G 的一个子群 H，对于任意 a \in G，有 a^{-1} Ha \subseteq H，那么 H
                    称为正规子群。<br>等价地，H
                    是正规的，如果对于每个 a \in G，有 aH = Ha，即左陪集和右陪集相等。</p>
                  <p>阿贝尔群的每个子群都是正规的。</p>
                  <p><strong>定理</strong> 设 H 是群 G 的一个正规子群，那么 H
                    的陪集在陪集乘法<br>$$<br>(aH)(bH) =
                    abH<br>$$<br>下构成群。称为<strong>商群</strong>，记作 G/H。</p>
                  <p>设 G 中的运算是加法或者说 G 是加法式的，那么 G 的子群 H 的陪集形如 a + H，而且，如果 H 是 G
                    的正规子集，那么 H
                    的陪集在：<br>$$<br>(a + H) + (b + H) = (a + b) +
                    H<br>$$<br>下形成群。</p>
                  <p>##　半群</p>
                  <p>设 S 是定义了一个运算的<strong>非空集合</strong>，若该运算是可结合的，则称 S
                    为半群；若该运算还有一个单位元，则称 S
                    为幺半群。
                  </p>
                  <h3 id="自由半群，自由幺半群"><a href="#自由半群，自由幺半群" class="headerlink"
                                                                                                    title="自由半群，自由幺半群"></a>自由半群，自由幺半群
                  </h3>
                  <p>设 F = F(A) 表示 A 上所有字符串在连接运算下的集合，显然对于任意串 u，v，w，串(uv)w 和
                    u(vw)是一样的；它们都是由u，v，w一个接一个地写成的。因此 F 是一个半群，称为 A
                    上的<strong>自由半群</strong>；A
                    的元素，称为
                    F 的<strong>生成元</strong>。</p>
                  <p>空序列记为 \lambda，也看做 A 上的一个串，但我们不能认为\lambda属于 自由半群 F =
                    F(A)。<br>A 上所有的串包括
                    \lambda 记为 A *。于是 A * 是连接下的一个幺半群，称为 A 上的自由幺半群。</p>
                  <h3 id="子半群"><a href="#子半群" class="headerlink"
                                                                                                    title="子半群"></a>子半群
                  </h3>
                  <p>设 A 是半群 S 的一个非空子集，如果 A 本身对于 S 上的运算是一个半群，则称 A 为 S 的一个子半群。因为
                    A 中的元素也是 S
                    的元素，A
                    中的元素自然满足结合行。</p>
                  <p>因此 A 是一个子半群当且仅当 其在 S 的运算下封闭。</p>
                  <h3 id="同余关系和商结构"><a href="#同余关系和商结构" class="headerlink"
                                                                                                    title="同余关系和商结构"></a>同余关系和商结构
                  </h3>
                  <p>设 S 是一个半群，~ 是 S 上的一个等价关系。回顾等价关系，可以把集合 S 分成等价类，且用[a]表示含有集合 S
                    中的元素 a
                    的等价类，等价类的集合记为：S/~。</p>
                  <p>假设 S 上的等价关系有下面的性质：<br>$$<br>a ~ a’, b ~ b’ \implies ab ~
                    a’b’<br>$$</p>
                  <p>那么 ~ 称为 S 上的同余关系。而且可以定义等价类上的一个运算：<br>$$<br>[a] * [b] = [a *
                    b], [a] [b]
                    =
                    [ab]<br>$$</p>
                  <p>并且这个 S/~ 上的运算是可结合的，因此，S/~ 是一个<strong>半群</strong>。</p>
                  <p><strong>定理</strong> 设 ~ 是半群 S 上的一个同余关系，那么 ~ 的等价类 S/~
                    关于运算<br>$$<br>[a]
                    [b] =
                    [ab]<br>$$<br>构成一个半群。这个半群 S/~ 称为由 ~生成的商群。</p>
                  <h3 id="半群的同态"><a href="#半群的同态" class="headerlink"
                                                                                                    title="半群的同态"></a>半群的同态
                  </h3>
                  <p>考虑两个半群(S, *) 和 (S’, *‘)，函数 f: S\to
                    S’，称为半群同态，或简称同态，如果：<br>$$<br>f(a *
                    b) =
                    f(a) *‘ f(b) 或 f(ab) = f(a)f(b)<br>$$<br>假设 f 是单射的，满射的，则 f
                    称为 S 与 S’
                    之间的一个同构，S
                    和 S’ 称为同构半群，记作：<br>$$<br>S\cong S’<br>$$</p>
                  <h3 id="半群同态的基本定理"><a href="#半群同态的基本定理" class="headerlink"
                                                                                                    title="半群同态的基本定理"></a>半群同态的基本定理
                  </h3>
                  <p><strong>定理</strong> 设 f: S\to S’ 是一个半群同态，如果 f(a) = f(b)，今 a
                    ~ b，则</p>
                  <p>i. ~ 是S 上的同余关系；<br>ii. S/~ 同构于 f(S)；</p>
                  <h3 id="半群的积"><a href="#半群的积" class="headerlink"
                                                                                                    title="半群的积"></a>半群的积
                  </h3>
                  <p>设 (S1, *1) 和 (S2, *2) 是两个半群，我们构造一个新半群 S = S1 \otimes S2，称为
                    S1 和 S2
                    的直积，如下：
                  </p>
                  <ol>
                    <li>S 中的元素来自 S1\times S2，即 S 中的元素是有序偶 (a,b), a\in S1, b\in
                      S2；</li>
                    <li>S 中的运算 * 定义为分量两两相乘，即：<br>$$<br>(a, b) * (a’, b’) = (a
                      *_1 a’, b *_2
                      b’)
                    </li>
                  </ol>
                  <p>$$</p>
                  <p>或简记为：</p>
                  <p>$$<br>(a, b)(a’, b’) = (aa’, bb’)</p>
                  <p>$$<br>（可证明，上面的运算是可结合的。）</p>
                  <h1 id="附录-9"><a href="#附录-9" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <h2 id="术语-8"><a href="#术语-8" class="headerlink"
                                                                                                    title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>运算 operation</li>
                    <li>结合律 associative law</li>
                    <li>交换律 commutative law</li>
                    <li>单位元 identity element</li>
                    <li>逆元 inverse</li>
                    <li>乘法式 multiplicatively</li>
                    <li>加法式 additively</li>
                    <li>负(元素) negative</li>
                    <li>消去律 cancellation law</li>
                    <li>左消去律 left cancellation law</li>
                    <li>右消去律 right cancellation law</li>
                    <li>半群 semigroup</li>
                    <li>幺半群 monoid</li>
                    <li>自由半群 free semigroup</li>
                    <li>生成元 generator</li>
                    <li>自由幺半群 free monoid</li>
                    <li>子半群 subsemigroup</li>
                    <li>（运算）封闭 closed</li>
                    <li>同余关系 congruence relation</li>
                    <li>商群 quotient</li>
                    <li>半群同态 semigroup homomorphism</li>
                    <li>同构 isomorphism</li>
                    <li>同构半群 isomorphic semigroup</li>
                    <li>半群的积 semigroup products</li>
                    <li>群 group</li>
                    <li>阿贝尔群 abelian group (commutative group)</li>
                    <li>乘法式 multiplicatively</li>
                    <li>加法式 additively</li>
                    <li>有限群 finite group</li>
                    <li>子群 subgroup</li>
                    <li>正规子群 normal subgroup</li>
                    <li>同态 homomorphism</li>
                    <li>商群 quotient group</li>
                  </ul>
                  <h5 id="operation-ts"><a href="#operation-ts" class="headerlink"
                                                                                                    title="operation.ts"></a>operation.ts
                  </h5>
                  <p>// 使用 Typescript 的泛型来表示“运算”</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">type Op&lt;T&gt; = (a: T, b: T) =&gt; T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 四则运算</span><br><span class="line">let plus: Op&lt;number&gt; = (a, b) =&gt; a + b</span><br><span class="line">let minus: Op&lt;number&gt; = (a, b) =&gt; a - b</span><br><span class="line">let multiply: Op&lt;number&gt; = (a, b) =&gt; a * b</span><br><span class="line">let divide: Op&lt;number&gt; = (a, b) =&gt; a / b</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h1 id="形式语言、形式语法和自动机"><a href="#形式语言、形式语法和自动机" class="headerlink"
                                                                                                    title="形式语言、形式语法和自动机"></a>形式语言、形式语法和自动机
                  </h1>
                  <p>难点：</p>
                  <ul>
                    <li>正则表达式</li>
                    <li>形式语言，正则语言</li>
                    <li>有限状态自动机</li>
                    <li>Kleene定理</li>
                    <li>Pumping引理</li>
                    <li>形式语法</li>
                    <li>形式语法的分类</li>
                    <li>有限状态机</li>
                    <li>Turing机<h1 id="形式语言、形式语法和自动机-1"><a href="#形式语言、形式语法和自动机-1" class="headerlink"
                                                                                                        title="形式语言、形式语法和自动机"></a>形式语言、形式语法和自动机
                      </h1>
                    </li>
                  </ul>
                  <h2 id="字母表，字符串，自由半群"><a href="#字母表，字符串，自由半群" class="headerlink"
                                                                                                    title="字母表，字符串，自由半群"></a>字母表，字符串，自由半群
                  </h2>
                  <p>字母表：非空符号集合（通常记作A）</p>
                  <p>字符串：字母表元素中的有限序列（通常记作 w, u, v）</p>
                  <p>空串：没有字符的序列（通常使用希腊字母 lambda 或 epsilon表示）</p>
                  <p>A 中所有字符串的集合记为 A*（读作 A 星）</p>
                  <p>字符串长度：记作 |u| 或 l(u)，表示 字符串u 中字符的个数。l(\lambda) = 0.</p>
                  <h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接
                  </h3>
                  <p>对于字母表A中的两个字符串 u 和 v，连接 u 和 v 记作 uv，表示字符串 v 紧接着写在字符串 u 之后。
                  </p>
                  <p>定理13.1 字母表A中的字符串的连接运算满足结合律，空串是运算中的单位元。<br>（一般地，运算的交换律不成立）
                  </p>
                  <h3 id="子串，前缀"><a href="#子串，前缀" class="headerlink"
                                                                                                    title="子串，前缀"></a>子串，前缀
                  </h3>
                  <p>子串：对于任意字符串 u = a1 a2 … an,任何序列 w = a_ {j} a_ {j+1} … a_k
                    称作u的子串。<br>前缀：子串 w =
                    a1 a2 … ak，以u的字符开头，称作 u 的前缀。</p>
                  <h3 id="自由半群，自由幺半群-1"><a href="#自由半群，自由幺半群-1" class="headerlink"
                                                                                                    title="自由半群，自由幺半群"></a>自由半群，自由幺半群
                  </h3>
                  <p>
                    自由半群：用F表示字母表A中所有非空字符串的集合，并且含有连接运算。由于连接运算满足结合律，因此F是一个<strong>半群</strong>。
                    称作 <em>A 的自由半群</em> 或 <em>由 A 生成的自由半群</em>。
                    当需要标明集合A时，A的自由半群记作 F_A。</p>
                  <p>自由幺半群：设 M = A*
                    是包括空串lambda在内的A中所有字符串的集合。由于lambda是连接运算的单位元，M是含幺半群，我们称
                    M为A上的自由幺半群。</p>
                  <p>$$<br>F_A = A^* - {\lambda}<br>$$</p>
                  <h2 id="形式语言"><a href="#形式语言" class="headerlink"
                                                                                                    title="形式语言"></a>形式语言
                  </h2>
                  <p>形式语言：字母表 A 中的字符串的集合 称为 A 上的形式语言 L。</p>
                  <p>因此，形式语言 L 是 A* 的一个子集。</p>
                  <h3 id="形式语言的运算"><a href="#形式语言的运算" class="headerlink"
                                                                                                    title="形式语言的运算"></a>形式语言的运算
                  </h3>
                  <p>假设 L 和 M 是 A 的形式语言，那么 L 和 M 的连接，记为 LM，是 A 上的一种形式语言，定义如下：
                  </p>
                  <p>$$<br>LM = {uv: u \in L, v \in M}<br>$$</p>
                  <p>形式语言的幂：形式语言 L 的幂定义如下：</p>
                  <p>$$<br>L^0 = {\lambda}, L^1 = L, L^2 = LL, L^{m + 1} =
                    L^mL(m &gt;
                    1)<br>$$
                  </p>
                  <p>一元运算 L* （读作 “L星”），称作 L 的 Kleene 闭包，<br>$$<br>L^* = L^0 \cup
                    L^1 \cup
                    L^2 \cup
                    \cdots = \cup_{k = 0}^{\infty} L^k<br>$$</p>
                  <p>定理13.2 L* 的定义与 A* 一致。</p>
                  <p>此外，记号 L+ 表示：<br>$$<br>L^+ = L^* - L^0<br>$$</p>
                  <h2 id="正则表达，正则语言"><a href="#正则表达，正则语言" class="headerlink"
                                                                                                    title="正则表达，正则语言"></a>正则表达，正则语言
                  </h2>
                  <p><strong>定义</strong> 下面每一项均为字母表A中的正则表达：</p>
                  <pre><code>1. 符号\lambda（空串） 和括号()（空表达）是正则表达；
2. A中每个字母a是正则表达
3. 如果r是正则表达，那么(r*)是正则表达
4. 如果 r1 和 r2 是正则表达，那么 (r1 \lor r2)是正则表达；
5. 如果 r1 和 r2 是正则表达，那么 (r1r2) 是正则表达；</code></pre>
                  <p> 注意： 正则表达r 是一种特殊的字符串，它用A中的字符和如下五种符号：<br>$$<br> ( ) * \lor
                    \lambda<br>$$<br>
                    此外，没有其它符号用于正则表达。</p>
                  <p><strong>定义</strong> A 上的形式语言 L(r) 由正则表达 r 定义如下：<br> 1.
                    L(\lambda) =
                    {\lambda}
                    和 L(()) = \emptyset（空集）<br> 2. L(a) = a，其中 a 是 A 中的字符串<br>
                    3. L( r* ) =
                    (L(r))* ；L(r) 的 Kleen闭包<br> 4. L(r1 \lor r2) = L(r1) \cup
                    L(r2)；
                    形式语言的并集<br>
                    5. L(r1 r2) = L(r1)L(r2) (形式语言的连接)</p>
                  <p><strong>定义</strong> 设 L 为 A 的形式语言，若存在 A 上的一正则表达式，使得 L =
                    L(r)，则L称为 A
                    的正则语言。
                  </p>
                  <h2 id="有限自动机"><a href="#有限自动机" class="headerlink"
                                                                                                    title="有限自动机"></a>有限自动机
                  </h2>
                  <p>有限自动机(FSA)，或者简单地说，自动机 M，由下述五部分组成：<br> 1.
                    一个有限的输入集合A（字母表）<br> 2.
                    （内部的）一个有限状态集合S<br> 3. S 的一个子集Y（Y的元素称为接受状态, yes）<br> 4.
                    S的初始状态s_0<br> 5.
                    S中的状态转移函数 F:S \times A -&gt; S</p>
                  <p>当要指明它的五部分时，自动机M被记为：<br>$$<br>M = (A, S, Y, s_0, F)<br>$$
                  </p>
                  <p>状态转移函数：<br>对每个 a \in A，定义 f_a: S \to S；即每一个输入a可看作引起自动机 M
                    的状态改变。<br>F(s,
                    a) =
                    f_a(s) 表示两个定义是等价的。</p>
                  <h3 id="自动机-M-的状态图"><a href="#自动机-M-的状态图" class="headerlink"
                                                                                                    title="自动机 M 的状态图"></a>自动机
                    M 的状态图</h3>
                  <p>自动机通常使用它的状态图 D = D(M) 来定义，而不是列出它的五个部分。状态图 D = D(M)
                    是如下的一种带标记的有向图。<br>
                    1. D(M)
                    的结点是 S 的状态，接受状态用双圈表示<br> 2. 在 D(M) 中，若 F(s_ j, a) = s_ k 或
                    f_ a(s_ j) =
                    s_
                    k，则用一个标有输入a的箭头从 s_ j 指向 s_ k<br> 3. 初始状态 s_ 0
                    是通过一特殊的箭号表示，这个箭号终止于 s_
                    0，但是没有初始结点。</p>
                  <h3 id="自动机-M-决定的形式语言-L-M"><a href="#自动机-M-决定的形式语言-L-M" class="headerlink"
                                                                                                    title="自动机 M 决定的形式语言 L(M)"></a>自动机
                    M 决定的形式语言 L(M)</h3>
                  <p>每一个有输入字母表 A 的自动机 M 定义 A 上的一种形式语言 L(M) 如下：<br>设 w = a1 a2 …
                    am
                    为A中的一字符串，则 w
                    确定一状态序列：</p>
                  <p>$$<br>s_0 \to s_1 \to s_2 \to \cdots \to s_m<br>$$</p>
                  <p>其中 s_0 为初始状态且 F(s_{i - 1}, a_i) = s_i(i &gt;= 1)，
                    换句话说，w确定了状态图 D(M)
                    的路径：<br>$$<br>P = (s_0, a_1, s_1, a_2, s_2, \cdots, a_m,
                    s_m)<br>$$</p>
                  <p>如果最后状态 s_m 是 Y 中的接受状态，则说 M 识别字符串 w。<br>M 的形式语言 L(M) 为 A中被 M
                    接受的所有字符串的集合。</p>
                  <p>定理 13.2（Kleene） 字母表 A 上的形式语言 L 是正则的当且仅当存在一个有限自动机 M 使得 L =
                    L(M)。</p>
                  <p>（形式语言 L 上的 * 运算 L* 有时称作 L 的 Kleene 闭包）。</p>
                  <h3 id="Pumping引理"><a href="#Pumping引理" class="headerlink"
                                                                                                    title="Pumping引理"></a>Pumping引理
                  </h3>
                  <p>定理13.3 （Pumping引理） 假设 M 是 A 上的自动机并满足：<br> 1. M 有 k 个状态<br>
                    2. M 接受 A
                    的字符串
                    w，这里 |w| &gt; k<br> 那么 w = xyz，这里对每一个正整数m，w_m = xy^m z 被 m
                    接受。</p>
                  <h2 id="形式语法"><a href="#形式语法" class="headerlink"
                                                                                                    title="形式语法"></a>形式语法
                  </h2>
                  <p>一个<strong>短语结构形式语法</strong>，简称形式语法G，由四个部分构成：<br> 1.
                    一个有限集（<strong>词汇</strong>）V；<br> 2. V 的一个子集T，T
                    的元素称为<strong>终结元</strong>；集合 N
                    = V\T 的元素称为 <strong>非终结元</strong> 或 <strong>变元</strong>；
                    3. 一个非终结符 S 称为<strong>起始符</strong>；
                    4. 一个产生式的有限集 P。产生式是一个有序偶(\alpha, \beta)，通常记作 \alpha \to
                    \beta，
                    其中\alpha，\beta是
                    V 上的字符串；P 中的每个产生式的左端必须至少包括一个非终结元。<br> 这样的形式语法 G，记作 G = G(V,
                    T, S, P)</p>
                  <p>除特别说明外，形式语法用下面的记法：终结元用斜体小写拉丁字母表示；非终结元用斜体大写拉丁字母表示；起始符用 S
                    表示；同时，V
                    中的字符串，即终结元 或
                    非终结元 的字符串用希腊字母表示，此外，将：<br>$$<br>\alpha \to \beta _1, \alpha
                    \to \beta
                    _2,
                    \cdots, \alpha \to \beta _k
                    $$</p>
                  <p>记作：</p>
                  <p>$$<br>\alpha \to (\beta _1, \beta _2, \cdots, \beta
                    _k)<br>$$</p>
                  <h3 id="形式语法-G-的形式语言-L-G"><a href="#形式语法-G-的形式语言-L-G" class="headerlink"
                                                                                                    title="形式语法 G 的形式语言 L(G)"></a>形式语法
                    G 的形式语言 L(G)</h3>
                  <p>假设 w 和 w’ 是形式语法 G 的词汇集合 V 上的字符串，如果 w’ 能够由 w
                    通过使用一个产生式得到，我们写成：<br>$$<br>w
                    \Rightarrow w’<br>$$</p>
                  <p>即，如果存在字符串 u 和 v，使得 w = u \alpha v 且 w’ = u\beta v，并且有一个产生式
                    \alpha \to
                    \beta，我们写成：<br>$$<br>w \Rightarrow \Rightarrow w’, w^*
                    \Rightarrow
                    w’<br>$$<br>如果 w’ 能够由 w 通过使用有限个产生式得到。</p>
                  <p>设 G 是一个形式语法，T 是 G 的终结元集。G 的形式语言，记作 L(G)；由初始符 S 通过以上过程得到 T
                    上的字符串组成，即：<br>$$<br>L(G) = { w \in T^*: s
                    \Rightarrow\Rightarrow w
                    }<br>$$</p>
                  <h3 id="形式语法的类型"><a href="#形式语法的类型" class="headerlink"
                                                                                                    title="形式语法的类型"></a>形式语法的类型
                  </h3>
                  <h4 id="Noam-Chomsky分类法"><a href="#Noam-Chomsky分类法" class="headerlink"
                                                                                                    title="Noam Chomsky分类法"></a>Noam
                    Chomsky分类法</h4>
                  <p>形式语法根据所允许的产生式的种类来分类。<br>以下是 Noam Chomsky 提出的形式语法的分类：<br> 0.
                    一个零型形式语法在产生式上没有限制；<br> 1. 第一类型：如果形式语法 G 所有的产生式都是<br>$$<br>
                    \alpha \to
                    \beta(|\alpha| \leq |\beta|), \alpha \to \lambda<br>$$</p>
                  <ol start="2">
                    <li>
                      <p>第二类型：如果形式语法 G 所有的产生式都是<br>$$<br>A \to
                        \beta<br>$$<br>即其中左端是一个非终结元的形式</p>
                    </li>
                    <li>
                      <p>第三类型：如果形式语法 G 所有的产生式都是：</p>
                    </li>
                    <li>
                      <p>$$<br>A \to a, A \to aB, S \to
                        \lambda<br>$$<br>即左端是一个非终结元，右端是一个终结元或一个终结元后跟一个非终结元；或起始符到空串。
                      </p>
                    </li>
                  </ol>
                  <p>
                    可以看出，形式语法分类形式一个阶层组织，即第三类型的形式语法都是第二类型的；第二类型的形式语法都是第一类型的；第一类型的形式语法都是零类型形式语法。
                  </p>
                  <h4 id="上下文相关性分类"><a href="#上下文相关性分类" class="headerlink"
                                                                                                    title="上下文相关性分类"></a>上下文相关性分类
                  </h4>
                  <p>形式语法也可以分类成上下文有关的法语、上下文无关的语法、正则的语法：</p>
                  <ol>
                    <li>
                      <p><strong>上下文相关的语法</strong>：一个形式语法
                        G，如果它的产生式都是：<br>$$<br>\alpha A
                        \alpha ‘
                        \to \alpha \beta \alpha ‘<br>$$<br>称它是“上下文相关的”，是因为只有当变元A
                        在 \alpha 与
                        \alpha’ 之间时，才总可以用\beta 来取代A。</p>
                    </li>
                    <li>
                      <p><strong>上下文无关的语法</strong>： 一个形式语法
                        G，如果它的产生式都是：<br>$$<br>A \to
                        \beta<br>$$<br>称它为“上下文无关的”，是因为无论变元A在什么位置，我们总可以用 \beta
                        来取代 A。</p>
                    </li>
                    <li>
                      <p>
                        <strong>正则的语法</strong>：一个形式语法是正则的，如果它的产生式都是这样的形式：<br>$$<br>A
                        \to a,
                        A \to
                        aB, S \to \lambda<br>$$</p>
                    </li>
                  </ol>
                  <p>可以看出，上下文无关的形式语法与第二类型形式语法是第个的，正则形式语法与第三类型形式语法是等价的。</p>
                  <p><strong>定理13.4</strong> 形式语言 L 能由第三类型（正则）形式语法 G
                    生成，当且仅当存在一个有限自动机 M 能够接受
                    L。<br>因此，一个形式语法是正则的，当且仅当 L = L(r)，其中r 是正则表达式；当且仅当 L =
                    L(M)，其中 M
                    是有限状态自动机；当且仅当
                    L = L(G)，其中 G 是正则形式语法。</p>
                  <h3 id="上下文无关语法的导出树"><a href="#上下文无关语法的导出树" class="headerlink"
                                                                                                    title="上下文无关语法的导出树"></a>上下文无关语法的导出树
                  </h3>
                  <p><strong>导出树</strong>：一个上下文无关的形式语法G，L(G) 中的字符串 w
                    的导出可以用有序、有根的树 T
                    来形象地描述，称为导出树。
                  </p>
                  <h3 id="Backus-Naur形式"><a href="#Backus-Naur形式" class="headerlink"
                                                                                                    title="Backus-Naur形式"></a>Backus-Naur形式
                  </h3>
                  <p>在描述上下文无关的形式语法（第二类型形式语法）的产生式时，有时也用另外一种词法，称作
                    Backus-Naur形式。它的特点在于：</p>
                  <pre><code>1. 不用 \to 而用 ::= ；
2. 非终结元要用 &lt;&gt; 括起来；
3. 所有左端有相同非终结元的产生式要合并成一句，所有的右端在 ::= 的右边列出并用短竖隔开；</code></pre>
                  <h3 id="自动机与形式语法"><a href="#自动机与形式语法" class="headerlink"
                                                                                                    title="自动机与形式语法"></a>自动机与形式语法
                  </h3>
                  <p>正则形式语法对应有限状态自动机（FSA）。此外，还有其他形式的自动机，对应其他形式的语法。<br> 1.
                    <strong>Pushdown自动机</strong>：Pushdown自动机 P 与 FSA 类似，且 P
                    有一个辅助储存器能为它提供无限大容量的存储空间。<br> 形式语言L能被Pushdown自动机识别，当且仅当 L 是
                    <em>上下文无关</em>
                    的形式语言。<br> 2. <strong>线性有界自动机</strong>：线性有界自动机 B 比
                    Pushdown自动机的功能更强，这样的自动机 B
                    使用一种带子，这种带子是根据输入字符串 w 的字长而线性有界的。<br> 形式语言L 能被自动机B识别当且仅当 L 是
                    <em>上下文有关</em>
                    的。<br> 3.
                    <strong>Turing自动机</strong>：Turing自动机，使用的是一种无限长的带子，它能识别由任何短语结构形式语法
                    G
                    生成的所有形式语言。 事实上，Turing自动机 M 是一系列定义可数函数的等价方法中的一种。</p>
                  <h2 id="有限状态机"><a href="#有限状态机" class="headerlink"
                                                                                                    title="有限状态机"></a>有限状态机
                  </h2>
                  <p>
                    有限状态机（FSM）与有限状态自动机（FSA）类似，只是FSM输出时使用一种与输入字母表不同的输出字母表。正式定义如下：<br>有限状态机（或完全序列机）M由六个部分组成：<br>
                    1. 一个输入符的有限集 A<br> 2. 一个内部状态的有限集 S<br> 3. 一个输出符的有限集 Z<br> 4.
                    S 中的一个初始状态
                    s_0<br> 5. 一个从 S\times A 到 S 状态转移函数 f<br> 6. 一个从 S\times A 到
                    Z 的输出函数
                    g<br>
                    这样的一个机器 M 被记作<br>$$<br>M = M(A, S, Z, s_0, f, g)<br>$$</p>
                  <h3 id="有限状态机的状态表与状态图"><a href="#有限状态机的状态表与状态图" class="headerlink"
                                                                                                    title="有限状态机的状态表与状态图"></a>有限状态机的状态表与状态图
                  </h3>
                  <p>描述有限状态机的方法通常有两种：一种是用表格，称作有限状态机 M
                    的状态表；另一种是用有标记的有向图，称作有限状态机的状态图。</p>
                  <p><strong>状态表</strong>：状态表把状态转移函数 f 与 输出函数 g
                    放在同一个表格内，这个表格描述了由<br>$$<br>F(s_i,
                    a_j) = (f(s_i, a_j), g(s_i,
                    a_j))<br>$$<br>定义的函数<br>$$<br>F:S\times A
                    \to S
                    \times Z<br>$$</p>
                  <p><strong>状态图</strong>：有限状态机 M = M(A, S, Z, s_0, f, g) 的状态图 D
                    = D(M)
                    是一个有标记的有向图。D的结点是M的状态。此外，如果：<br>$$<br>F(s_i, a_j) = (s_k,
                    z_r)<br>$$<br>亦即：<br>$$<br>f(s_i, a_j) = s_k \land g(s_i,
                    a_j) =
                    z_r<br>$$<br>那么，从 s_i 到 s_k 就有一条标着 a_j 和 z_r 的箭头。我们通常放输入符
                    a_j 靠近箭头的始端（靠近
                    s_i），输出符 z_r 靠近箭头的中心。此外，还通过另外画一条指向 s_0 的箭头来标记初始状态 s_0。</p>
                  <h3 id="输入与输出带"><a href="#输入与输出带" class="headerlink"
                                                                                                    title="输入与输出带"></a>输入与输出带
                  </h3>
                  <p>设定给 M 一个输入符的字符串，如：<br>$$<br>u = a_1 a_2 \cdots
                    a_m<br>$$<br>我们设想这些符号在一条“输入带”上，机器M一个一个地读这些输入符，同时进行一系列的状态转换：<br>$$<br>V
                    =
                    s_0
                    s_1 s_2 \cdots s_m<br>$$<br>其中 s_0
                    是初始状态，并且把输出符的字符串<br>$$<br>w = z_1 z_2
                    \cdots z_m<br>$$<br>打印在一条“输出带”上。准确地说，初始状态 s_0 和输入字符串 u
                    通过<br>$$<br>s_i =
                    f(s_{i - 1}, a_i), z_i = g(s_{i - 1}, a_i)<br>$$<br>来决定字符串 v
                    和 w，其中 i =
                    1, 2,
                    …, m。</p>
                  <h3 id="二进制加法"><a href="#二进制加法" class="headerlink"
                                                                                                    title="二进制加法"></a>二进制加法
                  </h3>
                  <p><strong>定理13.5</strong> 没有一种有限状态机能做二进制乘法。</p>
                  <h2 id="Godel数"><a href="#Godel数" class="headerlink"
                                                                                                    title="Gödel数"></a>Gödel数
                  </h2>
                  <p>Gödel数：任何正整数 n (n &gt; 1)
                    都能唯一地（除顺序外）写成素数的乘积，把数字的有限序列进行了编码，也把在有限或可数的字母表A上的字符上的字符串进行编码。每个序列或字符串按下面规则对应的正整数，叫做
                    Gödel数：<br>非负整数序列 s = (n_1, n_2, …, n_k) 的Gödel数是正整数 c(s)，其中
                    n_i 是 c(s)
                    的素数分解式中 p_i 的指数，即：<br>$$<br>c(s) = p_1^{n_1} p_2^{n_2}
                    \cdots
                    p_k^{n_k}<br>$$
                  </p>
                  <p>字母表 {a_0, a_1, a_2, a_3, …} 上的字符串 w 的 Gödel数 是正整数
                    c(w)，其中w的第i个字母的下标是c(w)的素数分解式中的 p_i 的指数。</p>
                  <p>（可以看出两种编码本质上是一样的，因为我们可以将字符串 w 看成是它的字母的下标的序列）。</p>
                  <p>定理13.6 如果字母表 A 是可数的，那么 A 上的所有形式的语言 L 都是可数的。</p>
                  <h2 id="Turing机"><a href="#Turing机" class="headerlink"
                                                                                                    title="Turing机"></a>Turing机
                  </h2>
                  <p>基本定义</p>
                  <p>一个Turing机包括三个不交的非空集：</p>
                  <ol>
                    <li>一个有限带集合：<br>$$<br>A = {a_1, a_2, \cdots, a_m} \cup
                      {B}<br>$$<br>这里 B
                      =
                      a_0，是“空格”符</li>
                    <li>一个有限状态集：<br>$$<br>S = {s_1, s_2, \cdots, s_n} \cup {s_0}
                      \cup {s_H,
                      s_Y,
                      s_N}<br>$$<br>这里 s_0 是初始状态。另外 SH(HALT)是停止状态, SY(YES)是接受状态,
                      SN(NO)是不接受状态。
                    </li>
                    <li>一个有向集<br>$$<br>d = {L, R, N}<br>$$<br>这里 L
                      表示“左”，R表示“右”，N表示“无运动”或“静止”。
                    </li>
                  </ol>
                  <p><strong>定义13.1</strong> <strong>表达</strong>是 A \cup S \cup
                    d
                    中的元素的一个有限（可能空）序列。</p>
                  <p><strong>定义13.2</strong> <strong>带表达</strong>是只使用带集 A
                    中元素的表达。</p>
                  <p><strong>定义13.3</strong> 一个格局 \alpha
                    是这样一个形状的表达：<br>$$<br>\alpha = P s_i
                    a_k
                    Q<br>$$<br>此处，P 和Q 是带表达（可能是空的）。</p>
                  <p><strong>定义13.4</strong> 设 \alpha = P s_i a_k Q 是一个格局，我们说
                    Turing机M 处于
                    s_i 状态，而
                    s_i 扫描字母 a_k，在线带上的表达是表达 P a_k Q，也就是没有状态符号 s_i 的 \alpha。</p>
                  <p><strong>定义13.5</strong> Turing机M是有限的五元组集合，满足：<br> 1.
                    没有两个五元组以相同的两个字母开始；<br>
                    2. 没有一个五元组是以 s_H, s_Y 或 s_N 开始；</p>
                  <p>下面是另一个等价的定义：<br><strong>定义13.6</strong> Turing机M
                    是一个部分函数：<br>$$<br>S\setminus{s_H, s_Y, s_N} \times A \to A
                    \times S
                    \times
                    d<br>$$<br>部分函数。简单地说，是表示 M 的定义域为<br>$$<br>S\setminus {s_H,
                    s_Y,
                    s_N}\times
                    A<br>$$<br>的子集。</p>
                  <p><strong>定义13.7</strong> 设 \alpha 和 \beta
                    是两个格局，我们写作：<br>$$<br>\alpha
                    \to
                    \beta<br>$$<br>如果下面中任何一个成立，此外 a,b,c 是线索字母，而P 和Q是线索表达（可能是空的）：
                  </p>
                  <ol>
                    <li>\alpha = Ps_i aQ, \beta = Ps_j bQ 和 M 包含着五元组 q = s_i ab
                      s_j N；</li>
                    <li>\alpha = Ps_i acQ, \beta = Pbs_j cQ 和 M 包含着五元组 q = s_i
                      abs_j R；</li>
                    <li>\alpha = Pcs_i aQ, \beta = Ps_j cbQ 和 M 包含着五元组 q = s_i
                      abs_j L；</li>
                    <li>\alpha = Ps_i a，\beta = Pbs_jB 和 M 包含着五元组 q = s_i abs_j
                      R；</li>
                    <li>\alpha = s_i aQ，\beta = s_jBbQ 和 M 包含着五元组 q = s_i abs_j
                      L；</li>
                  </ol>
                  <p>注意，在所有五种情况中，M用b在线带中代替了 a（此外我们允许 b = a），M改变了它的状态，从s_i 到
                    s_j（此处我们允许s_j =
                    s_i），还有：</p>
                  <ol>
                    <li>这里M不移动</li>
                    <li>这里M向右移动</li>
                    <li>这里M向左移动</li>
                    <li>这里M向右移动，但是，因为 M 正扫描最右面的字母，它必须在右边加上空格符B</li>
                    <li>这里M向左移动，但是，因为 M 正扫描最左面的字母，它必须在左边加上空格符B</li>
                  </ol>
                  <p><strong>定义13.8</strong> 格局\alpha 是终止的，如果没有格局\beta，使得\alpha
                    \to \beta。
                  </p>
                  <h3 id="用Turing机计算"><a href="#用Turing机计算" class="headerlink"
                                                                                                    title="用Turing机计算"></a>用Turing机计算
                  </h3>
                  <p><strong>定义13.9</strong> Turing机 的一个计算是一列格局 \alpha_0,
                    \alpha_1, …,
                    \alpha
                    <em>m，满足 \alpha</em>{i - 1} \to \alpha_{i} (i = 1, …, m) 以及
                    \alpha_m
                    是终止格局。<br>换句话说，一个计算是一个序列：<br>$$<br>\alpha_0 \to \alpha_1 \to
                    \alpha_2
                    \to
                    \cdots \alpha_m<br>$$<br>这个序列不能再延续，因为 a_m 是终止的。我们用
                    term(\alpha)来表示以
                    \alpha
                    开始的计算的最后格局，因此，在上面的计算中，term(\alpha_0) = \alpha_m</p>
                  <h3 id="Turing机的输入"><a href="#Turing机的输入" class="headerlink"
                                                                                                    title="Turing机的输入"></a>Turing机的输入
                  </h3>
                  <p><strong>定义13.10</strong> Turing机 M 的一个输入是一个线索表达 W。输入W的初始格局是
                    \alpha(W)，此处
                    \alpha(W) = s_0 W。</p>
                  <p><strong>定义13.11</strong> 设 M 是一个Turing机，W
                    是一个输入，如果有一个计算以初始格局
                    \alpha(W)开始，我们说
                    M 停止于 W 处。<br>也就是，给出一个输入W，我们能形成初始格局 \alpha(W) = s_0 W，并且应用 M
                    去获得一个序列：<br>$$<br>\alpha(W) \to \alpha_1 \to \alpha_2 \to
                    cdots<br>$$<br>两种情况可能发生：</p>
                  <ol>
                    <li>M 停止在 W 处，也就是说，序列在终止格局 \alpha_r处结束</li>
                    <li>M 在 W 处 没有停止，也就是说，序列不会结束</li>
                  </ol>
                  <h3 id="形式语法和Turing机"><a href="#形式语法和Turing机" class="headerlink"
                                                                                                    title="形式语法和Turing机"></a>形式语法和Turing机
                  </h3>
                  <p><strong>定理13.7</strong> 形式语言 L 能被 Turing机 M 识别，当且仅当 L 是一个类型
                    0 的形式语言。
                  </p>
                  <h2 id="可计算的函数"><a href="#可计算的函数" class="headerlink"
                                                                                                    title="可计算的函数"></a>可计算的函数
                  </h2>
                  <p>用N来表示正整数的集合，记 N_0：<br>$$<br>N_0 = { 0, 1, 2, 3, \cdots
                    }<br>$$</p>
                  <p><strong>定义13.12</strong> 每个数字 n 将通过带表达<n>表示；此处<n> = 1^{n +
                        1}，这样：<br>$$<br>\langle 0\rangle = 1, \langle 2\rangle =
                        111 = 1^3,
                        \langle 4\rangle = 11111 = 1^5<br>$$</n>
                    </n>
                  </p>
                  <p><strong>定义13.13</strong> 设E是一个表达，那么[E]将用来表示在 E
                    中1出现的次数，因此：<br>$$<br>[11B s_2
                    a_3 111Ba_4] = 5, [a_4 s_2 B a_2] = 0, [\langle n \rangle] =
                    n + 1<br>$$
                  </p>
                  <p><strong>定义13.14</strong> 函数 f: N_0 \to N_0 是可计算的，如果存在一个
                    Turing机 M
                    使得对每个整数 n，M
                    停止在<n>并且：<br>$$<br>f(n) = [term(\alpha(\langle n
                      \rangle))]<br>$$<br>此时，说 M
                      计算了 f。</n>
                  </p>
                  <p><strong>定义13.8</strong> 假设 f: N_0 \to N_0，和 g: N_0 \to N_0
                    是可计算的，那么复合函数
                    h = g
                    * f 也是可计算的。</p>
                  <h3 id="多元函数"><a href="#多元函数" class="headerlink"
                                                                                                    title="多元函数"></a>多元函数
                  </h3>
                  <p><strong>定义13.15</strong> 每一个 k 个整数的目录 m = (n_1, n_2,
                    \cdots, n_k) 由带表达
                    <m>
                      表示，这里：<br>$$<br>\langle m \rangle = \langle n_1 \rangle B
                      \langle n_2
                      \rangle B \cdots B \langle n_k \rangle<br>$$<br>（因此，
                      &lt;(2,0,4)&gt; =
                      111B1B11111 = 1^3 B 1^1 B 1^5）</m>
                  </p>
                  <p><strong>定义13.16</strong> 一个k元函数f(n_1, n_2, \cdots, n_k)
                    是可计算的，如果存在一个Turing机M，使得对每一个目录 m = (n_1, n_2, …, n_k)，M 停止在
                    <m>
                      处，并且：<br>$$<br>f(m) = [term(\alpha(\langle m
                      \rangle))]<br>$$<br>那么我们说
                      M 可计算
                      f。</m>
                  </p>
                  <h1 id="附录-10"><a href="#附录-10" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <h2 id="术语表-1"><a href="#术语表-1" class="headerlink"
                                                                                                    title="术语表"></a>术语表
                  </h2>
                  <ul>
                    <li>字母表 alphabet</li>
                    <li>字符串 words</li>
                    <li>空串 empty word</li>
                    <li>连接 concatenation</li>
                    <li>子串 subword</li>
                    <li>前缀 intial segment</li>
                    <li>自由半群 free semigroup</li>
                    <li>自由幺半群 free monoid</li>
                    <li>形式语言 language</li>
                    <li>形式语言的连接 concatenation of languages</li>
                    <li>形式语言的幂 powers of a language</li>
                    <li>Kleene闭包 Kleene closure</li>
                    <li>正则表达 regular expression</li>
                    <li>正则语言 regular language</li>
                    <li>有限状态自动机 finite state automata (FSA)</li>
                    <li>Pumping引理 Pumping Lemma</li>
                    <li>形式语法 grammar</li>
                    <li>词汇 vocabulary</li>
                    <li>终结元 terminal</li>
                    <li>非终结元 non-ternimal</li>
                    <li>起始符 start symbol</li>
                    <li>产生式的有限集 finite set of productions</li>
                    <li>形式语法的类型 types of grammar</li>
                    <li>Noam Chomsky分类法</li>
                    <li>Type 0 grammar</li>
                    <li>Type 1 grammar</li>
                    <li>Type 2 grammar</li>
                    <li>Type 3 grammar</li>
                    <li>上下文相关语法 context-sensitive grammar</li>
                    <li>上下文无关语法 context-free grammar</li>
                    <li>正则语法 regular grammar</li>
                    <li>上下文无关语法的导出树 derivation trees of context-free grammars
                    </li>
                    <li>自动机 automata</li>
                    <li>Pushdown自动机 Pushdown Automata</li>
                    <li>线性有界自动机 Linear Bounded Automata</li>
                    <li>Turing自动机 Turing Machine</li>
                    <li>有限状态机 finite state machine</li>
                    <li>状态表 State Table</li>
                    <li>状态图 State Diagram</li>
                    <li>Gödel数 Gödel numbers</li>
                    <li>表达 expression</li>
                    <li>带表达 tape expression</li>
                    <li>格局 picture</li>
                    <li>终结 terminal</li>
                    <li>可计算的 computable</li>
                  </ul>
                  <h1 id="有序集与格"><a href="#有序集与格" class="headerlink"
                                                                                                    title="有序集与格"></a>有序集与格
                  </h1>
                  <p>难点：</p>
                  <ul>
                    <li>积集</li>
                    <li>积序</li>
                    <li>极小元素，极大元素，最小元素，最大元素</li>
                    <li>相容编号</li>
                    <li>上确界，下确界</li>
                    <li>格<h2 id="有限集"><a href="#有限集" class="headerlink"
                                                                                                        title="有限集"></a>有限集
                      </h2>
                    </li>
                  </ul>
                  <p><strong>偏序（序关系），偏序集（有序集）</strong></p>
                  <p>假设 R 是集合 S 的一种关系，它满足下面三个性质：</p>
                  <ul>
                    <li>[O_1]（返身性）对任何 a \in S，有 aRa；</li>
                    <li>[O_2]（反对称性）若 aRb 且 bRa，则 a = b；</li>
                    <li>[O_3]（传递性）若aRb 且 bRc，则 aRc；</li>
                  </ul>
                  <p>则称 R 为一个 <strong>偏序</strong> 或 简称一个
                    <strong>序关系</strong>。带有偏序关系 R 的集合 S
                    叫做一个偏序集，或简称为有限集。当我们要标明 R时，记作 (S, R)。</p>
                  <p>最常见的序关系叫 <strong>常序</strong>，如在实数R的子集中正整数 N 中的 “&lt;=”
                    关系（读作小于等于）。由此，一个偏序关系通常记作 \precsim，即：<br>$$<br>a \precsim
                    b<br>$$</p>
                  <p>读作“a 先于 b”。</p>
                  <p>类似的：<br>$$<br>a \prec b \iff a \precsim b \land a \neq
                    b<br>$$<br>读作：“a
                    严格先于
                    b”。<br>$$<br>b \succsim a \iff a \precsim b<br>$$<br>读作：“b
                    后于
                    a”。<br>$$<br>b
                    \succ a \iff a \prec b<br>$$<br>读作“b 严格后于 a”。</p>
                  <p>此外：<br>$$<br>\not\precsim, \not\prec, \not\succsim,
                    \not\succ<br>$$<br>的定义是自然的。</p>
                  <p>当不产生混淆时，常用符号<br>$$<br>\leq, &lt;, &gt;,
                    \geq<br>$$<br>分别替代符号：<br>$$<br>\precsim, \prec, \succ,
                    \succsim<br>$$
                  </p>
                  <p><strong>特性</strong></p>
                  <p>对于集合 S，偏序可能有多种。</p>
                  <p>对于集合 S，如 n(S) &gt; 1，则 S 上的完全关系（S^2）不是偏序。</p>
                  <p>对于集合 S，S 上的具有对称性的关系不是偏序。</p>
                  <h3 id="对偶序"><a href="#对偶序" class="headerlink"
                                                                                                    title="对偶序"></a>对偶序
                  </h3>
                  <p>设 \precsim 为集合 S 的任何偏序，关系 \succsim，即 a 后于 b，也是 S
                    的偏序，叫做对偶序。<br>显然，
                    a\precsim
                    b 当且仅当 b\succsim a；因此对偶序\precsim 是 \succsim 的逆，即\precsim =
                    \succsim^{-1}。</p>
                  <h3 id="有序子集"><a href="#有序子集" class="headerlink"
                                                                                                    title="有序子集"></a>有序子集
                  </h3>
                  <p>设 A 为有限集 S 的一个子集，假设 a, b \in A。在 A 中定义 a\precsim b 当且仅当在 S
                    中有 a\precsim
                    b。<br>A 的这个偏序叫 A 上的<strong>诱导序</strong>，带有诱导序的子集 A 被称为 S
                    的<strong>有序子集</strong>。
                    除非特殊说明，序集 S 的任何子集被认为是 S 的有序子集。</p>
                  <h3 id="半序"><a href="#半序" class="headerlink" title="半序"></a>半序
                  </h3>
                  <p>设定 \prec 是集合S上的一种关系，满足下面两个性质：</p>
                  <ul>
                    <li>[Q_1]（非返身性） 对任何 a \in A，有 a\not\prec a;</li>
                    <li>[Q_2]（传递性） 若 a\prec b 且 b\prec c，则a\prec c;<br> 那么，\prec
                      叫作 S 的半序。
                    </li>
                  </ul>
                  <p>偏序和半序有着紧密的联系，特别地，如果 \precsim 是集合S上的偏序，则 a \prec b 意为 a
                    \precsim b 且
                    a\neq
                    b，即\prec是S上的半序。反之，如果\prec 是 S 上的半序，则 a \precsim b 意为 a\prec
                    b 或 a = b，即
                    \precsim 是 S 上的偏序。</p>
                  <h3 id="可比较性，线性序集"><a href="#可比较性，线性序集" class="headerlink"
                                                                                                    title="可比较性，线性序集"></a>可比较性，线性序集
                  </h3>
                  <p>假设 a 和 b 是偏序集合 S 的元素，我们说 a 和 b 是可比较的，如果有：<br>$$<br>a
                    \precsim b \lor b
                    \succsim a<br>$$<br>即，一个先于另一个。否则，a 和 b 是不可比较的，记作：<br>$$<br>a
                    |
                    b<br>$$<br>即，既没有 a \precsim b 也没有 b \succsim a。</p>
                  <p>“偏”是用来定义偏序集 S，因为 S 的某些元素是不需要可比较的。换句话说，假设 S 的每一对元素都是可比较的，则 S
                    被称为
                    <strong>全序</strong> 或 <strong>线性序</strong>，且 S 被叫做一条链。尽管序集 S
                    可能不是线性序集，S的子集A仍有可能是线性序集。很明显，线性序集 S 的每一个子集一定是线性序。</p>
                  <h3 id="积集和积序"><a href="#积集和积序" class="headerlink"
                                                                                                    title="积集和积序"></a>积集和积序
                  </h3>
                  <p>有很多方法定义所给定有序集的笛卡尔积上的序关系，下面是其中的两个方法：</p>
                  <ol>
                    <li>
                      <p><strong>积序</strong><br>设 S 和 T 是有序集，那么下面是积集 S\times T
                        上的一种有序关系，称为积序：<br>$$<br>(a, b) \precsim (a’, b’),
                        a\precsim a’ \land
                        b
                        \precsim b’<br>$$</p>
                    </li>
                    <li>
                      <p><strong>字典排序</strong><br>设 S 和 T 是线性序集，那么下面积集 S \times
                        T
                        上的一种序关系，称为<strong>字典排序</strong>。
                        $$<br>(a, b) \precsim (a’, b’), a\prec a’ \lor (a = a’
                        \land b
                        \precsim
                        b’)<br>$$</p>
                      <p>这个序能推广到 S_1 \times S_2 \times \cdots \times \S_n
                        上：<br>$$<br>(a_1,
                        a_2,
                        \cdots, a_n) \prec (a_1’, a_2’, \cdots,
                        a_n’)<br>$$<br>对于 i = 1, 2,
                        …, k -
                        1 有 a_i = a_{i}’ 且 a_k &lt; a_k’。</p>
                    </li>
                  </ol>
                  <h3 id="Kleene闭包与序"><a href="#Kleene闭包与序" class="headerlink"
                                                                                                    title="Kleene闭包与序"></a>Kleene闭包与序
                  </h3>
                  <p>设 A（非空）是一个线性序字母表，回顾A^* ，称作 A 的Kleene闭包，由A中所有字符串w构成，|w| 表示 w
                    的长度，因此下面是
                    A^*
                    上的两个序关系。</p>
                  <ol>
                    <li>
                      <p><strong>字母排序</strong></p>
                      <ul>
                        <li>\lambda &lt; w，\lambda是空字符串，w 是任何非空字符串；</li>
                        <li>设 u = au’ 和 v = bv’ 是不同的字符串，a,b \in A, u’, v’ \in
                          A^*，那么：<br>$$<br>u
                          \prec v \iff a \prec b \lor (a = b \land u’ \prec
                          v’)<br>$$</li>
                      </ul>
                    </li>
                    <li>
                      <p><strong>长度-字母序</strong><br>这里 A^* 先按长度排，再按字母涛掉，即对A*
                        中任何不同字符串u，v<br>$$<br>u \prec v \iff |u| &lt; |v| \lor
                        (|u| = |v|
                        \land
                        \text{alphabetical-ordered}, u \prec v)<br>$$<br>这个序也称作
                        <strong>自由半群序</strong>。</p>
                    </li>
                  </ol>
                  <h2 id="偏序集的-Hasse图"><a href="#偏序集的-Hasse图" class="headerlink"
                                                                                                    title="偏序集的 Hasse图"></a>偏序集的
                    Hasse图</h2>
                  <p><strong>直接前元，直接继承</strong></p>
                  <p>设 S 是一个偏序集，且a，b属于 S。如果 a &lt; b，且在 S 中没有元素介于a 与 b 之间，即不存在 c
                    \in S，使得 a
                    &lt; c
                    &lt; b，则称 a 是 b 的一个直接前元，或 b 是 a 的一个直接继元，或 b 盖住
                    a，记作：<br>$$<br>a \ll
                    b<br>$$
                  </p>
                  <p>假定 S 是有限偏序集，如果我们知道 S 中所有 a \ll b 的元素对 (a, b)，则知道 S 上的\ll
                    关系，S
                    中的序将完全清楚。<br>因为：x &lt; y 当且仅当 x \ll y 或 在S中存在元素 a_1, a_2, …,
                    a_m，使得：<br>$$<br>x \ll a_1 \ll a_2 \ll \cdots a_m \ll
                    y<br>$$</p>
                  <p><strong>Hasse图</strong><br>Hasse图是有序偏序集 S 的直接图解，它的顶点是 S
                    的元素，当 a
                    &lt;&lt;
                    b时，从a 到 b 有一个有向边。（此时，将 b 置于高于 a
                    的地方,然后画一条线将它们连起来；即，向上运动引起后元）。<br>因此，
                    在图中，从点x 到
                    y 有一有向路，当且仅当 x &lt; y。同样，在S的图中没有环，没有序关系是反对称的。</p>
                  <h3 id="极大元素，极小元素，最小元素和最大元素"><a href="#极大元素，极小元素，最小元素和最大元素" class="headerlink"
                                                                                                    title="极大元素，极小元素，最小元素和最大元素"></a>极大元素，极小元素，最小元素和最大元素
                  </h3>
                  <p>设 S 为一个偏序集，a 为 S 中的一个元素，</p>
                  <p><strong>极小元素</strong>：如果 S 中没有其他元素严格先于
                    a。<br><strong>极大元素</strong>：如果 S
                    中没有其他元素严格后于 a。</p>
                  <p>（S 中可以有多于一个极小元素和极大元素；如果 S 是无限的，那么 S 可能没有极小或极大元素，即，如果 S
                    是有限的，那么 S
                    一定至少有一个极小元素和一个极大元素）</p>
                  <p><strong>最小元素</strong>：如果对于 S 中的每一个元素 x，有<br>$$<br>a
                    \precsim
                    x<br>$$<br>即 a
                    先于 S 中其他每一个元素。</p>
                  <p><strong>最大元素</strong>：如果对于 S 中的每一个元素 x，有<br>$$<br>a
                    \succsim
                    x<br>$$<br>即 a
                    后于 S 中其他每一个元素。</p>
                  <p>（S 至多有一个最小元素，它一定是极小元素；S 中至多有一个最大元素，它一定是极大元素。总的说来，甚至在 S
                    是有限时，S
                    可能既无最小元素，也无最大元素。例如当 S 中的存在多个极小元素或极大元素当且相互之间不可比较时。）</p>
                  <h2 id="相容编号"><a href="#相容编号" class="headerlink"
                                                                                                    title="相容编号"></a>相容编号
                  </h2>
                  <p>设 S 是一个有限偏序集，对 S 中的每一个元素指派一个正整数，使得序关系能够保持。即求一个函数 f: S \to N
                    使得，如果 a
                    \prec b,
                    那么 f(a) &lt; f(b)，这样的函数被称为 S 的相容编号。</p>
                  <p><strong>定理14.1</strong> 任何有限偏序集 A 存在相容编号。</p>
                  <h2 id="上确界-和-下确界"><a href="#上确界-和-下确界" class="headerlink"
                                                                                                    title="上确界 和 下确界"></a>上确界
                    和 下确界</h2>
                  <p>设 A 是偏序集 S 的一个子集，M 是 S 中的元素，<br><strong>上界</strong>：如果 M 后于
                    A 中的每一个元素，即
                    对于 A
                    中的每一个 x，有：<br>$$<br>x \precsim M<br>$$<br>M 叫做 A 的一个上界。</p>
                  <p><strong>上确界</strong>：如果A的一个上界先于 A 的其他每个上界，那么它叫做 A
                    的上确界，记为：<br>$$<br>sup(A)<br>$$<br>如果 A 含有元素 a_1, …, a
                    _m，我们也将 sup(A)
                    记作：<br>$$<br>sup(a_1, \cdots, a_n)<br>$$</p>
                  <p>我们强调至多只有一个上确界sup(A)；当然 sup(A) 也可能不存在。</p>
                  <p>设 A 是偏序集 S 的一个子集，m 是 S 中的元素，<br><strong>下界</strong> 如果 m 后于
                    A 中的每一个元素，即
                    对于 A
                    中的每一个 x，有：<br>$$<br>x \succsim m<br>$$<br>M 叫做 A 的一个上界。</p>
                  <p><strong>下确界</strong>：如果 A 的一个下界后于 A 的其他每个下界，那么它叫做 A
                    的下确界，记为：<br>$$<br>inf(A)<br>$$<br>如果 A 含有元素 a_1, …, a
                    _m，我们也将 inf(A)
                    记作：<br>$$<br>inf(a_1, \cdots, a_n)<br>$$</p>
                  <p>我们强调至多只有一个下确界 inf(A)；当然 inf(A) 也可能不存在。</p>
                  <p>有的书使用 最小上界 代替 上确界，写作 lub(A)；用 最大下界 代替 下确界，写作 glb(A)。</p>
                  <p>如果 A 有一个上界，我们称 A 是<strong>上有界</strong>的；如果 A 有一个下界，我们称 A
                    是下有界的；特别地，如果A有上界和下界，A 是有界的。</p>
                  <h2 id="同构序集"><a href="#同构序集" class="headerlink"
                                                                                                    title="同构序集"></a>同构序集
                  </h2>
                  <p><strong>相似映射</strong> 假设 X 和 Y 是偏序集， f: X \to Y 是 A
                    的单射函数，如果f 保持序关系，即对于
                    X
                    中的任意元素 a 和 a’，下面两个条件成立：<br> 1. 若 a \precsim a’, 那么 f(a)
                    \precsim
                    f(a’)；<br> 2.
                    若 a || a’（不可比较），那么 f(a) || f(a’)；<br> 则 f 被叫做 X 到 Y
                    的相似映射。<br> （若A 和 B
                    是线性集，则只需要条件 1）</p>
                  <p><strong>同构</strong> 两个序集 X 和 Y 是同构的，如果存在一个保持序关系的双射 f: X \to
                    Y，即一个同构映射
                    f，记作：<br>$$<br>X \simeq Y<br>$$</p>
                  <h2 id="良序集"><a href="#良序集" class="headerlink"
                                                                                                    title="良序集"></a>良序集
                  </h2>
                  <p><strong>定义</strong> 如果序集 S 的每个一个子集都有最小元素，则 S 称为良序的。</p>
                  <h3 id="超限归纳法"><a href="#超限归纳法" class="headerlink"
                                                                                                    title="超限归纳法"></a>超限归纳法
                  </h3>
                  <p>设 A 是一个良序集 S 的子集，并具有以下两个性质：<br> 1. a_0 \in A；<br> 2. 如果
                    s(a) \subseteq
                    A，那么 a
                    \in A；<br> 则 A = S。<br> 此处的 a_0 是 S 中的最小元素，s(a) 称为 a 的前缀，即 S
                    中严格先于 a
                    的所有元素的集合。
                  </p>
                  <h3 id="选择公理，良序定理"><a href="#选择公理，良序定理" class="headerlink"
                                                                                                    title="选择公理，良序定理"></a>选择公理，良序定理
                  </h3>
                  <p><strong>选择函数</strong>：</p>
                  <p>设 { A_i : i \in I } 是一个非空的不交的集簇。<br>假设 A_i \subseteq X，函数
                    f: { A_i }
                    \to X
                    叫做一个<strong>选择函数</strong>，如果 f(A_i) = a_i \in A_i。<br>换句话说，f
                    为每个集合 A_i
                    选择一点
                    a_i \in A_i。</p>
                  <p><strong>选择公理</strong> 任何一个非空集合的非空集簇都存在一个选择函数。</p>
                  <p><strong>良序定理</strong> 每一个集合 S 都能成为良序集。</p>
                  <h2 id="格"><a href="#格" class="headerlink" title="格"></a>格
                  </h2>
                  <p>设 L 是对二元运算交 \land 和并 \lor 封闭的集合，如果对 L 中的任意元素a，b，c有：</p>
                  <ol>
                    <li>
                      <p>交换律：<br>$$<br>a \land b = b \land a, a \lor b = b \lor
                        a<br>$$</p>
                    </li>
                    <li>
                      <p>结合律：<br>$$<br>(a \land b)\land c = a \land (b \land c),
                        (a \lor
                        b)\lor c
                        = a \lor (b \lor c)<br>$$</p>
                    </li>
                    <li>
                      <p>吸收律：<br>$$<br>a \land (a\lor b) = a, a\lor (a \land b)
                        = a<br>$$
                      </p>
                    </li>
                  </ol>
                  <p>称 L 为格。记 (L, \land, \lor) 表示格 L。</p>
                  <h3 id="对偶律-和-幂等律"><a href="#对偶律-和-幂等律" class="headerlink"
                                                                                                    title="对偶律 和 幂等律"></a>对偶律
                    和 幂等律</h3>
                  <p>对偶：一个格 (L, \land, \lor) 中任何一个命题的对偶命题是通过互换 \land 和 \lor 得到的。
                  </p>
                  <p><strong>对偶原理</strong> 格 中任何一个定理的 对偶 还是 格 的一个定理。</p>
                  <p><strong>幂等律</strong> 1. a \land a = a 2. a \lor a = a</p>
                  <p>格 L 上的关系定义：<br>$$<br>a\land b = a \implies a \precsim
                    b<br>$$</p>
                  <p>$$<br>a\lor b = b \implies a \precsim b<br>$$</p>
                  <p><strong>定理14.4</strong> 设 L 是一个格，那么：<br> 1. a \land b = a
                    当且仅当 a\lor b
                    =
                    b；<br> 2. 关系 a \precsim b 是L的一个偏序；</p>
                  <p><strong>定理14.5</strong> 设 P 是一个偏序集使得对于任意a，b \in P，inf(a, b)
                    和 sup(a, b)
                    都存在，设
                    a\land b = inf(a, b), a\lor b = sup(a, b)。则 (P, \land,\ lor)
                    是一个格。进一步的，这个 格
                    推导出的偏序 与 原来的偏序 P 相同。</p>
                  <p><strong>替换定义</strong> 一个格是一个偏序集，在这个集合中，对任何一对元素 a 和
                    b：<br>$$<br>a \land
                    b =
                    inf(a, b) 和 a \lor b = sup(a, b)<br>$$<br>都存在。</p>
                  <h3 id="子格，同构格"><a href="#子格，同构格" class="headerlink"
                                                                                                    title="子格，同构格"></a>子格，同构格
                  </h3>
                  <p>假设 M 是格 L 的一个非空子集，</p>
                  <p>子格：若 M 本身也是一个格（关于 L 的运算），则 M 称为子格。</p>
                  <p>同构格：两个格 L 和 L’ 被认为是同构的，如果存在一个双射 f: L \to L’，使得对 L
                    中的任何元素a，b满足：<br>$$<br>f(a\land b) = f(a)\land f(b), f(a\lor
                    b) = f(a)
                    \lor
                    f(b)<br>$$</p>
                  <h2 id="有界格"><a href="#有界格" class="headerlink"
                                                                                                    title="有界格"></a>有界格
                  </h2>
                  <p>一个格 L 称为有下界 0，如果对 L 中任何元素 x 都有 0 \precsim x，类似地，L
                    称为是有上界I，如果对 L 中任何元素 x
                    都有任何元素 x 都有 x \precsim I。我们说 L 是有界的，如果 L 有下界 0 和上界
                    I。<br>在这样的格中，对于 L
                    中的任意元素a，我们有下面的恒等式：<br>$$<br>a\lor I = I, a \land I = a, a
                    \lor 0 = a, a
                    \land
                    0 = 0<br>$$</p>
                  <p>对于非负整数的常序；<br>$$<br>0 &lt; 1 &lt; 2 &lt; 3 &lt; 4 &lt;
                    \cdots<br>$$<br>有下界为
                    0，但没有上界。<br>全集U上所有子集构成的格 P(U) 是一个以 U 为上界，以 \emptyset
                    以下界的有界格。</p>
                  <p><strong>定理14.6</strong> 每一个有限格 L 都是有界的。</p>
                  <h2 id="分配格"><a href="#分配格" class="headerlink"
                                                                                                    title="分配格"></a>分配格
                  </h2>
                  <p>对于格 L，如果对于 L 中任何元素a，b，c，成立如下定律：</p>
                  <ol>
                    <li>分配律<br>$$<br>a \land (b \lor c) = (a\land b)\lor (a\land
                      c), a \lor
                      (b
                      \land c) = (a \lor b)\land (a \lor c)<br>$$</li>
                  </ol>
                  <p>则称为<strong>分配格</strong>；否则，L 是非分配的。</p>
                  <p><strong>定理14.7</strong> 格 L 是非分配格当且仅当它包含一个形如下列的同构的子格。</p>
                  <p> l<br> / <br>c <br>| b<br>a /<br> \ /<br> 0</p>
                  <p>或：</p>
                  <p> l<br> / | <br>a b c<br> \ | /<br> 0</p>
                  <h3 id="并不可约元素，原子"><a href="#并不可约元素，原子" class="headerlink"
                                                                                                    title="并不可约元素，原子"></a>并不可约元素，原子
                  </h3>
                  <p><strong>并不约元素</strong> 设 L 是一个以 0 为下界的格，对于L 中的一个元素 a，如果 a =
                    x \lor y蕴含着
                    a = x
                    或 a = y。<br>显然，0 是并不可约的当且仅当a有唯一的直接前元。</p>
                  <p><strong>原子</strong> 0 的 直接继元 叫原子，是并不可约的。</p>
                  <p><strong>定理14.8</strong> 设 L 是一个有限分配格，则 L 中的每一个元素 a
                    都可以唯一（不计顺序）地写成
                    两两不可比的
                    并不可约的 元素的并。</p>
                  <h2 id="补元，有补格"><a href="#补元，有补格" class="headerlink"
                                                                                                    title="补元，有补格"></a>补元，有补格
                  </h2>
                  <p><strong>补元</strong></p>
                  <p>设 L 是一个下界为 0，上界为 I 的有界格。a 是 L 中的一个元素，x 是 L
                    中的另一元素，如果：<br>$$<br>a \lor x
                    = I,
                    a \land x = 0<br>$$<br>x 叫做 a 的一个补元。<br>补元不一定存在也不一定唯一。</p>
                  <p><strong>定理14.9</strong> 设 L 是一个有界的分配格，如果补元存在，那么它也是唯一的。</p>
                  <h3 id="有补格"><a href="#有补格" class="headerlink"
                                                                                                    title="有补格"></a>有补格
                  </h3>
                  <p><strong>有补格</strong></p>
                  <p>如果格 L 是有界的，且 L 中的每一个元素都存在补元，则称 L 是有补格。</p>
                  <p><strong>定理14.10</strong> 设 L 是一个有唯一补元的有补格，那么 L 中的并不可约元素除 0
                    以外是它的原子。</p>
                  <p><strong>定理14.11</strong> 设 L 是一个有限的有补分配格，那么 L 中的每一个元素 a
                    都可以写成唯一的原子集合的并。
                  </p>
                  <h1 id="附录-11"><a href="#附录-11" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <h2 id="术语-9"><a href="#术语-9" class="headerlink"
                                                                                                    title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>自返性，返身性 reflexive</li>
                    <li>非返身性 irreflexive</li>
                    <li>反对称性 antisymmetric</li>
                    <li>传递性 transitive</li>
                    <li>偏序 partial order</li>
                    <li>序关系 order relation</li>
                    <li>偏序集 partially ordered set</li>
                    <li>有序集 ordered set, poset</li>
                    <li>常序 usual order</li>
                    <li>对偶序 dual order</li>
                    <li>诱导序 induced order</li>
                    <li>有序子集 ordered subsets</li>
                    <li>半序 quassi-order</li>
                    <li>可比较性 comparability</li>
                    <li>全序 totally ordered</li>
                    <li>线性序 linearly ordered</li>
                    <li>积集 product set</li>
                    <li>积序 product order</li>
                    <li>字典序 lexicographical order</li>
                    <li>Kleene闭包</li>
                    <li>字母序 alphabetical order</li>
                    <li>长度-字母序 short-lex order</li>
                    <li>直接前元 immediate predecessor</li>
                    <li>直接继承 immediate successor</li>
                    <li>盖住 cover</li>
                    <li>Hasse图 Hasse diagram</li>
                    <li>极大元素 minimal</li>
                    <li>极小元素 maximal</li>
                    <li>最小元素 first element</li>
                    <li>最大元素 last element</li>
                    <li>相容编号 consistent enumeration</li>
                    <li>上界 upper bound</li>
                    <li>上确界 supremum</li>
                    <li>下界 lower bound</li>
                    <li>下确界 infimum</li>
                    <li>最小上界 least upper bound</li>
                    <li>最大下界 greatest lower bound</li>
                    <li>上有界 bounded above</li>
                    <li>下有界 bounded below</li>
                    <li>有界 bounded</li>
                    <li>相似映射 similarity mapping</li>
                    <li>同构 isomorphic, similar</li>
                    <li>超限归纳法 transfinite induction</li>
                    <li>选择函数 choice function</li>
                    <li>选择公理 Axiom of Choice</li>
                    <li>良序定理 Well-Ordering Theorem</li>
                    <li>格 lattice<ul>
                        <li>交换律 Commutation law</li>
                        <li>结合律 Associative law</li>
                        <li>吸收律 Absorption law</li>
                        <li>对偶 dual</li>
                        <li>对偶律 Dulaity law</li>
                        <li>幂等律 Idempotent law</li>
                        <li>子格 sublattice</li>
                        <li>同构格 isomorphic lattice</li>
                        <li>分配格 distributive lattice</li>
                        <li>并不可约元素 irreducible element</li>
                        <li>原子 atom</li>
                        <li>补元 complement</li>
                        <li>有补格 complemented lattice</li>
                      </ul>
                    </li>
                  </ul>
                  <h3 id="examples-tex-1"><a href="#examples-tex-1" class="headerlink"
                                                                                                    title="examples.tex"></a>examples.tex
                  </h3>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">  \usepackage&#123;amsmath&#125;</span><br><span class="line">  \usepackage&#123;amssymb&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">  \item For a relation $R$ on $\mathbf&#123;Z&#125;$,</span><br><span class="line">  define $aRb$ if there is postive integer $r$ such that $a = b^r$.</span><br><span class="line">  Prove that R is a partial ordering of $\mathbf&#123;Z&#125;$.</span><br><span class="line"></span><br><span class="line">  \item Prove:</span><br><span class="line">  $</span><br><span class="line">  \forall a, b \in S, a\prec b \implies (a\precsim b \land a \neq b)</span><br><span class="line">  $.</span><br><span class="line"></span><br><span class="line">  \item Prove that quassi-ordered is not symmetry: $a\prec b \implies b \not\prec a$.</span><br><span class="line"></span><br><span class="line">  \item Prove: Suppose $S$ is finite poset with $n$ elements.</span><br><span class="line">  Then there exists a consistent enumeration $f: S\to \&#123;1, 2, \cdots, n\&#125;$.</span><br><span class="line"></span><br><span class="line">  \item Give an example of a finite nonlineraly ordered set $X = (A, R)$ which is</span><br><span class="line">  isomorphic to $Y = (A, R^&#123;-1&#125;)$, the set $A$ with the inverse order.</span><br><span class="line"></span><br><span class="line">  \item Prove the Principle of Transfinite Induction:</span><br><span class="line">  Let $A$ be a subset of a well-ordered set $S$</span><br><span class="line">  with the following two properties:</span><br><span class="line"></span><br><span class="line">  i. $a_0 \in A$, ii. $s(a) \subseteq A \implies a \in A$.</span><br><span class="line"></span><br><span class="line">  Then $A = S$.</span><br><span class="line"></span><br><span class="line">  \item Let $S$ be a well-ordered set. Let $f: S\to S$ be a similarity mapping of $S$ into $S$.</span><br><span class="line">  Prove that: $\forall a \in S \implies a \precsim f(a)$.</span><br><span class="line"></span><br><span class="line">  \item Let $A$ be a well-ordered set. Let $s(A)$ denote the collection of</span><br><span class="line">  all initial segments $s(a)$ of elements $a\in A$ ordered by set inclusion.</span><br><span class="line">  Prove: $A$ is isomorphic to $s(A)$ by showing that the map $f: A\to s(A)$,</span><br><span class="line">  defined by $f(a) = s(a)$, is a similarity mapping of $A$ onto $s(A)$.</span><br><span class="line"></span><br><span class="line">  \item Write the dual of each statement:</span><br><span class="line"></span><br><span class="line">  i. $(a\land b)\lor c = (b\lor c)\land(c\lor a)$;</span><br><span class="line">  ii. $(a\land b)\lor a = a\land(b\lor a)$.</span><br><span class="line"></span><br><span class="line">  \item Prove: Let $L$ be a lattice, then:</span><br><span class="line"></span><br><span class="line">  i. $a \land b = a \iff a \lor b = b$;</span><br><span class="line"></span><br><span class="line">  ii. The relation $a\precsim b$(defined by $a\land b = a$ or $a\lor b = b$)</span><br><span class="line">  is a partial order on $L$.</span><br><span class="line"></span><br><span class="line">  \item Prove: Let $L$ be a finite distributive lattice.</span><br><span class="line">  Then every $a\in L$ can be written uniquely(except for order)</span><br><span class="line">  as the join of irredudant join irreducible elements.</span><br><span class="line"></span><br><span class="line">  \item Prove: Let $L$ be a complemented lattice with unique complements.</span><br><span class="line">  Then the join irreducible elements of $L$, other than $0$, are its atoms.</span><br><span class="line"></span><br><span class="line">  \item Give a example of an infinite lattice $L$ with finite length.</span><br><span class="line"></span><br><span class="line">  \item Show that the isomorphic relation $A\simeq B$ for ordered sets is an equivalence relation, that is:</span><br><span class="line"></span><br><span class="line">  i. for any ordered set $A$, $A\simeq A$;</span><br><span class="line"></span><br><span class="line">  ii. $A\simeq B \implies B\simeq A$;</span><br><span class="line"></span><br><span class="line">  iii. $A\simeq B \land B\simeq C \implies A\simeq C$.</span><br><span class="line"></span><br><span class="line">  \item Let $A = \&#123;a, b, c\&#125;$ be linearly ordered by $a &lt; b &lt; c$,</span><br><span class="line">  and let $\mathbf&#123;N&#125;$ have the usual order $\leq$. Prove:</span><br><span class="line"></span><br><span class="line">  i. $S = \&#123;A; \mathbf&#123;N&#125;\&#125;$ is isomorphic to $\mathbf&#123;N&#125;$;</span><br><span class="line"></span><br><span class="line">  ii. $S&apos; = \&#123;\mathbf&#123;N&#125;; A\&#125;$ is not isomorphic to $\mathbf&#123;N&#125;$.</span><br><span class="line"></span><br><span class="line">  \item Suppose $A$ and $B$ are well-ordered isomorphic sets.</span><br><span class="line">  Show that there is only one similarity mapping $f: A\to B$.</span><br><span class="line"></span><br><span class="line">  \item Let S be a well-ordered set. For any $a \in S$, the set $s(a) = \&#123;x | x\prec a\&#125;$</span><br><span class="line">  is called an \textsl&#123;initial segments&#125; of a. Show that $S$ cannot be isomorphic to one of</span><br><span class="line">  its \textsl&#123;initial segments&#125;.</span><br><span class="line"></span><br><span class="line">  \item Suppose $s(a)$ and $s(b)$ are distinct initial segments of a well-ordered set $S$.</span><br><span class="line">  Show that $s(a)$ and $s(b)$ cannot be isomorphic.</span><br><span class="line"></span><br><span class="line">  \item A lattice M is said to be \textsl&#123;modular&#125; if whenever $a \leq c$ we have the law:</span><br><span class="line">  $$</span><br><span class="line">  a \lor (b \land c) = (a \lor b) \land c</span><br><span class="line">  $$</span><br><span class="line"></span><br><span class="line">  Prove that every distributive lattice is modular.</span><br><span class="line"></span><br><span class="line">  \item Let $R$ be a ring. Let $L$ be the collection of all ideals of $R$.</span><br><span class="line">  Prove that $L$ is a bounded lattice where, for any ideals $J$ and $K$ of $R$,</span><br><span class="line">  we define: $J \lor K = J + K$ and $J \land K = J \cap K$.</span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h4 id="code"><a href="#code" class="headerlink"
                                                                                                    title="code"></a>code
                  </h4>
                  <p>text.ts</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">import productOrder from &apos;./product-order&apos;</span><br><span class="line"></span><br><span class="line">// test</span><br><span class="line">const ascendProductOrder = productOrder((l: number, r: number) =&gt; &#123;</span><br><span class="line">  if (l &gt; r) return 1</span><br><span class="line">  if (l &lt; r) return -1</span><br><span class="line">  return 0</span><br><span class="line">&#125;)</span><br><span class="line">const descendProductOrder = productOrder((l: number, r: number) =&gt; &#123;</span><br><span class="line">  if (l &gt; r) return -1</span><br><span class="line">  if (l &lt; r) return 1</span><br><span class="line">  return 0</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const sl = new Set([2, 3, 1, 4])</span><br><span class="line">const sr = new Set([8, 5, 7, 6])</span><br><span class="line">console.log(ascendProductOrder(sl, sr))</span><br><span class="line">console.log(descendProductOrder(sl, sr))</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <p>product-order.ts</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">// 求两个偏序集的积序</span><br><span class="line"></span><br><span class="line">type SortFn&lt;T&gt;         = (e1: T, e2: T) =&gt; number</span><br><span class="line">type SetSortFn&lt;T&gt;      = (set: Set&lt;T&gt;) =&gt; Array&lt;T&gt;</span><br><span class="line">type ProductSet&lt;T&gt;     = Set&lt;[T, T]&gt;</span><br><span class="line">type ProductOrderFn&lt;T&gt; = (s1: Set&lt;T&gt;, s2: Set&lt;T&gt;) =&gt; ProductSet&lt;T&gt;</span><br><span class="line"></span><br><span class="line">export default function productOrder&lt;T&gt;(</span><br><span class="line">  sortFn: SortFn&lt;T&gt;</span><br><span class="line">): ProductOrderFn&lt;T&gt; &#123;</span><br><span class="line">  const $SORT: SetSortFn&lt;T&gt; = set =&gt; Array.from(set).sort(sortFn)</span><br><span class="line"></span><br><span class="line">  return function(s1, s2) &#123;</span><br><span class="line">    let a1 = $SORT(s1),</span><br><span class="line">        a2 = $SORT(s2)</span><br><span class="line">    let set: ProductSet&lt;T&gt; = new Set()</span><br><span class="line"></span><br><span class="line">    a1.forEach(e1 =&gt; &#123;</span><br><span class="line">      a2.forEach(e2 =&gt; &#123;</span><br><span class="line">        set.add([e1, e2])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return set</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <p>tsconfig.json</p>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es6&quot;,</span><br><span class="line">    &quot;lib&quot;: [</span><br><span class="line">      &quot;es2016&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <h1 id="布尔代数"><a href="#布尔代数" class="headerlink"
                                                                                                    title="布尔代数"></a>布尔代数
                  </h1>
                  <p>重点难点：</p>
                  <ul>
                    <li>布尔代数的概念</li>
                    <li>子布尔代数</li>
                    <li>同构的布尔代数</li>
                    <li>布尔代数与格</li>
                    <li>表示定理</li>
                  </ul>
                  <h1 id="布尔代数-1"><a href="#布尔代数-1" class="headerlink"
                                                                                                    title="布尔代数"></a>布尔代数
                  </h1>
                  <h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink"
                                                                                                    title="基本概念"></a>基本概念
                  </h2>
                  <p>设 B 是一个非空集合，具有二元运算 + 和 *，一元运算`和两个不同的元素0，1，若对于任意的 a, b, c
                    \in
                    B，以下公理成立，则称 B
                    为一个布尔代数：</p>
                  <p>交换律： a + b = b + a,<br> a * b = b * a<br>分配律： a + (b * c) =
                    (a + b) *
                    (a +
                    c),<br> a * (b + c) = (a * b) + (a * c)<br>单位元律： a + 0 = a,
                    a * 1 =
                    a<br>互补律：
                    a + a’ = 1, a * a’ = 0<br>当我们要强调其六个部分时，用(B, +, *, ‘, 0,
                    1)来表示一个布尔代数，称 0
                    为零元素，1
                    为单位元素，a’ 为 a 的补/</p>
                  <p>运算 +, * 与 ‘ 分别称为 和，积，与补。<br>优先级：’ 运算优先于 * 优先于 +。</p>
                  <h3 id="子代数，同构的布尔代数"><a href="#子代数，同构的布尔代数" class="headerlink"
                                                                                                    title="子代数，同构的布尔代数"></a>子代数，同构的布尔代数
                  </h3>
                  <p>子代数：设 C 是布尔代数 B 的一个非空子集，如果 C 本身是布尔代数（相对于 B 的运算），我们说称 C 是 B
                    的一个子代数。<br>注意 C 是
                    B 的一个子代数当且仅当 C 对于 B 中的三种运算，都是封闭的。</p>
                  <p>同构：两个布尔代数 B 和 B’ 称为同构的，如果有一一对应（双射）f: B \to
                    B’，并保持这三种运算，即使得对于 B 中任意元素 a
                    和
                    b，有：<br>$$<br>f(a + b) = f(a) + f(b), f(a * b) = f(a) *
                    f(b), f(a’) =
                    f(a)’<br>$$</p>
                  <h2 id="对偶性-1"><a href="#对偶性-1" class="headerlink"
                                                                                                    title="对偶性"></a>对偶性
                  </h2>
                  <p>在布尔代数中，任意命题的对偶是由在原命题中交换运算 + 和 *，并交换单位元 0 和 1 得到的命题。</p>
                  <p><strong>对偶原理</strong> 任何布尔代数的真命题的对偶仍是真命题。</p>
                  <h2 id="布尔代数的基本定理"><a href="#布尔代数的基本定理" class="headerlink"
                                                                                                    title="布尔代数的基本定理"></a>布尔代数的基本定理
                  </h2>
                  <p><strong>定理15.2</strong> 设 a, b, c 是布尔代数 B 中的任意元素，</p>
                  <ol>
                    <li>幂等律<br>a + a = a, a * a = a</li>
                    <li>有界律<br>a + 1 = 1, a * 0 = 0</li>
                    <li>吸收律<br>a + (a * b) = a, a * (a + b) = a</li>
                    <li>结合律<br>(a + b) + c = a + (b + c), (a * b) * c = a * (b *
                      c)</li>
                  </ol>
                  <p><strong>定理15.2</strong> 设 a 是布尔代数 B 中的任意元素，</p>
                  <ol>
                    <li>补的唯一性<br>a + x = 1 \land a * x = 0 \implies x = a’</li>
                    <li>对合律<br>(a’)’ = a</li>
                    <li>0’ = 1, 1’ = 0</li>
                  </ol>
                  <p><strong>DeMorgan律</strong></p>
                  <p>(a + b)’ = a’ * b’, (a * b)’ = a’ + b’</p>
                  <h2 id="作为格的布尔代数"><a href="#作为格的布尔代数" class="headerlink"
                                                                                                    title="作为格的布尔代数"></a>作为格的布尔代数
                  </h2>
                  <p>由于每个布尔代数都满足结合律，交换律和吸收律，因此它是一个格。并且，+ 和 * 分别为 \lor 和 \land
                    运算。<br>相对这个格，对于任意元素
                    a \in B，a + 1 = 1 蕴含 a &lt;= 1，而 a * 0 = 0 蕴含 0 &lt;= a。于是，B
                    是一个有界格。<br>此外，B
                    也是一个分配格和有补格。反之，每个有界的，分配的，有补的格 L 也满足布尔代数的定义。</p>
                  <p><strong>替换定义</strong> 一个布尔代数 B 是一个有界的、分配的、有补的格。反之。</p>
                  <p>定理15.5 在布尔代数中，下列条件是等价的：</p>
                  <ol>
                    <li>a + b = b, 2. a * b = a</li>
                    <li>a’ + b = 1, 4. a * b’ =
                      0<br>这样，在布尔代数中，只要知道上列四个条件之一是正确的话，我们就可以写 a
                      &lt;= b。
                    </li>
                  </ol>
                  <h2 id="表示定理"><a href="#表示定理" class="headerlink"
                                                                                                    title="表示定理"></a>表示定理
                  </h2>
                  <p>设 B 是一个有限的布尔代数，A 是 B 的原子的集合，且 P(A) 是原子集 A 的所有子集的布尔代数。</p>
                  <p>函数 f: B \to P(A) 表示：<br>$$<br>f(x) = { a_1, a_2, \cdots,
                    a_r }<br>$$
                  </p>
                  <p><strong>定理15.6</strong> 映射 f: B \to P(A) 是一个同构映射。</p>
                  <p><strong>推论15.7</strong> 一个有限的布尔代数有 2^n 个元素，n
                    为正整数<br>因此，布尔代数至少有 2 个元素。
                  </p>
                  <h2 id="集合的积和式"><a href="#集合的积和式" class="headerlink"
                                                                                                    title="集合的积和式"></a>集合的积和式
                  </h2>
                  <h2 id="布尔代数的积和式"><a href="#布尔代数的积和式" class="headerlink"
                                                                                                    title="布尔代数的积和式"></a>布尔代数的积和式
                  </h2>
                  <p><strong>定义</strong> 若布尔表达式 E
                    是一个基本积或是两个更多基本积的和，且这些积是互不包含的，这样的一个布尔表达式 E
                    被称为<strong>积和表达式</strong>。</p>
                  <p><strong>定义</strong> 设 E 是任意的布尔表达式，E
                    的一个<strong>积和式</strong>是一个等价的布尔积和表达式。</p>
                  <p><strong>定理</strong> 每个非零元的布尔表达式 E = E(x1, x2, …,
                    xn)等价于唯一的完全积和表达式。</p>
                  <h2 id="极小布尔表达式，素隐项"><a href="#极小布尔表达式，素隐项" class="headerlink"
                                                                                                    title="极小布尔表达式，素隐项"></a>极小布尔表达式，素隐项
                  </h2>
                  <h3 id="极小的积和式"><a href="#极小的积和式" class="headerlink"
                                                                                                    title="极小的积和式"></a>极小的积和式
                  </h3>
                  <p>我们说 E 是极小的，如果没有比 E 简洁的等价的积和表达式。（可能有不止一种极小积和表达式）</p>
                  <h3 id="素隐项"><a href="#素隐项" class="headerlink"
                                                                                                    title="素隐项"></a>素隐项
                  </h3>
                  <p>一个基本积 P 被称作一个布尔表达式 E 的素隐项，若：<br>$$<br>P + E = E<br>$$</p>
                  <p>且 P 中不包含齿条这个性质的其他基本积。</p>
                  <p><strong>定理</strong> 一个布尔表达式 E 的极小积和表达式是 E 的素隐项的和。</p>
                  <h3 id="基本积的共识"><a href="#基本积的共识" class="headerlink"
                                                                                                    title="基本积的共识"></a>基本积的共识
                  </h3>
                  <p><strong>引理</strong> 假设 Q 是 P1 和 P2 的共识，那么<br>$$<br>P_1 +
                    P_2 + Q = P_1
                    +
                    P_2<br>$$</p>
                  <h1 id="附录-12"><a href="#附录-12" class="headerlink"
                                                                                                    title="附录"></a>附录
                  </h1>
                  <h2 id="术语-10"><a href="#术语-10" class="headerlink"
                                                                                                    title="术语"></a>术语
                  </h2>
                  <ul>
                    <li>布尔代数 Boolean Algebra</li>
                    <li>交换律 commutative laws</li>
                    <li>分配律 distriutive laws</li>
                    <li>单位元律 identity laws</li>
                    <li>互补律 complement laws</li>
                    <li>零元素 zero element</li>
                    <li>单位元素 unit element</li>
                    <li>子代数 subalgebras</li>
                    <li>同构的布尔代数 isomorphic Boolean Algebra</li>
                    <li>对偶性 duality</li>
                    <li>幂等律 idempotent laws</li>
                    <li>有界律 boundedness laws</li>
                    <li>吸收律 absorption laws</li>
                    <li>结合律 associative laws</li>
                    <li>补的唯一性 uniqueness of complement</li>
                    <li>对合律 involution laws</li>
                    <li>DeMorgan律 DeMorgan’s laws</li>
                    <li>布尔代数的替换定义 alternate definition</li>
                    <li>表示定理 representation theorem</li>
                  </ul>
                  <h3 id="theorem-tex"><a href="#theorem-tex" class="headerlink"
                                                                                                    title="theorem.tex"></a>theorem.tex
                  </h3>
                  <figure class="highlight plain">
                    <table>
                      <tr>
                        <td class="gutter">
                          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre>
                        </td>
                        <td class="code">
                          <pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">  \usepackage&#123;amsmath&#125;</span><br><span class="line">  \usepackage&#123;amssymb&#125;</span><br><span class="line">  \newcommand&#123;\setcomp&#125;[1] &#123;&#123;#1&#125;^&#123;\mathsf&#123;c&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">Idempotent laws: 1. $x + x = x$; 2. $x * x = 0$.</span><br><span class="line"></span><br><span class="line">Proof 1:</span><br><span class="line"></span><br><span class="line">\begin&#123;eqnarray*&#125;</span><br><span class="line">x + x &amp; = &amp; (x + x) * 1 \\</span><br><span class="line">&amp; = &amp; (x + x) * (x + x&apos;) \\</span><br><span class="line">&amp; = &amp; x + (x * x&apos;) \\</span><br><span class="line">&amp; = &amp; x + 0 \\</span><br><span class="line">&amp; = &amp; x</span><br><span class="line">\end&#123;eqnarray*&#125;</span><br><span class="line"></span><br><span class="line">Key: $x + (x * x&apos;) = (x + x) * (x + x&apos;)$</span><br><span class="line"></span><br><span class="line">Proof 2:</span><br><span class="line"></span><br><span class="line">\begin&#123;eqnarray*&#125;</span><br><span class="line">x * x &amp; = &amp; (x * x) + 0 \\</span><br><span class="line">&amp; = &amp; (x * x) + (x * x&apos;) \\</span><br><span class="line">&amp; = &amp; x * (x + x&apos;) \\</span><br><span class="line">&amp; = &amp; x * 1 \\</span><br><span class="line">&amp; = &amp; x</span><br><span class="line">\end&#123;eqnarray*&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre>
                        </td>
                      </tr>
                    </table>
                  </figure>

                  <div class="declare">
                    <strong>本文作者：</strong>

                    小星星

                    <br>
                    <strong>本文链接：</strong>
                    http://javastar.club/archives/fb566d07.html
                    <br>
                    <strong>版权声明：</strong>
                    本作品采用
                    <a rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
                                                                                                    target="_blank">知识共享署名-非商业性使用-相同方式共享
                      4.0 国际许可协议</a>
                    进行许可。转载请注明出处！

                    <br>
                    <a rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
                                                                                                    target="_blank"><img
                                                                                                      alt="知识共享许可协议"
                                                                                                      style="border-width:0"
                                                                                                      src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a>

                  </div>

                  <div class="page-reward">
                    <a href="javascript:;" class="page-reward-btn tooltip-top">
                      <div class="tooltip tooltip-east">
                        <span class="tooltip-item">
                          赏
                        </span>
                        <span class="tooltip-content">
                          <span class="tooltip-text">
                            <span class="tooltip-inner">
                              <p class="reward-p"><i
                                                                                                                class="icon icon-quo-left"></i>请我喝一杯咖啡吧<i
                                                                                                                class="icon icon-quo-right"></i>
                              </p>
                              <div class="reward-box">

                                <div class="reward-box-item">
                                  <img class="reward-img"
                                                                                                                  src="/img/zhifubao.jpg">
                                  <span class="reward-type">支付宝</span>
                                </div>

                                <div class="reward-box-item">
                                  <img class="reward-img" src="/img/weixin.jpg">
                                  <span class="reward-type">微信</span>
                                </div>

                              </div>
                            </span>
                          </span>
                        </span>
                      </div>
                    </a>
                  </div>

                </div>
                <div class="article-info article-info-index">

                  <div class="article-tag tagcloud">
                    <i class="icon-price-tags icon"></i>
                    <ul class="article-tag-list">

                      <li class="article-tag-list-item">
                        <a href="javascript:void(0)"
                                                                                                        class="js-tag article-tag-list-link color5">数学基础</a>
                      </li>

                    </ul>
                  </div>

                  <div class="article-category tagcloud">
                    <i class="icon-book icon"></i>
                    <ul class="article-tag-list">

                      <li class="article-tag-list-item">
                        <a href="/categories/数学基础//"
                                                                                                        class="article-tag-list-link color5">数学基础</a>
                      </li>

                    </ul>
                  </div>

                  <div class="share-btn share-icons tooltip-left">
                    <div class="tooltip tooltip-east">
                      <span class="tooltip-item">
                        <a href="javascript:;" class="share-sns share-outer">
                          <i class="icon icon-share"></i>
                        </a>
                      </span>
                      <span class="tooltip-content">
                        <div class="share-wrap">
                          <div class="share-icons">
                            <a class="weibo share-sns" href="javascript:;"
                                                                                                            data-type="weibo">
                              <i class="icon icon-weibo"></i>
                            </a>
                            <a class="weixin share-sns wxFab" href="javascript:;"
                                                                                                            data-type="weixin">
                              <i class="icon icon-weixin"></i>
                            </a>
                            <a class="qq share-sns" href="javascript:;"
                                                                                                            data-type="qq">
                              <i class="icon icon-qq"></i>
                            </a>
                            <a class="douban share-sns" href="javascript:;"
                                                                                                            data-type="douban">
                              <i class="icon icon-douban"></i>
                            </a>
                            <a class="qzone share-sns" href="javascript:;"
                                                                                                            data-type="qzone">
                              <i class="icon icon-qzone"></i>
                            </a>
                            <a class="facebook share-sns" href="javascript:;"
                                                                                                            data-type="facebook">
                              <i class="icon icon-facebook"></i>
                            </a>
                            <a class="twitter share-sns" href="javascript:;"
                                                                                                            data-type="twitter">
                              <i class="icon icon-twitter"></i>
                            </a>
                            <a class="google share-sns" href="javascript:;"
                                                                                                            data-type="google">
                              <i class="icon icon-google"></i>
                            </a>
                          </div>
                        </div>
                      </span>
                    </div>
                  </div>

                  <div class="page-modal wx-share js-wx-box">
                    <a class="close js-modal-close" href="javascript:;"><i
                                                                                                      class="icon icon-close"></i></a>
                    <p>扫一扫，分享到微信</p>
                    <div class="wx-qrcode">
                      <img src="//pan.baidu.com/share/qrcode?url=http://javastar.club/archives/fb566d07.html"
                                                                                                      alt="微信分享二维码">
                    </div>
                  </div>

                  <div class="mask js-mask"></div>

                  <div class="clearfix"></div>
                </div>
              </div>
            </article>

            <nav id="article-nav">

              <a href="/archives/83ff8e26.html" id="article-nav-older"
                                                                                              class="article-nav-link-wrap">
                <div class="article-nav-title">数学基础复习</div>
                <i class="icon-circle-right"></i>
              </a>

            </nav>

            <aside class="wrap-side-operation">
              <div class="mod-side-operation">

                <div class="jump-container" id="js-jump-container"
                                                                                                style="display:none;">
                  <a href="javascript:void(0)"
                                                                                                  class="mod-side-operation__jump-to-top">
                    <i class="icon-font icon-back"></i>
                  </a>
                  <div id="js-jump-plan-container" class="jump-plan-container"
                                                                                                  style="top: -11px;">
                    <i class="icon-font icon-plane jump-plane"></i>
                  </div>
                </div>

                <div class="toc-container tooltip-left">
                  <i class="icon-font icon-category"></i>
                  <div class="tooltip tooltip-east">
                    <span class="tooltip-item">
                    </span>
                    <span class="tooltip-content">
                      <div class="toc-article">
                        <ol class="toc">
                          <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                            href="#基本概念"><span
                                                                                                              class="toc-number">1.</span>
                              <span class="toc-text">基本概念</span></a>
                            <ol class="toc-child">
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#集合与元素"><span
                                                                                                                  class="toc-number">1.1.</span>
                                  <span class="toc-text">集合与元素</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#标记法"><span
                                                                                                                      class="toc-number">1.1.1.</span>
                                      <span class="toc-text">标记法</span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#外延公理"><span
                                                                                                                      class="toc-number">1.1.2.</span>
                                      <span class="toc-text">外延公理</span></a>
                                  </li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#集合的表示"><span
                                                                                                                      class="toc-number">1.1.3.</span>
                                      <span class="toc-text">集合的表示</span></a>
                                  </li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#常用的集合及其表示"><span
                                                                                                                      class="toc-number">1.1.4.</span>
                                      <span class="toc-text">常用的集合及其表示
                                      </span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#抽象原则"><span
                                                                                                                      class="toc-number">1.1.5.</span>
                                      <span class="toc-text">抽象原则</span></a>
                                  </li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#全集与空集"><span
                                                                                                                  class="toc-number">1.2.</span>
                                  <span class="toc-text">全集与空集</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#全集"><span
                                                                                                                      class="toc-number">1.2.1.</span>
                                      <span class="toc-text">全集</span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#空集"><span
                                                                                                                      class="toc-number">1.2.2.</span>
                                      <span class="toc-text">空集</span></a>
                                    <ol class="toc-child">
                                      <li class="toc-item toc-level-4"><a class="toc-link"
                                                                                                                        href="#空集的特性："><span
                                                                                                                          class="toc-number">1.2.2.1.</span>
                                          <span class="toc-text">空集的特性：
                                          </span></a></li>
                                    </ol>
                                  </li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#子集"><span
                                                                                                                  class="toc-number">1.3.</span>
                                  <span class="toc-text">子集</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#定理1-1"><span
                                                                                                                      class="toc-number">1.3.1.</span>
                                      <span class="toc-text">定理1.1</span></a>
                                  </li>
                                </ol>
                              </li>
                            </ol>
                          </li>
                          <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                            href="#集合的运算"><span
                                                                                                              class="toc-number">2.</span>
                              <span class="toc-text">集合的运算</span></a>
                            <ol class="toc-child">
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#集合的并与交"><span
                                                                                                                  class="toc-number">2.1.</span>
                                  <span class="toc-text">集合的并与交
                                  </span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#定理1-2"><span
                                                                                                                      class="toc-number">2.1.1.</span>
                                      <span class="toc-text">定理1.2</span></a>
                                  </li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#集合的补"><span
                                                                                                                  class="toc-number">2.2.</span>
                                  <span class="toc-text">集合的补</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#相对补-差"><span
                                                                                                                      class="toc-number">2.2.1.</span>
                                      <span class="toc-text">相对补/差</span></a>
                                  </li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#集合的基本积"><span
                                                                                                                  class="toc-number">2.3.</span>
                                  <span class="toc-text">集合的基本积
                                  </span></a></li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#对称差"><span
                                                                                                                  class="toc-number">2.4.</span>
                                  <span class="toc-text">对称差</span></a></li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#集合的代数运算及对偶性"><span
                                                                                                                  class="toc-number">2.5.</span>
                                  <span class="toc-text">集合的代数运算及对偶性
                                  </span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#对偶性"><span
                                                                                                                      class="toc-number">2.5.1.</span>
                                      <span class="toc-text">对偶性</span></a></li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#有限集及计数原理"><span
                                                                                                                  class="toc-number">2.6.</span>
                                  <span class="toc-text">有限集及计数原理
                                  </span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#引理1-4"><span
                                                                                                                      class="toc-number">2.6.1.</span>
                                      <span class="toc-text">引理1.4</span></a>
                                  </li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#定理1-5"><span
                                                                                                                      class="toc-number">2.6.2.</span>
                                      <span class="toc-text">定理1.5</span></a>
                                  </li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#推论1-6"><span
                                                                                                                      class="toc-number">2.6.3.</span>
                                      <span class="toc-text">推论1.6</span></a>
                                  </li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#集族，幂集和集合的划分"><span
                                                                                                                  class="toc-number">2.7.</span>
                                  <span class="toc-text">集族，幂集和集合的划分
                                  </span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#幂集"><span
                                                                                                                      class="toc-number">2.7.1.</span>
                                      <span class="toc-text">幂集</span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#划分"><span
                                                                                                                      class="toc-number">2.7.2.</span>
                                      <span class="toc-text">划分</span></a></li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#集合运算的推广"><span
                                                                                                                  class="toc-number">2.8.</span>
                                  <span class="toc-text">集合运算的推广
                                  </span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#定理1-7"><span
                                                                                                                      class="toc-number">2.8.1.</span>
                                      <span class="toc-text">定理1.7</span></a>
                                  </li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#数学归纳法"><span
                                                                                                                  class="toc-number">2.9.</span>
                                  <span class="toc-text">数学归纳法</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#数学归纳法原理I"><span
                                                                                                                      class="toc-number">2.9.1.</span>
                                      <span class="toc-text">数学归纳法原理I
                                      </span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#数学归纳法原理II"><span
                                                                                                                      class="toc-number">2.9.2.</span>
                                      <span class="toc-text">数学归纳法原理II
                                      </span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#代码练习"><span
                                                                                                                      class="toc-number">2.9.3.</span>
                                      <span class="toc-text">代码练习</span></a>
                                  </li>
                                </ol>
                              </li>
                            </ol>
                          </li>
                          <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                            href="#附录"><span
                                                                                                              class="toc-number">3.</span>
                              <span class="toc-text">附录</span></a>
                            <ol class="toc-child">
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#术语"><span
                                                                                                                  class="toc-number">3.1.</span>
                                  <span class="toc-text">术语</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#标志约定"><span
                                                                                                                      class="toc-number">3.1.1.</span>
                                      <span class="toc-text">标志约定</span></a>
                                  </li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#难点"><span
                                                                                                                  class="toc-number">3.2.</span>
                                  <span class="toc-text">难点</span></a></li>
                            </ol>
                          </li>
                          <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                            href="#关系"><span
                                                                                                              class="toc-number">4.</span>
                              <span class="toc-text">关系</span></a>
                            <ol class="toc-child">
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#有序偶"><span
                                                                                                                  class="toc-number">4.1.</span>
                                  <span class="toc-text">有序偶</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#使用集合定义有序偶"><span
                                                                                                                      class="toc-number">4.1.1.</span>
                                      <span class="toc-text">使用集合定义有序偶
                                      </span></a></li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#集合的积（笛卡尔积）"><span
                                                                                                                  class="toc-number">4.2.</span>
                                  <span class="toc-text">集合的积（笛卡尔积）
                                  </span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#笛卡尔平面"><span
                                                                                                                      class="toc-number">4.2.1.</span>
                                      <span class="toc-text">笛卡尔平面</span></a>
                                  </li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#规律"><span
                                                                                                                      class="toc-number">4.2.2.</span>
                                      <span class="toc-text">规律</span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#集合积的推广"><span
                                                                                                                      class="toc-number">4.2.3.</span>
                                      <span class="toc-text">集合积的推广
                                      </span></a></li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#关系-1"><span
                                                                                                                  class="toc-number">4.3.</span>
                                  <span class="toc-text">关系</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#相等关系"><span
                                                                                                                      class="toc-number">4.3.1.</span>
                                      <span class="toc-text">相等关系</span></a>
                                  </li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#完全关系和空关系"><span
                                                                                                                      class="toc-number">4.3.2.</span>
                                      <span class="toc-text">完全关系和空关系
                                      </span></a></li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#逆关系"><span
                                                                                                                  class="toc-number">4.4.</span>
                                  <span class="toc-text">逆关系</span></a></li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#关系的图示"><span
                                                                                                                  class="toc-number">4.5.</span>
                                  <span class="toc-text">关系的图示</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#有限集上关系的图示"><span
                                                                                                                      class="toc-number">4.5.1.</span>
                                      <span class="toc-text">有限集上关系的图示
                                      </span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#集上关系的有向图"><span
                                                                                                                      class="toc-number">4.5.2.</span>
                                      <span class="toc-text">集上关系的有向图
                                      </span></a></li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#关系的合成"><span
                                                                                                                  class="toc-number">4.6.</span>
                                  <span class="toc-text">关系的合成</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#关系的合成与矩阵"><span
                                                                                                                      class="toc-number">4.6.1.</span>
                                      <span class="toc-text">关系的合成与矩阵
                                      </span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#定理2-1"><span
                                                                                                                      class="toc-number">4.6.2.</span>
                                      <span class="toc-text">定理2.1</span></a>
                                  </li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#典型关系"><span
                                                                                                                  class="toc-number">4.7.</span>
                                  <span class="toc-text">典型关系</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#自反关系"><span
                                                                                                                      class="toc-number">4.7.1.</span>
                                      <span class="toc-text">自反关系</span></a>
                                  </li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#对称和反对称关系"><span
                                                                                                                      class="toc-number">4.7.2.</span>
                                      <span class="toc-text">对称和反对称关系
                                      </span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#传递关系"><span
                                                                                                                      class="toc-number">4.7.3.</span>
                                      <span class="toc-text">传递关系</span></a>
                                    <ol class="toc-child">
                                      <li class="toc-item toc-level-4"><a class="toc-link"
                                                                                                                        href="#定理2-2"><span
                                                                                                                          class="toc-number">4.7.3.1.</span>
                                          <span
                                                                                                                          class="toc-text">定理2.2</span></a>
                                      </li>
                                    </ol>
                                  </li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#闭包性质"><span
                                                                                                                  class="toc-number">4.8.</span>
                                  <span class="toc-text">闭包性质</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#自反闭包和对称闭包"><span
                                                                                                                      class="toc-number">4.8.1.</span>
                                      <span class="toc-text">自反闭包和对称闭包
                                      </span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#传递闭包"><span
                                                                                                                      class="toc-number">4.8.2.</span>
                                      <span class="toc-text">传递闭包</span></a>
                                  </li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#等价关系"><span
                                                                                                                  class="toc-number">4.9.</span>
                                  <span class="toc-text">等价关系</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#等价类"><span
                                                                                                                      class="toc-number">4.9.1.</span>
                                      <span class="toc-text">等价类</span></a></li>
                                  <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                    href="#等价关系与集合的划分"><span
                                                                                                                      class="toc-number">4.9.2.</span>
                                      <span class="toc-text">等价关系与集合的划分
                                      </span></a></li>
                                </ol>
                              </li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#偏序关系"><span
                                                                                                                  class="toc-number">4.10.</span>
                                  <span class="toc-text">偏序关系</span></a></li>
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#n元关系"><span
                                                                                                                  class="toc-number">4.11.</span>
                                  <span class="toc-text">n元关系</span></a></li>
                            </ol>
                          </li>
                          <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                            href="#附录-1"><span
                                                                                                              class="toc-number">5.</span>
                              <span class="toc-text">附录</span></a>
                            <ol class="toc-child">
                              <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                                href="#术语-1"><span
                                                                                                                  class="toc-number">5.1.</span>
                                  <span class="toc-text">术语</span></a>
                                <ol class="toc-child">
                                  <li class="toc-item toc-level-4"><a class="toc-link"
                                                                                                                    href="#examples-tex"><span
                                                                                                                      class="toc-number">5.1.0.1.</span>
                                      <span class="toc-text">examples.tex
                                      </span></a>
                                    <ol class="toc-child">
                                      <li class="toc-item toc-level-5"><a class="toc-link"
                                                                                                                        href="#exercise"><span
                                                                                                                          class="toc-number">5.1.0.1.1.</span>
                                          <span class="toc-text">exercise
                                          </span></a></li>
                                    </ol>
                                  </li>
                                </ol>
                              </li>
                            </ol>
                          </li>
                        </ol>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#函数与算法"><span
                                                                                                            class="toc-number">6.</span>
                            <span class="toc-text">函数与算法</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#函数"><span
                                                                                                                class="toc-number">6.1.</span>
                                <span class="toc-text">函数</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#函数与关系"><span
                                                                                                                    class="toc-number">6.1.1.</span>
                                    <span class="toc-text">函数与关系</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#复合函数"><span
                                                                                                                    class="toc-number">6.1.2.</span>
                                    <span class="toc-text">复合函数</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#一一的、映上的与可逆的函数"><span
                                                                                                                class="toc-number">6.2.</span>
                                <span class="toc-text">一一的、映上的与可逆的函数
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#置换"><span
                                                                                                                class="toc-number">6.3.</span>
                                <span class="toc-text">置换</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#数学函数、指数函数、对数函数"><span
                                                                                                                class="toc-number">6.4.</span>
                                <span class="toc-text">数学函数、指数函数、对数函数
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#上、下取整函数"><span
                                                                                                                    class="toc-number">6.4.1.</span>
                                    <span class="toc-text">上、下取整函数
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#取整函数和绝对值函数"><span
                                                                                                                    class="toc-number">6.4.2.</span>
                                    <span class="toc-text">取整函数和绝对值函数
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#余数函数与模算术"><span
                                                                                                                    class="toc-number">6.4.3.</span>
                                    <span class="toc-text">余数函数与模算术
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#指数函数"><span
                                                                                                                    class="toc-number">6.4.4.</span>
                                    <span class="toc-text">指数函数</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#对数函数"><span
                                                                                                                    class="toc-number">6.4.5.</span>
                                    <span class="toc-text">对数函数</span></a>
                                  <ol class="toc-child">
                                    <li class="toc-item toc-level-4"><a class="toc-link"
                                                                                                                      href="#指数函数与对数函数的关系"><span
                                                                                                                        class="toc-number">6.4.5.1.</span>
                                        <span class="toc-text">指数函数与对数函数的关系
                                        </span></a></li>
                                  </ol>
                                </li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#序列、集合的指标类"><span
                                                                                                                class="toc-number">6.5.</span>
                                <span class="toc-text">序列、集合的指标类
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#序列"><span
                                                                                                                    class="toc-number">6.5.1.</span>
                                    <span class="toc-text">序列</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#求和记号与求和"><span
                                                                                                                    class="toc-number">6.5.2.</span>
                                    <span class="toc-text">求和记号与求和
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#集合的指标类"><span
                                                                                                                    class="toc-number">6.5.3.</span>
                                    <span class="toc-text">集合的指标类
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#递归函数"><span
                                                                                                                class="toc-number">6.6.</span>
                                <span class="toc-text">递归函数</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#阶乘函数"><span
                                                                                                                    class="toc-number">6.6.1.</span>
                                    <span class="toc-text">阶乘函数</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#水平数"><span
                                                                                                                    class="toc-number">6.6.2.</span>
                                    <span class="toc-text">水平数</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#Fibonacci序列"><span
                                                                                                                    class="toc-number">6.6.3.</span>
                                    <span class="toc-text">Fibonacci序列
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#Ackermann函数"><span
                                                                                                                    class="toc-number">6.6.4.</span>
                                    <span class="toc-text">Ackermann函数
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#基数"><span
                                                                                                                    class="toc-number">6.6.5.</span>
                                    <span class="toc-text">基数</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#基数与不等式"><span
                                                                                                                class="toc-number">6.7.</span>
                                <span class="toc-text">基数与不等式
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#算法与函数"><span
                                                                                                                class="toc-number">6.8.</span>
                                <span class="toc-text">算法与函数</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#算法的复杂性"><span
                                                                                                                class="toc-number">6.9.</span>
                                <span class="toc-text">算法的复杂性
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#线性查找"><span
                                                                                                                    class="toc-number">6.9.1.</span>
                                    <span class="toc-text">线性查找</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#增长率与大O记号"><span
                                                                                                                    class="toc-number">6.9.2.</span>
                                    <span class="toc-text">增长率与大O记号
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#常见算法的复杂性"><span
                                                                                                                    class="toc-number">6.9.3.</span>
                                    <span class="toc-text">常见算法的复杂性
                                    </span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-2"><span
                                                                                                            class="toc-number">7.</span>
                            <span class="toc-text">附录
                            </span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语-2"><span
                                                                                                                class="toc-number">7.1.</span>
                                <span class="toc-text">术语</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#exercise-1"><span
                                                                                                                    class="toc-number">7.1.1.</span>
                                    <span class="toc-text">exercise
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#exercise-tex"><span
                                                                                                                    class="toc-number">7.1.2.</span>
                                    <span class="toc-text">exercise.tex
                                    </span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#逻辑与命题演算"><span
                                                                                                            class="toc-number">8.</span>
                            <span class="toc-text">逻辑与命题演算
                            </span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#要点难点"><span
                                                                                                                class="toc-number">8.1.</span>
                                <span class="toc-text">要点难点</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#命题与复合命题"><span
                                                                                                                class="toc-number">8.2.</span>
                                <span class="toc-text">命题与复合命题
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#命题"><span
                                                                                                                    class="toc-number">8.2.1.</span>
                                    <span class="toc-text">命题</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#复合命题"><span
                                                                                                                class="toc-number">8.3.</span>
                                <span class="toc-text">复合命题</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#基本逻辑运算"><span
                                                                                                                class="toc-number">8.4.</span>
                                <span class="toc-text">基本逻辑运算
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#否定联结-lnot-p"><span
                                                                                                                    class="toc-number">8.4.1.</span>
                                    <span class="toc-text">否定联结,
                                      \lnot p</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#命题与真值表"><span
                                                                                                                class="toc-number">8.5.</span>
                                <span class="toc-text">命题与真值表
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#构造真值表的另一种方法"><span
                                                                                                                    class="toc-number">8.5.1.</span>
                                    <span class="toc-text">构造真值表的另一种方法
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#永真命题与永假命题"><span
                                                                                                                class="toc-number">8.6.</span>
                                <span class="toc-text">永真命题与永假命题
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#逻辑等价"><span
                                                                                                                class="toc-number">8.7.</span>
                                <span class="toc-text">逻辑等价</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#命题代数"><span
                                                                                                                class="toc-number">8.8.</span>
                                <span class="toc-text">命题代数</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#条件语句与双条件语句"><span
                                                                                                                class="toc-number">8.9.</span>
                                <span class="toc-text">条件语句与双条件语句
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#三段论律"><span
                                                                                                                    class="toc-number">8.9.1.</span>
                                    <span class="toc-text">三段论律</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#逻辑蕴含"><span
                                                                                                                class="toc-number">8.10.</span>
                                <span class="toc-text">逻辑蕴含</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#命题函数，量词"><span
                                                                                                                class="toc-number">8.11.</span>
                                <span class="toc-text">命题函数，量词
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#全称量词"><span
                                                                                                                    class="toc-number">8.11.1.</span>
                                    <span class="toc-text">全称量词</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#存在量词"><span
                                                                                                                    class="toc-number">8.11.2.</span>
                                    <span class="toc-text">存在量词</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#量词语句的否定"><span
                                                                                                                class="toc-number">8.12.</span>
                                <span class="toc-text">量词语句的否定
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#含有多个变量的命题函数"><span
                                                                                                                    class="toc-number">8.12.1.</span>
                                    <span class="toc-text">含有多个变量的命题函数
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#多变量的否定量词语句"><span
                                                                                                                    class="toc-number">8.12.2.</span>
                                    <span class="toc-text">多变量的否定量词语句
                                    </span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-3"><span
                                                                                                            class="toc-number">9.</span>
                            <span class="toc-text">附录</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语-3"><span
                                                                                                                class="toc-number">9.1.</span>
                                <span class="toc-text">术语</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#exercise-tex-1"><span
                                                                                                                    class="toc-number">9.1.1.</span>
                                    <span class="toc-text">exercise.tex
                                    </span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#向量与矩阵"><span
                                                                                                            class="toc-number">10.</span>
                            <span class="toc-text">向量与矩阵</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#要点难点-1"><span
                                                                                                                class="toc-number">10.1.</span>
                                <span class="toc-text">要点难点</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#向量"><span
                                                                                                                class="toc-number">10.2.</span>
                                <span class="toc-text">向量</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#向量的运算"><span
                                                                                                                    class="toc-number">10.2.1.</span>
                                    <span class="toc-text">向量的运算</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#列向量、行向量"><span
                                                                                                                    class="toc-number">10.2.2.</span>
                                    <span class="toc-text">列向量、行向量
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#矩阵"><span
                                                                                                                class="toc-number">10.3.</span>
                                <span class="toc-text">矩阵</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#矩阵的加法和数乘"><span
                                                                                                                    class="toc-number">10.3.1.</span>
                                    <span class="toc-text">矩阵的加法和数乘
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#矩阵的乘法"><span
                                                                                                                class="toc-number">10.4.</span>
                                <span class="toc-text">矩阵的乘法</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#矩阵的乘法-1"><span
                                                                                                                    class="toc-number">10.4.1.</span>
                                    <span class="toc-text">矩阵的乘法
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#矩阵的乘法与线性方程组"><span
                                                                                                                    class="toc-number">10.4.2.</span>
                                    <span class="toc-text">矩阵的乘法与线性方程组
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#转置矩阵"><span
                                                                                                                class="toc-number">10.5.</span>
                                <span class="toc-text">转置矩阵</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#方阵"><span
                                                                                                                class="toc-number">10.6.</span>
                                <span class="toc-text">方阵</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#方阵的代数运算"><span
                                                                                                                    class="toc-number">10.6.1.</span>
                                    <span class="toc-text">方阵的代数运算
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#可逆（非奇异矩阵）和逆矩阵"><span
                                                                                                                class="toc-number">10.7.</span>
                                <span class="toc-text">可逆（非奇异矩阵）和逆矩阵
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#行列式的一般定义"><span
                                                                                                                    class="toc-number">10.7.1.</span>
                                    <span class="toc-text">行列式的一般定义
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#初等行变换，高斯消去法"><span
                                                                                                                class="toc-number">10.8.</span>
                                <span class="toc-text">初等行变换，高斯消去法
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#矩阵格式的高斯消去法"><span
                                                                                                                    class="toc-number">10.8.1.</span>
                                    <span class="toc-text">矩阵格式的高斯消去法
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#线性方程组的矩阵解法"><span
                                                                                                                    class="toc-number">10.8.2.</span>
                                    <span class="toc-text">线性方程组的矩阵解法
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#n-times-n矩阵的逆阵"><span
                                                                                                                    class="toc-number">10.8.3.</span>
                                    <span class="toc-text">n\times
                                      n矩阵的逆阵</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#布尔（零-幺）矩阵"><span
                                                                                                                class="toc-number">10.9.</span>
                                <span class="toc-text">布尔（零-幺）矩阵
                                </span></a></li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-4"><span
                                                                                                            class="toc-number">11.</span>
                            <span class="toc-text">附录</span></a></li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#计数"><span
                                                                                                            class="toc-number">12.</span>
                            <span class="toc-text">计数</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#基本计数原理"><span
                                                                                                                class="toc-number">12.1.</span>
                                <span class="toc-text">基本计数原理
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#集合论的解释"><span
                                                                                                                    class="toc-number">12.1.1.</span>
                                    <span class="toc-text">集合论的解释
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#阶乘符号"><span
                                                                                                                class="toc-number">12.2.</span>
                                <span class="toc-text">阶乘符号</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#二项式符号"><span
                                                                                                                class="toc-number">12.3.</span>
                                <span class="toc-text">二项式符号</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#二项式系数与Pascal三角形"><span
                                                                                                                    class="toc-number">12.3.1.</span>
                                    <span class="toc-text">二项式系数与Pascal三角形
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#排列"><span
                                                                                                                class="toc-number">12.4.</span>
                                <span class="toc-text">排列</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#可重排列"><span
                                                                                                                    class="toc-number">12.4.1.</span>
                                    <span class="toc-text">可重排列</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#组合"><span
                                                                                                                class="toc-number">12.5.</span>
                                <span class="toc-text">组合</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#鸽笼原理"><span
                                                                                                                class="toc-number">12.6.</span>
                                <span class="toc-text">鸽笼原理</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#容斥原理"><span
                                                                                                                class="toc-number">12.7.</span>
                                <span class="toc-text">容斥原理</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#有序划分与无序划分"><span
                                                                                                                class="toc-number">12.8.</span>
                                <span class="toc-text">有序划分与无序划分
                                </span></a></li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#概率论"><span
                                                                                                            class="toc-number">13.</span>
                            <span class="toc-text">概率论</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#样本空间与事件"><span
                                                                                                                class="toc-number">13.1.</span>
                                <span class="toc-text">样本空间与事件
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#有限概率空间"><span
                                                                                                                class="toc-number">13.2.</span>
                                <span class="toc-text">有限概率空间
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#有限概率空间的定理"><span
                                                                                                                    class="toc-number">13.2.1.</span>
                                    <span class="toc-text">有限概率空间的定理
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#条件概率"><span
                                                                                                                class="toc-number">13.3.</span>
                                <span class="toc-text">条件概率</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#条件概率的乘法定理"><span
                                                                                                                    class="toc-number">13.3.1.</span>
                                    <span class="toc-text">条件概率的乘法定理
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#独立事件"><span
                                                                                                                class="toc-number">13.4.</span>
                                <span class="toc-text">独立事件</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#独立重复试验，二项分布"><span
                                                                                                                class="toc-number">13.5.</span>
                                <span class="toc-text">独立重复试验，二项分布
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#随机变量"><span
                                                                                                                class="toc-number">13.6.</span>
                                <span class="toc-text">随机变量</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#随机变量的概率分布"><span
                                                                                                                    class="toc-number">13.6.1.</span>
                                    <span class="toc-text">随机变量的概率分布
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#随机变量的期望"><span
                                                                                                                    class="toc-number">13.6.2.</span>
                                    <span class="toc-text">随机变量的期望
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#二项分布"><span
                                                                                                                    class="toc-number">13.6.3.</span>
                                    <span class="toc-text">二项分布</span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-5"><span
                                                                                                            class="toc-number">14.</span>
                            <span class="toc-text">附录</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语-4"><span
                                                                                                                class="toc-number">14.1.</span>
                                <span class="toc-text">术语</span></a></li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#图论"><span
                                                                                                            class="toc-number">15.</span>
                            <span class="toc-text">图论</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#链表与指针"><span
                                                                                                                class="toc-number">15.1.</span>
                                <span class="toc-text">链表与指针</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#堆栈、队列、优先队列"><span
                                                                                                                class="toc-number">15.2.</span>
                                <span class="toc-text">堆栈、队列、优先队列
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#图与多重图"><span
                                                                                                                class="toc-number">15.3.</span>
                                <span class="toc-text">图与多重图</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#多重图"><span
                                                                                                                    class="toc-number">15.3.1.</span>
                                    <span class="toc-text">多重图</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#顶点的度"><span
                                                                                                                class="toc-number">15.4.</span>
                                <span class="toc-text">顶点的度</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#有限图、平凡图"><span
                                                                                                                    class="toc-number">15.4.1.</span>
                                    <span class="toc-text">有限图、平凡图
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#子图，同构，同胚图"><span
                                                                                                                class="toc-number">15.5.</span>
                                <span class="toc-text">子图，同构，同胚图
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#子图"><span
                                                                                                                    class="toc-number">15.5.1.</span>
                                    <span class="toc-text">子图</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#同构图"><span
                                                                                                                    class="toc-number">15.5.2.</span>
                                    <span class="toc-text">同构图</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#同胚图"><span
                                                                                                                    class="toc-number">15.5.3.</span>
                                    <span class="toc-text">同胚图</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#路、连通度"><span
                                                                                                                class="toc-number">15.6.</span>
                                <span class="toc-text">路、连通度</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#路"><span
                                                                                                                    class="toc-number">15.6.1.</span>
                                    <span class="toc-text">路</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#连通度，连通分支"><span
                                                                                                                    class="toc-number">15.6.2.</span>
                                    <span class="toc-text">连通度，连通分支
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#距离与直径"><span
                                                                                                                    class="toc-number">15.6.3.</span>
                                    <span class="toc-text">距离与直径</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#割点与桥"><span
                                                                                                                    class="toc-number">15.6.4.</span>
                                    <span class="toc-text">割点与桥</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#Konigsberg桥，可旅行多重图"><span
                                                                                                                class="toc-number">15.7.</span>
                                <span class="toc-text">Konigsberg桥，可旅行多重图
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#Hamilton图"><span
                                                                                                                class="toc-number">15.8.</span>
                                <span class="toc-text">Hamilton图
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#标号图与赋权图"><span
                                                                                                                class="toc-number">15.9.</span>
                                <span class="toc-text">标号图与赋权图
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#完全图、正则图与二部图"><span
                                                                                                                class="toc-number">15.10.</span>
                                <span class="toc-text">完全图、正则图与二部图
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#树图"><span
                                                                                                                class="toc-number">15.11.</span>
                                <span class="toc-text">树图</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#支撑树"><span
                                                                                                                    class="toc-number">15.11.1.</span>
                                    <span class="toc-text">支撑树</span></a>
                                  <ol class="toc-child">
                                    <li class="toc-item toc-level-4"><a class="toc-link"
                                                                                                                      href="#求n个顶点连通赋权图的最小支撑树的算法"><span
                                                                                                                        class="toc-number">15.11.1.1.</span>
                                        <span
                                                                                                                        class="toc-text">求n个顶点连通赋权图的最小支撑树的算法
                                        </span></a></li>
                                  </ol>
                                </li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#平面图"><span
                                                                                                                class="toc-number">15.12.</span>
                                <span class="toc-text">平面图</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#地图、区域"><span
                                                                                                                    class="toc-number">15.12.1.</span>
                                    <span class="toc-text">地图、区域</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#Euler公式"><span
                                                                                                                class="toc-number">15.13.</span>
                                <span class="toc-text">Euler公式
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#非平面图，Kuratowski定理"><span
                                                                                                                    class="toc-number">15.13.1.</span>
                                    <span class="toc-text">非平面图，Kuratowski定理
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#图着色"><span
                                                                                                                class="toc-number">15.14.</span>
                                <span class="toc-text">图着色</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#图G着色的算法"><span
                                                                                                                    class="toc-number">15.14.1.</span>
                                    <span class="toc-text">图G着色的算法
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#对偶地图与四色定理"><span
                                                                                                                    class="toc-number">15.14.2.</span>
                                    <span class="toc-text">对偶地图与四色定理
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#在计算机中储存图"><span
                                                                                                                class="toc-number">15.15.</span>
                                <span class="toc-text">在计算机中储存图
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#邻接矩阵"><span
                                                                                                                    class="toc-number">15.15.1.</span>
                                    <span class="toc-text">邻接矩阵</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#链表示"><span
                                                                                                                    class="toc-number">15.15.2.</span>
                                    <span class="toc-text">链表示</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#图算法"><span
                                                                                                                class="toc-number">15.16.</span>
                                <span class="toc-text">图算法</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#深度优先查找（DFS）"><span
                                                                                                                    class="toc-number">15.16.1.</span>
                                    <span class="toc-text">深度优先查找（DFS）
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#广度优先查找（BFS）"><span
                                                                                                                class="toc-number">15.17.</span>
                                <span class="toc-text">广度优先查找（BFS）
                                </span></a></li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-6"><span
                                                                                                            class="toc-number">16.</span>
                            <span class="toc-text">附录</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语-5"><span
                                                                                                                class="toc-number">16.1.</span>
                                <span class="toc-text">术语</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#salesmen-代码练习"><span
                                                                                                                    class="toc-number">16.1.1.</span>
                                    <span class="toc-text">salesmen
                                      代码练习</span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#二叉树"><span
                                                                                                            class="toc-number">17.</span>
                            <span class="toc-text">二叉树</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#二叉树定义"><span
                                                                                                                class="toc-number">17.1.</span>
                                <span class="toc-text">二叉树定义</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#二叉树的图示"><span
                                                                                                                    class="toc-number">17.1.1.</span>
                                    <span class="toc-text">二叉树的图示
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#相似二叉树"><span
                                                                                                                    class="toc-number">17.1.2.</span>
                                    <span class="toc-text">相似二叉树</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语-6"><span
                                                                                                                class="toc-number">17.2.</span>
                                <span class="toc-text">术语</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#完全二叉树"><span
                                                                                                                    class="toc-number">17.2.1.</span>
                                    <span class="toc-text">完全二叉树</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#扩充二叉树"><span
                                                                                                                    class="toc-number">17.2.2.</span>
                                    <span class="toc-text">扩充二叉树</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#二叉树的存储"><span
                                                                                                                class="toc-number">17.3.</span>
                                <span class="toc-text">二叉树的存储
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#遍历二叉树"><span
                                                                                                                class="toc-number">17.4.</span>
                                <span class="toc-text">遍历二叉树</span></a></li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-7"><span
                                                                                                            class="toc-number">18.</span>
                            <span class="toc-text">附录</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语-7"><span
                                                                                                                class="toc-number">18.1.</span>
                                <span class="toc-text">术语</span></a></li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#整数的性质"><span
                                                                                                            class="toc-number">19.</span>
                            <span class="toc-text">整数的性质</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#引言"><span
                                                                                                                class="toc-number">19.1.</span>
                                <span class="toc-text">引言</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#序、不等式与绝对值"><span
                                                                                                                class="toc-number">19.2.</span>
                                <span class="toc-text">序、不等式与绝对值
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#不等式的基本性质"><span
                                                                                                                    class="toc-number">19.2.1.</span>
                                    <span class="toc-text">不等式的基本性质
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#绝对值"><span
                                                                                                                    class="toc-number">19.2.2.</span>
                                    <span class="toc-text">绝对值</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#数法归纳法"><span
                                                                                                                class="toc-number">19.3.</span>
                                <span class="toc-text">数法归纳法</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#整除算法"><span
                                                                                                                class="toc-number">19.4.</span>
                                <span class="toc-text">整除算法</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#整除，素数"><span
                                                                                                                class="toc-number">19.5.</span>
                                <span class="toc-text">整除，素数</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#素数"><span
                                                                                                                    class="toc-number">19.5.1.</span>
                                    <span class="toc-text">素数</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#最大公因数，带余除法"><span
                                                                                                                class="toc-number">19.6.</span>
                                <span class="toc-text">最大公因数，带余除法
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#带余除法"><span
                                                                                                                    class="toc-number">19.6.1.</span>
                                    <span class="toc-text">带余除法</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#最小公倍数"><span
                                                                                                                    class="toc-number">19.6.2.</span>
                                    <span class="toc-text">最小公倍数</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#算术基本定理"><span
                                                                                                                class="toc-number">19.7.</span>
                                <span class="toc-text">算术基本定理
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#算术基本定理-1"><span
                                                                                                                    class="toc-number">19.7.1.</span>
                                    <span class="toc-text">算术基本定理
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#同余关系"><span
                                                                                                                    class="toc-number">19.7.2.</span>
                                    <span class="toc-text">同余关系</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#剩余类"><span
                                                                                                                    class="toc-number">19.7.3.</span>
                                    <span class="toc-text">剩余类</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#同余式"><span
                                                                                                                class="toc-number">19.8.</span>
                                <span class="toc-text">同余式</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#中国剩余定理"><span
                                                                                                                    class="toc-number">19.8.1.</span>
                                    <span class="toc-text">中国剩余定理
                                    </span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-8"><span
                                                                                                            class="toc-number">20.</span>
                            <span class="toc-text">附录</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语表"><span
                                                                                                                class="toc-number">20.1.</span>
                                <span class="toc-text">术语表</span></a></li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#代数系统"><span
                                                                                                            class="toc-number">21.</span>
                            <span class="toc-text">代数系统</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#重点难点"><span
                                                                                                                class="toc-number">21.1.</span>
                                <span class="toc-text">重点难点</span></a></li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#代数系统-1"><span
                                                                                                            class="toc-number">22.</span>
                            <span class="toc-text">代数系统
                            </span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#运算"><span
                                                                                                                class="toc-number">22.1.</span>
                                <span class="toc-text">运算</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#运算的性质"><span
                                                                                                                    class="toc-number">22.1.1.</span>
                                    <span class="toc-text">运算的性质</span></a>
                                  <ol class="toc-child">
                                    <li class="toc-item toc-level-4"><a class="toc-link"
                                                                                                                      href="#结合律"><span
                                                                                                                        class="toc-number">22.1.1.1.</span>
                                        <span class="toc-text">结合律</span></a>
                                    </li>
                                    <li class="toc-item toc-level-4"><a class="toc-link"
                                                                                                                      href="#交换律"><span
                                                                                                                        class="toc-number">22.1.1.2.</span>
                                        <span class="toc-text">交换律</span></a>
                                    </li>
                                  </ol>
                                </li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#单位元-和-逆元"><span
                                                                                                                    class="toc-number">22.1.2.</span>
                                    <span class="toc-text">单位元
                                      和 逆元</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#消去律"><span
                                                                                                                    class="toc-number">22.1.3.</span>
                                    <span class="toc-text">消去律</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#群"><span
                                                                                                                class="toc-number">22.2.</span>
                                <span class="toc-text">群</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#对称群-S-n"><span
                                                                                                                    class="toc-number">22.2.1.</span>
                                    <span class="toc-text">对称群
                                      S_n</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#MAP-A-PERM-A-和-AUT-A"><span
                                                                                                                class="toc-number">22.3.</span>
                                <span class="toc-text">MAP(A),
                                  PERM(A) 和 AUT(A)</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#子群，正规子群和同态"><span
                                                                                                                class="toc-number">22.4.</span>
                                <span class="toc-text">子群，正规子群和同态
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#自由半群，自由幺半群"><span
                                                                                                                    class="toc-number">22.4.1.</span>
                                    <span class="toc-text">自由半群，自由幺半群
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#子半群"><span
                                                                                                                    class="toc-number">22.4.2.</span>
                                    <span class="toc-text">子半群</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#同余关系和商结构"><span
                                                                                                                    class="toc-number">22.4.3.</span>
                                    <span class="toc-text">同余关系和商结构
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#半群的同态"><span
                                                                                                                    class="toc-number">22.4.4.</span>
                                    <span class="toc-text">半群的同态</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#半群同态的基本定理"><span
                                                                                                                    class="toc-number">22.4.5.</span>
                                    <span class="toc-text">半群同态的基本定理
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#半群的积"><span
                                                                                                                    class="toc-number">22.4.6.</span>
                                    <span class="toc-text">半群的积</span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-9"><span
                                                                                                            class="toc-number">23.</span>
                            <span class="toc-text">附录</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语-8"><span
                                                                                                                class="toc-number">23.1.</span>
                                <span class="toc-text">术语</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-5"><a class="toc-link"
                                                                                                                  href="#operation-ts"><span
                                                                                                                    class="toc-number">23.1.0.0.1.</span>
                                    <span class="toc-text">operation.ts
                                    </span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#形式语言、形式语法和自动机"><span
                                                                                                            class="toc-number">24.</span>
                            <span class="toc-text">形式语言、形式语法和自动机
                            </span></a></li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#形式语言、形式语法和自动机-1"><span
                                                                                                            class="toc-number">25.</span>
                            <span class="toc-text">形式语言、形式语法和自动机
                            </span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#字母表，字符串，自由半群"><span
                                                                                                                class="toc-number">25.1.</span>
                                <span class="toc-text">字母表，字符串，自由半群
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#连接"><span
                                                                                                                    class="toc-number">25.1.1.</span>
                                    <span class="toc-text">连接</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#子串，前缀"><span
                                                                                                                    class="toc-number">25.1.2.</span>
                                    <span class="toc-text">子串，前缀</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#自由半群，自由幺半群-1"><span
                                                                                                                    class="toc-number">25.1.3.</span>
                                    <span class="toc-text">自由半群，自由幺半群
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#形式语言"><span
                                                                                                                class="toc-number">25.2.</span>
                                <span class="toc-text">形式语言</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#形式语言的运算"><span
                                                                                                                    class="toc-number">25.2.1.</span>
                                    <span class="toc-text">形式语言的运算
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#正则表达，正则语言"><span
                                                                                                                class="toc-number">25.3.</span>
                                <span class="toc-text">正则表达，正则语言
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#有限自动机"><span
                                                                                                                class="toc-number">25.4.</span>
                                <span class="toc-text">有限自动机</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#自动机-M-的状态图"><span
                                                                                                                    class="toc-number">25.4.1.</span>
                                    <span class="toc-text">自动机
                                      M 的状态图</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#自动机-M-决定的形式语言-L-M"><span
                                                                                                                    class="toc-number">25.4.2.</span>
                                    <span class="toc-text">自动机
                                      M 决定的形式语言 L(M)</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#Pumping引理"><span
                                                                                                                    class="toc-number">25.4.3.</span>
                                    <span class="toc-text">Pumping引理
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#形式语法"><span
                                                                                                                class="toc-number">25.5.</span>
                                <span class="toc-text">形式语法</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#形式语法-G-的形式语言-L-G"><span
                                                                                                                    class="toc-number">25.5.1.</span>
                                    <span class="toc-text">形式语法
                                      G 的形式语言 L(G)</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#形式语法的类型"><span
                                                                                                                    class="toc-number">25.5.2.</span>
                                    <span class="toc-text">形式语法的类型
                                    </span></a>
                                  <ol class="toc-child">
                                    <li class="toc-item toc-level-4"><a class="toc-link"
                                                                                                                      href="#Noam-Chomsky分类法"><span
                                                                                                                        class="toc-number">25.5.2.1.</span>
                                        <span class="toc-text">Noam
                                          Chomsky分类法</span></a></li>
                                    <li class="toc-item toc-level-4"><a class="toc-link"
                                                                                                                      href="#上下文相关性分类"><span
                                                                                                                        class="toc-number">25.5.2.2.</span>
                                        <span class="toc-text">上下文相关性分类
                                        </span></a></li>
                                  </ol>
                                </li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#上下文无关语法的导出树"><span
                                                                                                                    class="toc-number">25.5.3.</span>
                                    <span class="toc-text">上下文无关语法的导出树
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#Backus-Naur形式"><span
                                                                                                                    class="toc-number">25.5.4.</span>
                                    <span class="toc-text">Backus-Naur形式
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#自动机与形式语法"><span
                                                                                                                    class="toc-number">25.5.5.</span>
                                    <span class="toc-text">自动机与形式语法
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#有限状态机"><span
                                                                                                                class="toc-number">25.6.</span>
                                <span class="toc-text">有限状态机</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#有限状态机的状态表与状态图"><span
                                                                                                                    class="toc-number">25.6.1.</span>
                                    <span class="toc-text">有限状态机的状态表与状态图
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#输入与输出带"><span
                                                                                                                    class="toc-number">25.6.2.</span>
                                    <span class="toc-text">输入与输出带
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#二进制加法"><span
                                                                                                                    class="toc-number">25.6.3.</span>
                                    <span class="toc-text">二进制加法</span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#Godel数"><span
                                                                                                                class="toc-number">25.7.</span>
                                <span class="toc-text">Gödel数
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#Turing机"><span
                                                                                                                class="toc-number">25.8.</span>
                                <span class="toc-text">Turing机
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#用Turing机计算"><span
                                                                                                                    class="toc-number">25.8.1.</span>
                                    <span class="toc-text">用Turing机计算
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#Turing机的输入"><span
                                                                                                                    class="toc-number">25.8.2.</span>
                                    <span class="toc-text">Turing机的输入
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#形式语法和Turing机"><span
                                                                                                                    class="toc-number">25.8.3.</span>
                                    <span class="toc-text">形式语法和Turing机
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#可计算的函数"><span
                                                                                                                class="toc-number">25.9.</span>
                                <span class="toc-text">可计算的函数
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#多元函数"><span
                                                                                                                    class="toc-number">25.9.1.</span>
                                    <span class="toc-text">多元函数</span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-10"><span
                                                                                                            class="toc-number">26.</span>
                            <span class="toc-text">附录</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语表-1"><span
                                                                                                                class="toc-number">26.1.</span>
                                <span class="toc-text">术语表</span></a></li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#有序集与格"><span
                                                                                                            class="toc-number">27.</span>
                            <span class="toc-text">有序集与格</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#有限集"><span
                                                                                                                class="toc-number">27.1.</span>
                                <span class="toc-text">有限集</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#对偶序"><span
                                                                                                                    class="toc-number">27.1.1.</span>
                                    <span class="toc-text">对偶序</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#有序子集"><span
                                                                                                                    class="toc-number">27.1.2.</span>
                                    <span class="toc-text">有序子集</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#半序"><span
                                                                                                                    class="toc-number">27.1.3.</span>
                                    <span class="toc-text">半序</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#可比较性，线性序集"><span
                                                                                                                    class="toc-number">27.1.4.</span>
                                    <span class="toc-text">可比较性，线性序集
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#积集和积序"><span
                                                                                                                    class="toc-number">27.1.5.</span>
                                    <span class="toc-text">积集和积序</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#Kleene闭包与序"><span
                                                                                                                    class="toc-number">27.1.6.</span>
                                    <span class="toc-text">Kleene闭包与序
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#偏序集的-Hasse图"><span
                                                                                                                class="toc-number">27.2.</span>
                                <span class="toc-text">偏序集的
                                  Hasse图</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#极大元素，极小元素，最小元素和最大元素"><span
                                                                                                                    class="toc-number">27.2.1.</span>
                                    <span class="toc-text">极大元素，极小元素，最小元素和最大元素
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#相容编号"><span
                                                                                                                class="toc-number">27.3.</span>
                                <span class="toc-text">相容编号</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#上确界-和-下确界"><span
                                                                                                                class="toc-number">27.4.</span>
                                <span class="toc-text">上确界
                                  和 下确界</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#同构序集"><span
                                                                                                                class="toc-number">27.5.</span>
                                <span class="toc-text">同构序集</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#良序集"><span
                                                                                                                class="toc-number">27.6.</span>
                                <span class="toc-text">良序集</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#超限归纳法"><span
                                                                                                                    class="toc-number">27.6.1.</span>
                                    <span class="toc-text">超限归纳法</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#选择公理，良序定理"><span
                                                                                                                    class="toc-number">27.6.2.</span>
                                    <span class="toc-text">选择公理，良序定理
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#格"><span
                                                                                                                class="toc-number">27.7.</span>
                                <span class="toc-text">格</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#对偶律-和-幂等律"><span
                                                                                                                    class="toc-number">27.7.1.</span>
                                    <span class="toc-text">对偶律
                                      和 幂等律</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#子格，同构格"><span
                                                                                                                    class="toc-number">27.7.2.</span>
                                    <span class="toc-text">子格，同构格
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#有界格"><span
                                                                                                                class="toc-number">27.8.</span>
                                <span class="toc-text">有界格</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#分配格"><span
                                                                                                                class="toc-number">27.9.</span>
                                <span class="toc-text">分配格</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#并不可约元素，原子"><span
                                                                                                                    class="toc-number">27.9.1.</span>
                                    <span class="toc-text">并不可约元素，原子
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#补元，有补格"><span
                                                                                                                class="toc-number">27.10.</span>
                                <span class="toc-text">补元，有补格
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#有补格"><span
                                                                                                                    class="toc-number">27.10.1.</span>
                                    <span class="toc-text">有补格</span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-11"><span
                                                                                                            class="toc-number">28.</span>
                            <span class="toc-text">附录</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语-9"><span
                                                                                                                class="toc-number">28.1.</span>
                                <span class="toc-text">术语</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#examples-tex-1"><span
                                                                                                                    class="toc-number">28.1.1.</span>
                                    <span class="toc-text">examples.tex
                                    </span></a>
                                  <ol class="toc-child">
                                    <li class="toc-item toc-level-4"><a class="toc-link"
                                                                                                                      href="#code"><span
                                                                                                                        class="toc-number">28.1.1.1.</span>
                                        <span class="toc-text">code</span></a>
                                    </li>
                                  </ol>
                                </li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#布尔代数"><span
                                                                                                            class="toc-number">29.</span>
                            <span class="toc-text">布尔代数</span></a></li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#布尔代数-1"><span
                                                                                                            class="toc-number">30.</span>
                            <span class="toc-text">布尔代数</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#基本概念-1"><span
                                                                                                                class="toc-number">30.1.</span>
                                <span class="toc-text">基本概念</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#子代数，同构的布尔代数"><span
                                                                                                                    class="toc-number">30.1.1.</span>
                                    <span class="toc-text">子代数，同构的布尔代数
                                    </span></a></li>
                              </ol>
                            </li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#对偶性-1"><span
                                                                                                                class="toc-number">30.2.</span>
                                <span class="toc-text">对偶性</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#布尔代数的基本定理"><span
                                                                                                                class="toc-number">30.3.</span>
                                <span class="toc-text">布尔代数的基本定理
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#作为格的布尔代数"><span
                                                                                                                class="toc-number">30.4.</span>
                                <span class="toc-text">作为格的布尔代数
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#表示定理"><span
                                                                                                                class="toc-number">30.5.</span>
                                <span class="toc-text">表示定理</span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#集合的积和式"><span
                                                                                                                class="toc-number">30.6.</span>
                                <span class="toc-text">集合的积和式
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#布尔代数的积和式"><span
                                                                                                                class="toc-number">30.7.</span>
                                <span class="toc-text">布尔代数的积和式
                                </span></a></li>
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#极小布尔表达式，素隐项"><span
                                                                                                                class="toc-number">30.8.</span>
                                <span class="toc-text">极小布尔表达式，素隐项
                                </span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#极小的积和式"><span
                                                                                                                    class="toc-number">30.8.1.</span>
                                    <span class="toc-text">极小的积和式
                                    </span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#素隐项"><span
                                                                                                                    class="toc-number">30.8.2.</span>
                                    <span class="toc-text">素隐项</span></a></li>
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#基本积的共识"><span
                                                                                                                    class="toc-number">30.8.3.</span>
                                    <span class="toc-text">基本积的共识
                                    </span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                        <li class="toc-item toc-level-1"><a class="toc-link"
                                                                                                          href="#附录-12"><span
                                                                                                            class="toc-number">31.</span>
                            <span class="toc-text">附录</span></a>
                          <ol class="toc-child">
                            <li class="toc-item toc-level-2"><a class="toc-link"
                                                                                                              href="#术语-10"><span
                                                                                                                class="toc-number">31.1.</span>
                                <span class="toc-text">术语</span></a>
                              <ol class="toc-child">
                                <li class="toc-item toc-level-3"><a class="toc-link"
                                                                                                                  href="#theorem-tex"><span
                                                                                                                    class="toc-number">31.1.1.</span>
                                    <span class="toc-text">theorem.tex
                                    </span></a></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                      </div>
                    </span>
                  </div>
                </div>

              </div>
            </aside>

            <div id="gitalk-container"></div>
            <link rel="stylesheet"
                                                                                            href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
            <script
                                                                                            src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js">
            </script>
            <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js">
            </script>

            <script>
              var gitalk = new Gitalk({
                clientID: '367167232dbd609ac9d5',
                clientSecret: '20b31b08c74d9e90fad40f940e6b938fdf8d6cd2',
                repo: 'starstarb.github.io',
                owner: 'starstarb',
                admin: ['starstarb'],
                id: md5(window.location.pathname),
                distractionFreeMode: true
              })
              gitalk.render('gitalk-container')

            </script>

          </div>
        </div>
      </div>
      <footer id="footer">
        <div class="outer">
          <div id="footer-info">
            <div class="footer-left">
              &copy; 2019 小星星

              <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
              <script>
                var now = new Date();

                function createtime() {
                  var grt = new Date("06/29/2019 20:00:00");
                  now.setTime(now.getTime() + 250);
                  days = (now - grt) / 1000 / 60 / 60 / 24;
                  dnum = Math.floor(days);
                  hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
                  hnum = Math.floor(hours);
                  if (String(hnum).length == 1) {
                    hnum = "0" + hnum;
                  }
                  minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 *
                    hnum);
                  mnum = Math.floor(minutes);
                  if (String(mnum).length == 1) {
                    mnum = "0" + mnum;
                  }
                  seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 *
                    60 *
                    hnum) - (60 * mnum);
                  snum = Math.round(seconds);
                  if (String(snum).length == 1) {
                    snum = "0" + snum;
                  }
                  document.getElementById("timeDate").innerHTML = "本站已安全运行 " +
                    dnum +
                    " 天 ";
                  document.getElementById("times").innerHTML = hnum + " 小时 " +
                    mnum +
                    " 分 " + snum + " 秒";
                }
                setInterval("createtime()", 250);

              </script>

            </div>
            <div class="footer-right">

              <script async
                                                                                              src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
              </script>
              <span id="busuanzi_container_site_pv">
                本站总访问量：<span id="busuanzi_value_site_pv"></span>次
              </span>
              <span class="post-meta-divider">|</span>
              <span id="busuanzi_container_site_uv">
                本站访客数：<span id="busuanzi_value_site_uv"></span>人
              </span>

            </div>
          </div>

        </div>

      </footer>

      <!--页面点击小红心-->
      <script type="text/javascript" src="/love.js"></script>

    </div>
    <script>
      var yiliaConfig = {
        mathjax: false,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false,
        toc_hide_index: true,
        root: "/",
        innerArchive: true,
        showTags: false
      }

    </script>
    <script>
      ! function(t) {
        function n(e) {
          if (r[e]) return r[e].exports;
          var i = r[e] = {
            exports: {},
            id: e,
            loaded: !1
          };
          return t[e].call(i.exports, i, i.exports, n), i.loaded = !0, i.exports
        }
        var r = {};
        n.m = t, n.c = r, n.p = "./", n(0)
      }([function(t, n, r) {
        r(195), t.exports = r(191)
      }, function(t, n, r) {
        var e = r(3),
          i = r(52),
          o = r(27),
          u = r(28),
          c = r(53),
          f = "prototype",
          a = function(t, n, r) {
            var s, l, h, v, p = t & a.F,
              d = t & a.G,
              y = t & a.S,
              g = t & a.P,
              b = t & a.B,
              m = d ? e : y ? e[n] || (e[n] = {}) : (e[n] || {})[f],
              x = d ? i : i[n] || (i[n] = {}),
              w = x[f] || (x[f] = {});
            d && (r = n);
            for (s in r) l = !p && m && void 0 !== m[s], h = (l ? m : r)[s],
              v =
              b && l ? c(h, e) : g && "function" == typeof h ? c(Function
                .call,
                h) : h, m && u(m, s, h, t & a.U), x[s] != h && o(x, s, v),
              g &&
              w[s] != h && (w[s] = h)
          };
        e.core = i, a.F = 1, a.G = 2, a.S = 4, a.P = 8, a.B = 16, a.W = 32,
          a
          .U = 64, a.R = 128, t.exports = a
      }, function(t, n, r) {
        var e = r(6);
        t.exports = function(t) {
          if (!e(t)) throw TypeError(t + " is not an object!");
          return t
        }
      }, function(t, n) {
        var r = t.exports = "undefined" != typeof window && window.Math ==
          Math ? window : "undefined" != typeof self && self.Math == Math ?
          self : Function("return this")();
        "number" == typeof __g && (__g = r)
      }, function(t, n) {
        t.exports = function(t) {
          try {
            return !!t()
          } catch (t) {
            return !0
          }
        }
      }, function(t, n) {
        var r = t.exports = "undefined" != typeof window && window.Math ==
          Math ? window : "undefined" != typeof self && self.Math == Math ?
          self : Function("return this")();
        "number" == typeof __g && (__g = r)
      }, function(t, n) {
        t.exports = function(t) {
          return "object" == typeof t ? null !== t : "function" ==
            typeof t
        }
      }, function(t, n, r) {
        var e = r(126)("wks"),
          i = r(76),
          o = r(3).Symbol,
          u = "function" == typeof o;
        (t.exports = function(t) {
          return e[t] || (e[t] = u && o[t] || (u ? o : i)("Symbol." + t))
        }).store = e
      }, function(t, n) {
        var r = {}.hasOwnProperty;
        t.exports = function(t, n) {
          return r.call(t, n)
        }
      }, function(t, n, r) {
        var e = r(94),
          i = r(33);
        t.exports = function(t) {
          return e(i(t))
        }
      }, function(t, n, r) {
        t.exports = !r(4)(function() {
          return 7 != Object.defineProperty({}, "a", {
            get: function() {
              return 7
            }
          }).a
        })
      }, function(t, n, r) {
        var e = r(2),
          i = r(167),
          o = r(50),
          u = Object.defineProperty;
        n.f = r(10) ? Object.defineProperty : function(t, n, r) {
          if (e(t), n = o(n, !0), e(r), i) try {
            return u(t, n, r)
          } catch (t) {}
          if ("get" in r || "set" in r) throw TypeError(
            "Accessors not supported!");
          return "value" in r && (t[n] = r.value), t
        }
      }, function(t, n, r) {
        t.exports = !r(18)(function() {
          return 7 != Object.defineProperty({}, "a", {
            get: function() {
              return 7
            }
          }).a
        })
      }, function(t, n, r) {
        var e = r(14),
          i = r(22);
        t.exports = r(12) ? function(t, n, r) {
          return e.f(t, n, i(1, r))
        } : function(t, n, r) {
          return t[n] = r, t
        }
      }, function(t, n, r) {
        var e = r(20),
          i = r(58),
          o = r(42),
          u = Object.defineProperty;
        n.f = r(12) ? Object.defineProperty : function(t, n, r) {
          if (e(t), n = o(n, !0), e(r), i) try {
            return u(t, n, r)
          } catch (t) {}
          if ("get" in r || "set" in r) throw TypeError(
            "Accessors not supported!");
          return "value" in r && (t[n] = r.value), t
        }
      }, function(t, n, r) {
        var e = r(40)("wks"),
          i = r(23),
          o = r(5).Symbol,
          u = "function" == typeof o;
        (t.exports = function(t) {
          return e[t] || (e[t] = u && o[t] || (u ? o : i)("Symbol." + t))
        }).store = e
      }, function(t, n, r) {
        var e = r(67),
          i = Math.min;
        t.exports = function(t) {
          return t > 0 ? i(e(t), 9007199254740991) : 0
        }
      }, function(t, n, r) {
        var e = r(46);
        t.exports = function(t) {
          return Object(e(t))
        }
      }, function(t, n) {
        t.exports = function(t) {
          try {
            return !!t()
          } catch (t) {
            return !0
          }
        }
      }, function(t, n, r) {
        var e = r(63),
          i = r(34);
        t.exports = Object.keys || function(t) {
          return e(t, i)
        }
      }, function(t, n, r) {
        var e = r(21);
        t.exports = function(t) {
          if (!e(t)) throw TypeError(t + " is not an object!");
          return t
        }
      }, function(t, n) {
        t.exports = function(t) {
          return "object" == typeof t ? null !== t : "function" ==
            typeof t
        }
      }, function(t, n) {
        t.exports = function(t, n) {
          return {
            enumerable: !(1 & t),
            configurable: !(2 & t),
            writable: !(4 & t),
            value: n
          }
        }
      }, function(t, n) {
        var r = 0,
          e = Math.random();
        t.exports = function(t) {
          return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++r + e)
            .toString(36))
        }
      }, function(t, n) {
        var r = {}.hasOwnProperty;
        t.exports = function(t, n) {
          return r.call(t, n)
        }
      }, function(t, n) {
        var r = t.exports = {
          version: "2.4.0"
        };
        "number" == typeof __e && (__e = r)
      }, function(t, n) {
        t.exports = function(t) {
          if ("function" != typeof t) throw TypeError(t +
            " is not a function!");
          return t
        }
      }, function(t, n, r) {
        var e = r(11),
          i = r(66);
        t.exports = r(10) ? function(t, n, r) {
          return e.f(t, n, i(1, r))
        } : function(t, n, r) {
          return t[n] = r, t
        }
      }, function(t, n, r) {
        var e = r(3),
          i = r(27),
          o = r(24),
          u = r(76)("src"),
          c = "toString",
          f = Function[c],
          a = ("" + f).split(c);
        r(52).inspectSource = function(t) {
          return f.call(t)
        }, (t.exports = function(t, n, r, c) {
          var f = "function" == typeof r;
          f && (o(r, "name") || i(r, "name", n)), t[n] !== r && (f && (
              o(r,
                u) || i(r, u, t[n] ? "" + t[n] : a.join(String(n)))),
            t ===
            e ? t[n] = r : c ? t[n] ? t[n] = r : i(t, n, r) : (
              delete t[
                n], i(t, n, r)))
        })(Function.prototype, c, function() {
          return "function" == typeof this && this[u] || f.call(this)
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(4),
          o = r(46),
          u = function(t, n, r, e) {
            var i = String(o(t)),
              u = "<" + n;
            return "" !== r && (u += " " + r + '="' + String(e).replace(
              /"/g,
              "&quot;") + '"'), u + ">" + i + "</" + n + ">"
          };
        t.exports = function(t, n) {
          var r = {};
          r[t] = n(u), e(e.P + e.F * i(function() {
            var n = "" [t]('"');
            return n !== n.toLowerCase() || n.split('"').length > 3
          }), "String", r)
        }
      }, function(t, n, r) {
        var e = r(115),
          i = r(46);
        t.exports = function(t) {
          return e(i(t))
        }
      }, function(t, n, r) {
        var e = r(116),
          i = r(66),
          o = r(30),
          u = r(50),
          c = r(24),
          f = r(167),
          a = Object.getOwnPropertyDescriptor;
        n.f = r(10) ? a : function(t, n) {
          if (t = o(t), n = u(n, !0), f) try {
            return a(t, n)
          } catch (t) {}
          if (c(t, n)) return i(!e.f.call(t, n), t[n])
        }
      }, function(t, n, r) {
        var e = r(24),
          i = r(17),
          o = r(145)("IE_PROTO"),
          u = Object.prototype;
        t.exports = Object.getPrototypeOf || function(t) {
          return t = i(t), e(t, o) ? t[o] : "function" == typeof t
            .constructor && t instanceof t.constructor ? t.constructor
            .prototype : t instanceof Object ? u : null
        }
      }, function(t, n) {
        t.exports = function(t) {
          if (void 0 == t) throw TypeError("Can't call method on  " + t);
          return t
        }
      }, function(t, n) {
        t.exports =
          "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf"
          .split(",")
      }, function(t, n) {
        t.exports = {}
      }, function(t, n) {
        t.exports = !0
      }, function(t, n) {
        n.f = {}.propertyIsEnumerable
      }, function(t, n, r) {
        var e = r(14).f,
          i = r(8),
          o = r(15)("toStringTag");
        t.exports = function(t, n, r) {
          t && !i(t = r ? t : t.prototype, o) && e(t, o, {
            configurable: !0,
            value: n
          })
        }
      }, function(t, n, r) {
        var e = r(40)("keys"),
          i = r(23);
        t.exports = function(t) {
          return e[t] || (e[t] = i(t))
        }
      }, function(t, n, r) {
        var e = r(5),
          i = "__core-js_shared__",
          o = e[i] || (e[i] = {});
        t.exports = function(t) {
          return o[t] || (o[t] = {})
        }
      }, function(t, n) {
        var r = Math.ceil,
          e = Math.floor;
        t.exports = function(t) {
          return isNaN(t = +t) ? 0 : (t > 0 ? e : r)(t)
        }
      }, function(t, n, r) {
        var e = r(21);
        t.exports = function(t, n) {
          if (!e(t)) return t;
          var r, i;
          if (n && "function" == typeof(r = t.toString) && !e(i = r.call(
              t)))
            return i;
          if ("function" == typeof(r = t.valueOf) && !e(i = r.call(t)))
            return i;
          if (!n && "function" == typeof(r = t.toString) && !e(i = r.call(
              t)))
            return i;
          throw TypeError("Can't convert object to primitive value")
        }
      }, function(t, n, r) {
        var e = r(5),
          i = r(25),
          o = r(36),
          u = r(44),
          c = r(14).f;
        t.exports = function(t) {
          var n = i.Symbol || (i.Symbol = o ? {} : e.Symbol || {});
          "_" == t.charAt(0) || t in n || c(n, t, {
            value: u.f(t)
          })
        }
      }, function(t, n, r) {
        n.f = r(15)
      }, function(t, n) {
        var r = {}.toString;
        t.exports = function(t) {
          return r.call(t).slice(8, -1)
        }
      }, function(t, n) {
        t.exports = function(t) {
          if (void 0 == t) throw TypeError("Can't call method on  " + t);
          return t
        }
      }, function(t, n, r) {
        var e = r(4);
        t.exports = function(t, n) {
          return !!t && e(function() {
            n ? t.call(null, function() {}, 1) : t.call(null)
          })
        }
      }, function(t, n, r) {
        var e = r(53),
          i = r(115),
          o = r(17),
          u = r(16),
          c = r(203);
        t.exports = function(t, n) {
          var r = 1 == t,
            f = 2 == t,
            a = 3 == t,
            s = 4 == t,
            l = 6 == t,
            h = 5 == t || l,
            v = n || c;
          return function(n, c, p) {
            for (var d, y, g = o(n), b = i(g), m = e(c, p, 3), x = u(b
                  .length), w = 0, S = r ? v(n, x) : f ? v(n, 0) :
                void 0; x >
              w; w++)
              if ((h || w in b) && (d = b[w], y = m(d, w, g), t))
                if (r) S[w] = y;
                else if (y) switch (t) {
              case 3:
                return !0;
              case 5:
                return d;
              case 6:
                return w;
              case 2:
                S.push(d)
            } else if (s) return !1;
            return l ? -1 : a || s ? s : S
          }
        }
      }, function(t, n, r) {
        var e = r(1),
          i = r(52),
          o = r(4);
        t.exports = function(t, n) {
          var r = (i.Object || {})[t] || Object[t],
            u = {};
          u[t] = n(r), e(e.S + e.F * o(function() {
            r(1)
          }), "Object", u)
        }
      }, function(t, n, r) {
        var e = r(6);
        t.exports = function(t, n) {
          if (!e(t)) return t;
          var r, i;
          if (n && "function" == typeof(r = t.toString) && !e(i = r.call(
              t)))
            return i;
          if ("function" == typeof(r = t.valueOf) && !e(i = r.call(t)))
            return i;
          if (!n && "function" == typeof(r = t.toString) && !e(i = r.call(
              t)))
            return i;
          throw TypeError("Can't convert object to primitive value")
        }
      }, function(t, n, r) {
        var e = r(5),
          i = r(25),
          o = r(91),
          u = r(13),
          c = "prototype",
          f = function(t, n, r) {
            var a, s, l, h = t & f.F,
              v = t & f.G,
              p = t & f.S,
              d = t & f.P,
              y = t & f.B,
              g = t & f.W,
              b = v ? i : i[n] || (i[n] = {}),
              m = b[c],
              x = v ? e : p ? e[n] : (e[n] || {})[c];
            v && (r = n);
            for (a in r)(s = !h && x && void 0 !== x[a]) && a in b || (l =
              s ?
              x[a] : r[a], b[a] = v && "function" != typeof x[a] ? r[a] :
              y &&
              s ? o(l, e) : g && x[a] == l ? function(t) {
                var n = function(n, r, e) {
                  if (this instanceof t) {
                    switch (arguments.length) {
                      case 0:
                        return new t;
                      case 1:
                        return new t(n);
                      case 2:
                        return new t(n, r)
                    }
                    return new t(n, r, e)
                  }
                  return t.apply(this, arguments)
                };
                return n[c] = t[c], n
              }(l) : d && "function" == typeof l ? o(Function.call, l) :
              l,
              d && ((b.virtual || (b.virtual = {}))[a] = l, t & f.R &&
                m && !
                m[a] && u(m, a, l)))
          };
        f.F = 1, f.G = 2, f.S = 4, f.P = 8, f.B = 16, f.W = 32, f.U = 64, f
          .R =
          128, t.exports = f
      }, function(t, n) {
        var r = t.exports = {
          version: "2.4.0"
        };
        "number" == typeof __e && (__e = r)
      }, function(t, n, r) {
        var e = r(26);
        t.exports = function(t, n, r) {
          if (e(t), void 0 === n) return t;
          switch (r) {
            case 1:
              return function(r) {
                return t.call(n, r)
              };
            case 2:
              return function(r, e) {
                return t.call(n, r, e)
              };
            case 3:
              return function(r, e, i) {
                return t.call(n, r, e, i)
              }
          }
          return function() {
            return t.apply(n, arguments)
          }
        }
      }, function(t, n, r) {
        var e = r(183),
          i = r(1),
          o = r(126)("metadata"),
          u = o.store || (o.store = new(r(186))),
          c = function(t, n, r) {
            var i = u.get(t);
            if (!i) {
              if (!r) return;
              u.set(t, i = new e)
            }
            var o = i.get(n);
            if (!o) {
              if (!r) return;
              i.set(n, o = new e)
            }
            return o
          },
          f = function(t, n, r) {
            var e = c(n, r, !1);
            return void 0 !== e && e.has(t)
          },
          a = function(t, n, r) {
            var e = c(n, r, !1);
            return void 0 === e ? void 0 : e.get(t)
          },
          s = function(t, n, r, e) {
            c(r, e, !0).set(t, n)
          },
          l = function(t, n) {
            var r = c(t, n, !1),
              e = [];
            return r && r.forEach(function(t, n) {
              e.push(n)
            }), e
          },
          h = function(t) {
            return void 0 === t || "symbol" == typeof t ? t : String(t)
          },
          v = function(t) {
            i(i.S, "Reflect", t)
          };
        t.exports = {
          store: u,
          map: c,
          has: f,
          get: a,
          set: s,
          keys: l,
          key: h,
          exp: v
        }
      }, function(t, n, r) {
        "use strict";
        if (r(10)) {
          var e = r(69),
            i = r(3),
            o = r(4),
            u = r(1),
            c = r(127),
            f = r(152),
            a = r(53),
            s = r(68),
            l = r(66),
            h = r(27),
            v = r(73),
            p = r(67),
            d = r(16),
            y = r(75),
            g = r(50),
            b = r(24),
            m = r(180),
            x = r(114),
            w = r(6),
            S = r(17),
            _ = r(137),
            O = r(70),
            E = r(32),
            P = r(71).f,
            j = r(154),
            F = r(76),
            M = r(7),
            A = r(48),
            N = r(117),
            T = r(146),
            I = r(155),
            k = r(80),
            L = r(123),
            R = r(74),
            C = r(130),
            D = r(160),
            U = r(11),
            W = r(31),
            G = U.f,
            B = W.f,
            V = i.RangeError,
            z = i.TypeError,
            q = i.Uint8Array,
            K = "ArrayBuffer",
            J = "Shared" + K,
            Y = "BYTES_PER_ELEMENT",
            H = "prototype",
            $ = Array[H],
            X = f.ArrayBuffer,
            Q = f.DataView,
            Z = A(0),
            tt = A(2),
            nt = A(3),
            rt = A(4),
            et = A(5),
            it = A(6),
            ot = N(!0),
            ut = N(!1),
            ct = I.values,
            ft = I.keys,
            at = I.entries,
            st = $.lastIndexOf,
            lt = $.reduce,
            ht = $.reduceRight,
            vt = $.join,
            pt = $.sort,
            dt = $.slice,
            yt = $.toString,
            gt = $.toLocaleString,
            bt = M("iterator"),
            mt = M("toStringTag"),
            xt = F("typed_constructor"),
            wt = F("def_constructor"),
            St = c.CONSTR,
            _t = c.TYPED,
            Ot = c.VIEW,
            Et = "Wrong length!",
            Pt = A(1, function(t, n) {
              return Tt(T(t, t[wt]), n)
            }),
            jt = o(function() {
              return 1 === new q(new Uint16Array([1]).buffer)[0]
            }),
            Ft = !!q && !!q[H].set && o(function() {
              new q(1).set({})
            }),
            Mt = function(t, n) {
              if (void 0 === t) throw z(Et);
              var r = +t,
                e = d(t);
              if (n && !m(r, e)) throw V(Et);
              return e
            },
            At = function(t, n) {
              var r = p(t);
              if (r < 0 || r % n) throw V("Wrong offset!");
              return r
            },
            Nt = function(t) {
              if (w(t) && _t in t) return t;
              throw z(t + " is not a typed array!")
            },
            Tt = function(t, n) {
              if (!(w(t) && xt in t)) throw z(
                "It is not a typed array constructor!");
              return new t(n)
            },
            It = function(t, n) {
              return kt(T(t, t[wt]), n)
            },
            kt = function(t, n) {
              for (var r = 0, e = n.length, i = Tt(t, e); e > r;) i[r] = n[
                r++];
              return i
            },
            Lt = function(t, n, r) {
              G(t, n, {
                get: function() {
                  return this._d[r]
                }
              })
            },
            Rt = function(t) {
              var n, r, e, i, o, u, c = S(t),
                f = arguments.length,
                s = f > 1 ? arguments[1] : void 0,
                l = void 0 !== s,
                h = j(c);
              if (void 0 != h && !_(h)) {
                for (u = h.call(c), e = [], n = 0; !(o = u.next())
                  .done; n++) e
                  .push(o.value);
                c = e
              }
              for (l && f > 2 && (s = a(s, arguments[2], 2)), n = 0, r = d(c
                  .length), i = Tt(this, r); r > n; n++) i[n] = l ? s(c[n],
                  n) :
                c[n];
              return i
            },
            Ct = function() {
              for (var t = 0, n = arguments.length, r = Tt(this, n); n > t;)
                r[
                  t] = arguments[t++];
              return r
            },
            Dt = !!q && o(function() {
              gt.call(new q(1))
            }),
            Ut = function() {
              return gt.apply(Dt ? dt.call(Nt(this)) : Nt(this), arguments)
            },
            Wt = {
              copyWithin: function(t, n) {
                return D.call(Nt(this), t, n, arguments.length > 2 ?
                  arguments[2] : void 0)
              },
              every: function(t) {
                return rt(Nt(this), t, arguments.length > 1 ? arguments[
                  1] :
                  void 0)
              },
              fill: function(t) {
                return C.apply(Nt(this), arguments)
              },
              filter: function(t) {
                return It(this, tt(Nt(this), t, arguments.length > 1 ?
                  arguments[1] : void 0))
              },
              find: function(t) {
                return et(Nt(this), t, arguments.length > 1 ? arguments[
                  1] :
                  void 0)
              },
              findIndex: function(t) {
                return it(Nt(this), t, arguments.length > 1 ? arguments[
                  1] :
                  void 0)
              },
              forEach: function(t) {
                Z(Nt(this), t, arguments.length > 1 ? arguments[1] :
                  void 0)
              },
              indexOf: function(t) {
                return ut(Nt(this), t, arguments.length > 1 ? arguments[
                  1] :
                  void 0)
              },
              includes: function(t) {
                return ot(Nt(this), t, arguments.length > 1 ? arguments[
                  1] :
                  void 0)
              },
              join: function(t) {
                return vt.apply(Nt(this), arguments)
              },
              lastIndexOf: function(t) {
                return st.apply(Nt(this), arguments)
              },
              map: function(t) {
                return Pt(Nt(this), t, arguments.length > 1 ? arguments[
                  1] :
                  void 0)
              },
              reduce: function(t) {
                return lt.apply(Nt(this), arguments)
              },
              reduceRight: function(t) {
                return ht.apply(Nt(this), arguments)
              },
              reverse: function() {
                for (var t, n = this, r = Nt(n).length, e = Math.floor(r /
                      2),
                    i = 0; i < e;) t = n[i], n[i++] = n[--r], n[r] = t;
                return n
              },
              some: function(t) {
                return nt(Nt(this), t, arguments.length > 1 ? arguments[
                  1] :
                  void 0)
              },
              sort: function(t) {
                return pt.call(Nt(this), t)
              },
              subarray: function(t, n) {
                var r = Nt(this),
                  e = r.length,
                  i = y(t, e);
                return new(T(r, r[wt]))(r.buffer, r.byteOffset + i * r
                  .BYTES_PER_ELEMENT, d((void 0 === n ? e : y(n, e)) -
                    i))
              }
            },
            Gt = function(t, n) {
              return It(this, dt.call(Nt(this), t, n))
            },
            Bt = function(t) {
              Nt(this);
              var n = At(arguments[1], 1),
                r = this.length,
                e = S(t),
                i = d(e.length),
                o = 0;
              if (i + n > r) throw V(Et);
              for (; o < i;) this[n + o] = e[o++]
            },
            Vt = {
              entries: function() {
                return at.call(Nt(this))
              },
              keys: function() {
                return ft.call(Nt(this))
              },
              values: function() {
                return ct.call(Nt(this))
              }
            },
            zt = function(t, n) {
              return w(t) && t[_t] && "symbol" != typeof n && n in t &&
                String(+
                  n) == String(n)
            },
            qt = function(t, n) {
              return zt(t, n = g(n, !0)) ? l(2, t[n]) : B(t, n)
            },
            Kt = function(t, n, r) {
              return !(zt(t, n = g(n, !0)) && w(r) && b(r, "value")) || b(r,
                  "get") || b(r, "set") || r.configurable || b(r,
                  "writable") &&
                !r.writable || b(r, "enumerable") && !r.enumerable ? G(t, n,
                  r) : (t[n] = r.value, t)
            };
          St || (W.f = qt, U.f = Kt), u(u.S + u.F * !St, "Object", {
            getOwnPropertyDescriptor: qt,
            defineProperty: Kt
          }), o(function() {
            yt.call({})
          }) && (yt = gt = function() {
            return vt.call(this)
          });
          var Jt = v({}, Wt);
          v(Jt, Vt), h(Jt, bt, Vt.values), v(Jt, {
            slice: Gt,
            set: Bt,
            constructor: function() {},
            toString: yt,
            toLocaleString: Ut
          }), Lt(Jt, "buffer", "b"), Lt(Jt, "byteOffset", "o"), Lt(Jt,
            "byteLength", "l"), Lt(Jt, "length", "e"), G(Jt, mt, {
            get: function() {
              return this[_t]
            }
          }), t.exports = function(t, n, r, f) {
            f = !!f;
            var a = t + (f ? "Clamped" : "") + "Array",
              l = "Uint8Array" != a,
              v = "get" + t,
              p = "set" + t,
              y = i[a],
              g = y || {},
              b = y && E(y),
              m = !y || !c.ABV,
              S = {},
              _ = y && y[H],
              j = function(t, r) {
                var e = t._d;
                return e.v[v](r * n + e.o, jt)
              },
              F = function(t, r, e) {
                var i = t._d;
                f && (e = (e = Math.round(e)) < 0 ? 0 : e > 255 ? 255 :
                  255 &
                  e), i.v[p](r * n + i.o, e, jt)
              },
              M = function(t, n) {
                G(t, n, {
                  get: function() {
                    return j(this, n)
                  },
                  set: function(t) {
                    return F(this, n, t)
                  },
                  enumerable: !0
                })
              };
            m ? (y = r(function(t, r, e, i) {
              s(t, y, a, "_d");
              var o, u, c, f, l = 0,
                v = 0;
              if (w(r)) {
                if (!(r instanceof X || (f = x(r)) == K || f == J))
                  return _t in r ? kt(y, r) : Rt.call(y, r);
                o = r, v = At(e, n);
                var p = r.byteLength;
                if (void 0 === i) {
                  if (p % n) throw V(Et);
                  if ((u = p - v) < 0) throw V(Et)
                } else if ((u = d(i) * n) + v > p) throw V(Et);
                c = u / n
              } else c = Mt(r, !0), u = c * n, o = new X(u);
              for (h(t, "_d", {
                  b: o,
                  o: v,
                  l: u,
                  e: c,
                  v: new Q(o)
                }); l < c;) M(t, l++)
            }), _ = y[H] = O(Jt), h(_, "constructor", y)) : L(function(
              t) {
              new y(null), new y(t)
            }, !0) || (y = r(function(t, r, e, i) {
              s(t, y, a);
              var o;
              return w(r) ? r instanceof X || (o = x(r)) == K ||
                o ==
                J ? void 0 !== i ? new g(r, At(e, n), i) :
                void 0 !==
                e ? new g(r, At(e, n)) : new g(r) : _t in r ? kt(y,
                  r) :
                Rt.call(y, r) : new g(Mt(r, l))
            }), Z(b !== Function.prototype ? P(g).concat(P(b)) : P(g),
              function(t) {
                t in y || h(y, t, g[t])
              }), y[H] = _, e || (_.constructor = y));
            var A = _[bt],
              N = !!A && ("values" == A.name || void 0 == A.name),
              T = Vt.values;
            h(y, xt, !0), h(_, _t, a), h(_, Ot, !0), h(_, wt, y), (f ?
              new y(
                1)[mt] == a : mt in _) || G(_, mt, {
              get: function() {
                return a
              }
            }), S[a] = y, u(u.G + u.W + u.F * (y != g), S), u(u.S, a, {
              BYTES_PER_ELEMENT: n,
              from: Rt,
              of: Ct
            }), Y in _ || h(_, Y, n), u(u.P, a, Wt), R(a), u(u.P + u.F *
              Ft,
              a, {
                set: Bt
              }), u(u.P + u.F * !N, a, Vt), u(u.P + u.F * (_.toString !=
              yt), a, {
              toString: yt
            }), u(u.P + u.F * o(function() {
              new y(1).slice()
            }), a, {
              slice: Gt
            }), u(u.P + u.F * (o(function() {
              return [1, 2].toLocaleString() != new y([1, 2])
                .toLocaleString()
            }) || !o(function() {
              _.toLocaleString.call([1, 2])
            })), a, {
              toLocaleString: Ut
            }), k[a] = N ? A : T, e || N || h(_, bt, T)
          }
        } else t.exports = function() {}
      }, function(t, n) {
        var r = {}.toString;
        t.exports = function(t) {
          return r.call(t).slice(8, -1)
        }
      }, function(t, n, r) {
        var e = r(21),
          i = r(5).document,
          o = e(i) && e(i.createElement);
        t.exports = function(t) {
          return o ? i.createElement(t) : {}
        }
      }, function(t, n, r) {
        t.exports = !r(12) && !r(18)(function() {
          return 7 != Object.defineProperty(r(57)("div"), "a", {
            get: function() {
              return 7
            }
          }).a
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(36),
          i = r(51),
          o = r(64),
          u = r(13),
          c = r(8),
          f = r(35),
          a = r(96),
          s = r(38),
          l = r(103),
          h = r(15)("iterator"),
          v = !([].keys && "next" in [].keys()),
          p = "keys",
          d = "values",
          y = function() {
            return this
          };
        t.exports = function(t, n, r, g, b, m, x) {
          a(r, n, g);
          var w, S, _, O = function(t) {
              if (!v && t in F) return F[t];
              switch (t) {
                case p:
                case d:
                  return function() {
                    return new r(this, t)
                  }
              }
              return function() {
                return new r(this, t)
              }
            },
            E = n + " Iterator",
            P = b == d,
            j = !1,
            F = t.prototype,
            M = F[h] || F["@@iterator"] || b && F[b],
            A = M || O(b),
            N = b ? P ? O("entries") : A : void 0,
            T = "Array" == n ? F.entries || M : M;
          if (T && (_ = l(T.call(new t))) !== Object.prototype && (s(_, E,
              !
              0), e || c(_, h) || u(_, h, y)), P && M && M.name !== d && (
              j = !0, A = function() {
                return M.call(this)
              }), e && !x || !v && !j && F[h] || u(F, h, A), f[n] = A, f[
              E] =
            y, b)
            if (w = {
                values: P ? A : O(d),
                keys: m ? A : O(p),
                entries: N
              }, x)
              for (S in w) S in F || o(F, S, w[S]);
            else i(i.P + i.F * (v || j), n, w);
          return w
        }
      }, function(t, n, r) {
        var e = r(20),
          i = r(100),
          o = r(34),
          u = r(39)("IE_PROTO"),
          c = function() {},
          f = "prototype",
          a = function() {
            var t, n = r(57)("iframe"),
              e = o.length;
            for (n.style.display = "none", r(93).appendChild(n), n.src =
              "javascript:", t = n.contentWindow.document, t.open(), t
              .write(
                "<script>document.F=Object<\/script>"), t.close(), a = t
              .F; e--;
            ) delete a[f][o[e]];
            return a()
          };
        t.exports = Object.create || function(t, n) {
          var r;
          return null !== t ? (c[f] = e(t), r = new c, c[f] = null, r[u] =
            t) : r = a(), void 0 === n ? r : i(r, n)
        }
      }, function(t, n, r) {
        var e = r(63),
          i = r(34).concat("length", "prototype");
        n.f = Object.getOwnPropertyNames || function(t) {
          return e(t, i)
        }
      }, function(t, n) {
        n.f = Object.getOwnPropertySymbols
      }, function(t, n, r) {
        var e = r(8),
          i = r(9),
          o = r(90)(!1),
          u = r(39)("IE_PROTO");
        t.exports = function(t, n) {
          var r, c = i(t),
            f = 0,
            a = [];
          for (r in c) r != u && e(c, r) && a.push(r);
          for (; n.length > f;) e(c, r = n[f++]) && (~o(a, r) || a.push(
            r));
          return a
        }
      }, function(t, n, r) {
        t.exports = r(13)
      }, function(t, n, r) {
        var e = r(76)("meta"),
          i = r(6),
          o = r(24),
          u = r(11).f,
          c = 0,
          f = Object.isExtensible || function() {
            return !0
          },
          a = !r(4)(function() {
            return f(Object.preventExtensions({}))
          }),
          s = function(t) {
            u(t, e, {
              value: {
                i: "O" + ++c,
                w: {}
              }
            })
          },
          l = function(t, n) {
            if (!i(t)) return "symbol" == typeof t ? t : ("string" ==
              typeof t ?
              "S" : "P") + t;
            if (!o(t, e)) {
              if (!f(t)) return "F";
              if (!n) return "E";
              s(t)
            }
            return t[e].i
          },
          h = function(t, n) {
            if (!o(t, e)) {
              if (!f(t)) return !0;
              if (!n) return !1;
              s(t)
            }
            return t[e].w
          },
          v = function(t) {
            return a && p.NEED && f(t) && !o(t, e) && s(t), t
          },
          p = t.exports = {
            KEY: e,
            NEED: !1,
            fastKey: l,
            getWeak: h,
            onFreeze: v
          }
      }, function(t, n) {
        t.exports = function(t, n) {
          return {
            enumerable: !(1 & t),
            configurable: !(2 & t),
            writable: !(4 & t),
            value: n
          }
        }
      }, function(t, n) {
        var r = Math.ceil,
          e = Math.floor;
        t.exports = function(t) {
          return isNaN(t = +t) ? 0 : (t > 0 ? e : r)(t)
        }
      }, function(t, n) {
        t.exports = function(t, n, r, e) {
          if (!(t instanceof n) || void 0 !== e && e in t)
          throw TypeError(r +
              ": incorrect invocation!");
          return t
        }
      }, function(t, n) {
        t.exports = !1
      }, function(t, n, r) {
        var e = r(2),
          i = r(173),
          o = r(133),
          u = r(145)("IE_PROTO"),
          c = function() {},
          f = "prototype",
          a = function() {
            var t, n = r(132)("iframe"),
              e = o.length;
            for (n.style.display = "none", r(135).appendChild(n), n.src =
              "javascript:", t = n.contentWindow.document, t.open(), t
              .write(
                "<script>document.F=Object<\/script>"), t.close(), a = t
              .F; e--;
            ) delete a[f][o[e]];
            return a()
          };
        t.exports = Object.create || function(t, n) {
          var r;
          return null !== t ? (c[f] = e(t), r = new c, c[f] = null, r[u] =
            t) : r = a(), void 0 === n ? r : i(r, n)
        }
      }, function(t, n, r) {
        var e = r(175),
          i = r(133).concat("length", "prototype");
        n.f = Object.getOwnPropertyNames || function(t) {
          return e(t, i)
        }
      }, function(t, n, r) {
        var e = r(175),
          i = r(133);
        t.exports = Object.keys || function(t) {
          return e(t, i)
        }
      }, function(t, n, r) {
        var e = r(28);
        t.exports = function(t, n, r) {
          for (var i in n) e(t, i, n[i], r);
          return t
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(3),
          i = r(11),
          o = r(10),
          u = r(7)("species");
        t.exports = function(t) {
          var n = e[t];
          o && n && !n[u] && i.f(n, u, {
            configurable: !0,
            get: function() {
              return this
            }
          })
        }
      }, function(t, n, r) {
        var e = r(67),
          i = Math.max,
          o = Math.min;
        t.exports = function(t, n) {
          return t = e(t), t < 0 ? i(t + n, 0) : o(t, n)
        }
      }, function(t, n) {
        var r = 0,
          e = Math.random();
        t.exports = function(t) {
          return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++r + e)
            .toString(36))
        }
      }, function(t, n, r) {
        var e = r(33);
        t.exports = function(t) {
          return Object(e(t))
        }
      }, function(t, n, r) {
        var e = r(7)("unscopables"),
          i = Array.prototype;
        void 0 == i[e] && r(27)(i, e, {}), t.exports = function(t) {
          i[e][t] = !0
        }
      }, function(t, n, r) {
        var e = r(53),
          i = r(169),
          o = r(137),
          u = r(2),
          c = r(16),
          f = r(154),
          a = {},
          s = {},
          n = t.exports = function(t, n, r, l, h) {
            var v, p, d, y, g = h ? function() {
                return t
              } : f(t),
              b = e(r, l, n ? 2 : 1),
              m = 0;
            if ("function" != typeof g) throw TypeError(t +
              " is not iterable!");
            if (o(g)) {
              for (v = c(t.length); v > m; m++)
                if ((y = n ? b(u(p = t[m])[0], p[1]) : b(t[m])) === a ||
                  y ===
                  s) return y
            } else
              for (d = g.call(t); !(p = d.next()).done;)
                if ((y = i(d, b, p.value, n)) === a || y === s) return y
          };
        n.BREAK = a, n.RETURN = s
      }, function(t, n) {
        t.exports = {}
      }, function(t, n, r) {
        var e = r(11).f,
          i = r(24),
          o = r(7)("toStringTag");
        t.exports = function(t, n, r) {
          t && !i(t = r ? t : t.prototype, o) && e(t, o, {
            configurable: !0,
            value: n
          })
        }
      }, function(t, n, r) {
        var e = r(1),
          i = r(46),
          o = r(4),
          u = r(150),
          c = "[" + u + "]",
          f = "​",
          a = RegExp("^" + c + c + "*"),
          s = RegExp(c + c + "*$"),
          l = function(t, n, r) {
            var i = {},
              c = o(function() {
                return !!u[t]() || f[t]() != f
              }),
              a = i[t] = c ? n(h) : u[t];
            r && (i[r] = a), e(e.P + e.F * c, "String", i)
          },
          h = l.trim = function(t, n) {
            return t = String(i(t)), 1 & n && (t = t.replace(a, "")), 2 &
              n && (
                t = t.replace(s, "")), t
          };
        t.exports = l
      }, function(t, n, r) {
        t.exports = {
          default: r(86),
          __esModule: !0
        }
      }, function(t, n, r) {
        t.exports = {
          default: r(87),
          __esModule: !0
        }
      }, function(t, n, r) {
        "use strict";

        function e(t) {
          return t && t.__esModule ? t : {
            default: t
          }
        }
        n.__esModule = !0;
        var i = r(84),
          o = e(i),
          u = r(83),
          c = e(u),
          f = "function" == typeof c.default && "symbol" == typeof o
          .default ?
          function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof c.default && t.constructor ===
              c
              .default && t !== c.default.prototype ? "symbol" : typeof t
          };
        n.default = "function" == typeof c.default && "symbol" === f(o
          .default) ? function(t) {
          return void 0 === t ? "undefined" : f(t)
        } : function(t) {
          return t && "function" == typeof c.default && t.constructor ===
            c
            .default && t !== c.default.prototype ? "symbol" : void 0 ===
            t ?
            "undefined" : f(t)
        }
      }, function(t, n, r) {
        r(110), r(108), r(111), r(112), t.exports = r(25).Symbol
      }, function(t, n, r) {
        r(109), r(113), t.exports = r(44).f("iterator")
      }, function(t, n) {
        t.exports = function(t) {
          if ("function" != typeof t) throw TypeError(t +
            " is not a function!");
          return t
        }
      }, function(t, n) {
        t.exports = function() {}
      }, function(t, n, r) {
        var e = r(9),
          i = r(106),
          o = r(105);
        t.exports = function(t) {
          return function(n, r, u) {
            var c, f = e(n),
              a = i(f.length),
              s = o(u, a);
            if (t && r != r) {
              for (; a > s;)
                if ((c = f[s++]) != c) return !0
            } else
              for (; a > s; s++)
                if ((t || s in f) && f[s] === r) return t || s || 0;
            return !t && -1
          }
        }
      }, function(t, n, r) {
        var e = r(88);
        t.exports = function(t, n, r) {
          if (e(t), void 0 === n) return t;
          switch (r) {
            case 1:
              return function(r) {
                return t.call(n, r)
              };
            case 2:
              return function(r, e) {
                return t.call(n, r, e)
              };
            case 3:
              return function(r, e, i) {
                return t.call(n, r, e, i)
              }
          }
          return function() {
            return t.apply(n, arguments)
          }
        }
      }, function(t, n, r) {
        var e = r(19),
          i = r(62),
          o = r(37);
        t.exports = function(t) {
          var n = e(t),
            r = i.f;
          if (r)
            for (var u, c = r(t), f = o.f, a = 0; c.length > a;) f.call(t,
              u =
              c[a++]) && n.push(u);
          return n
        }
      }, function(t, n, r) {
        t.exports = r(5).document && document.documentElement
      }, function(t, n, r) {
        var e = r(56);
        t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(
          t) {
          return "String" == e(t) ? t.split("") : Object(t)
        }
      }, function(t, n, r) {
        var e = r(56);
        t.exports = Array.isArray || function(t) {
          return "Array" == e(t)
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(60),
          i = r(22),
          o = r(38),
          u = {};
        r(13)(u, r(15)("iterator"), function() {
          return this
        }), t.exports = function(t, n, r) {
          t.prototype = e(u, {
            next: i(1, r)
          }), o(t, n + " Iterator")
        }
      }, function(t, n) {
        t.exports = function(t, n) {
          return {
            value: n,
            done: !!t
          }
        }
      }, function(t, n, r) {
        var e = r(19),
          i = r(9);
        t.exports = function(t, n) {
          for (var r, o = i(t), u = e(o), c = u.length, f = 0; c > f;)
            if (o[r = u[f++]] === n) return r
        }
      }, function(t, n, r) {
        var e = r(23)("meta"),
          i = r(21),
          o = r(8),
          u = r(14).f,
          c = 0,
          f = Object.isExtensible || function() {
            return !0
          },
          a = !r(18)(function() {
            return f(Object.preventExtensions({}))
          }),
          s = function(t) {
            u(t, e, {
              value: {
                i: "O" + ++c,
                w: {}
              }
            })
          },
          l = function(t, n) {
            if (!i(t)) return "symbol" == typeof t ? t : ("string" ==
              typeof t ?
              "S" : "P") + t;
            if (!o(t, e)) {
              if (!f(t)) return "F";
              if (!n) return "E";
              s(t)
            }
            return t[e].i
          },
          h = function(t, n) {
            if (!o(t, e)) {
              if (!f(t)) return !0;
              if (!n) return !1;
              s(t)
            }
            return t[e].w
          },
          v = function(t) {
            return a && p.NEED && f(t) && !o(t, e) && s(t), t
          },
          p = t.exports = {
            KEY: e,
            NEED: !1,
            fastKey: l,
            getWeak: h,
            onFreeze: v
          }
      }, function(t, n, r) {
        var e = r(14),
          i = r(20),
          o = r(19);
        t.exports = r(12) ? Object.defineProperties : function(t, n) {
          i(t);
          for (var r, u = o(n), c = u.length, f = 0; c > f;) e.f(t, r = u[
            f++], n[r]);
          return t
        }
      }, function(t, n, r) {
        var e = r(37),
          i = r(22),
          o = r(9),
          u = r(42),
          c = r(8),
          f = r(58),
          a = Object.getOwnPropertyDescriptor;
        n.f = r(12) ? a : function(t, n) {
          if (t = o(t), n = u(n, !0), f) try {
            return a(t, n)
          } catch (t) {}
          if (c(t, n)) return i(!e.f.call(t, n), t[n])
        }
      }, function(t, n, r) {
        var e = r(9),
          i = r(61).f,
          o = {}.toString,
          u = "object" == typeof window && window && Object
          .getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
          c = function(t) {
            try {
              return i(t)
            } catch (t) {
              return u.slice()
            }
          };
        t.exports.f = function(t) {
          return u && "[object Window]" == o.call(t) ? c(t) : i(e(t))
        }
      }, function(t, n, r) {
        var e = r(8),
          i = r(77),
          o = r(39)("IE_PROTO"),
          u = Object.prototype;
        t.exports = Object.getPrototypeOf || function(t) {
          return t = i(t), e(t, o) ? t[o] : "function" == typeof t
            .constructor && t instanceof t.constructor ? t.constructor
            .prototype : t instanceof Object ? u : null
        }
      }, function(t, n, r) {
        var e = r(41),
          i = r(33);
        t.exports = function(t) {
          return function(n, r) {
            var o, u, c = String(i(n)),
              f = e(r),
              a = c.length;
            return f < 0 || f >= a ? t ? "" : void 0 : (o = c
              .charCodeAt(f),
              o < 55296 || o > 56319 || f + 1 === a || (u = c
                .charCodeAt(
                  f + 1)) < 56320 || u > 57343 ? t ? c.charAt(f) : o :
              t ? c
              .slice(f, f + 2) : u - 56320 + (o - 55296 << 10) + 65536
              )
          }
        }
      }, function(t, n, r) {
        var e = r(41),
          i = Math.max,
          o = Math.min;
        t.exports = function(t, n) {
          return t = e(t), t < 0 ? i(t + n, 0) : o(t, n)
        }
      }, function(t, n, r) {
        var e = r(41),
          i = Math.min;
        t.exports = function(t) {
          return t > 0 ? i(e(t), 9007199254740991) : 0
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(89),
          i = r(97),
          o = r(35),
          u = r(9);
        t.exports = r(59)(Array, "Array", function(t, n) {
          this._t = u(t), this._i = 0, this._k = n
        }, function() {
          var t = this._t,
            n = this._k,
            r = this._i++;
          return !t || r >= t.length ? (this._t = void 0, i(1)) :
            "keys" ==
            n ? i(0, r) : "values" == n ? i(0, t[r]) : i(0, [r, t[r]])
        }, "values"), o.Arguments = o.Array, e("keys"), e("values"), e(
          "entries")
      }, function(t, n) {}, function(t, n, r) {
        "use strict";
        var e = r(104)(!0);
        r(59)(String, "String", function(t) {
          this._t = String(t), this._i = 0
        }, function() {
          var t, n = this._t,
            r = this._i;
          return r >= n.length ? {
            value: void 0,
            done: !0
          } : (t = e(n, r), this._i += t.length, {
            value: t,
            done: !1
          })
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(5),
          i = r(8),
          o = r(12),
          u = r(51),
          c = r(64),
          f = r(99).KEY,
          a = r(18),
          s = r(40),
          l = r(38),
          h = r(23),
          v = r(15),
          p = r(44),
          d = r(43),
          y = r(98),
          g = r(92),
          b = r(95),
          m = r(20),
          x = r(9),
          w = r(42),
          S = r(22),
          _ = r(60),
          O = r(102),
          E = r(101),
          P = r(14),
          j = r(19),
          F = E.f,
          M = P.f,
          A = O.f,
          N = e.Symbol,
          T = e.JSON,
          I = T && T.stringify,
          k = "prototype",
          L = v("_hidden"),
          R = v("toPrimitive"),
          C = {}.propertyIsEnumerable,
          D = s("symbol-registry"),
          U = s("symbols"),
          W = s("op-symbols"),
          G = Object[k],
          B = "function" == typeof N,
          V = e.QObject,
          z = !V || !V[k] || !V[k].findChild,
          q = o && a(function() {
            return 7 != _(M({}, "a", {
              get: function() {
                return M(this, "a", {
                  value: 7
                }).a
              }
            })).a
          }) ? function(t, n, r) {
            var e = F(G, n);
            e && delete G[n], M(t, n, r), e && t !== G && M(G, n, e)
          } : M,
          K = function(t) {
            var n = U[t] = _(N[k]);
            return n._k = t, n
          },
          J = B && "symbol" == typeof N.iterator ? function(t) {
            return "symbol" == typeof t
          } : function(t) {
            return t instanceof N
          },
          Y = function(t, n, r) {
            return t === G && Y(W, n, r), m(t), n = w(n, !0), m(r), i(U,
              n) ? (r
                .enumerable ? (i(t, L) && t[L][n] && (t[L][n] = !1), r = _(
                  r, {
                    enumerable: S(0, !1)
                  })) : (i(t, L) || M(t, L, S(1, {})), t[L][n] = !0), q(t,
                  n, r)
              ) : M(t, n, r)
          },
          H = function(t, n) {
            m(t);
            for (var r, e = g(n = x(n)), i = 0, o = e.length; o > i;) Y(t,
              r =
              e[i++], n[r]);
            return t
          },
          $ = function(t, n) {
            return void 0 === n ? _(t) : H(_(t), n)
          },
          X = function(t) {
            var n = C.call(this, t = w(t, !0));
            return !(this === G && i(U, t) && !i(W, t)) && (!(n || !i(this,
              t) || !i(U, t) || i(this, L) && this[L][t]) || n)
          },
          Q = function(t, n) {
            if (t = x(t), n = w(n, !0), t !== G || !i(U, n) || i(W, n)) {
              var r = F(t, n);
              return !r || !i(U, n) || i(t, L) && t[L][n] || (r
                .enumerable = !
                0), r
            }
          },
          Z = function(t) {
            for (var n, r = A(x(t)), e = [], o = 0; r.length > o;) i(U, n =
              r[
                o++]) || n == L || n == f || e.push(n);
            return e
          },
          tt = function(t) {
            for (var n, r = t === G, e = A(r ? W : x(t)), o = [], u = 0; e
              .length > u;) !i(U, n = e[u++]) || r && !i(G, n) || o.push(U[
              n]);
            return o
          };
        B || (N = function() {
            if (this instanceof N) throw TypeError(
              "Symbol is not a constructor!");
            var t = h(arguments.length > 0 ? arguments[0] : void 0),
              n = function(r) {
                this === G && n.call(W, r), i(this, L) && i(this[L], t) &&
                  (
                    this[L][t] = !1), q(this, t, S(1, r))
              };
            return o && z && q(G, t, {
              configurable: !0,
              set: n
            }), K(t)
          }, c(N[k], "toString", function() {
            return this._k
          }), E.f = Q, P.f = Y, r(61).f = O.f = Z, r(37).f = X, r(62).f =
          tt,
          o && !r(36) && c(G, "propertyIsEnumerable", X, !0), p.f =
          function(
            t) {
            return K(v(t))
          }), u(u.G + u.W + u.F * !B, {
          Symbol: N
        });
        for (var nt =
            "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables"
            .split(","), rt = 0; nt.length > rt;) v(nt[rt++]);
        for (var nt = j(v.store), rt = 0; nt.length > rt;) d(nt[rt++]);
        u(u.S + u.F * !B, "Symbol", {
          for: function(t) {
            return i(D, t += "") ? D[t] : D[t] = N(t)
          },
          keyFor: function(t) {
            if (J(t)) return y(D, t);
            throw TypeError(t + " is not a symbol!")
          },
          useSetter: function() {
            z = !0
          },
          useSimple: function() {
            z = !1
          }
        }), u(u.S + u.F * !B, "Object", {
          create: $,
          defineProperty: Y,
          defineProperties: H,
          getOwnPropertyDescriptor: Q,
          getOwnPropertyNames: Z,
          getOwnPropertySymbols: tt
        }), T && u(u.S + u.F * (!B || a(function() {
          var t = N();
          return "[null]" != I([t]) || "{}" != I({
            a: t
          }) || "{}" != I(Object(t))
        })), "JSON", {
          stringify: function(t) {
            if (void 0 !== t && !J(t)) {
              for (var n, r, e = [t], i = 1; arguments.length > i;) e
                .push(arguments[i++]);
              return n = e[1], "function" == typeof n && (r = n), !
                r && b(
                  n) || (n = function(t, n) {
                  if (r && (n = r.call(this, t, n)), !J(n)) return n
                }), e[1] = n, I.apply(T, e)
            }
          }
        }), N[k][R] || r(13)(N[k], R, N[k].valueOf), l(N, "Symbol"), l(
          Math,
          "Math", !0), l(e.JSON, "JSON", !0)
      }, function(t, n, r) {
        r(43)("asyncIterator")
      }, function(t, n, r) {
        r(43)("observable")
      }, function(t, n, r) {
        r(107);
        for (var e = r(5), i = r(13), o = r(35), u = r(15)("toStringTag"),
            c = [
              "NodeList", "DOMTokenList", "MediaList", "StyleSheetList",
              "CSSRuleList"
            ], f = 0; f < 5; f++) {
          var a = c[f],
            s = e[a],
            l = s && s.prototype;
          l && !l[u] && i(l, u, a), o[a] = o.Array
        }
      }, function(t, n, r) {
        var e = r(45),
          i = r(7)("toStringTag"),
          o = "Arguments" == e(function() {
            return arguments
          }()),
          u = function(t, n) {
            try {
              return t[n]
            } catch (t) {}
          };
        t.exports = function(t) {
          var n, r, c;
          return void 0 === t ? "Undefined" : null === t ? "Null" :
            "string" == typeof(r = u(n = Object(t), i)) ? r : o ? e(n) :
            "Object" == (c = e(n)) && "function" == typeof n.callee ?
            "Arguments" : c
        }
      }, function(t, n, r) {
        var e = r(45);
        t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(
          t) {
          return "String" == e(t) ? t.split("") : Object(t)
        }
      }, function(t, n) {
        n.f = {}.propertyIsEnumerable
      }, function(t, n, r) {
        var e = r(30),
          i = r(16),
          o = r(75);
        t.exports = function(t) {
          return function(n, r, u) {
            var c, f = e(n),
              a = i(f.length),
              s = o(u, a);
            if (t && r != r) {
              for (; a > s;)
                if ((c = f[s++]) != c) return !0
            } else
              for (; a > s; s++)
                if ((t || s in f) && f[s] === r) return t || s || 0;
            return !t && -1
          }
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(3),
          i = r(1),
          o = r(28),
          u = r(73),
          c = r(65),
          f = r(79),
          a = r(68),
          s = r(6),
          l = r(4),
          h = r(123),
          v = r(81),
          p = r(136);
        t.exports = function(t, n, r, d, y, g) {
          var b = e[t],
            m = b,
            x = y ? "set" : "add",
            w = m && m.prototype,
            S = {},
            _ = function(t) {
              var n = w[t];
              o(w, t, "delete" == t ? function(t) {
                return !(g && !s(t)) && n.call(this, 0 === t ? 0 : t)
              } : "has" == t ? function(t) {
                return !(g && !s(t)) && n.call(this, 0 === t ? 0 : t)
              } : "get" == t ? function(t) {
                return g && !s(t) ? void 0 : n.call(this, 0 === t ?
                  0 : t)
              } : "add" == t ? function(t) {
                return n.call(this, 0 === t ? 0 : t), this
              } : function(t, r) {
                return n.call(this, 0 === t ? 0 : t, r), this
              })
            };
          if ("function" == typeof m && (g || w.forEach && !l(function() {
              (new m).entries().next()
            }))) {
            var O = new m,
              E = O[x](g ? {} : -0, 1) != O,
              P = l(function() {
                O.has(1)
              }),
              j = h(function(t) {
                new m(t)
              }),
              F = !g && l(function() {
                for (var t = new m, n = 5; n--;) t[x](n, n);
                return !t.has(-0)
              });
            j || (m = n(function(n, r) {
                a(n, m, t);
                var e = p(new b, n, m);
                return void 0 != r && f(r, y, e[x], e), e
              }), m.prototype = w, w.constructor = m), (P || F) && (_(
                "delete"), _("has"), y && _("get")), (F || E) && _(x),
              g && w
              .clear && delete w.clear
          } else m = d.getConstructor(n, t, y, x), u(m.prototype, r), c
            .NEED = !0;
          return v(m, t), S[t] = m, i(i.G + i.W + i.F * (m != b), S), g ||
            d
            .setStrong(m, t, y), m
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(27),
          i = r(28),
          o = r(4),
          u = r(46),
          c = r(7);
        t.exports = function(t, n, r) {
          var f = c(t),
            a = r(u, f, "" [t]),
            s = a[0],
            l = a[1];
          o(function() {
            var n = {};
            return n[f] = function() {
              return 7
            }, 7 != "" [t](n)
          }) && (i(String.prototype, t, s), e(RegExp.prototype, f, 2 ==
            n ?
            function(t, n) {
              return l.call(t, this, n)
            } : function(t) {
              return l.call(t, this)
            }))
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(2);
        t.exports = function() {
          var t = e(this),
            n = "";
          return t.global && (n += "g"), t.ignoreCase && (n += "i"), t
            .multiline && (n += "m"), t.unicode && (n += "u"), t.sticky &&
            (
              n += "y"), n
        }
      }, function(t, n) {
        t.exports = function(t, n, r) {
          var e = void 0 === r;
          switch (n.length) {
            case 0:
              return e ? t() : t.call(r);
            case 1:
              return e ? t(n[0]) : t.call(r, n[0]);
            case 2:
              return e ? t(n[0], n[1]) : t.call(r, n[0], n[1]);
            case 3:
              return e ? t(n[0], n[1], n[2]) : t.call(r, n[0], n[1], n[
              2]);
            case 4:
              return e ? t(n[0], n[1], n[2], n[3]) : t.call(r, n[0], n[1],
                n[
                  2], n[3])
          }
          return t.apply(r, n)
        }
      }, function(t, n, r) {
        var e = r(6),
          i = r(45),
          o = r(7)("match");
        t.exports = function(t) {
          var n;
          return e(t) && (void 0 !== (n = t[o]) ? !!n : "RegExp" == i(t))
        }
      }, function(t, n, r) {
        var e = r(7)("iterator"),
          i = !1;
        try {
          var o = [7][e]();
          o.return = function() {
            i = !0
          }, Array.from(o, function() {
            throw 2
          })
        } catch (t) {}
        t.exports = function(t, n) {
          if (!n && !i) return !1;
          var r = !1;
          try {
            var o = [7],
              u = o[e]();
            u.next = function() {
              return {
                done: r = !0
              }
            }, o[e] = function() {
              return u
            }, t(o)
          } catch (t) {}
          return r
        }
      }, function(t, n, r) {
        t.exports = r(69) || !r(4)(function() {
          var t = Math.random();
          __defineSetter__.call(null, t, function() {}), delete r(3)[t]
        })
      }, function(t, n) {
        n.f = Object.getOwnPropertySymbols
      }, function(t, n, r) {
        var e = r(3),
          i = "__core-js_shared__",
          o = e[i] || (e[i] = {});
        t.exports = function(t) {
          return o[t] || (o[t] = {})
        }
      }, function(t, n, r) {
        for (var e, i = r(3), o = r(27), u = r(76), c = u("typed_array"),
            f = u(
              "view"), a = !(!i.ArrayBuffer || !i.DataView), s = a, l = 0,
            h =
            "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array"
            .split(","); l < 9;)(e = i[h[l++]]) ? (o(e.prototype, c, !0), o(
          e
          .prototype, f, !0)) : s = !1;
        t.exports = {
          ABV: a,
          CONSTR: s,
          TYPED: c,
          VIEW: f
        }
      }, function(t, n) {
        "use strict";
        var r = {
          versions: function() {
            var t = window.navigator.userAgent;
            return {
              trident: t.indexOf("Trident") > -1,
              presto: t.indexOf("Presto") > -1,
              webKit: t.indexOf("AppleWebKit") > -1,
              gecko: t.indexOf("Gecko") > -1 && -1 == t.indexOf(
                "KHTML"),
              mobile: !!t.match(/AppleWebKit.*Mobile.*/),
              ios: !!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),
              android: t.indexOf("Android") > -1 || t.indexOf("Linux") >
                -1,
              iPhone: t.indexOf("iPhone") > -1 || t.indexOf("Mac") > -1,
              iPad: t.indexOf("iPad") > -1,
              webApp: -1 == t.indexOf("Safari"),
              weixin: -1 == t.indexOf("MicroMessenger")
            }
          }()
        };
        t.exports = r
      }, function(t, n, r) {
        "use strict";
        var e = r(85),
          i = function(t) {
            return t && t.__esModule ? t : {
              default: t
            }
          }(e),
          o = function() {
            function t(t, n, e) {
              return n || e ? String.fromCharCode(n || e) : r[t] || t
            }

            function n(t) {
              return e[t]
            }
            var r = {
                "&quot;": '"',
                "&lt;": "<",
                "&gt;": ">",
                "&amp;": "&",
                "&nbsp;": " "
              },
              e = {};
            for (var u in r) e[r[u]] = u;
            return r["&apos;"] = "'", e["'"] = "&#39;", {
              encode: function(t) {
                return t ? ("" + t).replace(/['<> "&]/g, n).replace(
                  /\r?\n/g, "<br/>").replace(/\s/g, "&nbsp;") : ""
              },
              decode: function(n) {
                return n ? ("" + n).replace(/<br\s*\/?>/gi, "\n")
                  .replace(
                    /&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,
                    t).replace(/\u00a0/g, " ") : ""
              },
              encodeBase16: function(t) {
                if (!t) return t;
                t += "";
                for (var n = [], r = 0, e = t.length; e > r; r++) n
                  .push(t
                    .charCodeAt(r).toString(16).toUpperCase());
                return n.join("")
              },
              encodeBase16forJSON: function(t) {
                if (!t) return t;
                t = t.replace(/[\u4E00-\u9FBF]/gi, function(t) {
                  return escape(t).replace("%u", "\\u")
                });
                for (var n = [], r = 0, e = t.length; e > r; r++) n
                  .push(t
                    .charCodeAt(r).toString(16).toUpperCase());
                return n.join("")
              },
              decodeBase16: function(t) {
                if (!t) return t;
                t += "";
                for (var n = [], r = 0, e = t.length; e > r; r += 2) n
                  .push(
                    String.fromCharCode("0x" + t.slice(r, r + 2)));
                return n.join("")
              },
              encodeObject: function(t) {
                if (t instanceof Array)
                  for (var n = 0, r = t.length; r > n; n++) t[n] = o
                    .encodeObject(t[n]);
                else if ("object" == (void 0 === t ? "undefined" : (0, i
                    .default)(t)))
                  for (var e in t) t[e] = o.encodeObject(t[e]);
                else if ("string" == typeof t) return o.encode(t);
                return t
              },
              loadScript: function(t) {
                var n = document.createElement("script");
                document.getElementsByTagName("body")[0].appendChild(n),
                  n
                  .setAttribute("src", t)
              },
              addLoadEvent: function(t) {
                var n = window.onload;
                "function" != typeof window.onload ? window.onload = t :
                  window.onload = function() {
                    n(), t()
                  }
              }
            }
          }();
        t.exports = o
      }, function(t, n, r) {
        "use strict";
        var e = r(17),
          i = r(75),
          o = r(16);
        t.exports = function(t) {
          for (var n = e(this), r = o(n.length), u = arguments.length, c =
              i(
                u > 1 ? arguments[1] : void 0, r), f = u > 2 ? arguments[
                2] :
              void 0, a = void 0 === f ? r : i(f, r); a > c;) n[c++] = t;
          return n
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(11),
          i = r(66);
        t.exports = function(t, n, r) {
          n in t ? e.f(t, n, i(0, r)) : t[n] = r
        }
      }, function(t, n, r) {
        var e = r(6),
          i = r(3).document,
          o = e(i) && e(i.createElement);
        t.exports = function(t) {
          return o ? i.createElement(t) : {}
        }
      }, function(t, n) {
        t.exports =
          "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf"
          .split(",")
      }, function(t, n, r) {
        var e = r(7)("match");
        t.exports = function(t) {
          var n = /./;
          try {
            "/./" [t](n)
          } catch (r) {
            try {
              return n[e] = !1, !"/./" [t](n)
            } catch (t) {}
          }
          return !0
        }
      }, function(t, n, r) {
        t.exports = r(3).document && document.documentElement
      }, function(t, n, r) {
        var e = r(6),
          i = r(144).set;
        t.exports = function(t, n, r) {
          var o, u = n.constructor;
          return u !== r && "function" == typeof u && (o = u
            .prototype) !== r
            .prototype && e(o) && i && i(t, o), t
        }
      }, function(t, n, r) {
        var e = r(80),
          i = r(7)("iterator"),
          o = Array.prototype;
        t.exports = function(t) {
          return void 0 !== t && (e.Array === t || o[i] === t)
        }
      }, function(t, n, r) {
        var e = r(45);
        t.exports = Array.isArray || function(t) {
          return "Array" == e(t)
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(70),
          i = r(66),
          o = r(81),
          u = {};
        r(27)(u, r(7)("iterator"), function() {
          return this
        }), t.exports = function(t, n, r) {
          t.prototype = e(u, {
            next: i(1, r)
          }), o(t, n + " Iterator")
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(69),
          i = r(1),
          o = r(28),
          u = r(27),
          c = r(24),
          f = r(80),
          a = r(139),
          s = r(81),
          l = r(32),
          h = r(7)("iterator"),
          v = !([].keys && "next" in [].keys()),
          p = "keys",
          d = "values",
          y = function() {
            return this
          };
        t.exports = function(t, n, r, g, b, m, x) {
          a(r, n, g);
          var w, S, _, O = function(t) {
              if (!v && t in F) return F[t];
              switch (t) {
                case p:
                case d:
                  return function() {
                    return new r(this, t)
                  }
              }
              return function() {
                return new r(this, t)
              }
            },
            E = n + " Iterator",
            P = b == d,
            j = !1,
            F = t.prototype,
            M = F[h] || F["@@iterator"] || b && F[b],
            A = M || O(b),
            N = b ? P ? O("entries") : A : void 0,
            T = "Array" == n ? F.entries || M : M;
          if (T && (_ = l(T.call(new t))) !== Object.prototype && (s(_, E,
              !
              0), e || c(_, h) || u(_, h, y)), P && M && M.name !== d && (
              j = !0, A = function() {
                return M.call(this)
              }), e && !x || !v && !j && F[h] || u(F, h, A), f[n] = A, f[
              E] =
            y, b)
            if (w = {
                values: P ? A : O(d),
                keys: m ? A : O(p),
                entries: N
              }, x)
              for (S in w) S in F || o(F, S, w[S]);
            else i(i.P + i.F * (v || j), n, w);
          return w
        }
      }, function(t, n) {
        var r = Math.expm1;
        t.exports = !r || r(10) > 22025.465794806718 || r(10) <
          22025.465794806718 || -2e-17 != r(-2e-17) ? function(t) {
            return 0 == (t = +t) ? t : t > -1e-6 && t < 1e-6 ? t + t * t /
              2 :
              Math.exp(t) - 1
          } : r
      }, function(t, n) {
        t.exports = Math.sign || function(t) {
          return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1
        }
      }, function(t, n, r) {
        var e = r(3),
          i = r(151).set,
          o = e.MutationObserver || e.WebKitMutationObserver,
          u = e.process,
          c = e.Promise,
          f = "process" == r(45)(u);
        t.exports = function() {
          var t, n, r, a = function() {
            var e, i;
            for (f && (e = u.domain) && e.exit(); t;) {
              i = t.fn, t = t.next;
              try {
                i()
              } catch (e) {
                throw t ? r() : n = void 0, e
              }
            }
            n = void 0, e && e.enter()
          };
          if (f) r = function() {
            u.nextTick(a)
          };
          else if (o) {
            var s = !0,
              l = document.createTextNode("");
            new o(a).observe(l, {
              characterData: !0
            }), r = function() {
              l.data = s = !s
            }
          } else if (c && c.resolve) {
            var h = c.resolve();
            r = function() {
              h.then(a)
            }
          } else r = function() {
            i.call(e, a)
          };
          return function(e) {
            var i = {
              fn: e,
              next: void 0
            };
            n && (n.next = i), t || (t = i, r()), n = i
          }
        }
      }, function(t, n, r) {
        var e = r(6),
          i = r(2),
          o = function(t, n) {
            if (i(t), !e(n) && null !== n) throw TypeError(n +
              ": can't set as prototype!")
          };
        t.exports = {
          set: Object.setPrototypeOf || ("__proto__" in {} ? function(t,
            n,
            e) {
            try {
              e = r(53)(Function.call, r(31).f(Object.prototype,
                "__proto__").set, 2), e(t, []), n = !(
                t instanceof Array)
            } catch (t) {
              n = !0
            }
            return function(t, r) {
              return o(t, r), n ? t.__proto__ = r : e(t, r), t
            }
          }({}, !1) : void 0),
          check: o
        }
      }, function(t, n, r) {
        var e = r(126)("keys"),
          i = r(76);
        t.exports = function(t) {
          return e[t] || (e[t] = i(t))
        }
      }, function(t, n, r) {
        var e = r(2),
          i = r(26),
          o = r(7)("species");
        t.exports = function(t, n) {
          var r, u = e(t).constructor;
          return void 0 === u || void 0 == (r = e(u)[o]) ? n : i(r)
        }
      }, function(t, n, r) {
        var e = r(67),
          i = r(46);
        t.exports = function(t) {
          return function(n, r) {
            var o, u, c = String(i(n)),
              f = e(r),
              a = c.length;
            return f < 0 || f >= a ? t ? "" : void 0 : (o = c
              .charCodeAt(f),
              o < 55296 || o > 56319 || f + 1 === a || (u = c
                .charCodeAt(
                  f + 1)) < 56320 || u > 57343 ? t ? c.charAt(f) : o :
              t ? c
              .slice(f, f + 2) : u - 56320 + (o - 55296 << 10) + 65536
              )
          }
        }
      }, function(t, n, r) {
        var e = r(122),
          i = r(46);
        t.exports = function(t, n, r) {
          if (e(n)) throw TypeError("String#" + r +
            " doesn't accept regex!");
          return String(i(t))
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(67),
          i = r(46);
        t.exports = function(t) {
          var n = String(i(this)),
            r = "",
            o = e(t);
          if (o < 0 || o == 1 / 0) throw RangeError(
            "Count can't be negative");
          for (; o > 0;
            (o >>>= 1) && (n += n)) 1 & o && (r += n);
          return r
        }
      }, function(t, n) {
        t.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"
      }, function(t, n, r) {
        var e, i, o, u = r(53),
          c = r(121),
          f = r(135),
          a = r(132),
          s = r(3),
          l = s.process,
          h = s.setImmediate,
          v = s.clearImmediate,
          p = s.MessageChannel,
          d = 0,
          y = {},
          g = "onreadystatechange",
          b = function() {
            var t = +this;
            if (y.hasOwnProperty(t)) {
              var n = y[t];
              delete y[t], n()
            }
          },
          m = function(t) {
            b.call(t.data)
          };
        h && v || (h = function(t) {
            for (var n = [], r = 1; arguments.length > r;) n.push(
              arguments[
                r++]);
            return y[++d] = function() {
              c("function" == typeof t ? t : Function(t), n)
            }, e(d), d
          }, v = function(t) {
            delete y[t]
          }, "process" == r(45)(l) ? e = function(t) {
            l.nextTick(u(b, t, 1))
          } : p ? (i = new p, o = i.port2, i.port1.onmessage = m, e = u(o
            .postMessage, o, 1)) : s.addEventListener && "function" ==
          typeof postMessage && !s.importScripts ? (e = function(t) {
            s.postMessage(t + "", "*")
          }, s.addEventListener("message", m, !1)) : e = g in a(
          "script") ?
          function(t) {
            f.appendChild(a("script"))[g] = function() {
              f.removeChild(this), b.call(t)
            }
          } : function(t) {
            setTimeout(u(b, t, 1), 0)
          }), t.exports = {
          set: h,
          clear: v
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(3),
          i = r(10),
          o = r(69),
          u = r(127),
          c = r(27),
          f = r(73),
          a = r(4),
          s = r(68),
          l = r(67),
          h = r(16),
          v = r(71).f,
          p = r(11).f,
          d = r(130),
          y = r(81),
          g = "ArrayBuffer",
          b = "DataView",
          m = "prototype",
          x = "Wrong length!",
          w = "Wrong index!",
          S = e[g],
          _ = e[b],
          O = e.Math,
          E = e.RangeError,
          P = e.Infinity,
          j = S,
          F = O.abs,
          M = O.pow,
          A = O.floor,
          N = O.log,
          T = O.LN2,
          I = "buffer",
          k = "byteLength",
          L = "byteOffset",
          R = i ? "_b" : I,
          C = i ? "_l" : k,
          D = i ? "_o" : L,
          U = function(t, n, r) {
            var e, i, o, u = Array(r),
              c = 8 * r - n - 1,
              f = (1 << c) - 1,
              a = f >> 1,
              s = 23 === n ? M(2, -24) - M(2, -77) : 0,
              l = 0,
              h = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
            for (t = F(t), t != t || t === P ? (i = t != t ? 1 : 0, e = f) :
              (
                e = A(N(t) / T), t * (o = M(2, -e)) < 1 && (e--, o *= 2),
                t +=
                e + a >= 1 ? s / o : s * M(2, 1 - a), t * o >= 2 && (e++,
                  o /=
                  2), e + a >= f ? (i = 0, e = f) : e + a >= 1 ? (i = (t *
                  o -
                  1) * M(2, n), e += a) : (i = t * M(2, a - 1) * M(2, n),
                  e = 0)
              ); n >= 8; u[l++] = 255 & i, i /= 256, n -= 8);
            for (e = e << n | i, c += n; c > 0; u[l++] = 255 & e, e /= 256,
              c -=
              8);
            return u[--l] |= 128 * h, u
          },
          W = function(t, n, r) {
            var e, i = 8 * r - n - 1,
              o = (1 << i) - 1,
              u = o >> 1,
              c = i - 7,
              f = r - 1,
              a = t[f--],
              s = 127 & a;
            for (a >>= 7; c > 0; s = 256 * s + t[f], f--, c -= 8);
            for (e = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; e = 256 *
              e +
              t[f], f--, c -= 8);
            if (0 === s) s = 1 - u;
            else {
              if (s === o) return e ? NaN : a ? -P : P;
              e += M(2, n), s -= u
            }
            return (a ? -1 : 1) * e * M(2, s - n)
          },
          G = function(t) {
            return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
          },
          B = function(t) {
            return [255 & t]
          },
          V = function(t) {
            return [255 & t, t >> 8 & 255]
          },
          z = function(t) {
            return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
          },
          q = function(t) {
            return U(t, 52, 8)
          },
          K = function(t) {
            return U(t, 23, 4)
          },
          J = function(t, n, r) {
            p(t[m], n, {
              get: function() {
                return this[r]
              }
            })
          },
          Y = function(t, n, r, e) {
            var i = +r,
              o = l(i);
            if (i != o || o < 0 || o + n > t[C]) throw E(w);
            var u = t[R]._b,
              c = o + t[D],
              f = u.slice(c, c + n);
            return e ? f : f.reverse()
          },
          H = function(t, n, r, e, i, o) {
            var u = +r,
              c = l(u);
            if (u != c || c < 0 || c + n > t[C]) throw E(w);
            for (var f = t[R]._b, a = c + t[D], s = e(+i), h = 0; h <
              n; h++) f[
              a + h] = s[o ? h : n - h - 1]
          },
          $ = function(t, n) {
            s(t, S, g);
            var r = +n,
              e = h(r);
            if (r != e) throw E(x);
            return e
          };
        if (u.ABV) {
          if (!a(function() {
              new S
            }) || !a(function() {
              new S(.5)
            })) {
            S = function(t) {
              return new j($(this, t))
            };
            for (var X, Q = S[m] = j[m], Z = v(j), tt = 0; Z.length > tt;)(
              X =
              Z[tt++]) in S || c(S, X, j[X]);
            o || (Q.constructor = S)
          }
          var nt = new _(new S(2)),
            rt = _[m].setInt8;
          nt.setInt8(0, 2147483648), nt.setInt8(1, 2147483649), !nt.getInt8(
            0) && nt.getInt8(1) || f(_[m], {
            setInt8: function(t, n) {
              rt.call(this, t, n << 24 >> 24)
            },
            setUint8: function(t, n) {
              rt.call(this, t, n << 24 >> 24)
            }
          }, !0)
        } else S = function(t) {
            var n = $(this, t);
            this._b = d.call(Array(n), 0), this[C] = n
          }, _ = function(t, n, r) {
            s(this, _, b), s(t, S, b);
            var e = t[C],
              i = l(n);
            if (i < 0 || i > e) throw E("Wrong offset!");
            if (r = void 0 === r ? e - i : h(r), i + r > e) throw E(x);
            this[R] = t, this[D] = i, this[C] = r
          }, i && (J(S, k, "_l"), J(_, I, "_b"), J(_, k, "_l"), J(_, L,
            "_o")),
          f(_[m], {
            getInt8: function(t) {
              return Y(this, 1, t)[0] << 24 >> 24
            },
            getUint8: function(t) {
              return Y(this, 1, t)[0]
            },
            getInt16: function(t) {
              var n = Y(this, 2, t, arguments[1]);
              return (n[1] << 8 | n[0]) << 16 >> 16
            },
            getUint16: function(t) {
              var n = Y(this, 2, t, arguments[1]);
              return n[1] << 8 | n[0]
            },
            getInt32: function(t) {
              return G(Y(this, 4, t, arguments[1]))
            },
            getUint32: function(t) {
              return G(Y(this, 4, t, arguments[1])) >>> 0
            },
            getFloat32: function(t) {
              return W(Y(this, 4, t, arguments[1]), 23, 4)
            },
            getFloat64: function(t) {
              return W(Y(this, 8, t, arguments[1]), 52, 8)
            },
            setInt8: function(t, n) {
              H(this, 1, t, B, n)
            },
            setUint8: function(t, n) {
              H(this, 1, t, B, n)
            },
            setInt16: function(t, n) {
              H(this, 2, t, V, n, arguments[2])
            },
            setUint16: function(t, n) {
              H(this, 2, t, V, n, arguments[2])
            },
            setInt32: function(t, n) {
              H(this, 4, t, z, n, arguments[2])
            },
            setUint32: function(t, n) {
              H(this, 4, t, z, n, arguments[2])
            },
            setFloat32: function(t, n) {
              H(this, 4, t, K, n, arguments[2])
            },
            setFloat64: function(t, n) {
              H(this, 8, t, q, n, arguments[2])
            }
          });
        y(S, g), y(_, b), c(_[m], u.VIEW, !0), n[g] = S, n[b] = _
      }, function(t, n, r) {
        var e = r(3),
          i = r(52),
          o = r(69),
          u = r(182),
          c = r(11).f;
        t.exports = function(t) {
          var n = i.Symbol || (i.Symbol = o ? {} : e.Symbol || {});
          "_" == t.charAt(0) || t in n || c(n, t, {
            value: u.f(t)
          })
        }
      }, function(t, n, r) {
        var e = r(114),
          i = r(7)("iterator"),
          o = r(80);
        t.exports = r(52).getIteratorMethod = function(t) {
          if (void 0 != t) return t[i] || t["@@iterator"] || o[e(t)]
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(78),
          i = r(170),
          o = r(80),
          u = r(30);
        t.exports = r(140)(Array, "Array", function(t, n) {
          this._t = u(t), this._i = 0, this._k = n
        }, function() {
          var t = this._t,
            n = this._k,
            r = this._i++;
          return !t || r >= t.length ? (this._t = void 0, i(1)) :
            "keys" ==
            n ? i(0, r) : "values" == n ? i(0, t[r]) : i(0, [r, t[r]])
        }, "values"), o.Arguments = o.Array, e("keys"), e("values"), e(
          "entries")
      }, function(t, n) {
        function r(t, n) {
          t.classList ? t.classList.add(n) : t.className += " " + n
        }
        t.exports = r
      }, function(t, n) {
        function r(t, n) {
          if (t.classList) t.classList.remove(n);
          else {
            var r = new RegExp("(^|\\b)" + n.split(" ").join("|") +
              "(\\b|$)",
              "gi");
            t.className = t.className.replace(r, " ")
          }
        }
        t.exports = r
      }, function(t, n) {
        function r() {
          throw new Error("setTimeout has not been defined")
        }

        function e() {
          throw new Error("clearTimeout has not been defined")
        }

        function i(t) {
          if (s === setTimeout) return setTimeout(t, 0);
          if ((s === r || !s) && setTimeout) return s = setTimeout,
            setTimeout(
              t, 0);
          try {
            return s(t, 0)
          } catch (n) {
            try {
              return s.call(null, t, 0)
            } catch (n) {
              return s.call(this, t, 0)
            }
          }
        }

        function o(t) {
          if (l === clearTimeout) return clearTimeout(t);
          if ((l === e || !l) && clearTimeout) return l = clearTimeout,
            clearTimeout(t);
          try {
            return l(t)
          } catch (n) {
            try {
              return l.call(null, t)
            } catch (n) {
              return l.call(this, t)
            }
          }
        }

        function u() {
          d && v && (d = !1, v.length ? p = v.concat(p) : y = -1, p
            .length &&
            c())
        }

        function c() {
          if (!d) {
            var t = i(u);
            d = !0;
            for (var n = p.length; n;) {
              for (v = p, p = []; ++y < n;) v && v[y].run();
              y = -1, n = p.length
            }
            v = null, d = !1, o(t)
          }
        }

        function f(t, n) {
          this.fun = t, this.array = n
        }

        function a() {}
        var s, l, h = t.exports = {};
        ! function() {
          try {
            s = "function" == typeof setTimeout ? setTimeout : r
          } catch (t) {
            s = r
          }
          try {
            l = "function" == typeof clearTimeout ? clearTimeout : e
          } catch (t) {
            l = e
          }
        }();
        var v, p = [],
          d = !1,
          y = -1;
        h.nextTick = function(t) {
            var n = new Array(arguments.length - 1);
            if (arguments.length > 1)
              for (var r = 1; r < arguments.length; r++) n[r - 1] =
                arguments[
                  r];
            p.push(new f(t, n)), 1 !== p.length || d || i(c)
          }, f.prototype.run = function() {
            this.fun.apply(null, this.array)
          }, h.title = "browser", h.browser = !0, h.env = {}, h.argv = [], h
          .version = "", h.versions = {}, h.on = a, h.addListener = a, h
          .once =
          a, h.off = a, h.removeListener = a, h.removeAllListeners = a, h
          .emit =
          a, h.prependListener = a, h.prependOnceListener = a, h.listeners =
          function(t) {
            return []
          }, h.binding = function(t) {
            throw new Error("process.binding is not supported")
          }, h.cwd = function() {
            return "/"
          }, h.chdir = function(t) {
            throw new Error("process.chdir is not supported")
          }, h.umask = function() {
            return 0
          }
      }, function(t, n, r) {
        var e = r(45);
        t.exports = function(t, n) {
          if ("number" != typeof t && "Number" != e(t)) throw TypeError(
          n);
          return +t
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(17),
          i = r(75),
          o = r(16);
        t.exports = [].copyWithin || function(t, n) {
          var r = e(this),
            u = o(r.length),
            c = i(t, u),
            f = i(n, u),
            a = arguments.length > 2 ? arguments[2] : void 0,
            s = Math.min((void 0 === a ? u : i(a, u)) - f, u - c),
            l = 1;
          for (f < c && c < f + s && (l = -1, f += s - 1, c += s - 1); s--
            >
            0;) f in r ? r[c] = r[f] : delete r[c], c += l, f += l;
          return r
        }
      }, function(t, n, r) {
        var e = r(79);
        t.exports = function(t, n) {
          var r = [];
          return e(t, !1, r.push, r, n), r
        }
      }, function(t, n, r) {
        var e = r(26),
          i = r(17),
          o = r(115),
          u = r(16);
        t.exports = function(t, n, r, c, f) {
          e(n);
          var a = i(t),
            s = o(a),
            l = u(a.length),
            h = f ? l - 1 : 0,
            v = f ? -1 : 1;
          if (r < 2)
            for (;;) {
              if (h in s) {
                c = s[h], h += v;
                break
              }
              if (h += v, f ? h < 0 : l <= h) throw TypeError(
                "Reduce of empty array with no initial value")
            }
          for (; f ? h >= 0 : l > h; h += v) h in s && (c = n(c, s[h], h,
            a));
          return c
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(26),
          i = r(6),
          o = r(121),
          u = [].slice,
          c = {},
          f = function(t, n, r) {
            if (!(n in c)) {
              for (var e = [], i = 0; i < n; i++) e[i] = "a[" + i + "]";
              c[n] = Function("F,a", "return new F(" + e.join(",") + ")")
            }
            return c[n](t, r)
          };
        t.exports = Function.bind || function(t) {
          var n = e(this),
            r = u.call(arguments, 1),
            c = function() {
              var e = r.concat(u.call(arguments));
              return this instanceof c ? f(n, e.length, e) : o(n, e, t)
            };
          return i(n.prototype) && (c.prototype = n.prototype), c
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(11).f,
          i = r(70),
          o = r(73),
          u = r(53),
          c = r(68),
          f = r(46),
          a = r(79),
          s = r(140),
          l = r(170),
          h = r(74),
          v = r(10),
          p = r(65).fastKey,
          d = v ? "_s" : "size",
          y = function(t, n) {
            var r, e = p(n);
            if ("F" !== e) return t._i[e];
            for (r = t._f; r; r = r.n)
              if (r.k == n) return r
          };
        t.exports = {
          getConstructor: function(t, n, r, s) {
            var l = t(function(t, e) {
              c(t, l, n, "_i"), t._i = i(null), t._f = void 0, t
                ._l =
                void 0, t[d] = 0, void 0 != e && a(e, r, t[s], t)
            });
            return o(l.prototype, {
              clear: function() {
                for (var t = this, n = t._i, r = t._f; r; r = r.n)
                  r
                  .r = !0, r.p && (r.p = r.p.n = void 0),
                  delete n[r
                    .i];
                t._f = t._l = void 0, t[d] = 0
              },
              delete: function(t) {
                var n = this,
                  r = y(n, t);
                if (r) {
                  var e = r.n,
                    i = r.p;
                  delete n._i[r.i], r.r = !0, i && (i.n = e), e &&
                    (e
                      .p = i), n._f == r && (n._f = e), n._l ==
                    r && (
                      n._l = i), n[d]--
                }
                return !!r
              },
              forEach: function(t) {
                c(this, l, "forEach");
                for (var n, r = u(t, arguments.length > 1 ?
                    arguments[
                      1] : void 0, 3); n = n ? n.n : this._f;)
                  for (r(n.v, n.k, this); n && n.r;) n = n.p
              },
              has: function(t) {
                return !!y(this, t)
              }
            }), v && e(l.prototype, "size", {
              get: function() {
                return f(this[d])
              }
            }), l
          },
          def: function(t, n, r) {
            var e, i, o = y(t, n);
            return o ? o.v = r : (t._l = o = {
                i: i = p(n, !0),
                k: n,
                v: r,
                p: e = t._l,
                n: void 0,
                r: !1
              }, t._f || (t._f = o), e && (e.n = o), t[d]++, "F" !==
              i &&
              (t._i[i] = o)), t
          },
          getEntry: y,
          setStrong: function(t, n, r) {
            s(t, n, function(t, n) {
              this._t = t, this._k = n, this._l = void 0
            }, function() {
              for (var t = this, n = t._k, r = t._l; r && r.r;) r =
                r.p;
              return t._t && (t._l = r = r ? r.n : t._t._f) ?
                "keys" ==
                n ? l(0, r.k) : "values" == n ? l(0, r.v) : l(0, [r
                  .k, r
                  .v
                ]) : (t._t = void 0, l(1))
            }, r ? "entries" : "values", !r, !0), h(n)
          }
        }
      }, function(t, n, r) {
        var e = r(114),
          i = r(161);
        t.exports = function(t) {
          return function() {
            if (e(this) != t) throw TypeError(t +
              "#toJSON isn't generic");
            return i(this)
          }
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(73),
          i = r(65).getWeak,
          o = r(2),
          u = r(6),
          c = r(68),
          f = r(79),
          a = r(48),
          s = r(24),
          l = a(5),
          h = a(6),
          v = 0,
          p = function(t) {
            return t._l || (t._l = new d)
          },
          d = function() {
            this.a = []
          },
          y = function(t, n) {
            return l(t.a, function(t) {
              return t[0] === n
            })
          };
        d.prototype = {
          get: function(t) {
            var n = y(this, t);
            if (n) return n[1]
          },
          has: function(t) {
            return !!y(this, t)
          },
          set: function(t, n) {
            var r = y(this, t);
            r ? r[1] = n : this.a.push([t, n])
          },
          delete: function(t) {
            var n = h(this.a, function(n) {
              return n[0] === t
            });
            return ~n && this.a.splice(n, 1), !!~n
          }
        }, t.exports = {
          getConstructor: function(t, n, r, o) {
            var a = t(function(t, e) {
              c(t, a, n, "_i"), t._i = v++, t._l = void 0, void 0 !=
                e && f(e, r, t[o], t)
            });
            return e(a.prototype, {
              delete: function(t) {
                if (!u(t)) return !1;
                var n = i(t);
                return !0 === n ? p(this).delete(t) : n && s(n,
                  this
                  ._i) && delete n[this._i]
              },
              has: function(t) {
                if (!u(t)) return !1;
                var n = i(t);
                return !0 === n ? p(this).has(t) : n && s(n, this
                  ._i)
              }
            }), a
          },
          def: function(t, n, r) {
            var e = i(o(n), !0);
            return !0 === e ? p(t).set(n, r) : e[t._i] = r, t
          },
          ufstore: p
        }
      }, function(t, n, r) {
        t.exports = !r(10) && !r(4)(function() {
          return 7 != Object.defineProperty(r(132)("div"), "a", {
            get: function() {
              return 7
            }
          }).a
        })
      }, function(t, n, r) {
        var e = r(6),
          i = Math.floor;
        t.exports = function(t) {
          return !e(t) && isFinite(t) && i(t) === t
        }
      }, function(t, n, r) {
        var e = r(2);
        t.exports = function(t, n, r, i) {
          try {
            return i ? n(e(r)[0], r[1]) : n(r)
          } catch (n) {
            var o = t.return;
            throw void 0 !== o && e(o.call(t)), n
          }
        }
      }, function(t, n) {
        t.exports = function(t, n) {
          return {
            value: n,
            done: !!t
          }
        }
      }, function(t, n) {
        t.exports = Math.log1p || function(t) {
          return (t = +t) > -1e-8 && t < 1e-8 ? t - t * t / 2 : Math.log(
            1 +
            t)
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(72),
          i = r(125),
          o = r(116),
          u = r(17),
          c = r(115),
          f = Object.assign;
        t.exports = !f || r(4)(function() {
          var t = {},
            n = {},
            r = Symbol(),
            e = "abcdefghijklmnopqrst";
          return t[r] = 7, e.split("").forEach(function(t) {
            n[t] = t
          }), 7 != f({}, t)[r] || Object.keys(f({}, n)).join("") != e
        }) ? function(t, n) {
          for (var r = u(t), f = arguments.length, a = 1, s = i.f, l = o
              .f; f > a;)
            for (var h, v = c(arguments[a++]), p = s ? e(v).concat(s(v)) :
                e(
                  v), d = p.length, y = 0; d > y;) l.call(v, h = p[
              y++]) && (r[
                h] = v[h]);
          return r
        } : f
      }, function(t, n, r) {
        var e = r(11),
          i = r(2),
          o = r(72);
        t.exports = r(10) ? Object.defineProperties : function(t, n) {
          i(t);
          for (var r, u = o(n), c = u.length, f = 0; c > f;) e.f(t, r = u[
            f++], n[r]);
          return t
        }
      }, function(t, n, r) {
        var e = r(30),
          i = r(71).f,
          o = {}.toString,
          u = "object" == typeof window && window && Object
          .getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
          c = function(t) {
            try {
              return i(t)
            } catch (t) {
              return u.slice()
            }
          };
        t.exports.f = function(t) {
          return u && "[object Window]" == o.call(t) ? c(t) : i(e(t))
        }
      }, function(t, n, r) {
        var e = r(24),
          i = r(30),
          o = r(117)(!1),
          u = r(145)("IE_PROTO");
        t.exports = function(t, n) {
          var r, c = i(t),
            f = 0,
            a = [];
          for (r in c) r != u && e(c, r) && a.push(r);
          for (; n.length > f;) e(c, r = n[f++]) && (~o(a, r) || a.push(
            r));
          return a
        }
      }, function(t, n, r) {
        var e = r(72),
          i = r(30),
          o = r(116).f;
        t.exports = function(t) {
          return function(n) {
            for (var r, u = i(n), c = e(u), f = c.length, a = 0,
            s = []; f >
              a;) o.call(u, r = c[a++]) && s.push(t ? [r, u[r]] : u[r]);
            return s
          }
        }
      }, function(t, n, r) {
        var e = r(71),
          i = r(125),
          o = r(2),
          u = r(3).Reflect;
        t.exports = u && u.ownKeys || function(t) {
          var n = e.f(o(t)),
            r = i.f;
          return r ? n.concat(r(t)) : n
        }
      }, function(t, n, r) {
        var e = r(3).parseFloat,
          i = r(82).trim;
        t.exports = 1 / e(r(150) + "-0") != -1 / 0 ? function(t) {
          var n = i(String(t), 3),
            r = e(n);
          return 0 === r && "-" == n.charAt(0) ? -0 : r
        } : e
      }, function(t, n, r) {
        var e = r(3).parseInt,
          i = r(82).trim,
          o = r(150),
          u = /^[\-+]?0[xX]/;
        t.exports = 8 !== e(o + "08") || 22 !== e(o + "0x16") ? function(t,
          n) {
          var r = i(String(t), 3);
          return e(r, n >>> 0 || (u.test(r) ? 16 : 10))
        } : e
      }, function(t, n) {
        t.exports = Object.is || function(t, n) {
          return t === n ? 0 !== t || 1 / t == 1 / n : t != t && n != n
        }
      }, function(t, n, r) {
        var e = r(16),
          i = r(149),
          o = r(46);
        t.exports = function(t, n, r, u) {
          var c = String(o(t)),
            f = c.length,
            a = void 0 === r ? " " : String(r),
            s = e(n);
          if (s <= f || "" == a) return c;
          var l = s - f,
            h = i.call(a, Math.ceil(l / a.length));
          return h.length > l && (h = h.slice(0, l)), u ? h + c : c + h
        }
      }, function(t, n, r) {
        n.f = r(7)
      }, function(t, n, r) {
        "use strict";
        var e = r(164);
        t.exports = r(118)("Map", function(t) {
          return function() {
            return t(this, arguments.length > 0 ? arguments[0] :
              void 0)
          }
        }, {
          get: function(t) {
            var n = e.getEntry(this, t);
            return n && n.v
          },
          set: function(t, n) {
            return e.def(this, 0 === t ? 0 : t, n)
          }
        }, e, !0)
      }, function(t, n, r) {
        r(10) && "g" != /./g.flags && r(11).f(RegExp.prototype, "flags", {
          configurable: !0,
          get: r(120)
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(164);
        t.exports = r(118)("Set", function(t) {
          return function() {
            return t(this, arguments.length > 0 ? arguments[0] :
              void 0)
          }
        }, {
          add: function(t) {
            return e.def(this, t = 0 === t ? 0 : t, t)
          }
        }, e)
      }, function(t, n, r) {
        "use strict";
        var e, i = r(48)(0),
          o = r(28),
          u = r(65),
          c = r(172),
          f = r(166),
          a = r(6),
          s = u.getWeak,
          l = Object.isExtensible,
          h = f.ufstore,
          v = {},
          p = function(t) {
            return function() {
              return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
          },
          d = {
            get: function(t) {
              if (a(t)) {
                var n = s(t);
                return !0 === n ? h(this).get(t) : n ? n[this._i] : void 0
              }
            },
            set: function(t, n) {
              return f.def(this, t, n)
            }
          },
          y = t.exports = r(118)("WeakMap", p, d, f, !0, !0);
        7 != (new y).set((Object.freeze || Object)(v), 7).get(v) && (e = f
          .getConstructor(p), c(e.prototype, d), u.NEED = !0, i(["delete",
            "has", "get", "set"
          ], function(t) {
            var n = y.prototype,
              r = n[t];
            o(n, t, function(n, i) {
              if (a(n) && !l(n)) {
                this._f || (this._f = new e);
                var o = this._f[t](n, i);
                return "set" == t ? this : o
              }
              return r.call(this, n, i)
            })
          }))
      }, , , , function(t, n) {
        "use strict";

        function r() {
          var t = document.querySelector("#page-nav");
          if (t && !document.querySelector("#page-nav .extend.prev") && (t
              .innerHTML =
              '<a class="extend prev disabled" rel="prev">&laquo; Prev</a>' +
              t
              .innerHTML), t && !document.querySelector(
              "#page-nav .extend.next") && (t.innerHTML = t.innerHTML +
              '<a class="extend next disabled" rel="next">Next &raquo;</a>'
              ),
            yiliaConfig && yiliaConfig.open_in_new) {
            document.querySelectorAll(
                ".article-entry a:not(.article-more-a)")
              .forEach(function(t) {
                var n = t.getAttribute("target");
                n && "" !== n || t.setAttribute("target", "_blank")
              })
          }
          if (yiliaConfig && yiliaConfig.toc_hide_index) {
            document.querySelectorAll(".toc-number").forEach(function(t) {
              t.style.display = "none"
            })
          }
          var n = document.querySelector("#js-aboutme");
          n && 0 !== n.length && (n.innerHTML = n.innerText)
        }
        t.exports = {
          init: r
        }
      }, function(t, n, r) {
        "use strict";

        function e(t) {
          return t && t.__esModule ? t : {
            default: t
          }
        }

        function i(t, n) {
          var r = /\/|index.html/g;
          return t.replace(r, "") === n.replace(r, "")
        }

        function o() {
          for (var t = document.querySelectorAll(".js-header-menu li a"),
              n =
              window.location.pathname, r = 0, e = t.length; r < e; r++) {
            var o = t[r];
            i(n, o.getAttribute("href")) && (0, h.default)(o, "active")
          }
        }

        function u(t) {
          for (var n = t.offsetLeft, r = t.offsetParent; null !== r;) n += r
            .offsetLeft, r = r.offsetParent;
          return n
        }

        function c(t) {
          for (var n = t.offsetTop, r = t.offsetParent; null !== r;) n += r
            .offsetTop, r = r.offsetParent;
          return n
        }

        function f(t, n, r, e, i) {
          var o = u(t),
            f = c(t) - n;
          if (f - r <= i) {
            var a = t.$newDom;
            a || (a = t.cloneNode(!0), (0, d.default)(t, a), t.$newDom = a,
                a
                .style.position = "fixed", a.style.top = (r || f) + "px", a
                .style.left = o + "px", a.style.zIndex = e || 2, a.style
                .width =
                "100%", a.style.color = "#fff"), a.style.visibility =
              "visible",
              t.style.visibility = "hidden"
          } else {
            t.style.visibility = "visible";
            var s = t.$newDom;
            s && (s.style.visibility = "hidden")
          }
        }

        function a() {
          var t = document.querySelector(".js-overlay"),
            n = document.querySelector(".js-header-menu");
          f(t, document.body.scrollTop, -63, 2, 0), f(n, document.body
            .scrollTop, 1, 3, 0)
        }

        function s() {
          document.querySelector("#container").addEventListener("scroll",
            function(t) {
              a()
            }), window.addEventListener("scroll", function(t) {
            a()
          }), a()
        }
        var l = r(156),
          h = e(l),
          v = r(157),
          p = (e(v), r(382)),
          d = e(p),
          y = r(128),
          g = e(y),
          b = r(190),
          m = e(b),
          x = r(129);
        (function() {
          g.default.versions.mobile && window.screen.width < 800 && (o(),
            s())
        })(), (0, x.addLoadEvent)(function() {
          m.default.init()
        }), t.exports = {}
      }, , , , function(t, n, r) {
        (function(t) {
          "use strict";

          function n(t, n, r) {
            t[n] || Object[e](t, n, {
              writable: !0,
              configurable: !0,
              value: r
            })
          }
          if (r(381), r(391), r(198), t._babelPolyfill) throw new Error(
            "only one instance of babel-polyfill is allowed");
          t._babelPolyfill = !0;
          var e = "defineProperty";
          n(String.prototype, "padLeft", "".padStart), n(String.prototype,
              "padRight", "".padEnd),
            "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill"
            .split(",").forEach(function(t) {
              [][t] && n(Array, t, Function.call.bind([][t]))
            })
        }).call(n, function() {
          return this
        }())
      }, , , function(t, n, r) {
        r(210), t.exports = r(52).RegExp.escape
      }, , , , function(t, n, r) {
        var e = r(6),
          i = r(138),
          o = r(7)("species");
        t.exports = function(t) {
          var n;
          return i(t) && (n = t.constructor, "function" != typeof n ||
            n !==
            Array && !i(n.prototype) || (n = void 0), e(n) && null === (
              n =
              n[o]) && (n = void 0)), void 0 === n ? Array : n
        }
      }, function(t, n, r) {
        var e = r(202);
        t.exports = function(t, n) {
          return new(e(t))(n)
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(2),
          i = r(50),
          o = "number";
        t.exports = function(t) {
          if ("string" !== t && t !== o && "default" !== t)
          throw TypeError(
              "Incorrect hint");
          return i(e(this), t != o)
        }
      }, function(t, n, r) {
        var e = r(72),
          i = r(125),
          o = r(116);
        t.exports = function(t) {
          var n = e(t),
            r = i.f;
          if (r)
            for (var u, c = r(t), f = o.f, a = 0; c.length > a;) f.call(t,
              u =
              c[a++]) && n.push(u);
          return n
        }
      }, function(t, n, r) {
        var e = r(72),
          i = r(30);
        t.exports = function(t, n) {
          for (var r, o = i(t), u = e(o), c = u.length, f = 0; c > f;)
            if (o[r = u[f++]] === n) return r
        }
      }, function(t, n, r) {
        "use strict";
        var e = r(208),
          i = r(121),
          o = r(26);
        t.exports = function() {
          for (var t = o(this), n = arguments.length, r = Array(n), u = 0,
              c =
              e._, f = !1; n > u;)(r[u] = arguments[u++]) === c && (f = !
            0);
          return function() {
            var e, o = this,
              u = arguments.length,
              a = 0,
              s = 0;
            if (!f && !u) return i(t, r, o);
            if (e = r.slice(), f)
              for (; n > a; a++) e[a] === c && (e[a] = arguments[s++]);
            for (; u > s;) e.push(arguments[s++]);
            return i(t, e, o)
          }
        }
      }, function(t, n, r) {
        t.exports = r(3)
      }, function(t, n) {
        t.exports = function(t, n) {
          var r = n === Object(n) ? function(t) {
            return n[t]
          } : n;
          return function(n) {
            return String(n).replace(t, r)
          }
        }
      }, function(t, n, r) {
        var e = r(1),
          i = r(209)(/[\\^$*+?.()|[\]{}]/g, "\\$&");
        e(e.S, "RegExp", {
          escape: function(t) {
            return i(t)
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.P, "Array", {
          copyWithin: r(160)
        }), r(78)("copyWithin")
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(48)(4);
        e(e.P + e.F * !r(47)([].every, !0), "Array", {
          every: function(t) {
            return i(this, t, arguments[1])
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.P, "Array", {
          fill: r(130)
        }), r(78)("fill")
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(48)(2);
        e(e.P + e.F * !r(47)([].filter, !0), "Array", {
          filter: function(t) {
            return i(this, t, arguments[1])
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(48)(6),
          o = "findIndex",
          u = !0;
        o in [] && Array(1)[o](function() {
          u = !1
        }), e(e.P + e.F * u, "Array", {
          findIndex: function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] :
              void 0)
          }
        }), r(78)(o)
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(48)(5),
          o = "find",
          u = !0;
        o in [] && Array(1)[o](function() {
          u = !1
        }), e(e.P + e.F * u, "Array", {
          find: function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] :
              void 0)
          }
        }), r(78)(o)
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(48)(0),
          o = r(47)([].forEach, !0);
        e(e.P + e.F * !o, "Array", {
          forEach: function(t) {
            return i(this, t, arguments[1])
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(53),
          i = r(1),
          o = r(17),
          u = r(169),
          c = r(137),
          f = r(16),
          a = r(131),
          s = r(154);
        i(i.S + i.F * !r(123)(function(t) {
          Array.from(t)
        }), "Array", {
          from: function(t) {
            var n, r, i, l, h = o(t),
              v = "function" == typeof this ? this : Array,
              p = arguments.length,
              d = p > 1 ? arguments[1] : void 0,
              y = void 0 !== d,
              g = 0,
              b = s(h);
            if (y && (d = e(d, p > 2 ? arguments[2] : void 0, 2)),
              void 0 == b || v == Array && c(b))
              for (n = f(h.length), r = new v(n); n > g; g++) a(r, g,
                y ?
                d(h[g], g) : h[g]);
            else
              for (l = b.call(h), r = new v; !(i = l.next())
                .done; g++) a(
                r, g, y ? u(l, d, [i.value, g], !0) : i.value);
            return r.length = g, r
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(117)(!1),
          o = [].indexOf,
          u = !!o && 1 / [1].indexOf(1, -0) < 0;
        e(e.P + e.F * (u || !r(47)(o)), "Array", {
          indexOf: function(t) {
            return u ? o.apply(this, arguments) || 0 : i(this, t,
              arguments[1])
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Array", {
          isArray: r(138)
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(30),
          o = [].join;
        e(e.P + e.F * (r(115) != Object || !r(47)(o)), "Array", {
          join: function(t) {
            return o.call(i(this), void 0 === t ? "," : t)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(30),
          o = r(67),
          u = r(16),
          c = [].lastIndexOf,
          f = !!c && 1 / [1].lastIndexOf(1, -0) < 0;
        e(e.P + e.F * (f || !r(47)(c)), "Array", {
          lastIndexOf: function(t) {
            if (f) return c.apply(this, arguments) || 0;
            var n = i(this),
              r = u(n.length),
              e = r - 1;
            for (arguments.length > 1 && (e = Math.min(e, o(arguments[
                1]))), e < 0 && (e = r + e); e >= 0; e--)
              if (e in n && n[e] === t) return e || 0;
            return -1
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(48)(1);
        e(e.P + e.F * !r(47)([].map, !0), "Array", {
          map: function(t) {
            return i(this, t, arguments[1])
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(131);
        e(e.S + e.F * r(4)(function() {
          function t() {}
          return !(Array.of.call(t) instanceof t)
        }), "Array", {
          of: function() {
            for (var t = 0, n = arguments.length, r = new(
                "function" ==
                typeof this ? this : Array)(n); n > t;) i(r, t,
              arguments[
                t++]);
            return r.length = n, r
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(162);
        e(e.P + e.F * !r(47)([].reduceRight, !0), "Array", {
          reduceRight: function(t) {
            return i(this, t, arguments.length, arguments[1], !0)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(162);
        e(e.P + e.F * !r(47)([].reduce, !0), "Array", {
          reduce: function(t) {
            return i(this, t, arguments.length, arguments[1], !1)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(135),
          o = r(45),
          u = r(75),
          c = r(16),
          f = [].slice;
        e(e.P + e.F * r(4)(function() {
          i && f.call(i)
        }), "Array", {
          slice: function(t, n) {
            var r = c(this.length),
              e = o(this);
            if (n = void 0 === n ? r : n, "Array" == e) return f.call(
              this, t, n);
            for (var i = u(t, r), a = u(n, r), s = c(a - i), l =
                Array(s),
                h = 0; h < s; h++) l[h] = "String" == e ? this.charAt(
              i +
              h) : this[i + h];
            return l
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(48)(3);
        e(e.P + e.F * !r(47)([].some, !0), "Array", {
          some: function(t) {
            return i(this, t, arguments[1])
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(26),
          o = r(17),
          u = r(4),
          c = [].sort,
          f = [1, 2, 3];
        e(e.P + e.F * (u(function() {
          f.sort(void 0)
        }) || !u(function() {
          f.sort(null)
        }) || !r(47)(c)), "Array", {
          sort: function(t) {
            return void 0 === t ? c.call(o(this)) : c.call(o(this), i(
              t))
          }
        })
      }, function(t, n, r) {
        r(74)("Array")
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Date", {
          now: function() {
            return (new Date).getTime()
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(4),
          o = Date.prototype.getTime,
          u = function(t) {
            return t > 9 ? t : "0" + t
          };
        e(e.P + e.F * (i(function() {
          return "0385-07-25T07:06:39.999Z" != new Date(-5e13 - 1)
            .toISOString()
        }) || !i(function() {
          new Date(NaN).toISOString()
        })), "Date", {
          toISOString: function() {
            if (!isFinite(o.call(this))) throw RangeError(
              "Invalid time value");
            var t = this,
              n = t.getUTCFullYear(),
              r = t.getUTCMilliseconds(),
              e = n < 0 ? "-" : n > 9999 ? "+" : "";
            return e + ("00000" + Math.abs(n)).slice(e ? -6 : -4) +
              "-" +
              u(t.getUTCMonth() + 1) + "-" + u(t.getUTCDate()) + "T" +
              u(t
                .getUTCHours()) + ":" + u(t.getUTCMinutes()) + ":" +
              u(t
                .getUTCSeconds()) + "." + (r > 99 ? r : "0" + u(r)) +
              "Z"
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(17),
          o = r(50);
        e(e.P + e.F * r(4)(function() {
          return null !== new Date(NaN).toJSON() || 1 !== Date
            .prototype
            .toJSON.call({
              toISOString: function() {
                return 1
              }
            })
        }), "Date", {
          toJSON: function(t) {
            var n = i(this),
              r = o(n);
            return "number" != typeof r || isFinite(r) ? n
              .toISOString() :
              null
          }
        })
      }, function(t, n, r) {
        var e = r(7)("toPrimitive"),
          i = Date.prototype;
        e in i || r(27)(i, e, r(204))
      }, function(t, n, r) {
        var e = Date.prototype,
          i = "Invalid Date",
          o = "toString",
          u = e[o],
          c = e.getTime;
        new Date(NaN) + "" != i && r(28)(e, o, function() {
          var t = c.call(this);
          return t === t ? u.call(this) : i
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.P, "Function", {
          bind: r(163)
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(6),
          i = r(32),
          o = r(7)("hasInstance"),
          u = Function.prototype;
        o in u || r(11).f(u, o, {
          value: function(t) {
            if ("function" != typeof this || !e(t)) return !1;
            if (!e(this.prototype)) return t instanceof this;
            for (; t = i(t);)
              if (this.prototype === t) return !0;
            return !1
          }
        })
      }, function(t, n, r) {
        var e = r(11).f,
          i = r(66),
          o = r(24),
          u = Function.prototype,
          c = "name",
          f = Object.isExtensible || function() {
            return !0
          };
        c in u || r(10) && e(u, c, {
          configurable: !0,
          get: function() {
            try {
              var t = this,
                n = ("" + t).match(/^\s*function ([^ (]*)/)[1];
              return o(t, c) || !f(t) || e(t, c, i(5, n)), n
            } catch (t) {
              return ""
            }
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(171),
          o = Math.sqrt,
          u = Math.acosh;
        e(e.S + e.F * !(u && 710 == Math.floor(u(Number.MAX_VALUE)) && u(1 /
          0) == 1 / 0), "Math", {
          acosh: function(t) {
            return (t = +t) < 1 ? NaN : t > 94906265.62425156 ? Math
              .log(
                t) + Math.LN2 : i(t - 1 + o(t - 1) * o(t + 1))
          }
        })
      }, function(t, n, r) {
        function e(t) {
          return isFinite(t = +t) && 0 != t ? t < 0 ? -e(-t) : Math.log(t +
            Math
            .sqrt(t * t + 1)) : t
        }
        var i = r(1),
          o = Math.asinh;
        i(i.S + i.F * !(o && 1 / o(0) > 0), "Math", {
          asinh: e
        })
      }, function(t, n, r) {
        var e = r(1),
          i = Math.atanh;
        e(e.S + e.F * !(i && 1 / i(-0) < 0), "Math", {
          atanh: function(t) {
            return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(142);
        e(e.S, "Math", {
          cbrt: function(t) {
            return i(t = +t) * Math.pow(Math.abs(t), 1 / 3)
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Math", {
          clz32: function(t) {
            return (t >>>= 0) ? 31 - Math.floor(Math.log(t + .5) *
              Math
              .LOG2E) : 32
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = Math.exp;
        e(e.S, "Math", {
          cosh: function(t) {
            return (i(t = +t) + i(-t)) / 2
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(141);
        e(e.S + e.F * (i != Math.expm1), "Math", {
          expm1: i
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(142),
          o = Math.pow,
          u = o(2, -52),
          c = o(2, -23),
          f = o(2, 127) * (2 - c),
          a = o(2, -126),
          s = function(t) {
            return t + 1 / u - 1 / u
          };
        e(e.S, "Math", {
          fround: function(t) {
            var n, r, e = Math.abs(t),
              o = i(t);
            return e < a ? o * s(e / a / c) * a * c : (n = (1 + c /
              u) *
              e, r = n - (n - e), r > f || r != r ? o * (1 / 0) :
              o * r)
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = Math.abs;
        e(e.S, "Math", {
          hypot: function(t, n) {
            for (var r, e, o = 0, u = 0, c = arguments.length, f =
              0; u <
              c;) r = i(arguments[u++]), f < r ? (e = f / r, o = o *
                e *
                e + 1, f = r) : r > 0 ? (e = r / f, o += e * e) : o +=
              r;
            return f === 1 / 0 ? 1 / 0 : f * Math.sqrt(o)
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = Math.imul;
        e(e.S + e.F * r(4)(function() {
          return -5 != i(4294967295, 5) || 2 != i.length
        }), "Math", {
          imul: function(t, n) {
            var r = 65535,
              e = +t,
              i = +n,
              o = r & e,
              u = r & i;
            return 0 | o * u + ((r & e >>> 16) * u + o * (r & i >>>
                16) <<
              16 >>> 0)
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Math", {
          log10: function(t) {
            return Math.log(t) / Math.LN10
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Math", {
          log1p: r(171)
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Math", {
          log2: function(t) {
            return Math.log(t) / Math.LN2
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Math", {
          sign: r(142)
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(141),
          o = Math.exp;
        e(e.S + e.F * r(4)(function() {
          return -2e-17 != !Math.sinh(-2e-17)
        }), "Math", {
          sinh: function(t) {
            return Math.abs(t = +t) < 1 ? (i(t) - i(-t)) / 2 : (o(t -
                1) -
              o(-t - 1)) * (Math.E / 2)
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(141),
          o = Math.exp;
        e(e.S, "Math", {
          tanh: function(t) {
            var n = i(t = +t),
              r = i(-t);
            return n == 1 / 0 ? 1 : r == 1 / 0 ? -1 : (n - r) / (o(
              t) + o(
                -t))
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Math", {
          trunc: function(t) {
            return (t > 0 ? Math.floor : Math.ceil)(t)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(3),
          i = r(24),
          o = r(45),
          u = r(136),
          c = r(50),
          f = r(4),
          a = r(71).f,
          s = r(31).f,
          l = r(11).f,
          h = r(82).trim,
          v = "Number",
          p = e[v],
          d = p,
          y = p.prototype,
          g = o(r(70)(y)) == v,
          b = "trim" in String.prototype,
          m = function(t) {
            var n = c(t, !1);
            if ("string" == typeof n && n.length > 2) {
              n = b ? n.trim() : h(n, 3);
              var r, e, i, o = n.charCodeAt(0);
              if (43 === o || 45 === o) {
                if (88 === (r = n.charCodeAt(2)) || 120 === r) return NaN
              } else if (48 === o) {
                switch (n.charCodeAt(1)) {
                  case 66:
                  case 98:
                    e = 2, i = 49;
                    break;
                  case 79:
                  case 111:
                    e = 8, i = 55;
                    break;
                  default:
                    return +n
                }
                for (var u, f = n.slice(2), a = 0, s = f.length; a < s; a++)
                  if ((u = f.charCodeAt(a)) < 48 || u > i) return NaN;
                return parseInt(f, e)
              }
            }
            return +n
          };
        if (!p(" 0o1") || !p("0b1") || p("+0x1")) {
          p = function(t) {
            var n = arguments.length < 1 ? 0 : t,
              r = this;
            return r instanceof p && (g ? f(function() {
              y.valueOf.call(r)
            }) : o(r) != v) ? u(new d(m(n)), r, p) : m(n)
          };
          for (var x, w = r(10) ? a(d) :
              "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger"
              .split(","), S = 0; w.length > S; S++) i(d, x = w[S]) && !i(p,
            x) && l(p, x, s(d, x));
          p.prototype = y, y.constructor = p, r(28)(e, v, p)
        }
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Number", {
          EPSILON: Math.pow(2, -52)
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(3).isFinite;
        e(e.S, "Number", {
          isFinite: function(t) {
            return "number" == typeof t && i(t)
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Number", {
          isInteger: r(168)
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Number", {
          isNaN: function(t) {
            return t != t
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(168),
          o = Math.abs;
        e(e.S, "Number", {
          isSafeInteger: function(t) {
            return i(t) && o(t) <= 9007199254740991
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Number", {
          MAX_SAFE_INTEGER: 9007199254740991
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Number", {
          MIN_SAFE_INTEGER: -9007199254740991
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(178);
        e(e.S + e.F * (Number.parseFloat != i), "Number", {
          parseFloat: i
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(179);
        e(e.S + e.F * (Number.parseInt != i), "Number", {
          parseInt: i
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(67),
          o = r(159),
          u = r(149),
          c = 1..toFixed,
          f = Math.floor,
          a = [0, 0, 0, 0, 0, 0],
          s = "Number.toFixed: incorrect invocation!",
          l = "0",
          h = function(t, n) {
            for (var r = -1, e = n; ++r < 6;) e += t * a[r], a[r] = e % 1e7,
              e =
              f(e / 1e7)
          },
          v = function(t) {
            for (var n = 6, r = 0; --n >= 0;) r += a[n], a[n] = f(r / t),
              r =
              r % t * 1e7
          },
          p = function() {
            for (var t = 6, n = ""; --t >= 0;)
              if ("" !== n || 0 === t || 0 !== a[t]) {
                var r = String(a[t]);
                n = "" === n ? r : n + u.call(l, 7 - r.length) + r
              } return n
          },
          d = function(t, n, r) {
            return 0 === n ? r : n % 2 == 1 ? d(t, n - 1, r * t) : d(t * t,
              n /
              2, r)
          },
          y = function(t) {
            for (var n = 0, r = t; r >= 4096;) n += 12, r /= 4096;
            for (; r >= 2;) n += 1, r /= 2;
            return n
          };
        e(e.P + e.F * (!!c && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9
            .toFixed(0) || "1.25" !== 1.255.toFixed(2) ||
            "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) ||
          !r(
            4)(function() {
            c.call({})
          })), "Number", {
          toFixed: function(t) {
            var n, r, e, c, f = o(this, s),
              a = i(t),
              g = "",
              b = l;
            if (a < 0 || a > 20) throw RangeError(s);
            if (f != f) return "NaN";
            if (f <= -1e21 || f >= 1e21) return String(f);
            if (f < 0 && (g = "-", f = -f), f > 1e-21)
              if (n = y(f * d(2, 69, 1)) - 69, r = n < 0 ? f * d(2, -
                  n,
                  1) : f / d(2, n, 1), r *= 4503599627370496, (n =
                  52 -
                  n) >
                0) {
                for (h(0, r), e = a; e >= 7;) h(1e7, 0), e -= 7;
                for (h(d(10, e, 1), 0), e = n - 1; e >= 23;) v(1 <<
                    23),
                  e -= 23;
                v(1 << e), h(1, 1), v(2), b = p()
              } else h(0, r), h(1 << -n, 0), b = p() + u.call(l, a);
            return a > 0 ? (c = b.length, b = g + (c <= a ? "0." + u
              .call(
                l, a - c) + b : b.slice(0, c - a) + "." + b.slice(
                c -
                a))) : b = g + b, b
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(4),
          o = r(159),
          u = 1..toPrecision;
        e(e.P + e.F * (i(function() {
          return "1" !== u.call(1, void 0)
        }) || !i(function() {
          u.call({})
        })), "Number", {
          toPrecision: function(t) {
            var n = o(this,
              "Number#toPrecision: incorrect invocation!");
            return void 0 === t ? u.call(n) : u.call(n, t)
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S + e.F, "Object", {
          assign: r(172)
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Object", {
          create: r(70)
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S + e.F * !r(10), "Object", {
          defineProperties: r(173)
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S + e.F * !r(10), "Object", {
          defineProperty: r(11).f
        })
      }, function(t, n, r) {
        var e = r(6),
          i = r(65).onFreeze;
        r(49)("freeze", function(t) {
          return function(n) {
            return t && e(n) ? t(i(n)) : n
          }
        })
      }, function(t, n, r) {
        var e = r(30),
          i = r(31).f;
        r(49)("getOwnPropertyDescriptor", function() {
          return function(t, n) {
            return i(e(t), n)
          }
        })
      }, function(t, n, r) {
        r(49)("getOwnPropertyNames", function() {
          return r(174).f
        })
      }, function(t, n, r) {
        var e = r(17),
          i = r(32);
        r(49)("getPrototypeOf", function() {
          return function(t) {
            return i(e(t))
          }
        })
      }, function(t, n, r) {
        var e = r(6);
        r(49)("isExtensible", function(t) {
          return function(n) {
            return !!e(n) && (!t || t(n))
          }
        })
      }, function(t, n, r) {
        var e = r(6);
        r(49)("isFrozen", function(t) {
          return function(n) {
            return !e(n) || !!t && t(n)
          }
        })
      }, function(t, n, r) {
        var e = r(6);
        r(49)("isSealed", function(t) {
          return function(n) {
            return !e(n) || !!t && t(n)
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Object", {
          is: r(180)
        })
      }, function(t, n, r) {
        var e = r(17),
          i = r(72);
        r(49)("keys", function() {
          return function(t) {
            return i(e(t))
          }
        })
      }, function(t, n, r) {
        var e = r(6),
          i = r(65).onFreeze;
        r(49)("preventExtensions", function(t) {
          return function(n) {
            return t && e(n) ? t(i(n)) : n
          }
        })
      }, function(t, n, r) {
        var e = r(6),
          i = r(65).onFreeze;
        r(49)("seal", function(t) {
          return function(n) {
            return t && e(n) ? t(i(n)) : n
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Object", {
          setPrototypeOf: r(144).set
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(114),
          i = {};
        i[r(7)("toStringTag")] = "z", i + "" != "[object z]" && r(28)(Object
          .prototype, "toString",
          function() {
            return "[object " + e(this) + "]"
          }, !0)
      }, function(t, n, r) {
        var e = r(1),
          i = r(178);
        e(e.G + e.F * (parseFloat != i), {
          parseFloat: i
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(179);
        e(e.G + e.F * (parseInt != i), {
          parseInt: i
        })
      }, function(t, n, r) {
        "use strict";
        var e, i, o, u = r(69),
          c = r(3),
          f = r(53),
          a = r(114),
          s = r(1),
          l = r(6),
          h = r(26),
          v = r(68),
          p = r(79),
          d = r(146),
          y = r(151).set,
          g = r(143)(),
          b = "Promise",
          m = c.TypeError,
          x = c.process,
          w = c[b],
          x = c.process,
          S = "process" == a(x),
          _ = function() {},
          O = !! function() {
            try {
              var t = w.resolve(1),
                n = (t.constructor = {})[r(7)("species")] = function(t) {
                  t(_, _)
                };
              return (S || "function" == typeof PromiseRejectionEvent) && t
                .then(_) instanceof n
            } catch (t) {}
          }(),
          E = function(t, n) {
            return t === n || t === w && n === o
          },
          P = function(t) {
            var n;
            return !(!l(t) || "function" != typeof(n = t.then)) && n
          },
          j = function(t) {
            return E(w, t) ? new F(t) : new i(t)
          },
          F = i = function(t) {
            var n, r;
            this.promise = new t(function(t, e) {
              if (void 0 !== n || void 0 !== r) throw m(
                "Bad Promise constructor");
              n = t, r = e
            }), this.resolve = h(n), this.reject = h(r)
          },
          M = function(t) {
            try {
              t()
            } catch (t) {
              return {
                error: t
              }
            }
          },
          A = function(t, n) {
            if (!t._n) {
              t._n = !0;
              var r = t._c;
              g(function() {
                for (var e = t._v, i = 1 == t._s, o = 0; r.length > o;)
                  !
                  function(n) {
                    var r, o, u = i ? n.ok : n.fail,
                      c = n.resolve,
                      f = n.reject,
                      a = n.domain;
                    try {
                      u ? (i || (2 == t._h && I(t), t._h = 1), !0 ===
                        u ?
                        r = e : (a && a.enter(), r = u(e), a && a
                          .exit()),
                        r === n.promise ? f(m(
                        "Promise-chain cycle")) : (
                          o = P(r)) ? o.call(r, c, f) : c(r)) : f(e)
                    } catch (t) {
                      f(t)
                    }
                  }(r[o++]);
                t._c = [], t._n = !1, n && !t._h && N(t)
              })
            }
          },
          N = function(t) {
            y.call(c, function() {
              var n, r, e, i = t._v;
              if (T(t) && (n = M(function() {
                  S ? x.emit("unhandledRejection", i, t) : (r = c
                    .onunhandledrejection) ? r({
                    promise: t,
                    reason: i
                  }) : (e = c.console) && e.error && e.error(
                    "Unhandled promise rejection", i)
                }), t._h = S || T(t) ? 2 : 1), t._a = void 0, n) throw n
                .error
            })
          },
          T = function(t) {
            if (1 == t._h) return !1;
            for (var n, r = t._a || t._c, e = 0; r.length > e;)
              if (n = r[e++], n.fail || !T(n.promise)) return !1;
            return !0
          },
          I = function(t) {
            y.call(c, function() {
              var n;
              S ? x.emit("rejectionHandled", t) : (n = c
                .onrejectionhandled) && n({
                promise: t,
                reason: t._v
              })
            })
          },
          k = function(t) {
            var n = this;
            n._d || (n._d = !0, n = n._w || n, n._v = t, n._s = 2, n._a || (
              n
              ._a = n._c.slice()), A(n, !0))
          },
          L = function(t) {
            var n, r = this;
            if (!r._d) {
              r._d = !0, r = r._w || r;
              try {
                if (r === t) throw m("Promise can't be resolved itself");
                (n = P(t)) ? g(function() {
                  var e = {
                    _w: r,
                    _d: !1
                  };
                  try {
                    n.call(t, f(L, e, 1), f(k, e, 1))
                  } catch (t) {
                    k.call(e, t)
                  }
                }): (r._v = t, r._s = 1, A(r, !1))
              } catch (t) {
                k.call({
                  _w: r,
                  _d: !1
                }, t)
              }
            }
          };
        O || (w = function(t) {
          v(this, w, b, "_h"), h(t), e.call(this);
          try {
            t(f(L, this, 1), f(k, this, 1))
          } catch (t) {
            k.call(this, t)
          }
        }, e = function(t) {
          this._c = [], this._a = void 0, this._s = 0, this._d = !1,
            this
            ._v = void 0, this._h = 0, this._n = !1
        }, e.prototype = r(73)(w.prototype, {
          then: function(t, n) {
            var r = j(d(this, w));
            return r.ok = "function" != typeof t || t, r.fail =
              "function" == typeof n && n, r.domain = S ? x.domain :
              void 0, this._c.push(r), this._a && this._a.push(r),
              this
              ._s && A(this, !1), r.promise
          },
          catch: function(t) {
            return this.then(void 0, t)
          }
        }), F = function() {
          var t = new e;
          this.promise = t, this.resolve = f(L, t, 1), this.reject = f(
            k, t,
            1)
        }), s(s.G + s.W + s.F * !O, {
          Promise: w
        }), r(81)(w, b), r(74)(b), o = r(52)[b], s(s.S + s.F * !O, b, {
          reject: function(t) {
            var n = j(this);
            return (0, n.reject)(t), n.promise
          }
        }), s(s.S + s.F * (u || !O), b, {
          resolve: function(t) {
            if (t instanceof w && E(t.constructor, this)) return t;
            var n = j(this);
            return (0, n.resolve)(t), n.promise
          }
        }), s(s.S + s.F * !(O && r(123)(function(t) {
          w.all(t).catch(_)
        })), b, {
          all: function(t) {
            var n = this,
              r = j(n),
              e = r.resolve,
              i = r.reject,
              o = M(function() {
                var r = [],
                  o = 0,
                  u = 1;
                p(t, !1, function(t) {
                  var c = o++,
                    f = !1;
                  r.push(void 0), u++, n.resolve(t).then(
                    function(
                      t) {
                      f || (f = !0, r[c] = t, --u || e(r))
                    }, i)
                }), --u || e(r)
              });
            return o && i(o.error), r.promise
          },
          race: function(t) {
            var n = this,
              r = j(n),
              e = r.reject,
              i = M(function() {
                p(t, !1, function(t) {
                  n.resolve(t).then(r.resolve, e)
                })
              });
            return i && e(i.error), r.promise
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(26),
          o = r(2),
          u = (r(3).Reflect || {}).apply,
          c = Function.apply;
        e(e.S + e.F * !r(4)(function() {
          u(function() {})
        }), "Reflect", {
          apply: function(t, n, r) {
            var e = i(t),
              f = o(r);
            return u ? u(e, n, f) : c.call(e, n, f)
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(70),
          o = r(26),
          u = r(2),
          c = r(6),
          f = r(4),
          a = r(163),
          s = (r(3).Reflect || {}).construct,
          l = f(function() {
            function t() {}
            return !(s(function() {}, [], t) instanceof t)
          }),
          h = !f(function() {
            s(function() {})
          });
        e(e.S + e.F * (l || h), "Reflect", {
          construct: function(t, n) {
            o(t), u(n);
            var r = arguments.length < 3 ? t : o(arguments[2]);
            if (h && !l) return s(t, n, r);
            if (t == r) {
              switch (n.length) {
                case 0:
                  return new t;
                case 1:
                  return new t(n[0]);
                case 2:
                  return new t(n[0], n[1]);
                case 3:
                  return new t(n[0], n[1], n[2]);
                case 4:
                  return new t(n[0], n[1], n[2], n[3])
              }
              var e = [null];
              return e.push.apply(e, n), new(a.apply(t, e))
            }
            var f = r.prototype,
              v = i(c(f) ? f : Object.prototype),
              p = Function.apply.call(t, v, n);
            return c(p) ? p : v
          }
        })
      }, function(t, n, r) {
        var e = r(11),
          i = r(1),
          o = r(2),
          u = r(50);
        i(i.S + i.F * r(4)(function() {
          Reflect.defineProperty(e.f({}, 1, {
            value: 1
          }), 1, {
            value: 2
          })
        }), "Reflect", {
          defineProperty: function(t, n, r) {
            o(t), n = u(n, !0), o(r);
            try {
              return e.f(t, n, r), !0
            } catch (t) {
              return !1
            }
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(31).f,
          o = r(2);
        e(e.S, "Reflect", {
          deleteProperty: function(t, n) {
            var r = i(o(t), n);
            return !(r && !r.configurable) && delete t[n]
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(2),
          o = function(t) {
            this._t = i(t), this._i = 0;
            var n, r = this._k = [];
            for (n in t) r.push(n)
          };
        r(139)(o, "Object", function() {
          var t, n = this,
            r = n._k;
          do {
            if (n._i >= r.length) return {
              value: void 0,
              done: !0
            }
          } while (!((t = r[n._i++]) in n._t));
          return {
            value: t,
            done: !1
          }
        }), e(e.S, "Reflect", {
          enumerate: function(t) {
            return new o(t)
          }
        })
      }, function(t, n, r) {
        var e = r(31),
          i = r(1),
          o = r(2);
        i(i.S, "Reflect", {
          getOwnPropertyDescriptor: function(t, n) {
            return e.f(o(t), n)
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(32),
          o = r(2);
        e(e.S, "Reflect", {
          getPrototypeOf: function(t) {
            return i(o(t))
          }
        })
      }, function(t, n, r) {
        function e(t, n) {
          var r, c, s = arguments.length < 3 ? t : arguments[2];
          return a(t) === s ? t[n] : (r = i.f(t, n)) ? u(r, "value") ? r
            .value :
            void 0 !== r.get ? r.get.call(s) : void 0 : f(c = o(t)) ? e(c,
              n,
              s) : void 0
        }
        var i = r(31),
          o = r(32),
          u = r(24),
          c = r(1),
          f = r(6),
          a = r(2);
        c(c.S, "Reflect", {
          get: e
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Reflect", {
          has: function(t, n) {
            return n in t
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(2),
          o = Object.isExtensible;
        e(e.S, "Reflect", {
          isExtensible: function(t) {
            return i(t), !o || o(t)
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Reflect", {
          ownKeys: r(177)
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(2),
          o = Object.preventExtensions;
        e(e.S, "Reflect", {
          preventExtensions: function(t) {
            i(t);
            try {
              return o && o(t), !0
            } catch (t) {
              return !1
            }
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(144);
        i && e(e.S, "Reflect", {
          setPrototypeOf: function(t, n) {
            i.check(t, n);
            try {
              return i.set(t, n), !0
            } catch (t) {
              return !1
            }
          }
        })
      }, function(t, n, r) {
        function e(t, n, r) {
          var f, h, v = arguments.length < 4 ? t : arguments[3],
            p = o.f(s(t), n);
          if (!p) {
            if (l(h = u(t))) return e(h, n, r, v);
            p = a(0)
          }
          return c(p, "value") ? !(!1 === p.writable || !l(v) || (f = o.f(v,
              n) || a(0), f.value = r, i.f(v, n, f), 0)) : void 0 !== p
            .set && (
              p.set.call(v, r), !0)
        }
        var i = r(11),
          o = r(31),
          u = r(32),
          c = r(24),
          f = r(1),
          a = r(66),
          s = r(2),
          l = r(6);
        f(f.S, "Reflect", {
          set: e
        })
      }, function(t, n, r) {
        var e = r(3),
          i = r(136),
          o = r(11).f,
          u = r(71).f,
          c = r(122),
          f = r(120),
          a = e.RegExp,
          s = a,
          l = a.prototype,
          h = /a/g,
          v = /a/g,
          p = new a(h) !== h;
        if (r(10) && (!p || r(4)(function() {
            return v[r(7)("match")] = !1, a(h) != h || a(v) == v ||
              "/a/i" != a(h, "i")
          }))) {
          a = function(t, n) {
            var r = this instanceof a,
              e = c(t),
              o = void 0 === n;
            return !r && e && t.constructor === a && o ? t : i(p ? new s(
              e &&
              !o ? t.source : t, n) : s((e = t instanceof a) ? t
              .source :
              t, e && o ? f.call(t) : n), r ? this : l, a)
          };
          for (var d = u(s), y = 0; d.length > y;) ! function(t) {
            t in a || o(a, t, {
              configurable: !0,
              get: function() {
                return s[t]
              },
              set: function(n) {
                s[t] = n
              }
            })
          }(d[y++]);
          l.constructor = a, a.prototype = l, r(28)(e, "RegExp", a)
        }
        r(74)("RegExp")
      }, function(t, n, r) {
        r(119)("match", 1, function(t, n, r) {
          return [function(r) {
            "use strict";
            var e = t(this),
              i = void 0 == r ? void 0 : r[n];
            return void 0 !== i ? i.call(r, e) : new RegExp(r)[n](
              String(e))
          }, r]
        })
      }, function(t, n, r) {
        r(119)("replace", 2, function(t, n, r) {
          return [function(e, i) {
            "use strict";
            var o = t(this),
              u = void 0 == e ? void 0 : e[n];
            return void 0 !== u ? u.call(e, o, i) : r.call(String(
              o), e,
              i)
          }, r]
        })
      }, function(t, n, r) {
        r(119)("search", 1, function(t, n, r) {
          return [function(r) {
            "use strict";
            var e = t(this),
              i = void 0 == r ? void 0 : r[n];
            return void 0 !== i ? i.call(r, e) : new RegExp(r)[n](
              String(e))
          }, r]
        })
      }, function(t, n, r) {
        r(119)("split", 2, function(t, n, e) {
          "use strict";
          var i = r(122),
            o = e,
            u = [].push,
            c = "split",
            f = "length",
            a = "lastIndex";
          if ("c" == "abbc" [c](/(b)*/)[1] || 4 != "test" [c](/(?:)/, -
              1)[
              f] || 2 != "ab" [c](/(?:ab)*/)[f] || 4 != "." [c](
              /(.?)(.?)/)[
              f] || "." [c](/()()/)[f] > 1 || "" [c](/.?/)[f]) {
            var s = void 0 === /()??/.exec("")[1];
            e = function(t, n) {
              var r = String(this);
              if (void 0 === t && 0 === n) return [];
              if (!i(t)) return o.call(r, t, n);
              var e, c, l, h, v, p = [],
                d = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" :
                  "") +
                (t.unicode ? "u" : "") + (t.sticky ? "y" : ""),
                y = 0,
                g = void 0 === n ? 4294967295 : n >>> 0,
                b = new RegExp(t.source, d + "g");
              for (s || (e = new RegExp("^" + b.source + "$(?!\\s)",
                  d));
                (c = b.exec(r)) && !((l = c.index + c[0][f]) > y && (p
                  .push(r.slice(y, c.index)), !s && c[f] > 1 && c[0]
                  .replace(e, function() {
                    for (v = 1; v < arguments[f] - 2; v++)
                      void 0 ===
                      arguments[v] && (c[v] = void 0)
                  }), c[f] > 1 && c.index < r[f] && u.apply(p, c
                    .slice(
                      1)), h = c[0][f], y = l, p[f] >= g));) b[a] ===
                c
                .index && b[a]++;
              return y === r[f] ? !h && b.test("") || p.push("") : p
                .push(
                  r.slice(y)), p[f] > g ? p.slice(0, g) : p
            }
          } else "0" [c](void 0, 0)[f] && (e = function(t, n) {
            return void 0 === t && 0 === n ? [] : o.call(this, t, n)
          });
          return [function(r, i) {
            var o = t(this),
              u = void 0 == r ? void 0 : r[n];
            return void 0 !== u ? u.call(r, o, i) : e.call(String(
              o), r,
              i)
          }, e]
        })
      }, function(t, n, r) {
        "use strict";
        r(184);
        var e = r(2),
          i = r(120),
          o = r(10),
          u = "toString",
          c = /./ [u],
          f = function(t) {
            r(28)(RegExp.prototype, u, t, !0)
          };
        r(4)(function() {
          return "/a/b" != c.call({
            source: "a",
            flags: "b"
          })
        }) ? f(function() {
          var t = e(this);
          return "/".concat(t.source, "/", "flags" in t ? t.flags : !
            o &&
            t instanceof RegExp ? i.call(t) : void 0)
        }) : c.name != u && f(function() {
          return c.call(this)
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("anchor", function(t) {
          return function(n) {
            return t(this, "a", "name", n)
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("big", function(t) {
          return function() {
            return t(this, "big", "", "")
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("blink", function(t) {
          return function() {
            return t(this, "blink", "", "")
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("bold", function(t) {
          return function() {
            return t(this, "b", "", "")
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(147)(!1);
        e(e.P, "String", {
          codePointAt: function(t) {
            return i(this, t)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(16),
          o = r(148),
          u = "endsWith",
          c = "" [u];
        e(e.P + e.F * r(134)(u), "String", {
          endsWith: function(t) {
            var n = o(this, t, u),
              r = arguments.length > 1 ? arguments[1] : void 0,
              e = i(n.length),
              f = void 0 === r ? e : Math.min(i(r), e),
              a = String(t);
            return c ? c.call(n, a, f) : n.slice(f - a.length, f) ===
              a
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("fixed", function(t) {
          return function() {
            return t(this, "tt", "", "")
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("fontcolor", function(t) {
          return function(n) {
            return t(this, "font", "color", n)
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("fontsize", function(t) {
          return function(n) {
            return t(this, "font", "size", n)
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(75),
          o = String.fromCharCode,
          u = String.fromCodePoint;
        e(e.S + e.F * (!!u && 1 != u.length), "String", {
          fromCodePoint: function(t) {
            for (var n, r = [], e = arguments.length, u = 0; e > u;) {
              if (n = +arguments[u++], i(n, 1114111) !== n)
                throw RangeError(n + " is not a valid code point");
              r.push(n < 65536 ? o(n) : o(55296 + ((n -= 65536) >>
                10),
                n % 1024 + 56320))
            }
            return r.join("")
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(148),
          o = "includes";
        e(e.P + e.F * r(134)(o), "String", {
          includes: function(t) {
            return !!~i(this, t, o).indexOf(t, arguments.length > 1 ?
              arguments[1] : void 0)
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("italics", function(t) {
          return function() {
            return t(this, "i", "", "")
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(147)(!0);
        r(140)(String, "String", function(t) {
          this._t = String(t), this._i = 0
        }, function() {
          var t, n = this._t,
            r = this._i;
          return r >= n.length ? {
            value: void 0,
            done: !0
          } : (t = e(n, r), this._i += t.length, {
            value: t,
            done: !1
          })
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("link", function(t) {
          return function(n) {
            return t(this, "a", "href", n)
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(30),
          o = r(16);
        e(e.S, "String", {
          raw: function(t) {
            for (var n = i(t.raw), r = o(n.length), e = arguments
                .length,
                u = [], c = 0; r > c;) u.push(String(n[c++])), c <
              e && u
              .push(String(arguments[c]));
            return u.join("")
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.P, "String", {
          repeat: r(149)
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("small", function(t) {
          return function() {
            return t(this, "small", "", "")
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(16),
          o = r(148),
          u = "startsWith",
          c = "" [u];
        e(e.P + e.F * r(134)(u), "String", {
          startsWith: function(t) {
            var n = o(this, t, u),
              r = i(Math.min(arguments.length > 1 ? arguments[1] :
                void 0,
                n.length)),
              e = String(t);
            return c ? c.call(n, e, r) : n.slice(r, r + e.length) ===
              e
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("strike", function(t) {
          return function() {
            return t(this, "strike", "", "")
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("sub", function(t) {
          return function() {
            return t(this, "sub", "", "")
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(29)("sup", function(t) {
          return function() {
            return t(this, "sup", "", "")
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(82)("trim", function(t) {
          return function() {
            return t(this, 3)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(3),
          i = r(24),
          o = r(10),
          u = r(1),
          c = r(28),
          f = r(65).KEY,
          a = r(4),
          s = r(126),
          l = r(81),
          h = r(76),
          v = r(7),
          p = r(182),
          d = r(153),
          y = r(206),
          g = r(205),
          b = r(138),
          m = r(2),
          x = r(30),
          w = r(50),
          S = r(66),
          _ = r(70),
          O = r(174),
          E = r(31),
          P = r(11),
          j = r(72),
          F = E.f,
          M = P.f,
          A = O.f,
          N = e.Symbol,
          T = e.JSON,
          I = T && T.stringify,
          k = "prototype",
          L = v("_hidden"),
          R = v("toPrimitive"),
          C = {}.propertyIsEnumerable,
          D = s("symbol-registry"),
          U = s("symbols"),
          W = s("op-symbols"),
          G = Object[k],
          B = "function" == typeof N,
          V = e.QObject,
          z = !V || !V[k] || !V[k].findChild,
          q = o && a(function() {
            return 7 != _(M({}, "a", {
              get: function() {
                return M(this, "a", {
                  value: 7
                }).a
              }
            })).a
          }) ? function(t, n, r) {
            var e = F(G, n);
            e && delete G[n], M(t, n, r), e && t !== G && M(G, n, e)
          } : M,
          K = function(t) {
            var n = U[t] = _(N[k]);
            return n._k = t, n
          },
          J = B && "symbol" == typeof N.iterator ? function(t) {
            return "symbol" == typeof t
          } : function(t) {
            return t instanceof N
          },
          Y = function(t, n, r) {
            return t === G && Y(W, n, r), m(t), n = w(n, !0), m(r), i(U,
              n) ? (r
                .enumerable ? (i(t, L) && t[L][n] && (t[L][n] = !1), r = _(
                  r, {
                    enumerable: S(0, !1)
                  })) : (i(t, L) || M(t, L, S(1, {})), t[L][n] = !0), q(t,
                  n, r)
              ) : M(t, n, r)
          },
          H = function(t, n) {
            m(t);
            for (var r, e = g(n = x(n)), i = 0, o = e.length; o > i;) Y(t,
              r =
              e[i++], n[r]);
            return t
          },
          $ = function(t, n) {
            return void 0 === n ? _(t) : H(_(t), n)
          },
          X = function(t) {
            var n = C.call(this, t = w(t, !0));
            return !(this === G && i(U, t) && !i(W, t)) && (!(n || !i(this,
              t) || !i(U, t) || i(this, L) && this[L][t]) || n)
          },
          Q = function(t, n) {
            if (t = x(t), n = w(n, !0), t !== G || !i(U, n) || i(W, n)) {
              var r = F(t, n);
              return !r || !i(U, n) || i(t, L) && t[L][n] || (r
                .enumerable = !
                0), r
            }
          },
          Z = function(t) {
            for (var n, r = A(x(t)), e = [], o = 0; r.length > o;) i(U, n =
              r[
                o++]) || n == L || n == f || e.push(n);
            return e
          },
          tt = function(t) {
            for (var n, r = t === G, e = A(r ? W : x(t)), o = [], u = 0; e
              .length > u;) !i(U, n = e[u++]) || r && !i(G, n) || o.push(U[
              n]);
            return o
          };
        B || (N = function() {
            if (this instanceof N) throw TypeError(
              "Symbol is not a constructor!");
            var t = h(arguments.length > 0 ? arguments[0] : void 0),
              n = function(r) {
                this === G && n.call(W, r), i(this, L) && i(this[L], t) &&
                  (
                    this[L][t] = !1), q(this, t, S(1, r))
              };
            return o && z && q(G, t, {
              configurable: !0,
              set: n
            }), K(t)
          }, c(N[k], "toString", function() {
            return this._k
          }), E.f = Q, P.f = Y, r(71).f = O.f = Z, r(116).f = X, r(125)
          .f =
          tt, o && !r(69) && c(G, "propertyIsEnumerable", X, !0), p.f =
          function(t) {
            return K(v(t))
          }), u(u.G + u.W + u.F * !B, {
          Symbol: N
        });
        for (var nt =
            "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables"
            .split(","), rt = 0; nt.length > rt;) v(nt[rt++]);
        for (var nt = j(v.store), rt = 0; nt.length > rt;) d(nt[rt++]);
        u(u.S + u.F * !B, "Symbol", {
          for: function(t) {
            return i(D, t += "") ? D[t] : D[t] = N(t)
          },
          keyFor: function(t) {
            if (J(t)) return y(D, t);
            throw TypeError(t + " is not a symbol!")
          },
          useSetter: function() {
            z = !0
          },
          useSimple: function() {
            z = !1
          }
        }), u(u.S + u.F * !B, "Object", {
          create: $,
          defineProperty: Y,
          defineProperties: H,
          getOwnPropertyDescriptor: Q,
          getOwnPropertyNames: Z,
          getOwnPropertySymbols: tt
        }), T && u(u.S + u.F * (!B || a(function() {
          var t = N();
          return "[null]" != I([t]) || "{}" != I({
            a: t
          }) || "{}" != I(Object(t))
        })), "JSON", {
          stringify: function(t) {
            if (void 0 !== t && !J(t)) {
              for (var n, r, e = [t], i = 1; arguments.length > i;) e
                .push(arguments[i++]);
              return n = e[1], "function" == typeof n && (r = n), !
                r && b(
                  n) || (n = function(t, n) {
                  if (r && (n = r.call(this, t, n)), !J(n)) return n
                }), e[1] = n, I.apply(T, e)
            }
          }
        }), N[k][R] || r(27)(N[k], R, N[k].valueOf), l(N, "Symbol"), l(
          Math,
          "Math", !0), l(e.JSON, "JSON", !0)
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(127),
          o = r(152),
          u = r(2),
          c = r(75),
          f = r(16),
          a = r(6),
          s = r(3).ArrayBuffer,
          l = r(146),
          h = o.ArrayBuffer,
          v = o.DataView,
          p = i.ABV && s.isView,
          d = h.prototype.slice,
          y = i.VIEW,
          g = "ArrayBuffer";
        e(e.G + e.W + e.F * (s !== h), {
          ArrayBuffer: h
        }), e(e.S + e.F * !i.CONSTR, g, {
          isView: function(t) {
            return p && p(t) || a(t) && y in t
          }
        }), e(e.P + e.U + e.F * r(4)(function() {
          return !new h(2).slice(1, void 0).byteLength
        }), g, {
          slice: function(t, n) {
            if (void 0 !== d && void 0 === n) return d.call(u(this),
              t);
            for (var r = u(this).byteLength, e = c(t, r), i = c(
                  void 0 ===
                  n ? r : n, r), o = new(l(this, h))(f(i - e)), a =
                new v(
                  this), s = new v(o), p = 0; e < i;) s.setUint8(p++,
              a
              .getUint8(e++));
            return o
          }
        }), r(74)(g)
      }, function(t, n, r) {
        var e = r(1);
        e(e.G + e.W + e.F * !r(127).ABV, {
          DataView: r(152).DataView
        })
      }, function(t, n, r) {
        r(55)("Float32", 4, function(t) {
          return function(n, r, e) {
            return t(this, n, r, e)
          }
        })
      }, function(t, n, r) {
        r(55)("Float64", 8, function(t) {
          return function(n, r, e) {
            return t(this, n, r, e)
          }
        })
      }, function(t, n, r) {
        r(55)("Int16", 2, function(t) {
          return function(n, r, e) {
            return t(this, n, r, e)
          }
        })
      }, function(t, n, r) {
        r(55)("Int32", 4, function(t) {
          return function(n, r, e) {
            return t(this, n, r, e)
          }
        })
      }, function(t, n, r) {
        r(55)("Int8", 1, function(t) {
          return function(n, r, e) {
            return t(this, n, r, e)
          }
        })
      }, function(t, n, r) {
        r(55)("Uint16", 2, function(t) {
          return function(n, r, e) {
            return t(this, n, r, e)
          }
        })
      }, function(t, n, r) {
        r(55)("Uint32", 4, function(t) {
          return function(n, r, e) {
            return t(this, n, r, e)
          }
        })
      }, function(t, n, r) {
        r(55)("Uint8", 1, function(t) {
          return function(n, r, e) {
            return t(this, n, r, e)
          }
        })
      }, function(t, n, r) {
        r(55)("Uint8", 1, function(t) {
          return function(n, r, e) {
            return t(this, n, r, e)
          }
        }, !0)
      }, function(t, n, r) {
        "use strict";
        var e = r(166);
        r(118)("WeakSet", function(t) {
          return function() {
            return t(this, arguments.length > 0 ? arguments[0] :
              void 0)
          }
        }, {
          add: function(t) {
            return e.def(this, t, !0)
          }
        }, e, !1, !0)
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(117)(!0);
        e(e.P, "Array", {
          includes: function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] :
              void 0)
          }
        }), r(78)("includes")
      }, function(t, n, r) {
        var e = r(1),
          i = r(143)(),
          o = r(3).process,
          u = "process" == r(45)(o);
        e(e.G, {
          asap: function(t) {
            var n = u && o.domain;
            i(n ? n.bind(t) : t)
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(45);
        e(e.S, "Error", {
          isError: function(t) {
            return "Error" === i(t)
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.P + e.R, "Map", {
          toJSON: r(165)("Map")
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Math", {
          iaddh: function(t, n, r, e) {
            var i = t >>> 0,
              o = n >>> 0,
              u = r >>> 0;
            return o + (e >>> 0) + ((i & u | (i | u) & ~(i + u >>>
              0)) >>>
              31) | 0
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Math", {
          imulh: function(t, n) {
            var r = 65535,
              e = +t,
              i = +n,
              o = e & r,
              u = i & r,
              c = e >> 16,
              f = i >> 16,
              a = (c * u >>> 0) + (o * u >>> 16);
            return c * f + (a >> 16) + ((o * f >>> 0) + (a & r) >> 16)
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Math", {
          isubh: function(t, n, r, e) {
            var i = t >>> 0,
              o = n >>> 0,
              u = r >>> 0;
            return o - (e >>> 0) - ((~i & u | ~(i ^ u) & i - u >>>
              0) >>>
              31) | 0
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "Math", {
          umulh: function(t, n) {
            var r = 65535,
              e = +t,
              i = +n,
              o = e & r,
              u = i & r,
              c = e >>> 16,
              f = i >>> 16,
              a = (c * u >>> 0) + (o * u >>> 16);
            return c * f + (a >>> 16) + ((o * f >>> 0) + (a & r) >>>
              16)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(17),
          o = r(26),
          u = r(11);
        r(10) && e(e.P + r(124), "Object", {
          __defineGetter__: function(t, n) {
            u.f(i(this), t, {
              get: o(n),
              enumerable: !0,
              configurable: !0
            })
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(17),
          o = r(26),
          u = r(11);
        r(10) && e(e.P + r(124), "Object", {
          __defineSetter__: function(t, n) {
            u.f(i(this), t, {
              set: o(n),
              enumerable: !0,
              configurable: !0
            })
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(176)(!0);
        e(e.S, "Object", {
          entries: function(t) {
            return i(t)
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(177),
          o = r(30),
          u = r(31),
          c = r(131);
        e(e.S, "Object", {
          getOwnPropertyDescriptors: function(t) {
            for (var n, r = o(t), e = u.f, f = i(r), a = {}, s = 0; f
              .length > s;) c(a, n = f[s++], e(r, n));
            return a
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(17),
          o = r(50),
          u = r(32),
          c = r(31).f;
        r(10) && e(e.P + r(124), "Object", {
          __lookupGetter__: function(t) {
            var n, r = i(this),
              e = o(t, !0);
            do {
              if (n = c(r, e)) return n.get
            } while (r = u(r))
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(17),
          o = r(50),
          u = r(32),
          c = r(31).f;
        r(10) && e(e.P + r(124), "Object", {
          __lookupSetter__: function(t) {
            var n, r = i(this),
              e = o(t, !0);
            do {
              if (n = c(r, e)) return n.set
            } while (r = u(r))
          }
        })
      }, function(t, n, r) {
        var e = r(1),
          i = r(176)(!1);
        e(e.S, "Object", {
          values: function(t) {
            return i(t)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(3),
          o = r(52),
          u = r(143)(),
          c = r(7)("observable"),
          f = r(26),
          a = r(2),
          s = r(68),
          l = r(73),
          h = r(27),
          v = r(79),
          p = v.RETURN,
          d = function(t) {
            return null == t ? void 0 : f(t)
          },
          y = function(t) {
            var n = t._c;
            n && (t._c = void 0, n())
          },
          g = function(t) {
            return void 0 === t._o
          },
          b = function(t) {
            g(t) || (t._o = void 0, y(t))
          },
          m = function(t, n) {
            a(t), this._c = void 0, this._o = t, t = new x(this);
            try {
              var r = n(t),
                e = r;
              null != r && ("function" == typeof r.unsubscribe ? r =
                function() {
                  e.unsubscribe()
                } : f(r), this._c = r)
            } catch (n) {
              return void t.error(n)
            }
            g(this) && y(this)
          };
        m.prototype = l({}, {
          unsubscribe: function() {
            b(this)
          }
        });
        var x = function(t) {
          this._s = t
        };
        x.prototype = l({}, {
          next: function(t) {
            var n = this._s;
            if (!g(n)) {
              var r = n._o;
              try {
                var e = d(r.next);
                if (e) return e.call(r, t)
              } catch (t) {
                try {
                  b(n)
                } finally {
                  throw t
                }
              }
            }
          },
          error: function(t) {
            var n = this._s;
            if (g(n)) throw t;
            var r = n._o;
            n._o = void 0;
            try {
              var e = d(r.error);
              if (!e) throw t;
              t = e.call(r, t)
            } catch (t) {
              try {
                y(n)
              } finally {
                throw t
              }
            }
            return y(n), t
          },
          complete: function(t) {
            var n = this._s;
            if (!g(n)) {
              var r = n._o;
              n._o = void 0;
              try {
                var e = d(r.complete);
                t = e ? e.call(r, t) : void 0
              } catch (t) {
                try {
                  y(n)
                } finally {
                  throw t
                }
              }
              return y(n), t
            }
          }
        });
        var w = function(t) {
          s(this, w, "Observable", "_f")._f = f(t)
        };
        l(w.prototype, {
          subscribe: function(t) {
            return new m(t, this._f)
          },
          forEach: function(t) {
            var n = this;
            return new(o.Promise || i.Promise)(function(r, e) {
              f(t);
              var i = n.subscribe({
                next: function(n) {
                  try {
                    return t(n)
                  } catch (t) {
                    e(t), i.unsubscribe()
                  }
                },
                error: e,
                complete: r
              })
            })
          }
        }), l(w, {
          from: function(t) {
            var n = "function" == typeof this ? this : w,
              r = d(a(t)[c]);
            if (r) {
              var e = a(r.call(t));
              return e.constructor === n ? e : new n(function(t) {
                return e.subscribe(t)
              })
            }
            return new n(function(n) {
              var r = !1;
              return u(function() {
                  if (!r) {
                    try {
                      if (v(t, !1, function(t) {
                          if (n.next(t), r) return p
                        }) === p) return
                    } catch (t) {
                      if (r) throw t;
                      return void n.error(t)
                    }
                    n.complete()
                  }
                }),
                function() {
                  r = !0
                }
            })
          },
          of: function() {
            for (var t = 0, n = arguments.length, r = Array(n); t <
              n;) r[
              t] = arguments[t++];
            return new("function" == typeof this ? this : w)(function(
              t) {
              var n = !1;
              return u(function() {
                  if (!n) {
                    for (var e = 0; e < r.length; ++e)
                      if (t.next(r[e]), n) return;
                    t.complete()
                  }
                }),
                function() {
                  n = !0
                }
            })
          }
        }), h(w.prototype, c, function() {
          return this
        }), e(e.G, {
          Observable: w
        }), r(74)("Observable")
      }, function(t, n, r) {
        var e = r(54),
          i = r(2),
          o = e.key,
          u = e.set;
        e.exp({
          defineMetadata: function(t, n, r, e) {
            u(t, n, i(r), o(e))
          }
        })
      }, function(t, n, r) {
        var e = r(54),
          i = r(2),
          o = e.key,
          u = e.map,
          c = e.store;
        e.exp({
          deleteMetadata: function(t, n) {
            var r = arguments.length < 3 ? void 0 : o(arguments[2]),
              e = u(i(n), r, !1);
            if (void 0 === e || !e.delete(t)) return !1;
            if (e.size) return !0;
            var f = c.get(n);
            return f.delete(r), !!f.size || c.delete(n)
          }
        })
      }, function(t, n, r) {
        var e = r(185),
          i = r(161),
          o = r(54),
          u = r(2),
          c = r(32),
          f = o.keys,
          a = o.key,
          s = function(t, n) {
            var r = f(t, n),
              o = c(t);
            if (null === o) return r;
            var u = s(o, n);
            return u.length ? r.length ? i(new e(r.concat(u))) : u : r
          };
        o.exp({
          getMetadataKeys: function(t) {
            return s(u(t), arguments.length < 2 ? void 0 : a(
              arguments[
                1]))
          }
        })
      }, function(t, n, r) {
        var e = r(54),
          i = r(2),
          o = r(32),
          u = e.has,
          c = e.get,
          f = e.key,
          a = function(t, n, r) {
            if (u(t, n, r)) return c(t, n, r);
            var e = o(n);
            return null !== e ? a(t, e, r) : void 0
          };
        e.exp({
          getMetadata: function(t, n) {
            return a(t, i(n), arguments.length < 3 ? void 0 : f(
              arguments[
                2]))
          }
        })
      }, function(t, n, r) {
        var e = r(54),
          i = r(2),
          o = e.keys,
          u = e.key;
        e.exp({
          getOwnMetadataKeys: function(t) {
            return o(i(t), arguments.length < 2 ? void 0 : u(
              arguments[
                1]))
          }
        })
      }, function(t, n, r) {
        var e = r(54),
          i = r(2),
          o = e.get,
          u = e.key;
        e.exp({
          getOwnMetadata: function(t, n) {
            return o(t, i(n), arguments.length < 3 ? void 0 : u(
              arguments[
                2]))
          }
        })
      }, function(t, n, r) {
        var e = r(54),
          i = r(2),
          o = r(32),
          u = e.has,
          c = e.key,
          f = function(t, n, r) {
            if (u(t, n, r)) return !0;
            var e = o(n);
            return null !== e && f(t, e, r)
          };
        e.exp({
          hasMetadata: function(t, n) {
            return f(t, i(n), arguments.length < 3 ? void 0 : c(
              arguments[
                2]))
          }
        })
      }, function(t, n, r) {
        var e = r(54),
          i = r(2),
          o = e.has,
          u = e.key;
        e.exp({
          hasOwnMetadata: function(t, n) {
            return o(t, i(n), arguments.length < 3 ? void 0 : u(
              arguments[
                2]))
          }
        })
      }, function(t, n, r) {
        var e = r(54),
          i = r(2),
          o = r(26),
          u = e.key,
          c = e.set;
        e.exp({
          metadata: function(t, n) {
            return function(r, e) {
              c(t, n, (void 0 !== e ? i : o)(r), u(e))
            }
          }
        })
      }, function(t, n, r) {
        var e = r(1);
        e(e.P + e.R, "Set", {
          toJSON: r(165)("Set")
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(147)(!0);
        e(e.P, "String", {
          at: function(t) {
            return i(this, t)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(46),
          o = r(16),
          u = r(122),
          c = r(120),
          f = RegExp.prototype,
          a = function(t, n) {
            this._r = t, this._s = n
          };
        r(139)(a, "RegExp String", function() {
          var t = this._r.exec(this._s);
          return {
            value: t,
            done: null === t
          }
        }), e(e.P, "String", {
          matchAll: function(t) {
            if (i(this), !u(t)) throw TypeError(t +
              " is not a regexp!");
            var n = String(this),
              r = "flags" in f ? String(t.flags) : c.call(t),
              e = new RegExp(t.source, ~r.indexOf("g") ? r : "g" + r);
            return e.lastIndex = o(t.lastIndex), new a(e, n)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(181);
        e(e.P, "String", {
          padEnd: function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] :
              void 0, !1)
          }
        })
      }, function(t, n, r) {
        "use strict";
        var e = r(1),
          i = r(181);
        e(e.P, "String", {
          padStart: function(t) {
            return i(this, t, arguments.length > 1 ? arguments[1] :
              void 0, !0)
          }
        })
      }, function(t, n, r) {
        "use strict";
        r(82)("trimLeft", function(t) {
          return function() {
            return t(this, 1)
          }
        }, "trimStart")
      }, function(t, n, r) {
        "use strict";
        r(82)("trimRight", function(t) {
          return function() {
            return t(this, 2)
          }
        }, "trimEnd")
      }, function(t, n, r) {
        r(153)("asyncIterator")
      }, function(t, n, r) {
        r(153)("observable")
      }, function(t, n, r) {
        var e = r(1);
        e(e.S, "System", {
          global: r(3)
        })
      }, function(t, n, r) {
        for (var e = r(155), i = r(28), o = r(3), u = r(27), c = r(80), f =
            r(
              7), a = f("iterator"), s = f("toStringTag"), l = c.Array,
            h = [
              "NodeList", "DOMTokenList", "MediaList", "StyleSheetList",
              "CSSRuleList"
            ], v = 0; v < 5; v++) {
          var p, d = h[v],
            y = o[d],
            g = y && y.prototype;
          if (g) {
            g[a] || u(g, a, l), g[s] || u(g, s, d), c[d] = l;
            for (p in e) g[p] || i(g, p, e[p], !0)
          }
        }
      }, function(t, n, r) {
        var e = r(1),
          i = r(151);
        e(e.G + e.B, {
          setImmediate: i.set,
          clearImmediate: i.clear
        })
      }, function(t, n, r) {
        var e = r(3),
          i = r(1),
          o = r(121),
          u = r(207),
          c = e.navigator,
          f = !!c && /MSIE .\./.test(c.userAgent),
          a = function(t) {
            return f ? function(n, r) {
              return t(o(u, [].slice.call(arguments, 2), "function" ==
                typeof n ? n : Function(n)), r)
            } : t
          };
        i(i.G + i.B + i.F * f, {
          setTimeout: a(e.setTimeout),
          setInterval: a(e.setInterval)
        })
      }, function(t, n, r) {
        r(330), r(269), r(271), r(270), r(273), r(275), r(280), r(274), r(
            272),
          r(282), r(281), r(277), r(278), r(276), r(268), r(279), r(283), r(
            284), r(236), r(238), r(237), r(286), r(285), r(256), r(266), r(
            267),
          r(257), r(258), r(259), r(260), r(261), r(262), r(263), r(264), r(
            265), r(239), r(240), r(241), r(242), r(243), r(244), r(245), r(
            246),
          r(247), r(248), r(249), r(250), r(251), r(252), r(253), r(254), r(
            255), r(317), r(322), r(329), r(320), r(312), r(313), r(318), r(
            323),
          r(325), r(308), r(309), r(310), r(311), r(314), r(315), r(316), r(
            319), r(321), r(324), r(326), r(327), r(328), r(231), r(233), r(
            232),
          r(235), r(234), r(220), r(218), r(224), r(221), r(227), r(229), r(
            217), r(223), r(214), r(228), r(212), r(226), r(225), r(219), r(
            222),
          r(211), r(213), r(216), r(215), r(230), r(155), r(302), r(307), r(
            184), r(303), r(304), r(305), r(306), r(287), r(183), r(185), r(
            186),
          r(342), r(331), r(332), r(337), r(340), r(341), r(335), r(338), r(
            336), r(339), r(333), r(334), r(288), r(289), r(290), r(291), r(
            292),
          r(295), r(293), r(294), r(296), r(297), r(298), r(299), r(301), r(
            300), r(343), r(369), r(372), r(371), r(373), r(374), r(370), r(
            375),
          r(376), r(354), r(357), r(353), r(351), r(352), r(355), r(356), r(
            346), r(368), r(377), r(345), r(347), r(349), r(348), r(350), r(
            359),
          r(360), r(362), r(361), r(364), r(363), r(365), r(366), r(367), r(
            344), r(358), r(380), r(379), r(378), t.exports = r(52)
      }, function(t, n) {
        function r(t, n) {
          if ("string" == typeof n) return t.insertAdjacentHTML("afterend",
            n);
          var r = t.nextSibling;
          return r ? t.parentNode.insertBefore(n, r) : t.parentNode
            .appendChild(
              n)
        }
        t.exports = r
      }, , , , , , , , , function(t, n, r) {
        (function(n, r) {
          ! function(n) {
            "use strict";

            function e(t, n, r, e) {
              var i = n && n.prototype instanceof o ? n : o,
                u = Object.create(i.prototype),
                c = new p(e || []);
              return u._invoke = s(t, r, c), u
            }

            function i(t, n, r) {
              try {
                return {
                  type: "normal",
                  arg: t.call(n, r)
                }
              } catch (t) {
                return {
                  type: "throw",
                  arg: t
                }
              }
            }

            function o() {}

            function u() {}

            function c() {}

            function f(t) {
              ["next", "throw", "return"].forEach(function(n) {
                t[n] = function(t) {
                  return this._invoke(n, t)
                }
              })
            }

            function a(t) {
              function n(r, e, o, u) {
                var c = i(t[r], t, e);
                if ("throw" !== c.type) {
                  var f = c.arg,
                    a = f.value;
                  return a && "object" == typeof a && m.call(a,
                    "__await") ?
                    Promise.resolve(a.__await).then(function(t) {
                      n("next", t, o, u)
                    }, function(t) {
                      n("throw", t, o, u)
                    }) : Promise.resolve(a).then(function(t) {
                      f.value = t, o(f)
                    }, u)
                }
                u(c.arg)
              }

              function e(t, r) {
                function e() {
                  return new Promise(function(e, i) {
                    n(t, r, e, i)
                  })
                }
                return o = o ? o.then(e, e) : e()
              }
              "object" == typeof r && r.domain && (n = r.domain.bind(n));
              var o;
              this._invoke = e
            }

            function s(t, n, r) {
              var e = P;
              return function(o, u) {
                if (e === F) throw new Error(
                  "Generator is already running");
                if (e === M) {
                  if ("throw" === o) throw u;
                  return y()
                }
                for (r.method = o, r.arg = u;;) {
                  var c = r.delegate;
                  if (c) {
                    var f = l(c, r);
                    if (f) {
                      if (f === A) continue;
                      return f
                    }
                  }
                  if ("next" === r.method) r.sent = r._sent = r.arg;
                  else if ("throw" === r.method) {
                    if (e === P) throw e = M, r.arg;
                    r.dispatchException(r.arg)
                  } else "return" === r.method && r.abrupt("return", r
                    .arg);
                  e = F;
                  var a = i(t, n, r);
                  if ("normal" === a.type) {
                    if (e = r.done ? M : j, a.arg === A) continue;
                    return {
                      value: a.arg,
                      done: r.done
                    }
                  }
                  "throw" === a.type && (e = M, r.method = "throw", r
                    .arg =
                    a.arg)
                }
              }
            }

            function l(t, n) {
              var r = t.iterator[n.method];
              if (r === g) {
                if (n.delegate = null, "throw" === n.method) {
                  if (t.iterator.return && (n.method = "return", n.arg =
                      g, l(
                        t, n), "throw" === n.method)) return A;
                  n.method = "throw", n.arg = new TypeError(
                    "The iterator does not provide a 'throw' method")
                }
                return A
              }
              var e = i(r, t.iterator, n.arg);
              if ("throw" === e.type) return n.method = "throw", n.arg = e
                .arg, n.delegate = null, A;
              var o = e.arg;
              return o ? o.done ? (n[t.resultName] = o.value, n.next = t
                .nextLoc, "return" !== n.method && (n.method = "next", n
                  .arg = g), n.delegate = null, A) : o : (n.method =
                "throw", n.arg = new TypeError(
                  "iterator result is not an object"), n.delegate =
                null, A)
            }

            function h(t) {
              var n = {
                tryLoc: t[0]
              };
              1 in t && (n.catchLoc = t[1]), 2 in t && (n.finallyLoc = t[
                  2], n
                .afterLoc = t[3]), this.tryEntries.push(n)
            }

            function v(t) {
              var n = t.completion || {};
              n.type = "normal", delete n.arg, t.completion = n
            }

            function p(t) {
              this.tryEntries = [{
                tryLoc: "root"
              }], t.forEach(h, this), this.reset(!0)
            }

            function d(t) {
              if (t) {
                var n = t[w];
                if (n) return n.call(t);
                if ("function" == typeof t.next) return t;
                if (!isNaN(t.length)) {
                  var r = -1,
                    e = function n() {
                      for (; ++r < t.length;)
                        if (m.call(t, r)) return n.value = t[r], n
                          .done = !1,
                          n;
                      return n.value = g, n.done = !0, n
                    };
                  return e.next = e
                }
              }
              return {
                next: y
              }
            }

            function y() {
              return {
                value: g,
                done: !0
              }
            }
            var g, b = Object.prototype,
              m = b.hasOwnProperty,
              x = "function" == typeof Symbol ? Symbol : {},
              w = x.iterator || "@@iterator",
              S = x.asyncIterator || "@@asyncIterator",
              _ = x.toStringTag || "@@toStringTag",
              O = "object" == typeof t,
              E = n.regeneratorRuntime;
            if (E) return void(O && (t.exports = E));
            E = n.regeneratorRuntime = O ? t.exports : {}, E.wrap = e;
            var P = "suspendedStart",
              j = "suspendedYield",
              F = "executing",
              M = "completed",
              A = {},
              N = {};
            N[w] = function() {
              return this
            };
            var T = Object.getPrototypeOf,
              I = T && T(T(d([])));
            I && I !== b && m.call(I, w) && (N = I);
            var k = c.prototype = o.prototype = Object.create(N);
            u.prototype = k.constructor = c, c.constructor = u, c[_] = u
              .displayName = "GeneratorFunction", E.isGeneratorFunction =
              function(t) {
                var n = "function" == typeof t && t.constructor;
                return !!n && (n === u || "GeneratorFunction" === (n
                  .displayName || n.name))
              }, E.mark = function(t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t,
                  c) : (
                    t.__proto__ = c, _ in t || (t[_] =
                      "GeneratorFunction")),
                  t.prototype = Object.create(k), t
              }, E.awrap = function(t) {
                return {
                  __await: t
                }
              }, f(a.prototype), a.prototype[S] = function() {
                return this
              }, E.AsyncIterator = a, E.async = function(t, n, r, i) {
                var o = new a(e(t, n, r, i));
                return E.isGeneratorFunction(n) ? o : o.next().then(
                  function(
                    t) {
                    return t.done ? t.value : o.next()
                  })
              }, f(k), k[_] = "Generator", k.toString = function() {
                return "[object Generator]"
              }, E.keys = function(t) {
                var n = [];
                for (var r in t) n.push(r);
                return n.reverse(),
                  function r() {
                    for (; n.length;) {
                      var e = n.pop();
                      if (e in t) return r.value = e, r.done = !1, r
                    }
                    return r.done = !0, r
                  }
              }, E.values = d, p.prototype = {
                constructor: p,
                reset: function(t) {
                  if (this.prev = 0, this.next = 0, this.sent = this
                    ._sent =
                    g, this.done = !1, this.delegate = null, this
                    .method =
                    "next", this.arg = g, this.tryEntries.forEach(v), !t
                    )
                    for (var n in this) "t" === n.charAt(0) && m.call(
                      this,
                      n) && !isNaN(+n.slice(1)) && (this[n] = g)
                },
                stop: function() {
                  this.done = !0;
                  var t = this.tryEntries[0],
                    n = t.completion;
                  if ("throw" === n.type) throw n.arg;
                  return this.rval
                },
                dispatchException: function(t) {
                  function n(n, e) {
                    return o.type = "throw", o.arg = t, r.next = n, e &&
                      (r
                        .method = "next", r.arg = g), !!e
                  }
                  if (this.done) throw t;
                  for (var r = this, e = this.tryEntries.length -
                    1; e >=
                    0; --e) {
                    var i = this.tryEntries[e],
                      o = i.completion;
                    if ("root" === i.tryLoc) return n("end");
                    if (i.tryLoc <= this.prev) {
                      var u = m.call(i, "catchLoc"),
                        c = m.call(i, "finallyLoc");
                      if (u && c) {
                        if (this.prev < i.catchLoc) return n(i.catchLoc,
                          !
                          0);
                        if (this.prev < i.finallyLoc) return n(i
                          .finallyLoc)
                      } else if (u) {
                        if (this.prev < i.catchLoc) return n(i.catchLoc,
                          !0)
                      } else {
                        if (!c) throw new Error(
                          "try statement without catch or finally");
                        if (this.prev < i.finallyLoc) return n(i
                          .finallyLoc)
                      }
                    }
                  }
                },
                abrupt: function(t, n) {
                  for (var r = this.tryEntries.length - 1; r >= 0; --
                    r) {
                    var e = this.tryEntries[r];
                    if (e.tryLoc <= this.prev && m.call(e,
                      "finallyLoc") &&
                      this.prev < e.finallyLoc) {
                      var i = e;
                      break
                    }
                  }
                  i && ("break" === t || "continue" === t) && i
                    .tryLoc <=
                    n && n <= i.finallyLoc && (i = null);
                  var o = i ? i.completion : {};
                  return o.type = t, o.arg = n, i ? (this.method =
                    "next",
                    this.next = i.finallyLoc, A) : this.complete(o)
                },
                complete: function(t, n) {
                  if ("throw" === t.type) throw t.arg;
                  return "break" === t.type || "continue" === t.type ?
                    this
                    .next = t.arg : "return" === t.type ? (this.rval =
                      this
                      .arg = t.arg, this.method = "return", this.next =
                      "end") : "normal" === t.type && n && (this.next =
                      n),
                    A
                },
                finish: function(t) {
                  for (var n = this.tryEntries.length - 1; n >= 0; --
                    n) {
                    var r = this.tryEntries[n];
                    if (r.finallyLoc === t) return this.complete(r
                      .completion, r.afterLoc), v(r), A
                  }
                },
                catch: function(t) {
                  for (var n = this.tryEntries.length - 1; n >= 0; --
                    n) {
                    var r = this.tryEntries[n];
                    if (r.tryLoc === t) {
                      var e = r.completion;
                      if ("throw" === e.type) {
                        var i = e.arg;
                        v(r)
                      }
                      return i
                    }
                  }
                  throw new Error("illegal catch attempt")
                },
                delegateYield: function(t, n, r) {
                  return this.delegate = {
                    iterator: d(t),
                    resultName: n,
                    nextLoc: r
                  }, "next" === this.method && (this.arg = g), A
                }
              }
          }("object" == typeof n ? n : "object" == typeof window ?
            window :
            "object" == typeof self ? self : this)
        }).call(n, function() {
          return this
        }(), r(158))
      }])

    </script>
    <script src="/./main.0cf68a.js"></script>
    <script>
      ! function() {
        ! function(e) {
          var t = document.createElement("script");
          document.getElementsByTagName("body")[0].appendChild(t), t
            .setAttribute(
              "src", e)
        }("/slider.e37972.js")
      }()

    </script>

    <div class="tools-col" q-class="show:isShow,hide:isShow|isFalse"
                                                                                    q-on="click:stop(e)">
      <div class="tools-nav header-menu">

        <ul style="width: 70%">

          <li style="width: 33.333333333333336%"
                                                                                          q-on="click: openSlider(e, 'innerArchive')">
            <a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a>
          </li>

          <li style="width: 33.333333333333336%"
                                                                                          q-on="click: openSlider(e, 'friends')">
            <a href="javascript:void(0)" q-class="active:friends">友情链</a></li>

          <li style="width: 33.333333333333336%"
                                                                                          q-on="click: openSlider(e, 'aboutme')">
            <a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>

        </ul>
      </div>
      <div class="tools-wrap">

        <section class="tools-section tools-section-all" q-show="innerArchive">
          <div class="search-wrap">
            <input class="search-ipt" q-model="search" type="text"
                                                                                            placeholder="find something…">
            <i class="icon-search icon" q-show="search|isEmptyStr"></i>
            <i class="icon-close icon" q-show="search|isNotEmptyStr"
                                                                                            q-on="click:clearChose(e)"></i>
          </div>
          <div class="widget tagcloud search-tag">
            <p class="search-tag-wording">tag:</p>
            <label class="search-switch">
              <input type="checkbox" q-on="click:toggleTag(e)"
                                                                                              q-attr="checked:showTags">
            </label>
            <ul class="article-tag-list" q-show="showTags">

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">java</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">python爬虫</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)"
                                                                                                class="js-tag color1">Python统计分析</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Qt</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">RESTful</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Spring</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Git</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">java并发</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">linux</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">linux运维</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">spring</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">vue</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">佛学</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">前端面试题汇总</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">图</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">面试题</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">数据库</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">树状数组</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">SA</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">ActiveMQ</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">数学基础</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">dairy</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">GA</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">C++11</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">JDK</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">MarkDown</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">MyBatis</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Java基础</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">js</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">多线程笔试</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">算法模板</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">C++</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Mysql</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">字典树</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">刷题</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">树</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">DFS</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">设计模式</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">DP</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">nginx</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">MongoDB</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">JVM</a>
              </li>

              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">RabbitMQ</a>
              </li>

              <div class="clearfix"></div>
            </ul>
          </div>
          <ul class="search-ul">
            <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
              缺失模块。<br>1、请确保node版本大于6.2<br>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br> npm
              i
              hexo-generator-json-content --save<br><br>
              3、在根目录_config.yml里添加配置：
              <pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
            </p>
            <li class="search-li" q-repeat="items" q-show="isShow">
              <a q-attr="href:path|urlformat" class="search-title"><i
                                                                                                class="icon-quo-left icon"></i><span
                                                                                                q-text="title"></span></a>
              <p class="search-time">
                <i class="icon-calendar icon"></i>
                <span q-text="date|dateformat"></span>
              </p>
              <p class="search-tag">
                <i class="icon-price-tags icon"></i>
                <span q-repeat="tags" q-on="click:choseTag(e, name)"
                                                                                                q-text="name|tagformat"></span>
              </p>
            </li>
          </ul>
        </section>

        <section class="tools-section tools-section-friends" q-show="friends">

          <ul class="search-ul">

            <li class="search-li">
              <a href="https://www.cnblogs.com/javabai/" target="_blank" class="search-title"
                                                                                              rel="external nofollow noopener noreferrer"><i
                                                                                                class="icon-quo-left icon"></i>博客园</a>
            </li>

          </ul>

        </section>

        <section class="tools-section tools-section-me" q-show="aboutme">

          <div class="aboutme-wrap" id="js-aboutme">
            技术分享&lt;br&gt;&lt;br&gt;QQ:230326401</div>

        </section>

      </div>

    </div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

      <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
      <div class="pswp__bg"></div>

      <!-- Slides wrapper with overflow:hidden. -->
      <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
          <div class="pswp__item"></div>
          <div class="pswp__item"></div>
          <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

          <div class="pswp__top-bar">

            <!--  Controls are self-explanatory. Order can be changed. -->

            <div class="pswp__counter"></div>

            <button class="pswp__button pswp__button--close"
                                                                                            title="Close (Esc)"></button>

            <button class="pswp__button pswp__button--share" style="display:none"
                                                                                            title="Share"></button>

            <button class="pswp__button pswp__button--fs"
                                                                                            title="Toggle fullscreen"></button>

            <button class="pswp__button pswp__button--zoom"
                                                                                            title="Zoom in/out"></button>

            <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
            <!-- element will get class pswp__preloader--active when preloader is running -->
            <div class="pswp__preloader">
              <div class="pswp__preloader__icn">
                <div class="pswp__preloader__cut">
                  <div class="pswp__preloader__donut"></div>
                </div>
              </div>
            </div>
          </div>

          <div
                                                                                          class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
            <div class="pswp__share-tooltip"></div>
          </div>

          <button class="pswp__button pswp__button--arrow--left"
                                                                                          title="Previous (arrow left)">
          </button>

          <button class="pswp__button pswp__button--arrow--right"
                                                                                          title="Next (arrow right)">
          </button>

          <div class="pswp__caption">
            <div class="pswp__caption__center"></div>
          </div>

        </div>

      </div>

    </div>

  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
