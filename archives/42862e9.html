<!DOCTYPE html>

<html class="theme-next gemini use-motion" lang="zh-Hans">

<head>
  <meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport"
                                                                                  content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#222">

  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet"
                                                                                  type="text/css">

  <link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet"
                                                                                  type="text/css">

  <link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">

  <link rel="apple-touch-icon" sizes="180x180"
                                                                                  href="/images/apple-touch-icon-next.png?v=5.1.4">

  <link rel="icon" type="image/png" sizes="32x32"
                                                                                  href="/images/favicon-32x32-next.png?v=5.1.4">

  <link rel="icon" type="image/png" sizes="16x16"
                                                                                  href="/images/favicon-16x16-next.png?v=5.1.4">

  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">

  <meta name="keywords" content="DP,">

  <link rel="alternate" href="/atom.xml" title="star"
                                                                                  type="application/atom+xml">

  <meta name="description" content="DP算法题训练">
  <meta name="keywords" content="DP">
  <meta property="og:type" content="article">
  <meta property="og:title" content="DP问题归类">
  <meta property="og:url" content="http://javastar.club/archives/42862e9.html">
  <meta property="og:site_name" content="star">
  <meta property="og:description" content="DP算法题训练">
  <meta property="og:locale" content="zh-Hans">
  <meta property="og:image"
                                                                                  content="https://github.com/starstarb/clouding/raw/master/head/Cg-4k1oWK_6ITsuEAGLaXmEP7foAAN_pwOKzB4AYtp2207.jpg">
  <meta property="og:updated_time" content="2019-08-16T03:12:36.472Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="DP问题归类">
  <meta name="twitter:description" content="DP算法题训练">
  <meta name="twitter:image"
                                                                                  content="https://github.com/starstarb/clouding/raw/master/head/Cg-4k1oWK_6ITsuEAGLaXmEP7foAAN_pwOKzB4AYtp2207.jpg">

  <script type="text/javascript" id="hexo.configurations">
    var NexT = window.NexT || {};
    var CONFIG = {
      root: '/',
      scheme: 'Gemini',
      version: '5.1.4',
      sidebar: {
        "position": "left",
        "display": "post",
        "offset": 12,
        "b2t": false,
        "scrollpercent": false,
        "onmobile": false
      },
      fancybox: true,
      tabs: true,
      motion: {
        "enable": true,
        "async": false,
        "transition": {
          "post_block": "fadeIn",
          "post_header": "slideDownIn",
          "post_body": "slideDownIn",
          "coll_header": "slideLeftIn",
          "sidebar": "slideUpIn"
        }
      },
      duoshuo: {
        userId: '0',
        author: '博主'
      },
      algolia: {
        applicationID: '',
        apiKey: '',
        indexName: '',
        hits: {
          "per_page": 10
        },
        labels: {
          "input_placeholder": "Search for Posts",
          "hits_empty": "We didn't find any results for the search: ${query}",
          "hits_stats": "${hits} results found in ${time} ms"
        }
      }
    };

  </script>

  <link rel="canonical" href="http://javastar.club/archives/42862e9.html">

  <title>DP问题归类 | star</title>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope
                                                                                    itemtype="http://schema.org/WPHeader">
      <div class="header-inner">
        <div class="site-brand-wrapper">
          <div class="site-meta ">

            <div class="custom-logo-site-title">
              <a href="/" class="brand" rel="start">
                <span class="logo-line-before"><i></i></span>
                <span class="site-title">star</span>
                <span class="logo-line-after"><i></i></span>
              </a>
            </div>

            <p class="site-subtitle">前端小白|java萌新|Geek精神</p>

          </div>

          <div class="site-nav-toggle">
            <button>
              <span class="btn-bar"></span>
              <span class="btn-bar"></span>
              <span class="btn-bar"></span>
            </button>
          </div>
        </div>

        <nav class="site-nav">

          <ul id="menu" class="menu">

            <li class="menu-item menu-item-home">
              <a href="/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-home"></i> <br>

                首页
              </a>
            </li>

            <li class="menu-item menu-item-categories">
              <a href="/categories/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-th"></i> <br>

                分类
              </a>
            </li>

            <li class="menu-item menu-item-archives">
              <a href="/archives/" rel="section">

                <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>

                归档
              </a>
            </li>

          </ul>

        </nav>

      </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">

            <div id="posts" class="posts-expand">

              <article class="post post-type-normal" itemscope
                                                                                              itemtype="http://schema.org/Article">

                <div class="post-block">
                  <link itemprop="mainEntityOfPage"
                                                                                                  href="http://javastar.club/archives/42862e9.html">

                  <span hidden itemprop="author" itemscope
                                                                                                  itemtype="http://schema.org/Person">
                    <meta itemprop="name" content="stardust">
                    <meta itemprop="description" content>
                    <meta itemprop="image" content="/images/head.jpg">
                  </span>

                  <span hidden itemprop="publisher" itemscope
                                                                                                  itemtype="http://schema.org/Organization">
                    <meta itemprop="name" content="star">
                  </span>

                  <header class="post-header">

                    <h1 class="post-title" itemprop="name headline">DP问题归类</h1>

                    <div class="post-meta">
                      <span class="post-time">

                        <span class="post-meta-item-icon">
                          <i class="fa fa-calendar-o"></i>
                        </span>

                        <span class="post-meta-item-text">发表于</span>

                        <time title="创建于" itemprop="dateCreated datePublished"
                                                                                                        datetime="2019-07-22T12:42:52+08:00">
                          2019-07-22
                        </time>

                        <span class="post-meta-divider">|</span>

                        <span class="post-meta-item-icon">
                          <i class="fa fa-calendar-check-o"></i>
                        </span>

                        <span class="post-meta-item-text">更新于&#58;</span>

                        <time title="更新于" itemprop="dateModified"
                                                                                                        datetime="2019-08-16T11:12:36+08:00">
                          2019-08-16
                        </time>

                      </span>

                      <span class="post-category">

                        <span class="post-meta-divider">|</span>

                        <span class="post-meta-item-icon">
                          <i class="fa fa-folder-o"></i>
                        </span>

                        <span class="post-meta-item-text">分类于</span>

                        <span itemprop="about" itemscope
                                                                                                        itemtype="http://schema.org/Thing">
                          <a href="/categories/DP问题/" itemprop="url"
                                                                                                          rel="index">
                            <span itemprop="name">DP问题</span>
                          </a>
                        </span>

                      </span>

                      <span class="post-comments-count">
                        <span class="post-meta-divider">|</span>
                        <span class="post-meta-item-icon">
                          <i class="fa fa-comment-o"></i>
                        </span>
                        <a href="/archives/42862e9.html#comments"
                                                                                                        itemprop="discussionUrl">
                          <span class="post-comments-count valine-comment-count" data-xid="/archives/42862e9.html"
                                                                                                          itemprop="commentCount"></span>
                        </a>
                      </span>

                      <span id="/archives/42862e9.html" class="leancloud_visitors"
                                                                                                      data-flag-title="DP问题归类">
                        <span class="post-meta-divider">|</span>
                        <span class="post-meta-item-icon">
                          <i class="fa fa-eye"></i>
                        </span>

                        <span class="post-meta-item-text">热度&#58;</span>

                        <span class="leancloud-visitors-count"></span>
                        <span>℃</span>
                      </span>

                      <div class="post-wordcount">

                        <span class="post-meta-item-icon">
                          <i class="fa fa-file-word-o"></i>
                        </span>

                        <span class="post-meta-item-text">字数统计&#58;</span>

                        <span title="字数统计">
                          8.3k
                        </span>

                        <span class="post-meta-divider">|</span>

                        <span class="post-meta-item-icon">
                          <i class="fa fa-clock-o"></i>
                        </span>

                        <span class="post-meta-item-text">阅读时长 &asymp;</span>

                        <span title="阅读时长">
                          36
                        </span>

                      </div>

                    </div>
                  </header>

                  <div class="post-body" itemprop="articleBody">

                    <p>DP算法题训练<br><img src="https://github.com/starstarb/clouding/raw/master/head/Cg-4k1oWK_6ITsuEAGLaXmEP7foAAN_pwOKzB4AYtp2207.jpg"
                                                                                                      alt>
                    </p>
                    <a id="more"></a>
                    <h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink"
                                                                                                      title="最长回文子串"></a>最长回文子串
                    </h3>
                    <p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
                    <p>示例 1：</p>
                    <p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：
                    </p>
                    <p>输入: “cbbd”<br>输出: “bb”</p>
                    <p>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" rel="external nofollow noopener noreferrer"
                                                                                                      target="_blank">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>算法思路：
                    </p>
                    <ol>
                      <li>
                        <p>暴力法(会超时)</p>
                      </li>
                      <li>
                        <p>
                          将字符串s反转得到字符串rev，再求他们的最长公共子串，再判断该最长公共子串是否就是我们要找的最长回文子串。(依然会超时)
                        </p>
                      </li>
                      <li>
                        <p>动态规划<br>初始状态：</p>
                        <ul>
                          <li>dp[i][i]=1;//单个字符是回文串</li>
                          <li>dp[i][i+1]=1 if s[i]=s[i+1];//连续两个相同字符是回文串</li>
                        </ul>
                      </li>
                      <li>
                        <p>
                          中心扩展法<br>回文中心的两侧互为镜像，因此，回文可以从他的中心展开，并且只有2n-1个这样的中心(一个元素为中心的情况有n个，两个元素为中心的情况有n-1个)
                        </p>
                      </li>
                      <li>
                        <p>
                          Manacher：<br>主要思想是，把给定的字符串的每一个字母当做中心，向两边扩展，这样来找最长的子回文串，这个叫中心扩展法，但是这个方法还要考虑到处理
                          abba 这种偶数个字符的回文串。Manacher 法将所有的字符串全部变成奇数个字符。</p>
                      </li>
                    </ol>
                    <p>代码实现：</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">//1.暴力求解</span><br><span class="line">class Solution&#123;</span><br><span class="line">	public:</span><br><span class="line">	string longestPalindrome(string s)</span><br><span class="line">	&#123;</span><br><span class="line">		string res=&quot;&quot;;</span><br><span class="line">		string temp=&quot;&quot;;</span><br><span class="line">		for(int i=0;i&lt;s.length();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j=i;j&lt;s.length();j++)</span><br><span class="line">			&#123;</span><br><span class="line">				temp=temp+s[j];</span><br><span class="line">				string tem=temp;</span><br><span class="line">				std::reverse(tem.begin(),tem.end());</span><br><span class="line">				if(temp==tem)</span><br><span class="line">				res=res.length()&gt;temp.length()?res:temp;</span><br><span class="line">			&#125;</span><br><span class="line">			temp=&quot;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">class Solution&#123;</span><br><span class="line">	public:</span><br><span class="line">	    string longestPalindrome(string s)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	if(s.length()==1) return s;</span><br><span class="line">	    	string rev=s;</span><br><span class="line">	    	string res;</span><br><span class="line">	    	std::reverse(rev.begin(),rev.end());</span><br><span class="line">	    	if(rev==s)return s;</span><br><span class="line">	    	int len=0;</span><br><span class="line">	    	for(int i=0;i&lt;s.length();i++)</span><br><span class="line">	    	&#123;</span><br><span class="line">	    		string temp;</span><br><span class="line">	    		for(int j=i;j&lt;s.length();j++)</span><br><span class="line">	    		&#123;</span><br><span class="line">	    			temp=temp+s[j];</span><br><span class="line">	    			if(len&gt;=temp.length())</span><br><span class="line">	    			continue;</span><br><span class="line">	    			else if(rev.find(temp)!=-1)</span><br><span class="line">	    			&#123;</span><br><span class="line">	    				string q=temp;</span><br><span class="line">	    				std::reverse(q.begin(),q.end());</span><br><span class="line">	    				if(q==temp)</span><br><span class="line">	    				&#123;</span><br><span class="line">	    					len=temp.length();</span><br><span class="line">	    					res=temp;</span><br><span class="line">	    				&#125;</span><br><span class="line">	    			&#125;</span><br><span class="line">	    			else break;</span><br><span class="line">	    		&#125;</span><br><span class="line">	    		temp=&quot;&quot;;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	return res;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\\DP求解</span><br><span class="line">初始状态：</span><br><span class="line"> * dp[i][i]=1;//单个字符</span><br><span class="line"> * dp[i][i+1] if s[i]=s[i+1];//连续两个相同字符是回文串</span><br><span class="line">  class Solution&#123;</span><br><span class="line"> 	public:</span><br><span class="line"> 	string longestPalindrome(string s)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		int len=s.size();</span><br><span class="line"> 		if(len==0||len==1) return s;</span><br><span class="line"> 		int start;</span><br><span class="line"> 		int max=1;</span><br><span class="line"> 		vector&lt;vector&lt;int&gt;&gt; dp(len ,vector&lt;int&gt;(len));</span><br><span class="line"> 		for(int i=0;i&lt;len;i++)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			dp[i][i]=1;</span><br><span class="line"> 			if(i&lt;len-1&amp;&amp;s[i]==s[i+1])</span><br><span class="line"> 			&#123;</span><br><span class="line"> 				dp[i][i+1]=1;</span><br><span class="line"> 				max=2;</span><br><span class="line"> 				start=i;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		for(int j=3;j&lt;=len;j++)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			for(int i=0;i+j-1&lt;len;i++)</span><br><span class="line"> 			&#123;</span><br><span class="line"> 				int m=j+i-1;</span><br><span class="line"> 				if(s[i]==s[m]&amp;&amp;dp[i+1][m-1]==1)</span><br><span class="line"> 				&#123;</span><br><span class="line"> 					dp[i][m]=1;</span><br><span class="line"> 					start=i;</span><br><span class="line"> 					max=j;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		return s.substr(start,max);</span><br><span class="line"></span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <h3 id="解决这类-“最优子结构”-问题，可以考虑使用-“动态规划”："><a href="#解决这类-“最优子结构”-问题，可以考虑使用-“动态规划”：" class="headerlink"
                                                                                                      title="解决这类 “最优子结构” 问题，可以考虑使用 “动态规划”："></a>解决这类
                      “最优子结构” 问题，可以考虑使用 “动态规划”：</h3>
                    <ol>
                      <li>定义 “状态”；</li>
                      <li>找到 “状态转移方程”。</li>
                    </ol>
                    <blockquote>
                      <p>记号说明： 下文中，使用记号 s[l, r] 表示原始字符串的一个子串，l、r
                        分别是区间的左右边界的索引值，使用左闭、右闭区间表示左右边界可以取到。<br>举个例子，当 s =
                        ‘babad’ 时，s[0, 1] = ‘ba’
                        ，s[2, 4] = ‘bad’。</p>
                    </blockquote>
                    <p>1、定义 “状态”，这里 “状态”数组是二维数组。</p>
                    <p>dp[l][r] 表示子串 s[l, r]（包括区间左右端点）是否构成回文串，是一个二维布尔型数组。即如果子串
                      s[l, r] 是回文串，那么
                      dp[l][r] = true。</p>
                    <p>2、找到 “状态转移方程”。</p>
                    <p>首先，我们很清楚一个事实：</p>
                    <p>1、当子串只包含 1 个字符，它一定是回文子串；</p>
                    <p>2、当子串包含 2 个以上字符的时候：如果 s[l, r] 是一个回文串，例如
                      “abccba”，那么这个回文串两边各往里面收缩一个字符（如果可以的话）的子串 s[l + 1, r - 1]
                      也一定是回文串，<br>即：</p>
                    <figure class="highlight plain">
                      <figcaption><span>dp[l][r] </span></figcaption>
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">   根据这一点，我们可以知道，给出一个子串 s[l, r] ，如果 s[l] != s[r]，那么这个子串就一定不是回文串。如果 s[l] == s[r] 成立，就接着判断 s[l + 1] 与 s[r - 1]，这很像中心扩散法的逆方法。</span><br><span class="line"></span><br><span class="line"> 事实上，当 s[l] == s[r] 成立的时候，dp[l][r] 的值由 dp[l + 1][r - l] 决定，这一点也不难思考：当左右边界字符串相等的时候，整个字符串是否是回文就完全由“原字符串去掉左右边界”的子串是否回文决定。</span><br><span class="line"> 但是这里还需要再多考虑一点点：</span><br><span class="line"> “原字符串去掉左右边界”的子串的边界情况。</span><br><span class="line"></span><br><span class="line">1、当原字符串的元素个数为 3 个的时候，如果左右边界相等，那么去掉它们以后，只剩下 1 个字符，它一定是回文串，故原字符串也一定是回文串；</span><br><span class="line"></span><br><span class="line">2、当原字符串的元素个数为 2 个的时候，如果左右边界相等，那么去掉它们以后，只剩下 0 个字符，显然原字符串也一定是回文串。</span><br><span class="line">把上面两点归纳一下，只要 s[l + 1, r - 1] 至少包含两个元素，就有必要继续做判断，否则直接根据左右边界是否相等就能得到原字符串的回文性。而“s[l + 1, r - 1] 至少包含两个元素”等价于 l + 1 &lt; r - 1，整理得 l - r &lt; -2，或者 r - l &gt; 2。</span><br><span class="line"></span><br><span class="line">综上，如果一个字符串的左右边界相等，以下二者之一成立即可：</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>1、去掉左右边界以后的字符串不构成区间，即“ s[l + 1, r - 1] 至少包含两个元素”的反面，即 l -
                      r &gt;= -2，或者 r - l
                      &lt;= 2； 2、去掉左右边界以后的字符串是回文串，具体说，它的回文性决定了原字符串的回文性。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">于是整理成“状态转移方程”：</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>dp[l, r] = (s[l] == s[r] and (l - r &gt;= -2 or dp[l + 1,
                      r - 1]))</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">或者</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>dp[l, r] = (s[l] == s[r] and (r - l &lt;= 2 or dp[l + 1,
                      r - 1]))</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">编码实现细节：因为要构成子串 l 一定小于等于 r ，我们只关心 “状态”数组“上三角”的那部分取值。</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>理解上面的“状态转移方程”中的 (r - l &lt;= 2 or dp[l + 1, r - 1])
                      这部分是关键，因为 or
                      是短路运算，因此，如果收缩以后不构成区间，那么就没有必要看继续 dp[l + 1, r - 1] 的取值。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">读者可以思考一下：为什么在动态规划的算法中，不用考虑回文串长度的奇偶性呢。想一想，答案就在状态转移方程里面。</span><br><span class="line"></span><br><span class="line">具体编码细节在代码的注释中已经体现。</span><br><span class="line"></span><br><span class="line">参考代码：</span><br><span class="line">Python:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>class Solution:<br> def longestPalindrome(self, s: str)
                      -&gt; str:<br> size =
                      len(s)<br> if size &lt;= 1:<br> return s</p>
                    <pre><code># 二维 dp 问题
# 状态：dp[l,r]: s[l:r] 包括 l，r ，表示的字符串是不是回文串
# 设置为 None 是为了方便调试，看清楚代码执行流程
dp = [[False for _ in range(size)] for _ in range(size)]

longest_l = 1
res = s[0]

# 因为只有 1 个字符的情况在最开始做了判断
# 左边界一定要比右边界小，因此右边界从 1 开始
for r in range(1, size):
    for l in range(r):
        # 状态转移方程：如果头尾字符相等并且中间也是回文
        # 在头尾字符相等的前提下，如果收缩以后不构成区间（最多只有 1 个元素），直接返回 True 即可
        # 否则要继续看收缩以后的区间的回文性
        # 重点理解 or 的短路性质在这里的作用
        if s[l] == s[r] and (r - l &lt;= 2 or dp[l + 1][r - 1]):
            dp[l][r] = True
            cur_len = r - l + 1
            if cur_len &gt; longest_l:
                longest_l = cur_len
                res = s[l:r + 1]
    # 调试语句
    # for item in dp:
    #     print(item)
    # print(&apos;---&apos;)
return res</code></pre>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">Java:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>class Solution {<br> public String
                      longestPalindrome(String s) {<br> int
                      len=s.length();<br> if(len&lt;=1)<br> return s;<br> int
                      longestPalindrome=1;<br> String
                      longestPalindromeStr=s.substring(0,1);<br>
                      boolean[][] dp=new boolean[len][len];<br> // abcdedcba<br>
                      // l r<br> // 如果
                      dp[l, r] = true 那么 dp[l + 1, r - 1] 也一定为 true<br> //
                      关键在这里：[l + 1, r - 1]
                      一定至少有 2 个元素才有判断的必要<br> // 因为如果 [l + 1, r - 1]
                      只有一个元素，不用判断，一定是回文串<br> // 如果 [l
                      + 1, r - 1] 表示的区间为空，不用判断，也一定是回文串<br> // [l + 1, r - 1]
                      一定至少有 2 个元素 等价于 l + 1
                      &lt; r - 1，即 r - l &gt; 2</p>
                    <pre><code>    // 写代码的时候这样写：如果 [l + 1, r - 1]  的元素小于等于 1 个，即 r - l &lt;=  2 ，就不用做判断了

    // 因为只有 1 个字符的情况在最开始做了判断
    // 左边界一定要比右边界小，因此右边界从 1 开始
    for(int r=1;r&lt;len;r++)
    {
        for(int l=0;l&lt;r;l++)
        {
            // 区间应该慢慢放大
            // 状态转移方程：如果头尾字符相等并且中间也是回文
            // 在头尾字符相等的前提下，如果收缩以后不构成区间（最多只有 1 个元素），直接返回 True 即可
            // 否则要继续看收缩以后的区间的回文性
            // 重点理解 or 的短路性质在这里的作用

            if(s.charAt(l)==s.charAt(r)&amp;&amp;(l+1&gt;=r-1|| dp[l+1][r-1])){
                dp[l][r]=true;
                if(r-l+1&gt;longestPalindrome)
                {
                    longestPalindrome=r-l+1;
                    longestPalindromeStr=s.substring(l,r+1);
                }
            }
        }
    }
    return longestPalindromeStr;
}</code></pre>
                    <p>}</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">### 正则表达式匹配</span><br><span class="line"></span><br><span class="line">给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &apos;.&apos; 和 &apos;* &apos; 的正则表达式匹配。</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串
                      s的，而不是部分字符串。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">说明:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 .
                      和 *。<br>示例 1:</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">输入:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa”
                      整个字符串。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">示例 2:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>输入:<br>s = “aa”<br>p = “a*”<br>输出: true</p>
                    <p>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串
                      “aa” 可被视为 ‘a’ 重复了一次。
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">示例 3:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>输入:<br>s = “ab”<br>p = “.*”<br>输出: true<br>解释: “.*”
                      表示可匹配零个或多个（’*’）任意字符（’.’）。
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">示例 4:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>输入:<br>s = “aab”<br>p = “c<em>a</em>b”<br>输出: true<br>解释:
                      因为 ‘*’ 表示零个或多个，这里
                      ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">示例 5:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>输入:<br>s = “mississippi”<br>p =
                      “mis<em>is</em>p*.”<br>输出: false</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">链接：https://leetcode-cn.com/problems/regular-expression-matching</span><br><span class="line"></span><br><span class="line">算法思路：</span><br><span class="line">方法一：回溯</span><br><span class="line">    当pattern(模式串)中由* 时，需要检查匹配串s 中的不同后缀，以判断它们能否匹配模式串剩余的部分。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">方法二：DP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    最优子结构：动态规划做，将中间结果保存，通过dp(i,j) 表示text[i:] 和pattern[j:] 是否能匹配。</span><br><span class="line">    我们可以用更短的字符串匹配问题来表示原本的问题。</span><br><span class="line"></span><br><span class="line">如果模式串中由星号，则pattern[1]，这种情况下，我们可以直接忽略模式串中这一部分，或者删除匹配串中的第一个字符，前提是它能够匹配模式串当前位置字符，即pattern[0] 。如果两种操作中由任何一种使得剩下的字符串能够匹配，那么初始时，匹配串和模式串就可以被匹配。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参考代码：</span><br><span class="line">Java</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>class Solution {<br> public boolean isMatch(String text,
                      String pattern)
                      {<br> if (pattern.isEmpty()) return text.isEmpty();<br>
                      boolean first_match =
                      (!text.isEmpty() &amp;&amp;<br> (pattern.charAt(0) ==
                      text.charAt(0) ||
                      pattern.charAt(0) == ‘.’));</p>
                    <pre><code>    if (pattern.length() &gt;= 2 &amp;&amp; pattern.charAt(1) == &apos;*&apos;){
        return (isMatch(text, pattern.substring(2)) ||
                (first_match &amp;&amp; isMatch(text.substring(1), pattern)));
    } else {
        return first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1));
    }
}</code></pre>
                    <p>}</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">### 最长有效括号</span><br><span class="line">给定一个只包含 &apos;(&apos; 和 &apos;)&apos; 的字符串，找出最长的包含有效括号的子串的长度。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br><span class="line">链接：https://leetcode-cn.com/problems/longest-valid-parentheses</span><br><span class="line">算法思路：</span><br><span class="line">1. 暴力</span><br><span class="line">   遇到&quot;(&quot;，放到栈顶，遇到每个&quot;)&quot;，从栈中弹出一个&quot;(&quot;，</span><br><span class="line">如果栈顶没有&quot;(&quot;,或者遍历完整个子字符串后栈中仍然有元素，则该子字符串是无效的。</span><br><span class="line">    此种方法对每个偶数长度子字符串都进行了判断，并保存目前为止找到的最长的有效子字符串的长度。</span><br><span class="line"></span><br><span class="line">参考代码：</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p> public class Solution{<br> public boolean isValid(String
                      s)<br> {<br> Stack
                      <character> stack=new Stack<character>();<br> for(int
                          i=0;i&lt;s.length();i++)<br> {<br>
                          if(s.charAt(i)==’(‘)<br> {<br>
                          stack.push(‘(‘);<br> }<br> else if
                          (!stack.empty()&amp;&amp;
                          stack.peek()==’(‘){<br> stack.pop();<br> }<br>
                          else<br> {<br> return
                          false;<br> }<br> }<br> return stack.empty();<br> }<br>
                          public int
                          longestValidParentheses(String s)<br> {<br> int
                          maxlen=0;<br> for(int
                          i=0;i&lt;s.length();i++)<br> {<br> for(int
                          j=i+2;j&lt;=s.length();j+=2)<br> {<br>
                          if(isValid(s.substring(i,j)))<br>
                          {<br> maxlen=Math.max(maxlen,j-i);<br> }<br> }<br>
                          }<br> return
                          maxlen;<br> }<br> }</character>
                      </character>
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">时间复杂度： O(n^2)</span><br><span class="line">从长度为n的字符串产生所有可能的子字符串需要的时间复杂度为 O(n^2)。</span><br><span class="line">验证一个长度为 n 的子字符串需要的时间为 O(n) 。</span><br><span class="line"></span><br><span class="line">空间复杂度： O(n)</span><br><span class="line">子字符串的长度最多会需要一个深度为 n的栈。</span><br><span class="line"></span><br><span class="line">2. DP动态规划</span><br><span class="line">算法：</span><br><span class="line">   定义一个dp数组，其中第i个元素表示以下标为i的字符结尾的最长有效字符串的长度。</span><br><span class="line">   将dp数组全部初始化为0，以&apos;(&apos;结尾的子字符串对应的dp数组位置上的值必定为0,因此只需要更新&apos;)&apos;在dp数组中对应位置的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  为求出dp数组，每两个字符将检查一次，如果满足如下条件：</span><br><span class="line">      1. s[i]=&apos;)&apos;且s[i-1]=&apos;(&apos;, 也就是形如&quot;......()&quot;，我们可以推出：</span><br><span class="line">          dp[i]=dp[i-2]+2</span><br><span class="line">       因为结束部分的&quot;()&quot;是一个有效子字符串，并且将之前有效子字符串的长度增加了2</span><br><span class="line">      2. s[i]=&apos;)&apos; 且s[i-1]=&apos;)&apos;,也就是形如&quot;.....))&quot;,我们可以推出：</span><br><span class="line">      如果s[i-dp[i-1]-1]=&apos;(&apos;,那么</span><br><span class="line">          dp[i]=dp[i-1]+dp[i-dp[i-1]-2]+2</span><br><span class="line"></span><br><span class="line">      因为如果倒数第二个&apos;)&apos;是一个有效子字符串的一部分(subs),对于最后一个&apos;)&apos;，如果它是一个更长子字符串的一部分，那么它一定有一个对应的&apos;(&apos;，它的位置在倒数第二个&apos;)&apos;所在的有效子字符串的前面(subs).</span><br><span class="line"></span><br><span class="line">      因此，如果子字符串subs的前面恰好是&apos;(&apos;，那么就用2加上subs的长度(dp[i-1])去更新dp[i]，除此以外，我们也会把有效子字符串&quot;(,subs,)&quot;之前的有效子字符串的长度也加上，也就是加上dp[i-dp[i-1]-2]。</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n)，遍历整个字符串一次，就可以将dp数组求出来。</span><br><span class="line">空间复杂度:O(n),需要一个大小为n的dp数组。</span><br><span class="line">参考代码：</span><br><span class="line">Java</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>public class Solution{<br> public int
                      longestValidParentheses(String s)<br>
                      {<br> int maxans=0;<br> int dp[]=new int[s.length()];<br>
                      for(int
                      i=1;i&lt;s.length();i++)<br> {<br>
                      if(s.charAt(i)==’)’)<br> {<br>
                      if(s.charAt(i-1)==’(‘)<br> {<br>
                      dp[i]=(i&gt;=2?dp[i-2]:0)+2;<br> }<br> else
                      if(i-dp[i-1]&gt;0&amp;&amp;s.charAt(i-dp[i-1]-1)==’(‘)<br>
                      {<br>
                      dp[i]=dp[i-1]+((i-dp[i-1])&gt;=2?dp[i-dp[i-1]-2]:0)+2;<br>
                      }<br>
                      maxans=Math.max(maxans,dp[i]);<br> }<br> }<br> return
                      maxans;<br> }<br>}</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">### 通配符匹配</span><br><span class="line">给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &apos;?&apos; 和 &apos; * &apos; 的通配符匹配。</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>‘?’ 可以匹配任何单个字符。<br>‘*’
                      可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">说明:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ?
                      和 *。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">示例 1:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配
                      “aa” 整个字符串。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">示例 2:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>输入:<br>s = “aa”<br>p = “*”<br>输出: true<br>解释: ‘*’
                      可以匹配任意字符串。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">示例 3:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>输入:<br>s = “cb”<br>p = “?a”<br>输出: false<br>解释: ‘?’ 可以匹配
                      ‘c’, 但第二个 ‘a’ 无法匹配
                      ‘b’。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">示例 4:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>输入:<br>s = “adceb”<br>p = “<em>a</em>b”<br>输出:
                      true<br>解释: 第一个 ‘<em>‘
                        可以匹配空字符串, 第二个 ‘</em>‘ 可以匹配字符串 “dce”.</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">示例 5:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>输入:</p>
                    <p>s = “acdcb”<br>p = “a*c?b”<br>输出: false</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">链接：https://leetcode-cn.com/problems/wildcard-matching</span><br><span class="line">算法思路：</span><br><span class="line">  1. 双指针遍历  时间复杂度:O(mn)</span><br><span class="line">  2. 动态规划DP  </span><br><span class="line">  dp[i][j]表示s到i位置，p到j位置是否匹配。</span><br><span class="line">  初始化：</span><br><span class="line">  1. dp[0][0]:true</span><br><span class="line">  2. 第一行dp[0][j]，即就是s为空，与p匹配，所以只要p开始为 * 才为true</span><br><span class="line">  3. 第一列dp[i][0],全部为False.</span><br><span class="line">  动态方程：</span><br><span class="line">  1. 如果(s[i]==p[j]||p[j]==&quot;?&quot;)&amp;&amp;dp[i-1][j-1],有dp[i][j]=true</span><br><span class="line">  2. 如果p[j]==&quot; * &quot;&amp;&amp;(dp[i-1][j]=true||dp[i][j-1]=true) 有dp[i][j]=true</span><br><span class="line">      dp[i-1][j],表示 * 代表的是非空任何字符，例如：abcd,ab*</span><br><span class="line">      dp[i][j-1]，表示 * 代表空字符，例如：ab,ab*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参考代码：</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>class Solution{<br> public boolean isMatch(String
                      s,String p)<br> {<br>
                      boolean[][] dp=new boolean[<br> s.length()+1][p.length()
                      +1];<br>
                      dp[0][0]=true;<br> for(int j=1;j&lt;p.length()+1;j++){<br>
                      if(p.charAt(j-1)==’<em>‘){<br> dp[0][j]=dp[0][j-1];<br>
                        }<br> }<br> for(int
                        i=1;i&lt;s.length()+1;i++)<br> {<br> for(int
                        j=1;j&lt;p.length()+1;j++)<br>
                        {<br>
                        if(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)==’?’)<br>
                        {<br>
                        dp[i][j]=dp[i-1][j-1];<br> }<br> else
                        if(p.charAt(j-1)==’</em>‘)<br> {<br>
                      dp[i][j]=dp[i][j-1]||dp[i-1][j];<br> }<br> }<br> }<br>
                      return
                      dp[s.length()][p.length()];</p>
                    <pre><code>}</code></pre>
                    <p>}</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">###  最大子序和</span><br><span class="line">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br><span class="line">进阶:</span><br><span class="line">如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</span><br><span class="line">链接：https://leetcode-cn.com/problems/maximum-subarray</span><br><span class="line"></span><br><span class="line">算法思路：</span><br><span class="line">      动态规划算法，对数组遍历，当前最大连续子序列和为sum,结果为ans.</span><br><span class="line">  * 如果 sum&gt;0,则说明sum对结果有增益效果，则sum保留并加上当前遍历数字</span><br><span class="line">  * 如果sum&lt;=0 ，则说明sum对结果无增益效果，需要舍弃，则sum直接更新为当前遍历数字</span><br><span class="line">  * 每次比较sum 和ans的大小，将最大值置为ans ,遍历结束返回结果</span><br><span class="line">  时间复杂度:O(n)</span><br><span class="line">  参考代码：</span><br><span class="line">  Java</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>class Solution{<br> public int maxSubArray(int[]
                      nums)<br> {<br> int
                      ans=nums[0];<br> int sum=0;<br> for(int num:nums)<br>
                      {<br> if(sum&gt;0)<br>
                      {<br> sum+=num;<br> }<br> else{<br> sum=num;<br> }<br>
                      ans=Math.max(ans,sum);<br> }<br> return ans;<br> }<br>}
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">### 买卖股票的最佳时机</span><br><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</span><br><span class="line"></span><br><span class="line">注意你不能在买入股票前卖出股票。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 =
                      1）的时候买入，在第 5 天（股票价格 =
                      6）的时候卖出，最大利润 = 6-1 = 5 。<br> 注意利润不能是 7-1 = 6,
                      因为卖出价格需要大于买入价格。<br>
                      <figure class="highlight plain">
                        <table>
                          <tr>
                            <td class="gutter">
                              <pre><span class="line">1</span><br></pre>
                            </td>
                            <td class="code">
                              <pre><span class="line">示例 2:</span><br></pre>
                            </td>
                          </tr>
                        </table>
                      </figure>
                    </p>
                    <p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为
                      0。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</span><br><span class="line">算法思路：</span><br><span class="line">1. 暴力法</span><br><span class="line">   找出最大利润，即就是找出给定数组两个数字之间的最大差值，且第二个数字必须大于第一个数字</span><br><span class="line">    对于每组i和j(其中j&gt;i)我们需要找出max(prices[j]-prices[i])</span><br><span class="line">    </span><br><span class="line">参考代码：</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>class Solution {<br> public int maxProfit(int[] prices)
                      {<br> int
                      maxprofit=0;<br> for(int i=0;i&lt;prices.length;i++)<br>
                      {<br> for(int
                      j=i+1;j&lt;prices.length;j++)<br> {<br> int
                      profit=prices[j]-prices[i];<br>
                      if(profit&gt;maxprofit)<br> maxprofit=profit;<br> }<br>
                      }<br> return
                      maxprofit;<br> }<br>}</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">时间复杂度：O(n^2)</span><br><span class="line">空间复杂度：O(1)</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>public class Solution{<br> public int maxProfit(int
                      prices[])<br> {<br> int
                      minprice=Integer.MAX_VALUE;<br> int maxprofit=0;<br>
                      for(int
                      i=0;i&lt;prices.length;i++)<br> {<br>
                      if(prices[i]&lt;minprice)<br>
                      minprice=prices[i];<br> else<br>
                      if(prices[i]-minprice&gt;maxprofit)<br>
                      maxprofit=prices[i]-minprice;<br> }<br> return
                      maxprofit;<br> }<br>}</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">时间复杂度：O(n)</span><br><span class="line">空间复杂度：O(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 最短路径和</span><br><span class="line">给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span><br><span class="line"></span><br><span class="line">说明：每次只能向下或者向右移动一步。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br><span class="line"></span><br><span class="line">链接：https://leetcode-cn.com/problems/minimum-path-sum</span><br><span class="line"></span><br><span class="line">算法思路：</span><br><span class="line">    找出一条从左上角到右下角的路径，路径上数字之和最小。</span><br><span class="line">1. 暴力算法</span><br><span class="line">    cost(i,j)=grid[i][j]+min(cost(i+1,j),cost(i,j+1))</span><br><span class="line">时间复杂度：O(2^(m+n))，每次移动最多有两种选择</span><br><span class="line">空间复杂度:O(m+n)，递归深度是m+n</span><br><span class="line">2. DP算法 二维动态规划</span><br><span class="line">    新建一个额外的dp数组，与原矩阵大小相同，在这个矩阵中，dp(i,j)表示从坐标(i,j)到右下角的最小路径权值，我们初始化右下角的dp值为对应的原矩阵值，然后填充整个矩阵，对于每个元素考虑移动到右边或者下面，因此获得最小路径，递推公式如下：</span><br><span class="line">    dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))</span><br><span class="line">时间复杂度:O(mn)。遍历整个矩阵恰好一次</span><br><span class="line">空间复杂度:O(mn)。额外的一个同大小矩阵。</span><br><span class="line">3. 一维动态规划</span><br><span class="line">   我们可以用一个一维数组来代替二维数组，dp数组的大小和行大小相同，这是因为对于某个固定状态，只需要考虑下方和右侧的节点。</span><br><span class="line">   首先初始化dp数组最后一个元素是右下角的元素值，然后我们向左更新每个dp(j)为：</span><br><span class="line">    dp(j)=grid(i,j)+min(dp(j),dp(j+1))</span><br><span class="line">    我们对于每一行都重复这个过程，然后向上一行移动，计算完成后dp(0)就是最后的结果。</span><br><span class="line"></span><br><span class="line"> 时间复杂度 ：O(mn)遍历整个矩阵恰好一次。</span><br><span class="line"> 空间复杂度 ：O(n)额外的一维数组，和一行大小相同。</span><br><span class="line">4. 动态规划（不需要额外存储空间）</span><br><span class="line">  与二维DP算法相同，但是不需要用额外的dp数组，而是在原数组上存储，这样就不需要额外的存储空间。递推公式如下：</span><br><span class="line">  grid(i,j)=grid(i,j)+min(grid(i+1,j),grid(i,j+1))</span><br><span class="line"></span><br><span class="line">  时间复杂度：</span><br><span class="line">   O(mn)。遍历整个矩阵恰好一次。</span><br><span class="line"></span><br><span class="line">  空间复杂度：</span><br><span class="line">  O(1)。不需要额外空间。</span><br><span class="line">参考代码：</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>//暴力<br>class Solution {<br> public int calculate(int
                      [][] grid ,int i,int
                      j)<br> {<br> if(i==grid.length||j==grid[0].length)<br>
                      return
                      Integer.MAX_VALUE;<br> if(i==grid.length-1 &amp;&amp;
                      j==grid[0].length-1)<br>
                      return grid[i][j];<br> return
                      grid[i][j]+Math.min(calculate(grid,i+1,j),calculate(grid,i,j+1));<br>
                      }</p>
                    <pre><code>public int minPathSum(int[][] grid) {
    return calculate(grid,0,0);
}</code></pre>
                    <p>}
                      //二维DP算法<br>class Solution {<br> public int
                      minPathSum(int[][] grid) {<br> int
                      [][]dp=new int[grid.length][grid[0].length];<br> for(int
                      i=grid.length-1;i&gt;=0;i–)<br> {<br> for(int
                      j=grid[0].length-1;j&gt;=0;j–)<br> {<br>
                      if(i==grid.length-1&amp;&amp;j!=grid[0].length-1)<br>
                      dp[i][j]=grid[i][j]+dp[i][j+1];<br> else
                      if(j==grid[0].length-1&amp;&amp;i!=grid.length-1)<br>
                      dp[i][j]=grid[i][j]+dp[i+1][j];<br> else
                      if(j!=grid[0].length&amp;&amp;i!=grid.length-1)<br>
                      dp[i][j]=grid[i][j]+Math.min(dp[i+1][j],dp[i][j+1]);<br>
                      else<br>
                      dp[i][j]=grid[i][j];<br> }<br> }<br> return dp[0][0];<br>
                      }<br>}
                      //一维动态规划<br>class Solution {<br> public int
                      minPathSum(int[][] grid) {<br> int
                      []dp=new int[grid[0].length];<br> for(int
                      i=grid.length-1;i&gt;=0;i–)<br>
                      {<br> for(int j=grid[0].length-1;j&gt;=0;j–)<br> {<br>
                      if(i==grid.length-1&amp;&amp;j!=grid[0].length-1)<br>
                      dp[j]=grid[i][j]+dp[j+1];<br> else
                      if(i!=grid.length-1&amp;&amp;j==grid[0].length-1)<br>
                      dp[j]=grid[i][j]+dp[j];<br> else
                      if(i!=grid.length-1&amp;&amp;j!=grid[0].length-1)<br>
                      dp[j]=grid[i][j]+Math.min(dp[j],dp[j+1]);<br> else<br>
                      dp[j]=grid[i][j];<br>
                      }<br> }<br> return dp[0];<br> }<br>}
                      //不需要存储空间的DP<br>class Solution {<br> public int
                      minPathSum(int[][] grid) {<br>
                      for(int i=grid.length-1;i&gt;=0;i–)<br> {<br> for(int
                      j=grid[0].length-1;j&gt;=0;j–)<br> {<br>
                      if(i==grid.length-1&amp;&amp;j!=grid[0].length-1)<br>
                      grid[i][j]=grid[i][j]+grid[i][j+1];<br> else
                      if(i!=grid.length-1&amp;&amp;j==grid[0].length-1)<br>
                      grid[i][j]=grid[i][j]+grid[i+1][j];<br> else
                      if(i!=grid.length-1&amp;&amp;j!=grid[0].length-1)<br>
                      grid[i][j]=grid[i][j]+Math.min(grid[i][j+1],grid[i+1][j]);<br>
                      else<br>
                      grid[i][j]=grid[i][j];<br> }<br> }<br> return
                      grid[0][0];<br> }<br>}</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">### 扰乱字符串</span><br><span class="line">给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。</span><br><span class="line"></span><br><span class="line">下图是字符串 s1 = &quot;great&quot; 的一种可能的表示形式。</span><br><span class="line"></span><br><span class="line">    great</span><br><span class="line">   /    \</span><br><span class="line">  gr    eat</span><br><span class="line"> / \    /  \</span><br><span class="line">g   r  e   at</span><br><span class="line">           / \</span><br><span class="line">          a   t</span><br><span class="line"></span><br><span class="line">在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。</span><br><span class="line"></span><br><span class="line">例如，如果我们挑选非叶节点 &quot;gr&quot; ，交换它的两个子节点，将会产生扰乱字符串 &quot;rgeat&quot; 。</span><br><span class="line"></span><br><span class="line">    rgeat</span><br><span class="line">   /    \</span><br><span class="line">  rg    eat</span><br><span class="line"> / \    /  \</span><br><span class="line">r   g  e   at</span><br><span class="line">           / \</span><br><span class="line">          a   t</span><br><span class="line"></span><br><span class="line">我们将 &quot;rgeat” 称作 &quot;great&quot; 的一个扰乱字符串。</span><br><span class="line"></span><br><span class="line">同样地，如果我们继续将其节点 &quot;eat&quot; 和 &quot;at&quot; 进行交换，将会产生另一个新的扰乱字符串 &quot;rgtae&quot; 。</span><br><span class="line"></span><br><span class="line">    rgtae</span><br><span class="line">   /    \</span><br><span class="line">  rg    tae</span><br><span class="line"> / \    /  \</span><br><span class="line">r   g  ta  e</span><br><span class="line">       / \</span><br><span class="line">      t   a</span><br><span class="line"></span><br><span class="line">我们将 &quot;rgtae” 称作 &quot;great&quot; 的一个扰乱字符串。</span><br><span class="line"></span><br><span class="line">给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;</span><br><span class="line">输出: false</span><br><span class="line">链接：https://leetcode-cn.com/problems/scramble-string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">算法思路：</span><br><span class="line">1. 递归</span><br><span class="line">  第 1 种情况： S1 切割为两部分，然后进行若干步切割交换，最后判断两个子树分别是否能变成 S2 的两部分。</span><br><span class="line"> 第 2 种情况：S1 切割并且交换为两部分，然后进行若干步切割交换，最后判断两个子树是否能变成 S2 的两部分。</span><br><span class="line">2. DP动态规划</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参考代码：</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>//递归 6ms<br>public boolean isScramble(String s1, String
                      s2) {<br> if
                      (s1.length() != s2.length()) {<br> return false;<br> }<br>
                      if (s1.equals(s2))
                      {<br> return true;<br> }</p>
                    <pre><code>//判断两个字符串每个字母出现的次数是否一致
int[] letters = new int[26];
for (int i = 0; i &lt; s1.length(); i++) {
    letters[s1.charAt(i) - &apos;a&apos;]++;
    letters[s2.charAt(i) - &apos;a&apos;]--;
}
//如果两个字符串的字母出现不一致直接返回 false
for (int i = 0; i &lt; 26; i++) {
    if (letters[i] != 0) {
        return false;
    }
} 
//遍历每个切割位置
for (int i = 1; i &lt; s1.length(); i++) {
    //对应情况 1 ，判断 S1 的子树能否变为 S2 相应部分
    if (isScramble(s1.substring(0, i), s2.substring(0, i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) {
        return true;
    }
    //对应情况 2 ，S1 两个子树先进行了交换，然后判断 S1 的子树能否变为 S2 相应部分
    if (isScramble(s1.substring(i), s2.substring(0, s2.length() - i)) &amp;&amp;
       isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) ) {
        return true;
    }
}
return false;</code></pre>
                    <p>}
                      //动态规划 34ms<br>public boolean isScramble(String s1, String
                      s2) {<br> if
                      (s1.length() != s2.length()) {<br> return false;<br> }<br>
                      if (s1.equals(s2))
                      {<br> return true;<br> }</p>
                    <pre><code>int[] letters = new int[26];
for (int i = 0; i &lt; s1.length(); i++) {
    letters[s1.charAt(i) - &apos;a&apos;]++;
    letters[s2.charAt(i) - &apos;a&apos;]--;
}
for (int i = 0; i &lt; 26; i++) {
    if (letters[i] != 0) {
        return false;
    }
}

int length = s1.length();
boolean[][][] dp = new boolean[length + 1][length][length];</code></pre>
                    <p> //遍历所有的字符串长度<br> for (int len = 1; len &lt;= length;
                      len++) {<br> //S1
                      开始的地方<br> for (int i = 0; i + len &lt;= length; i++) {<br>
                      //S2 开始的地方<br> for
                      (int j = 0; j + len &lt;= length; j++) {<br> //长度是 1
                      无需切割<br> if (len == 1)
                      {<br> dp[len][i][j] = s1.charAt(i) == s2.charAt(j);<br> }
                      else {<br>
                      //遍历切割后的左半部分长度<br> for (int q = 1; q &lt; len; q++) {<br>
                      dp[len][i][j] =
                      dp[q][i][j] &amp;&amp; dp[len - q][i + q][j + q]<br> ||
                      dp[q][i][j + len - q]
                      &amp;&amp; dp[len - q][i + q][j];<br> //如果当前是 true 就
                      break，防止被覆盖为 false<br> if
                      (dp[len][i][j]) {<br> break;<br> }<br> }<br> }<br> }<br>
                      }<br> }<br> return
                      dp[length][0][0];<br>}</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 最小的必要团队</span><br><span class="line">作为项目经理，你规划了一份需求的技能清单 req_skills，并打算从备选人员名单 people 中选出些人组成一个「必要团队」（ 编号为 i 的备选人员 people[i] 含有一份该备选人员掌握的技能列表）。</span><br><span class="line"></span><br><span class="line">所谓「必要团队」，就是在这个团队中，对于所需求的技能列表 req_skills 中列出的每项技能，团队中至少有一名成员已经掌握。</span><br><span class="line"></span><br><span class="line">我们可以用每个人的编号来表示团队中的成员：例如，团队 team = [0, 1, 3] 表示掌握技能分别为 people[0]，people[1]，和 people[3] 的备选人员。</span><br><span class="line"></span><br><span class="line">请你返回 任一 规模最小的必要团队，团队成员用人员编号表示。你可以按任意顺序返回答案，本题保证答案存在。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：req_skills = [&quot;java&quot;,&quot;nodejs&quot;,&quot;reactjs&quot;], people = [[&quot;java&quot;],[&quot;nodejs&quot;],[&quot;nodejs&quot;,&quot;reactjs&quot;]]</span><br><span class="line">输出：[0,2]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：req_skills = [&quot;algorithms&quot;,&quot;math&quot;,&quot;java&quot;,&quot;reactjs&quot;,&quot;csharp&quot;,&quot;aws&quot;], people = [[&quot;algorithms&quot;,&quot;math&quot;,&quot;java&quot;],[&quot;algorithms&quot;,&quot;math&quot;,&quot;reactjs&quot;],[&quot;java&quot;,&quot;csharp&quot;,&quot;aws&quot;],[&quot;reactjs&quot;,&quot;csharp&quot;],[&quot;csharp&quot;,&quot;math&quot;],[&quot;aws&quot;,&quot;java&quot;]]</span><br><span class="line">输出：[1,2]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= req_skills.length &lt;= 16</span><br><span class="line">1 &lt;= people.length &lt;= 60</span><br><span class="line">1 &lt;= people[i].length, req_skills[i].length, people[i][j].length &lt;= 16</span><br><span class="line">req_skills 和 people[i] 中的元素分别各不相同</span><br><span class="line">req_skills[i][j], people[i][j][k] 都由小写英文字母组成</span><br><span class="line">本题保证「必要团队」一定存在</span><br><span class="line"></span><br><span class="line">链接：https://leetcode-cn.com/problems/smallest-sufficient-team</span><br><span class="line">算法思路：</span><br><span class="line">典型的背包问题，用位图实现，递推公式</span><br><span class="line">dp[x|y]=min(dp[x|y],dp[x]+dp[y])</span><br><span class="line"></span><br><span class="line">S表示一个二进制集合，S中第i位是1表示该集合包含标号是i的技能。</span><br><span class="line">令dp[S]表示要获得集合S表示的技能的最小花费，也就是最少需要选多少人。</span><br><span class="line">假设技能个数是n，那么要求的答案就是dp[(1&lt; &lt; n ) - n ]</span><br><span class="line">对于状态转移方程：</span><br><span class="line">假设当前第i个人的技能集合是now，我们就拿当前的技能集合now去更新每一个dp[now|j],0&lt;=j&lt;(1&lt; &lt; n)的值，因为要记录最后所选的答案，所以拿一个team数组维护一下。</span><br><span class="line">时间复杂度O(m * 2^n),m是人的个数，n是技能个数</span><br><span class="line"></span><br><span class="line">代码实现：</span><br><span class="line">C++:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>class Solution<br>{
                      public:<br> vector<int> smallestSufficientTeam(vector
                        <string>&amp;
                          req_skills,vector&lt;vector<string>&gt;&amp;
                            people)<br>
                            unordered_map&lt;string,int&gt; mp;<br> int
                            n=req_skills.size();<br>
                            for(int i = 0 ;i &lt; n; ++i)
                            mp[req_skills[i]]=i;<br> vector<int>
                              dp(1&lt;&lt;n,-1);<br> vector<int>
                                team[1&lt;&lt;n];<br> dp[0]=0;<br>
                                for(int i=0;i&lt;people.size();++i)<br> {<br>
                                int now=0;<br>
                                for(string s: people[i])<br> {<br> int
                                x=mp[s];<br>
                                now|=(1&lt;&lt;x);<br> }<br> for(int
                                j=0;j&lt;(1&lt;&lt;n);++j)<br>
                                {<br> if(dp[j]&gt;=0)<br> {<br> int x=now|j;<br>
                                if(dp[x]==-1||dp[x]&gt;dp[j]+1)<br> {<br>
                                dp[x]=dp[j]+1;<br>
                                team[x]=team[j];<br> team[x].push_back(i);<br>
                                }<br> }<br> }<br>
                                }<br> return team[(1&lt;&lt;n)-1];</int>
                            </int>
                          </string>
                        </string>
                      </int>
                    </p>
                    <p>}</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">本题是一个 集合覆盖问题，决定性问题 的集合覆盖是 NP完全问题，最佳化问题的集合覆盖是NP困难问题。所以想得到最优解（之一），只能用暴力搜索。好在数据范围并不大，最大状态空间也只有 2^&#123;16&#125;=65,536‬2 种状态，也就是 1616 个人每个人有选和不选两种情况。我们可以用动态规划的方法进行搜索。先将 req_skills 的全集建立一个字典，对每个技能进行编号 0 ~ n-1 。然后建立 dp 数组，长度为 2^n2 </span><br><span class="line">  ，数组元素初始化为 people 的全集，然后对 dp[0] 初始化为空集。然后我们遍历每个人，对于所有状态，计算把这个人加入团队后，整个团队的技能是否增加，如果增加并且人数比拥有相同技能的团队更优化，则更新结果。最终，全集 dp[(1 &lt;&lt; n) - 1] 中的 people 集合就是我们要求的结果。</span><br><span class="line">python:</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>class Solution:<br> def smallestSufficientTeam(self,
                      req_skills: List[str],
                      people: List[List[str]]) -&gt; List[int]:</p>
                    <pre><code># 为skills建立字典
n = len(req_skills)
d = dict()
for i in range(n):
    d[req_skills[i]] = i
# 所有状态
dp = [list(range(len(people))) for _ in range(1 &lt;&lt; n)]
dp[0] = []
# 遍历所有人
for i in range(len(people)):
    # 求这个人的技能
    skill = 0
    for s in people[i]:
        skill |= (1 &lt;&lt; d[s])
    for k, v in enumerate(dp):
        # 把这个人加入进来以后的团队技能
        new_skills = k | skill
        # 如果团队技能因此而增加 并且增加后的人数比新技能原来的人数少 则更新答案
        if new_skills != k and len(dp[new_skills]) &gt; len(v) + 1:
            dp[new_skills] = v + [i]
return dp[(1 &lt;&lt; n) - 1]</code></pre>
                    <p>```</p>

                  </div>
                  <div>

                    <div>

                      <div
                                                                                                      style="text-align:center;color: #ccc;font-size:14px;">
                        -------------本文结束<i
                                                                                                        class="fa fa-paw"></i>感谢您的阅读-------------
                      </div>

                    </div>

                  </div>

                  <div>

                  </div>

                  <div>
                    <div
                                                                                                    style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
                      <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
                      <button id="rewardButton" disable="enable"
                                                                                                      onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
                        <span>打赏</span>
                      </button>
                      <div id="QR" style="display: none;">

                        <div id="wechat" style="display: inline-block">
                          <img id="wechat_qr" src="/images/wechatpay.jpg"
                                                                                                          alt="stardust 微信支付">
                          <p>微信支付</p>
                        </div>

                        <div id="alipay" style="display: inline-block">
                          <img id="alipay_qr" src="/images/alipay.jpg"
                                                                                                          alt="stardust 支付宝">
                          <p>支付宝</p>
                        </div>

                      </div>
                    </div>

                  </div>

                  <div>
                    <ul class="post-copyright">
                      <li class="post-copyright-author">
                        <strong>本文作者：</strong>
                        stardust
                      </li>
                      <li class="post-copyright-link">
                        <strong>本文链接：</strong>
                        <a href="http://javastar.club/archives/42862e9.html"
                                                                                                        title="DP问题归类">http://javastar.club/archives/42862e9.html</a>
                      </li>
                      <li class="post-copyright-license">
                        <strong>版权声明： </strong>
                        本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow noopener noreferrer"
                                                                                                        target="_blank">CC
                          BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
                      </li>
                    </ul>

                  </div>

                  <footer class="post-footer">

                    <div class="post-tags">

                      <a href="/tags/DP/" rel="tag"># DP</a>

                    </div>

                    <div class="post-nav">
                      <div class="post-nav-next post-nav-item">

                        <a href="/archives/9f4133d4.html" rel="next"
                                                                                                        title="头条面试题">
                          <i class="fa fa-chevron-left"></i> 头条面试题
                        </a>

                      </div>

                      <span class="post-nav-divider"></span>

                      <div class="post-nav-prev post-nav-item">

                        <a href="/archives/78ab4875.html" rel="prev"
                                                                                                        title="链表问题归类">
                          链表问题归类 <i class="fa fa-chevron-right"></i>
                        </a>

                      </div>
                    </div>

                  </footer>
                </div>

              </article>

              <div class="post-spread">

              </div>
            </div>

          </div>

          <div class="comments" id="comments">
          </div>

        </div>

        <div class="sidebar-toggle">
          <div class="sidebar-toggle-line-wrap">
            <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
            <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
            <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
          </div>
        </div>

        <aside id="sidebar" class="sidebar">

          <div class="sidebar-inner">

            <ul class="sidebar-nav motion-element">
              <li class="sidebar-nav-toc sidebar-nav-active"
                                                                                              data-target="post-toc-wrap">
                文章目录
              </li>
              <li class="sidebar-nav-overview" data-target="site-overview-wrap">
                站点概览
              </li>
            </ul>

            <section class="site-overview-wrap sidebar-panel">
              <div class="site-overview">
                <div class="site-author motion-element" itemprop="author" itemscope
                                                                                                itemtype="http://schema.org/Person">

                  <img class="site-author-image" itemprop="image" src="/images/head.jpg"
                                                                                                  alt="stardust">

                  <p class="site-author-name" itemprop="name">stardust</p>
                  <p class="site-description motion-element"
                                                                                                  itemprop="description">
                    个人技术博客</p>
                </div>

                <nav class="site-state motion-element">

                  <div class="site-state-item site-state-posts">

                    <a href="/archives/">

                      <span class="site-state-item-count">87</span>
                      <span class="site-state-item-name">日志</span>
                    </a>
                  </div>

                  <div class="site-state-item site-state-categories">
                    <a href="/categories/index.html">
                      <span class="site-state-item-count">54</span>
                      <span class="site-state-item-name">分类</span>
                    </a>
                  </div>

                  <div class="site-state-item site-state-tags">

                    <span class="site-state-item-count">61</span>
                    <span class="site-state-item-name">标签</span>

                  </div>

                </nav>

                <div class="feed-link motion-element">
                  <a href="/atom.xml" rel="alternate">
                    <i class="fa fa-rss"></i>
                    RSS
                  </a>
                </div>

                -
                <div id="days"></div>
                <script>
                  function show_date_time() {
                    window.setTimeout("show_date_time()"，
                      1000);
                    BirthDay = new Date("06/27/2019 15:13:14");
                    today = new Date();
                    timeold = (today.getTime() - BirthDay.getTime());
                    sectimeold = timeold / 1000
                    secondsold = Math.floor(sectimeold);
                    msPerDay = 24 * 60 * 60 * 1000
                    e_daysold = timeold / msPerDay
                    daysold = Math.floor(e_daysold);
                    e_hrsold = (e_daysold - daysold) * 24;
                    hrsold = setzero(Math.floor(e_hrsold));
                    e_minsold = (e_hrsold - hrsold) * 60;
                    minsold = setzero(Math.floor((e_hrsold - hrsold) * 60));
                    seconds = setzero(Math.floor((e_minsold - minsold) * 60));
                    document.getElementById('days').innerHTML = "已运行" +
                      daysold + "天" + hrsold + "小时" + minsold + "分" + seconds +
                      "秒";
                  }

                  function setzero(i) {
                    if (i < 10) {
                      i = "0" + i
                    };
                    return i;
                  }
                  show_date_time();

                </script>

              </div>
            </section>

            <!--noindex-->
            <section
                                                                                            class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
              <div class="post-toc">

                <div class="post-toc-content">
                  <ol class="nav">
                    <li class="nav-item nav-level-3"><a class="nav-link"
                                                                                                      href="#最长回文子串"><span
                                                                                                        class="nav-number">1.</span>
                        <span class="nav-text">最长回文子串
                        </span></a></li>
                    <li class="nav-item nav-level-3"><a class="nav-link"
                                                                                                      href="#解决这类-“最优子结构”-问题，可以考虑使用-“动态规划”："><span
                                                                                                        class="nav-number">2.</span>
                        <span class="nav-text">解决这类
                          “最优子结构” 问题，可以考虑使用 “动态规划”：</span></a></li>
                  </ol>
                </div>

              </div>
            </section>
            <!--/noindex-->

          </div>
        </aside>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
          <span class="with-love">
            <i class="fa fa-[object Object]"></i>
          </span>
          <span class="author" itemprop="copyrightHolder">stardust</span>

          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
            <i class="fa fa-area-chart"></i>
          </span>

          <span class="post-meta-item-text">Site words total count&#58;</span>

          <span title="Site words total count">227.5k</span>

        </div>

        <script async
                                                                                        src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
        </script>
        <span id="busuanzi_container_site_pv">本站总访问量<span
                                                                                          id="busuanzi_value_site_pv"></span>次</span>
        <span id="busuanzi_container_site_uv">
          本站访客数<span id="busuanzi_value_site_uv"></span>人次
        </span>

        <div class="busuanzi-count">
          <script async
                                                                                          src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
          </script>

        </div>

      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>

    </div>

  </div>

  <script type="text/javascript">
    if (Object.prototype.toString.call(window.Promise) !==
      '[object Function]') {
      window.Promise = null;
    }

  </script>

  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript"
                                                                                  src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6">
  </script>

  <script type="text/javascript"
                                                                                  src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7">
  </script>

  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1">
  </script>

  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1">
  </script>

  <script type="text/javascript"
                                                                                  src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5">
  </script>

  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4">
  </script>

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>

  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>

  <script type="text/javascript">
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.indexOf(item) > -1;
    });
    new Valine({
      el: '#comments',
      verify: true,
      notify: true,
      appId: 'SC04XqdJGidywEU8kpDnXmu6-MdYXbMMI',
      appKey: 'WWH572JLnQB3A4r74XKMGOok',
      placeholder: '来评论下呗',
      avatar: 'mm',
      guest_info: guest,
      pageSize: '10' || 10,
    });

  </script>

  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>
    AV.initialize("SC04XqdJGidywEU8kpDnXmu6-MdYXbMMI",
      "WWH572JLnQB3A4r74XKMGOok");

  </script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");
      $visitors.each(function() {
        entries.push($(this).attr("id").trim());
      });
      query.containedIn('url', entries);
      query.find()
        .done(function(results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);
            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function(object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);
      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(
                  counter.get('time'));
              },
              error: function(counter, error) {
                console.log(
                  'Failed to save Visitor num, with error message: ' +
                  error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(
                  newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }
    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });

  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":70,"height":120},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script type="text/javascript" src="/js/src/dytitle.js"></script>
