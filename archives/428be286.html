<!DOCTYPE html>

<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
                                                                                  content="width=device-width, initial-scale=1, maximum-scale=2">
  <meta name="theme-color" content="#222">
  <meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180"
                                                                                  href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32"
                                                                                  href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16"
                                                                                  href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="staring"
                                                                                  type="application/atom+xml">

  <link rel="stylesheet" href="/css/main.css?v=7.4.0">

  <link rel="stylesheet"
                                                                                  href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet"
                                                                                  href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

  <script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {
      root: '/',
      scheme: 'Mist',
      version: '7.4.0',
      exturl: false,
      sidebar: {
        "position": "left",
        "display": "post",
        "offset": 12,
        "onmobile": false
      },
      copycode: {
        "enable": true,
        "show_result": true,
        "style": null
      },
      back2top: {
        "enable": true,
        "sidebar": false,
        "scrollpercent": false
      },
      bookmark: {
        "enable": false,
        "color": "#222",
        "save": "auto"
      },
      fancybox: false,
      mediumzoom: false,
      lazyload: false,
      pangu: false,
      algolia: {
        appID: '',
        apiKey: '',
        indexName: '',
        hits: {
          "per_page": 10
        },
        labels: {
          "input_placeholder": "Search for Posts",
          "hits_empty": "We didn't find any results for the search: ${query}",
          "hits_stats": "${hits} results found in ${time} ms"
        }
      },
      localsearch: {
        "enable": true,
        "trigger": "auto",
        "top_n_per_article": 1,
        "unescape": false,
        "preload": false
      },
      path: '',
      motion: {
        "enable": true,
        "async": false,
        "transition": {
          "post_block": "fadeIn",
          "post_header": "slideDownIn",
          "post_body": "slideDownIn",
          "coll_header": "slideLeftIn",
          "sidebar": "slideUpIn"
        }
      },
      translation: {
        copy_button: '复制',
        copy_success: '复制成功',
        copy_failure: '复制失败'
      },
      sidebarPadding: 40
    };

  </script>

  <meta name="description" content="Js原型和原型链">
  <meta name="keywords" content="Javascript">
  <meta property="og:type" content="article">
  <meta property="og:title" content="每天一道Js基础：Js原型和原型链">
  <meta property="og:url" content="http://javastar.club/archives/428be286.html">
  <meta property="og:site_name" content="staring">
  <meta property="og:description" content="Js原型和原型链">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:image"
                                                                                  content="https://github.com/starstarb/clouding/raw/master/js/%E5%8E%9F%E5%9E%8B%E9%93%BE.png">
  <meta property="og:image"
                                                                                  content="https://github.com/starstarb/clouding/raw/master/js/%E5%8E%9F%E5%9E%8B%E9%93%BE2.png">
  <meta property="og:updated_time" content="2019-11-01T02:36:15.000Z">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="每天一道Js基础：Js原型和原型链">
  <meta name="twitter:description" content="Js原型和原型链">
  <meta name="twitter:image"
                                                                                  content="https://github.com/starstarb/clouding/raw/master/js/%E5%8E%9F%E5%9E%8B%E9%93%BE.png">
  <link rel="canonical" href="http://javastar.club/archives/428be286">

  <script id="page-configurations">
    // https://hexo.io/docs/variables.html
    CONFIG.page = {
      sidebar: "",
      isHome: false,
      isPost: true,
      isPage: false,
      isArchive: false
    };

  </script>

  <title>每天一道Js基础：Js原型和原型链 | staring</title>

  <noscript>
    <style>
      .use-motion .brand,
      .use-motion .menu-item,
      .sidebar-inner,
      .use-motion .post-block,
      .use-motion .pagination,
      .use-motion .comments,
      .use-motion .post-header,
      .use-motion .post-body,
      .use-motion .collection-header {
        opacity: initial;
      }

      .use-motion .logo,
      .use-motion .site-title,
      .use-motion .site-subtitle {
        opacity: initial;
        top: initial;
      }

      .use-motion .logo-line-before i {
        left: initial;
      }

      .use-motion .logo-line-after i {
        right: initial;
      }

    </style>
  </noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope
                                                                                    itemtype="http://schema.org/WPHeader">
      <div class="header-inner">
        <div class="site-brand-container">
          <div class="site-meta">

            <div>
              <a href="/" class="brand" rel="start">
                <span class="logo-line-before"><i></i></span>
                <span class="site-title">staring</span>
                <span class="logo-line-after"><i></i></span>
              </a>
            </div>
            <p class="site-subtitle">从来如此，便对么？</p>

          </div>

          <div class="site-nav-toggle">
            <button aria-label="切换导航栏">
              <span class="btn-bar"></span>
              <span class="btn-bar"></span>
              <span class="btn-bar"></span>
            </button>
          </div>
        </div>

        <nav class="site-nav">
          <ul id="menu" class="menu">

            <li class="menu-item menu-item-home">

              <a href="/" rel="section"><i
                                                                                                class="menu-item-icon fa fa-fw fa-home"></i>
                <br>首页</a>

            </li>

            <li class="menu-item menu-item-archives">

              <a href="/archives/" rel="section"><i
                                                                                                class="menu-item-icon fa fa-fw fa-archive"></i>
                <br>归档</a>

            </li>
            <li class="menu-item menu-item-search">
              <a href="javascript:;" class="popup-trigger">

                <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
            </li>

          </ul>

        </nav>
        <div class="site-search">
          <div class="popup search-popup">
            <div class="search-header">
              <span class="search-icon">
                <i class="fa fa-search"></i>
              </span>
              <div class="search-input-container">
                <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..."
                                                                                                spellcheck="false"
                                                                                                type="text"
                                                                                                id="search-input">
              </div>
              <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
              </span>
            </div>
            <div id="search-result"></div>

          </div>
          <div class="search-pop-overlay"></div>

        </div>
      </div>
    </header>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span>0%</span>
    </div>

    <a href="https://github.com/starstarb" class="github-corner" title="Follow me on GitHub"
                                                                                    aria-label="Follow me on GitHub"
                                                                                    rel="external nofollow noopener noreferrer"
                                                                                    target="_blank"><svg
                                                                                      width="80"
                                                                                      height="80"
                                                                                      viewbox="0 0 250 250"
                                                                                      aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z" />
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
                                                                                        fill="currentColor"
                                                                                        style="transform-origin: 130px 106px;"
                                                                                        class="octo-arm" />
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
                                                                                        fill="currentColor"
                                                                                        class="octo-body" />
      </svg></a>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">

            <div id="posts" class="posts-expand">
              <article itemscope itemtype="http://schema.org/Article">

                <div class="post-block post">
                  <link itemprop="mainEntityOfPage"
                                                                                                  href="http://javastar.club/archives/428be286.html">

                  <span hidden itemprop="author" itemscope
                                                                                                  itemtype="http://schema.org/Person">
                    <meta itemprop="name" content="staring">
                    <meta itemprop="description" content="个人技术博客">
                    <meta itemprop="image" content="/img/head.jpg">
                  </span>

                  <span hidden itemprop="publisher" itemscope
                                                                                                  itemtype="http://schema.org/Organization">
                    <meta itemprop="name" content="staring">
                  </span>
                  <header class="post-header">
                    <h1 class="post-title" itemprop="name headline">
                      每天一道Js基础：Js原型和原型链<a href="https://github.com/starstarb/starstarb.github.io_posts/每天一道Js基础：Js原型和原型链.md"
                                                                                                      class="post-edit-link"
                                                                                                      title="编辑"
                                                                                                      rel="external nofollow noopener noreferrer"
                                                                                                      target="_blank"><i
                                                                                                        class="fa fa-pencil"></i></a>

                    </h1>

                    <div class="post-meta">
                      <span class="post-meta-item">
                        <span class="post-meta-item-icon">
                          <i class="fa fa-calendar-o"></i>
                        </span>
                        <span class="post-meta-item-text">发表于</span>

                        <time title="创建时间：2019-09-28 16:47:06" itemprop="dateCreated datePublished"
                                                                                                        datetime="2019-09-28T16:47:06+08:00">2019-09-28</time>
                      </span>

                      <span class="post-meta-item">
                        <span class="post-meta-item-icon">
                          <i class="fa fa-calendar-check-o"></i>
                        </span>
                        <span class="post-meta-item-text">更新于</span>
                        <time title="修改时间：2019-11-01 10:36:15" itemprop="dateModified"
                                                                                                        datetime="2019-11-01T10:36:15+08:00">2019-11-01</time>
                      </span>

                      <span class="post-meta-item">
                        <span class="post-meta-item-icon">
                          <i class="fa fa-folder-o"></i>
                        </span>
                        <span class="post-meta-item-text">分类于</span>

                        <span itemprop="about" itemscope
                                                                                                        itemtype="http://schema.org/Thing"><a
                                                                                                          href="/categories/Javascript/"
                                                                                                          itemprop="url"
                                                                                                          rel="index"><span
                                                                                                            itemprop="name">Javascript</span></a></span>

                      </span>

                      <span class="post-meta-item" title="热度" id="busuanzi_container_page_pv"
                                                                                                      style="display: none;">
                        <span class="post-meta-item-icon">
                          <i class="fa fa-eye"></i>
                        </span>
                        <span class="post-meta-item-text">热度：</span>
                        <span id="busuanzi_value_page_pv"></span>
                      </span>
                      <span class="post-meta-item">

                        <span class="post-meta-item-icon">
                          <i class="fa fa-comment-o"></i>
                        </span>

                        <span class="post-meta-item-text">Valine：</span>

                        <a title="valine" href="/archives/428be286.html#comments"
                                                                                                        itemprop="discussionUrl"><span
                                                                                                          class="post-comments-count valine-comment-count"
                                                                                                          data-xid="/archives/428be286.html"
                                                                                                          itemprop="commentCount"></span></a>
                      </span>

                      <br>
                      <span class="post-meta-item" title="本文字数">
                        <span class="post-meta-item-icon">
                          <i class="fa fa-file-word-o"></i>
                        </span>

                        <span class="post-meta-item-text">本文字数：</span>

                        <span>16k</span>
                      </span>

                      <span class="post-meta-item" title="阅读时长">
                        <span class="post-meta-item-icon">
                          <i class="fa fa-clock-o"></i>
                        </span>

                        <span class="post-meta-item-text">阅读时长 &asymp;</span>

                        <span>15 分钟</span>
                      </span>

                    </div>
                  </header>

                  <div class="post-body" itemprop="articleBody">

                    <p><strong>Js原型和原型链</strong></p>
                    <a id="more"></a>
                    <h6 id="Js中的继承实现的方式："><a href="#Js中的继承实现的方式：" class="headerlink"
                                                                                                      title="Js中的继承实现的方式："></a>Js中的继承实现的方式：
                    </h6>
                    <h6 id="new-操作符具体干了什么？"><a href="#new-操作符具体干了什么？" class="headerlink"
                                                                                                      title="new 操作符具体干了什么？"></a>new
                      操作符具体干了什么？</h6>
                    <p>
                      ######<br><strong>实现继承</strong><br>JS中没有真正意义的继承，利用原型和原型链能实现继承。<br><strong>应用场景</strong>
                    </p>
                    <p>当一个项目要针对不同的场景如用户设备类型（是手机还是PC还是平板）写出多个版本就能用上继承。</p>
                    <p>
                      把一些多版本公用的属性和方法放在一个父类里，然后其他版本继承父类就有了父类的属性和方法，然后在子类中写子类独有的属性和方法。
                    </p>
                    <p>这样一来代码做到了复用，提高了开发效率，结构也更清晰。</p>
                    <p><strong>原型链是一种机制，</strong>指的是 JavaScript 每个对象都有一个内置的 __
                      proto __
                      属性指向创建它的构造函数的 prototype（原型）属性。</p>
                    <p><strong>原型链的作用</strong>是为了实现对象的继承。</p>
                    <p>在JavaScript中，函数即对象。</p>
                    <p>普通对象：</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">var v1=&#123;&#125;;</span><br><span class="line">var v2=new Object();</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>函数对象：</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function f1()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f2=function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f3=new Function(&apos;str&apos;,&apos;console.log(str)&apos;);</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>凡是使用function关键字或者Function构造函数创建的对象都是函数对象。</p>
                    <p>同时，只有函数对象才拥有prototype（原型）属性。</p>
                    <p>自定义的构造函数，构造函数首字母都应该大写，非构造函数首字母应当小写，例如：</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>创建构造函数的新实例，需要使用new 操作符，<br>以这种方式调用构造函数实际上会经历以下4个步骤：</p>
                    <ol>
                      <li>创建一个新对象；</li>
                      <li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li>
                      <li>执行构造函数中的代码（为这个新对象添加属性）；</li>
                      <li>返回新对象。</li>
                    </ol>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">// 当作构造函数使用</span><br><span class="line">var person = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);</span><br><span class="line">person.sayName(); // &quot;Stone&quot;</span><br><span class="line"></span><br><span class="line">// 作为普通函数调用</span><br><span class="line">Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;); // 添加到 window</span><br><span class="line">window.sayName(); // &quot;Sophie&quot;</span><br><span class="line"></span><br><span class="line">// 在另一个对象的作用域中调用</span><br><span class="line">var o = new Object();</span><br><span class="line">Person.call(o, &quot;Tommy&quot;, 3, &quot;Baby&quot;);</span><br><span class="line">o.sayName(); // &quot;Tommy&quot;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1 和
                      person2 都有一个名为
                      sayName()
                      的方法，但那两个方法不是同一个 Function 的实例。</p>
                    <p>因为 JavaScript
                      中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = new Function(&quot;console.log(this.name)&quot;); // 与声明函数在逻辑上是等价的&#125;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>以这种方式创建函数，虽然创建 Function 新实例的机制仍然是相同的，但是不同实例上的同名函数是不相等的.
                    </p>
                    <p>因此，创建两个完成同样任务的 Function 实例的确没有必要。</p>
                    <p>况且有 this
                      对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = sayName;&#125;</span><br><span class="line"></span><br><span class="line">function sayName()&#123;</span><br><span class="line">    console.log(this.name);&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>在这个例子中，我们把 sayName() 函数的定义转移到了构造函数外部。</p>
                    <p>而在构造函数内部，我们将 sayName 属性设置成等于全局的 sayName 函数。</p>
                    <p>这样一来，由于 sayName 包含的是一个指向函数的指针，因此 person1 和 person2
                      对象就共享了在全局作用域中定义的同一个
                      sayName() 函数。</p>
                    <p>这样做确实解决了两个函数做同一件事的问题。</p>
                    <p>
                      可是新问题又来了，在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是，如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，这些问题可以通过使用<strong>原型</strong>来解决。
                    </p>
                    <p><strong>prototype 原型</strong></p>
                    <p>我们创建的每个函数都有一个 prototype（原型）属性。</p>
                    <ul>
                      <li>使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。</li>
                      <li>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型中，如下面的例子所示。
                        <figure class="highlight plain">
                          <table>
                            <tr>
                              <td class="gutter">
                                <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
                              </td>
                              <td class="code">
                                <pre><span class="line"></span><br><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &quot;Stone&quot;;</span><br><span class="line">Person.prototype.age = 28;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();   // &quot;Stone&quot;</span><br><span class="line"></span><br><span class="line">var person2 = new Person();</span><br><span class="line">person2.sayName();   // &quot;Stone&quot;</span><br><span class="line"></span><br><span class="line">console.log(person1.sayName == person2.sayName);  // true</span><br></pre>
                              </td>
                            </tr>
                          </table>
                        </figure>

                      </li>
                    </ul>
                    <p>在此，我们将 sayName() 方法和所有属性直接添加到了 Person 的 prototype
                      属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与前面的例子不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1
                      和 person2 访问的都是同一组属性和同一个 sayName() 函数。</p>
                    <p>在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向
                      prototype
                      属性所在函数的指针。</p>
                    <p>就拿前面的例子来说，Person.prototype.constructor 指向 Person。</p>
                    <p>而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。</p>
                    <p>虽然可以通过对象实例访问保存在原型中的值<strong>，但却不能通过对象实例重写原型中的值。</strong>
                    </p>
                    <p>
                      如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &quot;Stone&quot;;</span><br><span class="line">Person.prototype.age = 28;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">person1.name = &quot;Sophie&quot;;</span><br><span class="line">console.log(person1.name);     // &quot;Sophie&quot;，来自实例</span><br><span class="line">console.log(person2.name);     // &quot;Stone&quot;，来自原型</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>在这个例子中，person1 的 name 被一个新值给屏蔽了。</p>
                    <p>但无论访问 person1.name 还是访问 person2.name 都能够正常地返回值，即分别是
                      “Sophie”（来自对象实例）和
                      “Stone”（来自原型）。</p>
                    <p>当访问 person1.name 时，需要读取它的值，因此就会在这个实例上搜索一个名为 name 的属性。</p>
                    <p>这个属性确实存在，于是就返回它的值而不必再搜索原型了。当访问 person2. name
                      时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了 name 属性。</p>
                    <p>
                      当为对象实例添加一个属性时，这个属性就会屏蔽原型中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。
                    </p>
                    <p>即使将这个属性设置为 null ，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用 delete
                      操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &quot;Stone&quot;;</span><br><span class="line"></span><br><span class="line">Person.prototype.age = 28;</span><br><span class="line"></span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();var person2 = new Person();</span><br><span class="line"></span><br><span class="line">person1.name = &quot;Sophie&quot;;</span><br><span class="line">console.log(person1.name);     // &quot;Sophie&quot;，来自实例</span><br><span class="line">console.log(person2.name);     // &quot;Stone&quot;，来自原型</span><br><span class="line"></span><br><span class="line">delete person1.name;</span><br><span class="line">console.log(person1.name);     // &quot;Stone&quot;，来自原型</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>在这个修改后的例子中，我们使用 delete 操作符删除了 person1.name，之前它保存的
                      “Sophie”
                      值屏蔽了同名的原型属性。</p>
                    <p>把它删除以后，就恢复了对原型中 name 属性的连接。因此，接下来再调用 person1.name
                      时，返回的就是原型中 name
                      属性的值了。</p>
                    <p><strong>简化语法</strong><br>前面例子中每添加一个属性和方法就要敲一遍
                      Person.prototype。为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示。
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;&#125;;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>在上面的代码中，我们将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。</p>
                    <p>最终结果相同，但有一个例外：constructor 属性不再指向 Person 了。</p>
                    <p>前面曾经介绍过，每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得
                      constructor 属性。</p>
                    <p>而我们在这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor
                      属性也就变成了新对象的
                      constructor
                      属性（指向 Object 构造函数），不再指向 Person 函数。</p>
                    <p>此时，尽管 instanceof 操作符还能返回正确的结果，但通过 constructor
                      已经无法确定对象的类型了，如下所示。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">var friend = new Person();</span><br><span class="line"></span><br><span class="line">console.log(friend instanceof Object);        // true</span><br><span class="line">console.log(friend instanceof Person);        // true</span><br><span class="line">console.log(friend.constructor === Person);    // false</span><br><span class="line">console.log(friend.constructor === Object);    // true</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>在此，用 instanceof 操作符测试 Object 和 Person 仍然返回 true，但
                      constructor 属性则等于
                      Object
                      而不等于 Person 了。如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;&#125;;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>以上代码特意包含了一个 constructor 属性，并将它的值设置为 Person
                      ，从而确保了通过该属性能够访问到适当的值。</p>
                    <p>注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为
                      true。</p>
                    <p>默认情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的
                      JavaScript
                      引擎，可以试一试
                      Object.defineProperty()。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;&#125;; </span><br><span class="line"></span><br><span class="line">// 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器</span><br><span class="line">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;);</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p><strong>原型的动态性</strong></p>
                    <p>
                      由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。请看下面的例子。
                    </p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">var friend = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = function()&#123;</span><br><span class="line">    console.log(&quot;hi&quot;);&#125;;</span><br><span class="line"></span><br><span class="line">friend.sayHi();   // &quot;hi&quot;（没有问题！）</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>以上代码先创建了 Person 的一个实例，并将其保存在 friend 中。然后，下一条语句在
                      Person.prototype
                      中添加了一个方法
                      sayHi()。</p>
                    <p>即使 person 实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。</p>
                    <p>其原因可以归结为实例与原型之间的松散连接关系。当我们调用 friend.sayHi() 时，首先会在实例中搜索名为
                      sayHi
                      的属性，在没找到的情况下，会继续搜索原型。</p>
                    <p>因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi
                      属性并返回保存在那里的函数。</p>
                    <p>
                      尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。
                    </p>
                    <p>我们知道，调用构造函数时会为实例添加一个指向最初原型的 [[Prototype]]
                      指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</p>
                    <p>请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">var friend = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">friend.sayName();   // Uncaught TypeError: friend.sayName is not a function</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>在这个例子中，我们先创建了 Person 的一个实例，然后又重写了其原型对象。然后在调用
                      friend.sayName()
                      时发生了错误，因为
                      friend 指向的是重写前的原型对象，其中并不包含以该名字命名的属性。</p>
                    <p><strong>原生对象的原型</strong></p>
                    <p>原型的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。</p>
                    <p>所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。</p>
                    <p>例如，在 Array.prototype 中可以找到 sort() 方法，而在 String.prototype
                      中可以找到
                      substring()
                      方法，如下所示。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">console.log(typeof Array.prototype.sort);       // &quot;function&quot;</span><br><span class="line">console.log(typeof String.prototype.substring); //&quot;function&quot;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>
                      通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型
                      String 添加了一个名为 startsWith() 的方法。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">String.prototype.startsWith = function (text) &#123;</span><br><span class="line">    return this.indexOf(text) === 0;&#125;;</span><br><span class="line"></span><br><span class="line">var msg = &quot;Hello world!&quot;;</span><br><span class="line">console.log(msg.startsWith(&quot;Hello&quot;));   // true</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>这里新定义的 startsWith() 方法会在传入的文本位于一个字符串开始时返回 true。</p>
                    <p>既然方法被添加给了 String.prototype ，那么当前环境中的所有字符串就都可以调用它。</p>
                    <p>由于 msg 是字符串，而且后台会调用 String 基本包装函数创建这个字符串，因此通过 msg 就可以调用
                      startsWith()
                      方法。</p>
                    <p><strong>尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。</strong></p>
                    <p>
                      如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。
                    </p>
                    <p>而且，这样做也可能会意外地重写原生方法。</p>
                    <p><strong>原型对象的问题</strong></p>
                    <p>原型模式也不是没有缺点。</p>
                    <p>首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。</p>
                    <p>虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。</p>
                    <p>
                      原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。
                    </p>
                    <p>然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    friends : [&quot;ZhangSan&quot;, &quot;LiSi&quot;],</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();var person2 = new Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;WangWu&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person1.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="line">console.log(person2.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="line">console.log(person1.friends === person2.friends);  // true</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>在此，Person.prototype 对象有一个名为 friends 的属性，该属性包含一个字符串数组。</p>
                    <p>然后，创建了 Person 的两个实例。</p>
                    <p>接着，修改了 person1.friends 引用的数组，向数组中添加了一个字符串。</p>
                    <p>由于 friends 数组存在于 Person.prototype 而非 person1
                      中，所以刚刚提到的修改也会通过
                      person2.friends（与 person1.friends 指向同一个数组）反映出来。</p>
                    <p>假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果我没有话可说。</p>
                    <p>可是，实例一般都是要有属于自己的全部属性的。</p>
                    <p><strong>构造函数和原型结合</strong></p>
                    <p>所以，构造函数用于定义实例属性，而原型用于定义方法和共享的属性。</p>
                    <p>结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。</p>
                    <p>下面的代码重写了前面的例子。</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&quot;ZhangSan&quot;, &quot;LiSi&quot;];&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;WangWu&quot;);</span><br><span class="line">console.log(person1.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="line">console.log(person2.friends);    // &quot;ZhangSan,LiSi&quot;</span><br><span class="line">console.log(person1.friends === person2.friends);    // false</span><br><span class="line">console.log(person1.sayName === person2.sayName);    // true</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方法
                      sayName()
                      则是在原型中定义的。</p>
                    <p>而修改了 person1.friends（向其中添加一个新字符串），并不会影响到
                      person2.friends，因为它们分别引用了不同的数组。</p>
                    <p>这种构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。
                    </p>
                    <p>可以说，这是用来定义引用类型的一种默认模式。</p>
                    <p><strong>__ proto __</strong></p>
                    <p>为什么在构造函数的 prototype 中定义了属性和方法，它的实例中就能访问呢？</p>
                    <p>那是因为当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 __ proto __ ，指向构造函数的原型。
                    </p>
                    <p>Firefox、Safari 和 Chrome 的每个对象上都有这个属性
                      ，而在其他浏览器中是完全不可见的（为了确保浏览器兼容性问题，不要直接使用 __
                      proto__ 属性，此处只为解释原型链而演示）。让我们来看下面代码和图片：</p>
                    <p>![](<a href="https://github.com/starstarb/clouding/raw/master/js/原型链0" rel="external nofollow noopener noreferrer"
                                                                                                      target="_blank">https://github.com/starstarb/clouding/raw/master/js/原型链0</a>
                      (1).jpg)</p>
                    <p>图中展示了 Person 构造函数、Person 的原型属性以及 Person 现有的两个实例之间的关系。</p>
                    <p>在此，Person.prototype.constructor 指回了
                      Person。Person.prototype 中除了包含
                      constructor
                      属性之外，还包括后来添加的其他属性。</p>
                    <p>此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用 person1.sayName()。
                    </p>
                    <p>这是因为内部指针 __ proto__ 指向 Person.prototype，而在
                      Person.prototype 中能找到
                      sayName()
                      方法。</p>
                    <p>我们来证实一下，<strong>proto</strong> 是不是真的指向 Person.prototype
                      的？如下代码所示：</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__ === Person.prototype); // true</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>既然，<strong>proto</strong> 确实是指向 Person.prototype，那么使用 new
                      操作符创建对象的过程可以演变为，为实例对象的 __ proto__ 赋值的过程。如下代码所示：</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">// var person = new Person(); </span><br><span class="line">// 上一行代码等同于以下过程 ==&gt; </span><br><span class="line">var person = &#123;&#125;;</span><br><span class="line">person.__proto__ = Person.prototype;</span><br><span class="line">Person.call(person);</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>这个例子中，我先创建了一个空对象 person，然后把 person.__ proto__ 指向了 Person
                      的原型对象，便继承了
                      Person
                      原型对象中的所有属性和方法，最后又以 person 为作用域执行了 Person 函数，person 便就拥有了
                      Person
                      的所有属性和方法。</p>
                    <p>这个过程和 var person = new
                      Person();<br>完全一样。简单来说，当我们访问一个对象的属性时，如果这个属性不存在，那么就会去
                      __ proto__ 里找，这个 __ proto__ 又会有自己的 __
                      proto__，于是就这样一直找下去，直到找到为止。</p>
                    <p>在找不到的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p>
                    <p>原型链JavaScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。</p>
                    <p>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
                    <p>
                      简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如下图所示：（图源：segmentfault.com，作者：manxisuo）
                    </p>
                    <p><img src="https://github.com/starstarb/clouding/raw/master/js/%E5%8E%9F%E5%9E%8B%E9%93%BE.png"
                                                                                                      alt>
                    </p>
                    <p>那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢<br>？</p>
                    <p>显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。
                    </p>
                    <p>假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。</p>
                    <p>这就是所谓原型链的基本概念。</p>
                    <p>上面这段话比较绕口，代码更容易理解，让我们来看看实现原型链的基本模式。<br>如下代码所示：</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">function Father()&#123;</span><br><span class="line">    this.value = true;&#125;Father.prototype.getValue = function()&#123;</span><br><span class="line">    return this.value;&#125;;</span><br><span class="line"></span><br><span class="line">function Son()&#123;</span><br><span class="line">    this.value2 = false;&#125;</span><br><span class="line"></span><br><span class="line">// 继承了 FatherSon.prototype = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype.getValue2 = function ()&#123;</span><br><span class="line">    return this.value2;&#125;;</span><br><span class="line"></span><br><span class="line">var son = new Son();</span><br><span class="line">console.log(son.getValue());  // true</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>以上代码定义了两个类型：Father 和 Son。每个类型分别有一个属性和一个方法。</p>
                    <p>它们的主要区别是 Son 继承了 Father，而继承是通过创建 Father 的实例，并将该实例赋给
                      Son.prototype
                      实现的。</p>
                    <p>实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于 Father
                      的实例中的所有属性和方法，现在也存在于
                      Son.prototype
                      中了。</p>
                    <p>在确立了继承关系之后，我们给 Son.prototype 添加了一个方法，这样就在继承了 Father
                      的属性和方法的基础上又添加了一个新方法。</p>
                    <p>我们再用 __ proto__ 重写上面代码，更便于大家的理解：</p>
                    <figure class="highlight plain">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"></span><br><span class="line">function Father()&#123;</span><br><span class="line">    this.value = true;&#125;Father.prototype.getValue = function()&#123;</span><br><span class="line">    return this.value;&#125;;</span><br><span class="line"></span><br><span class="line">function Son()&#123;</span><br><span class="line">    this.value2 = false;&#125;</span><br><span class="line"></span><br><span class="line">// 继承了 Father</span><br><span class="line">// Son.prototype = new Father(); ==&gt;</span><br><span class="line"></span><br><span class="line">Son.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Son.prototype.__proto__ = Father.prototype;</span><br><span class="line"></span><br><span class="line">Father.call(Son.prototype);</span><br><span class="line"></span><br><span class="line">Son.prototype.getValue2 = function ()&#123;</span><br><span class="line">    return this.value2;&#125;;</span><br><span class="line"></span><br><span class="line">// var son = new Son(); ==&gt;</span><br><span class="line"></span><br><span class="line">var son = &#123;&#125;;</span><br><span class="line">son.__proto__ = Son.prototype;Son.call(son);</span><br><span class="line"></span><br><span class="line">console.log(son.getValue()); // true</span><br><span class="line">console.log(son.getValue === son.__proto__.__proto__.getValue); // true</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>

                    <p>从以上代码可以看出，实例 son 调用 getValue() 方法，实际是经过了 son.__
                      proto__.__
                      proto__.getValue
                      的过程的，其中 son.__ proto__ 等于 Son.prototype，</p>
                    <p>而 Son.prototype.__ proto__ 又等于 Father.prototype，所以 son.__
                      proto__.__
                      proto__.getValue 其实就是 Father.prototype.getValue。</p>
                    <p>事实上，前面例子中展示的原型链还少一环。</p>
                    <p>我们知道，所有引用类型默然都继承了 Obeject，而这个继承也是通过原型链实现的。</p>
                    <p>大家要记住，所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针 __
                      proto__，指向
                      Object.prototype。
                    </p>
                    <p>这也正是所有自定义类型都会继承 toString()、valueOf()
                      等默认方法的根本原因。下图展示了原型链实现继承的全部过程。（图源：segmentfault.com，作者：manxisuo）
                    </p>
                    <p><img src="https://github.com/starstarb/clouding/raw/master/js/%E5%8E%9F%E5%9E%8B%E9%93%BE2.png"
                                                                                                      alt>
                    </p>
                    <p>上图中，p 指 prototype 属性，[p] 即 __ proto__ 指对象的原型，[p]
                      形成的链（虚线部分）就是原型链。</p>
                    <p>从图中可以得出以下信息：</p>
                    <p>Object.prototype 是顶级对象，所有对象都继承自它。</p>
                    <p>Object.prototype.__ proto__ === null ，说明原型链到
                      Object.prototype 终止。</p>
                    <p>Function.__ proto__ 指向 Function.prototype。</p>
                    <p>参考自：<a href="https://www.jianshu.com/p/f69d8767c066" rel="external nofollow noopener noreferrer"
                                                                                                      target="_blank">简书</a>
                    </p>

                  </div>

                  <div id="reward-container">
                    <div></div>
                    <button id="reward-button" disable="enable"
                                                                                                    onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
                      打赏
                    </button>
                    <div id="qr" style="display: none;">

                      <div style="display: inline-block">
                        <img src="/img/weixin.jpg" alt="staring 微信支付">
                        <p>微信支付</p>
                      </div>

                      <div style="display: inline-block">
                        <img src="/img/zhifubao.jpg" alt="staring 支付宝">
                        <p>支付宝</p>
                      </div>

                    </div>
                  </div>

                  <div>
                    <ul class="post-copyright">
                      <li class="post-copyright-author">
                        <strong>本文作者： </strong>staring</li>
                      <li class="post-copyright-link">
                        <strong>本文链接：</strong>
                        <a href="http://javastar.club/archives/428be286.html"
                                                                                                        title="每天一道Js基础：Js原型和原型链">http://javastar.club/archives/428be286.html</a>
                      </li>
                      <li class="post-copyright-license">
                        <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN"
                                                                                                        rel="external nofollow noopener noreferrer"
                                                                                                        target="_blank"><i
                                                                                                          class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a>
                        许可协议。转载请注明出处！</li>
                    </ul>
                  </div>

                  <footer class="post-footer">

                    <div class="post-tags">

                      <a href="/tags/Javascript/" rel="tag"># Javascript</a>

                    </div>

                    <div class="post-nav">
                      <div class="post-nav-next post-nav-item">

                        <a href="/archives/48d54608.html" rel="next"
                                                                                                        title="每天一道LeetCode：7. Reverse Integer">
                          <i class="fa fa-chevron-left"></i> 每天一道LeetCode：7.
                          Reverse Integer
                        </a>

                      </div>

                      <span class="post-nav-divider"></span>

                      <div class="post-nav-prev post-nav-item">

                        <a href="/archives/6db07ab3.html" rel="prev"
                                                                                                        title="每天一道LeetCode：8. String to Integer (atoi)">
                          每天一道LeetCode：8. String to Integer (atoi) <i
                                                                                                          class="fa fa-chevron-right"></i>
                        </a>

                      </div>
                    </div>

                  </footer>

                </div>

              </article>

            </div>

          </div>

          <div class="comments" id="comments"></div>

        </div>

        <div class="sidebar-toggle">
          <div class="sidebar-toggle-line-wrap">
            <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
            <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
            <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
          </div>
        </div>

        <aside class="sidebar">
          <div class="sidebar-inner">

            <ul class="sidebar-nav motion-element">
              <li class="sidebar-nav-toc">
                文章目录
              </li>
              <li class="sidebar-nav-overview">
                站点概览
              </li>
            </ul>

            <!--noindex-->
            <div class="post-toc-wrap sidebar-panel">
              <div class="post-toc motion-element">
                <ol class="nav">
                  <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                    href="#Js中的继承实现的方式："><span
                                                                                                      class="nav-number">1.</span>
                      <span class="nav-text">Js中的继承实现的方式：
                      </span></a></li>
                  <li class="nav-item nav-level-6"><a class="nav-link"
                                                                                                    href="#new-操作符具体干了什么？"><span
                                                                                                      class="nav-number">2.</span>
                      <span class="nav-text">new
                        操作符具体干了什么？</span></a></li>
                </ol>
              </div>

            </div>
            <!--/noindex-->

            <div class="site-overview-wrap sidebar-panel">
              <div class="site-author motion-element" itemprop="author" itemscope
                                                                                              itemtype="http://schema.org/Person">
                <img class="site-author-image" itemprop="image" src="/img/head.jpg"
                                                                                                alt="staring">
                <p class="site-author-name" itemprop="name">staring</p>
                <div class="site-description" itemprop="description">个人技术博客
                </div>
              </div>
              <nav class="site-state motion-element">
                <div class="site-state-item site-state-posts">

                  <a href="/archives/">

                    <span class="site-state-item-count">130</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>

                <div class="site-state-item site-state-categories">

                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>

                </div>

                <div class="site-state-item site-state-tags">

                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>

                </div>

              </nav>
              <div class="feed-link motion-element">
                <a href="/atom.xml" rel="alternate">
                  <i class="fa fa-rss"></i>RSS
                </a>
              </div>
              <div class="cc-license motion-element" itemprop="license">

                <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity"
                                                                                                rel="external nofollow noopener noreferrer"
                                                                                                target="_blank"><img
                                                                                                  src="/images/cc-by-nc-sa.svg"
                                                                                                  alt="Creative Commons"></a>
              </div>

            </div>

          </div>
        </aside>
        <div id="sidebar-dimmer"></div>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
          <span class="with-love" id="animate">
            <i class="fa fa-heart"></i>
          </span>
          <span class="author" itemprop="copyrightHolder">staring</span>
          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
            <i class="fa fa-area-chart"></i>
          </span>
          <span title="站点总字数">106k</span>
          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
            <i class="fa fa-coffee"></i>
          </span>
          <span title="站点阅读时长">1:36</span>
        </div>

        <div class="busuanzi-count">
          <script async
                                                                                          src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
          </script>

          <script async
                                                                                          src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
          </script>

          <span class="site-uv">
            我的第 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
            位朋友，
          </span>

          <span class="site-pv">
            历经 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
            次回眸才与你相遇
          </span>

        </div>

      </div>
    </footer>
  </div>

  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="/lib/pjax/pjax.min.js?v=0.2.8"></script>
  <script src="/js/utils.js?v=7.4.0"></script>
  <script src="/js/motion.js?v=7.4.0"></script>
  <script src="/js/schemes/muse.js?v=7.4.0"></script>

  <script src="/js/next-boot.js?v=7.4.0"></script>
  <script>
    var pjax = new Pjax({
      selectors: [
        'head title',
        '#page-configurations',
        '.content-wrap',
        '.post-toc-wrap',
        '#pjax'
      ],
      switches: {
        '.post-toc-wrap': Pjax.switches.innerHTML
      },
      analytics: false,
      cacheBust: false,
      scrollTo: !CONFIG.bookmark.enable
    });
    window.addEventListener('pjax:success', () => {
      document.querySelectorAll(
        'script[pjax], script#page-configurations, #pjax script').forEach(
        element => {
          var id = element.id || '';
          var src = element.src || '';
          var code = element.text || element.textContent || element
            .innerHTML || '';
          var parent = element.parentNode;
          parent.removeChild(element);
          var script = document.createElement('script');
          if (id !== '') {
            script.id = element.id;
          }
          if (src !== '') {
            script.src = src;
            // Force synchronous loading of peripheral JS.
            script.async = false;
          }
          if (code !== '') {
            script.appendChild(document.createTextNode(code));
          }
          parent.appendChild(script);
        });
      NexT.boot.refresh();
      // Define Motion Sequence & Bootstrap Motion.
      if (CONFIG.motion.enable) {
        NexT.motion.integrator
          .init()
          .add(NexT.motion.middleWares.postList)
          .bootstrap();
      }
      NexT.utils.updateSidebarPosition();
    });

  </script>

  <script>
    (function() {
      window.addEventListener('DOMContentLoaded', () => {
        let script = document.createElement('script');
        script.src = '/lib/three/three.min.js';
        document.body.appendChild(script);
      });
      let styles = ['', 'true', ''];
      window.addEventListener('load', () => {
        styles.forEach(item => {
          if (item !== '') {
            let script = document.createElement('script');
            script.src = item;
            document.body.appendChild(script);
          }
        });
      });
    })();

  </script>

  <script src="/js/local-search.js?v=7.4.0"></script>

  <script pjax>
    if (document.querySelectorAll('div.pdf').length) {
      NexT.utils.getScript(
        '//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js',
        () => {
          document.querySelectorAll('div.pdf').forEach(element => {
            PDFObject.embed(element.getAttribute('target'), element, {
              pdfOpenParams: {
                navpanes: 0,
                toolbar: 0,
                statusbar: 0,
                pagemode: 'thumbs',
                view: 'FitH'
              },
              PDFJS_URL: '/lib/pdf/web/viewer.html',
              height: element.getAttribute('height') || '500px'
            });
          });
        }, window.PDFObject);
    }

  </script>

  <div id="pjax">

    <script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js">
    </script>
    <script
                                                                                    src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js">
    </script>
    <script>
      function timer() {
        var ages = moment.preciseDiff(moment(), moment(20190619, "YYYYMMDD"));
        //去除时分秒信息
        ages = ages.replace(/\s?\d{0,2}\s+hours?/, "");
        ages = ages.replace(/\s?\d{0,2}\s+minutes?/, "");
        ages = ages.replace(/\s?\d{0,2}\s+seconds?/, "");
        //将年月日转换为中文
        ages = ages.replace(/years?/, "年");
        ages = ages.replace(/months?/, "月");
        ages = ages.replace(/days?/, "天");
        ages = ages.replace(/\d+/g, '<span style="color:#1094e8">$&</span>');
        span.innerHTML = `我已在此等候你 ${ages}`;
      }
      var span = document.createElement("span");
      //插入到agesicon之后
      var agesicon = document.querySelector(".footer-ages-icon");
      document.querySelector(".copyright").insertBefore(span, agesicon
        .nextSibling);
      timer();

    </script>
    <script>
      NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
        var GUEST = ['nick', 'mail', 'link'];
        var guest = 'nick,mail,link';
        guest = guest.split(',').filter(item => {
          return GUEST.includes(item);
        });
        new Valine({
          el: '#comments',
          verify: false,
          notify: false,
          appId: 'SC04XqdJGidywEU8kpDnXmu6-MdYXbMMI',
          appKey: 'WWH572JLnQB3A4r74XKMGOok',
          placeholder: '来评论下呗',
          avatar: 'mm',
          meta: guest,
          pageSize: '10' || 10,
          visitor: false,
          lang: '' || 'zh-cn',
          path: location.pathname
        });
      }, window.Valine);

    </script>

  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":70,"height":120},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
