---
title: Java设计模式学习
tags: 设计模式
categories: 设计模式
abbrlink: be85c169
date: 2019-07-17 16:46:52
---
java设计模式汇总学习，转载于阿里云
<!--more-->
### Java设计模式(一)----单例模式
##### 一、特点： 
1、单例类只能有一个实例。 
2、单例类必须自己创建自己的唯一实例。 
3、单例类必须给所有其他对象提供这一实例。 
单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

##### 二．分类 
(一)、懒汉式单例
```
//懒汉式单例类.在第一次调用的时候实例化自己   
public class Singleton {
    // 构造方法私有化
    private Singleton() {
    }
    private static Singleton single = null;
    // 静态工厂方法
    public static Singleton getInstance() {
        if (single == null) {
            single = new Singleton();
        }
        return single;
    }
}
```
Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。 
（事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且掩耳盗铃地认为反射机制不存在。） 
但 是以上懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例，要实现线程安全，有以下三种方式，都 是对getInstance这个方法改造，保证了懒汉式单例的线程安全，如果你第一次接触单例模式，对线程安全不是很了解，可以先跳过下面这三小条，去看 饿汉式单例，等看完后面再回头考虑线程安全的问题：

1、在getInstance方法上加同步
```
public static synchronized  Singleton getInstance() {
        if (single == null) {
            single = new Singleton();
        }
        return single;
}
```
(二)、双重检查锁定 
  可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。
  那么什么是“双重检查加锁”机制呢？ 
  所谓“双重检查加锁”机制，指的是：
  并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样 一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。 
“双重检查加锁”机制的实现会使用关键字 __volatile__ ，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。 
注意：在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java5及以上的版本。
```
public class Singleton {
    private volatile static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance(){
        //先检查实例是否存在，如果不存在才进入下面的同步块
        if(instance == null){
            //同步块，线程安全的创建实例
            synchronized (Singleton.class) {
                //再次检查实例是否存在，如果不存在才真正的创建实例
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。 
(摘自网络)提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。

(三)、静态(类级)内部类
```
public class Singleton {

    private Singleton(){}
    /**
     *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例
     *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。
     */
    private static class SingletonHolder{
        /**
         * 静态初始化器，由JVM来保证线程安全
         */
        private static Singleton instance = new Singleton();
    }

    public static Singleton getInstance(){
        return SingletonHolder.instance;
    }
}
```
   这种比上面1、2都好一些，既实现了线程安全，又避免了同步带来的性能影响。　当getInstance方法第一次被调用的时候，它第一次读取 SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静 态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。 
   这个模式的优势在于，getInstance方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。

(四)、饿汉式单例
```
//饿汉式单例类.在类初始化时，已经自行实例化   
public class EagerSingleton {
        private static EagerSingleton instance = new EagerSingleton();
        /**
         * 构造方法私有化
         */
        private EagerSingleton(){}
        /**
         * 静态工厂方法
         */
        public static EagerSingleton getInstance(){
            return instance;
        }
}
```
饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。

(五)、单例和枚举 
用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。
```
public enum Singleton {
    /**
     * 定义一个枚举的元素，它就代表了Singleton的一个实例。
     */

    uniqueInstance;

    /**
     * 单例可以有自己的操作
     */
    public void singletonOperation(){
        //功能处理
    }
}
```
　相关测试代码：
```
public enum SingletonEnum {
    INSTANCE01, INSTANCE02;// 定义枚举的两个类型
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name){
        this.name = name;
    }
}


public class Test {

    public static void main(String[] args) {
            SingletonEnum instance01=SingletonEnum.INSTANCE01;
            instance01.setName("tanggao");
            System.out.println(instance01.getName());

            SingletonEnum instance02=SingletonEnum.INSTANCE01;
            System.out.println(instance02.getName());

            SingletonEnum instance03=SingletonEnum.INSTANCE02;
            instance03.setName("zsy");
            System.out.println(instance03.getName());

            SingletonEnum instance04=SingletonEnum.INSTANCE02;
            instance04.setName("zsy1");
            System.out.println(instance04.getName());
            System.out.println(instance03.hashCode()+"\t"+instance04.hashCode());
            System.out.println(instance03==instance04);

    }
}
结果: 
tanggao 
tanggao 
zsy 
zsy1 
3346521 3346521 
true
```
使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。

##### 三、饿汉式和懒汉式区别 
   从名字上来说，饿汉和懒汉， 
     饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了， 
     而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。 
  另外从以下两点再区分以下这两种方式：

1、线程安全： 
饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题， 
懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。

2、资源加载和性能： 
饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成.

而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。 

至于1、2、3这三种实现又有些区别， 
第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的， 
第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗 
第3种，保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，一般倾向于使用这一种。

3、什么是线程安全？ 
如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 
或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换 __不会导致该接口的执行结果存在二义性__,也就是说我们不用考虑同步的问题，那就是线程安全的.


### Java设计模式（二）----建造者模式

##### 一、概念　 
建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。

1、产品的内部表象 
一个产品常有不同的组成成分作为产品的零件，这些零件有可能是对象，也有可能不是对象，它们通常又叫做产品的内部表象（internal representation）。不同的产品可以有不同的内部表象，也就是不同的零件。使用建造模式可以使客户端不需要知道所生成的产品有哪些零件，每个 产品的对应零件彼此有何不同，是怎么建造出来的，以及怎么组成产品。 

2、对象性质的建造

　　有些情况下，一个对象的一些性质必须按照某个顺序赋值才有意义。在某个性质没有赋值之前，另一个性质则无法赋值。这些情况使得性质本身的建造涉 及到复杂的商业逻辑。这时候，此对象相当于一个有待建造的产品，而对象的这些性质相当于产品的零件，建造产品的过程是建造零件的过程。由于建造零件的过程 很复杂，因此，这些零件的建造过程往往被“外部化”到另一个称做建造者的对象里，建造者对象返还给客户端的是一个全部零件都建造完毕的产品对象。 

顾名思义，builder的意思是建造者或者建筑工人。例如：楼房是千差万别的，楼房的外形，层数，内部房间的数量，房间的装饰都不一样。但是对于 建造者来 说，抽象出来的建筑流程是确定的。因为建筑一座楼房，都可以归纳为几个步骤(也就是生产过程：对象性质的建造)：1打桩(内部具体细节构建:内部表象, 下2-4同为内部具体细节构建)、2建地基、3搭框架、4内部建设。同理，建造者设计模式也是基于这样 的概念而生的，这个设计模式用来解决什么样的情况呢：即流程不变，但每个流程实现的具体细节是会变化的。这样的情况，可以考虑使用建造者。就像盖房子，4 个流程都必须有，但每个流程各自的实现细节，各个房子各有不同。建造者模式的好处就是保证了流程不会变化，即流程不会增加也不会遗漏，也不会产生流程次序 的错误。这是非常重要的，看新闻，一些楼歪歪的事件，很多都是建设楼盘的时候，流程出现了问题导致的。（看来这些人并不知道建造者模式啊）。而建造者模 式，保证了流程的确定性，而流程内部的实现细节，是可继承扩展的。从根源上解决了流程不规范的问题。

##### 二、建造模式的结构 
    在这个示意性的系统里，最终产品Product只有两个零件，即part1和part2。相应的建造方法也有两个：buildPart1()和buildPart2()、同时可以看出本模式涉及到四个角色，它们分别是：

　　抽象建造者（Builder）角色：给 出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法：一种是建造方法(buildPart1和 buildPart2)，另一种是返还结构方法(retrieveResult)。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少 零件，就有多少相应的建造方法。 

　　导演者（Director）角色：担任这个角色的类调用具体建造者角色以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。 

产品（Product）角色：产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。 

　　一般来说，每有一个产品类，就有一个相应的具体建造者类。这些产品应当有一样数目的零件，而每有一个零件就相应地在所有的建造者角色里有一个建造方法。 

源代码：
```
/**
 * 产品角色
 * 　产品类Product
 * @author Administrator
 *
 */
public class Product {
    //定义一些产品的部件
    private String part1;
    private String part2;

    public String getPart1() {
        return part1;
    }
    public void setPart1(String part1) {
        this.part1 = part1;
    }
    public String getPart2() {
        return part2;
    }
    public void setPart2(String part2) {
        this.part2 = part2;
    }
}
/**
 * 抽象建造者角色
 *      抽象建造者类Builder
 * @author Administrator
 *
 */
public interface Builder {
    //产品零件一建造方法
    public void buildPart1();
    //产品零件二建造方法
    public void buildPart2();
    //返回产品的方法
    public Product retrieveResult();

}
/**
 * 具体建造者角色
 *      具体建造者类ConcreteBuilder
 * @author Administrator
 *
 */
public class ConcreteBuilder implements Builder {
    private Product product = new Product();
    @Override
    public void buildPart1() {
        //构建产品的第一个零件
        product.setPart1("编号：007");
    }

    @Override
    public void buildPart2() {
        //构建产品的第二个零件
        product.setPart2("名称：暗黑者");
    }

    @Override
    public Product retrieveResult() {
        //返回产品
        return product;
    }

}
/**
 * 导演者角色
 *      导演者类Director
 * @author Administrator
 *
 */
public class Director {
    /**
     * 持有当前需要使用的建造器对象
     */
    private Builder builder;
    /**
     * 构造方法，传入建造器对象
     * @param builder 建造器对象
     */
    public Director(Builder builder){
        this.builder = builder;
    }
    /**
     * 产品构造方法，负责调用各个零件建造方法,比如产品的生产顺序等
     */
    public void construct(){
        builder.buildPart1();
        builder.buildPart2();
    }
}
//客户端
public class Client {

    public static void main(String[] args) {
        Builder builder = new ConcreteBuilder();
        Director director = new Director(builder);
        director.construct();
        Product product = builder.retrieveResult();
        System.out.println(product.getPart1());
        System.out.println(product.getPart2());
    }

}
```

客户端负责创建导演者和具体建造者对象。然后，客户端把具体建造者对象交给导演者，导演者操作具体建造者，开始创建产品。当产品完成后，建造者把产品返还给客户端。 
把创建具体建造者对象的任务交给客户端而不是导演者对象，是为了将导演者对象与具体建造者对象的耦合变成动态的，从而使导演者对象可以操纵数个具体建造者对象中的任何一个。

##### 三、建造模式分成两个很重要的部分 
1. 一个部分是Builder接口，这里是定义了如何构建各个部件，也就是知道每个部件功能如何实现 
2. 另外一个部分是Director，Director是知道如何组合来构建产品，也就是说Director负责整体的构建算法，而且通常是分步骤地来执行,也就是说如何组装这些部件。

不管如何变化，建造模式都存在这么两个部分，一个部分是部件构造。另一个部分是整体构建的算法。 
再直白点说，建造模式的重心在于分离构建算法和具体的构造实现，从而使得构建算法可以重用。具体的构造实现可以很方便地扩展和切换，从而可以灵活地组合来构造出不同的产品对象。

##### 四、使用场景

　　假设有一个电子杂志系统，定期地向用户的电子邮件信箱发送电子杂志。用户可以通过网页订阅电子杂志，也可以通过网页结束订阅。当客户开始订阅 时，系统发送一个电子邮件表示欢迎，当客户结束订阅时，系统发送一个电子邮件表示欢送。本例子就是这个系统负责发送“欢迎”和“欢送”邮件的模块。 
在本例中，产品类就是发给某个客户的“欢迎”和“欢送”邮件，如下图所示。 
这里写图片描述

虽然在这个例子里面各个产品类均有一个共同的接口，但这仅仅是本例 子特有的，并不代表建造模式的特点。建造模式可以应用到具有完全不同接口的产品类上。大多数情况下是不知道最终构建出来的产品是什么样的，所以在标准的建 造模式里面，一般是不需要对产品定义抽象接口的，因为最终构造的产品千差万别，给这些产品定义公共接口几乎是没有意义的。 
下图所示就是这个系统的类图。 
这里写图片描述

这个系统含有客户端（Client）、导演者（Director）、抽象建造者（Builder）、具体建造者（WelcomeBuilder和GoodbyeBuilder）、产品（WelcomeMessage和GoodbyeMessage）等角色。 
源代码 
抽象类AutoMessage源代码，send()操作仅仅是示意性的，并没有给出任何发送电子邮件的代码。
```
public abstract class AutoMessage {
    //收件人地址
 private String to;
    //发件人地址
 private String from;
    //标题
 private String subject;
    //内容
 private String body;
    //发送日期
 private Date sendDate;
    public void send(){
        System.out.println("收件人地址：" + to);
        System.out.println("发件人地址：" + from);
        System.out.println("标题：" + subject);
        System.out.println("内容：" + body);
        System.out.println("发送日期：" + sendDate);
    }
    public String getTo() {
        return to;
    }
    public void setTo(String to) {
        this.to = to;
    }
    public String getFrom() {
        return from;
    }
    public void setFrom(String from) {
        this.from = from;
    }
    public String getSubject() {
        return subject;
    }
    public void setSubject(String subject) {
        this.subject = subject;
    }
    public String getBody() {
        return body;
    }
    public void setBody(String body) {
        this.body = body;
    }
    public Date getSendDate() {
        return sendDate;
    }
    public void setSendDate(Date sendDate) {
        this.sendDate = sendDate;
    }

}



具体产品类WelcomeMessage

public class WelcomeMessage extends AutoMessage {
    /**
     * 构造子
     */
    public WelcomeMessage(){
        System.out.println("发送欢迎信息");
    }
}
具体产品类GoodbyeMessage

public class GoodbyeMessage extends AutoMessage{
    /**
     * 构造子
     */
    public GoodbyeMessage(){
        System.out.println("发送欢送信息");
    }
}
抽象建造者类

public abstract class Builder {
    protected AutoMessage msg;
    //标题零件的建造方法
 public abstract void buildSubject();
    //内容零件的建造方法
 public abstract void buildBody();
    //收件人零件的建造方法
 public void buildTo(String to){
        msg.setTo(to);
    }
    //发件人零件的建造方法
 public void buildFrom(String from){
        msg.setFrom(from);
    }
    //发送时间零件的建造方法
 public void buildSendDate(){
        msg.setSendDate(new Date());
    }
    /**
     * 邮件产品完成后，用此方法发送邮件
     * 此方法相当于产品返还方法
     */
    public void sendMessage(){
        msg.send();
    }
}
具体建造者WelcomeBuilder

public class WelcomeBuilder extends Builder {
    public WelcomeBuilder(){
        msg = new WelcomeMessage();
    }
    @Override
    public void buildBody() {
        // TODO Auto-generated method stub
 　　　　msg.setBody("欢迎内容");
    }

    @Override
    public void buildSubject() {
        // TODO Auto-generated method stub
 　　　　msg.setSubject("欢迎标题");
    }

}
具体建造者GoodbyeBuilder

public class GoodbyeBuilder extends Builder {

    public GoodbyeBuilder(){
        msg = new GoodbyeMessage();
    }
    @Override
    public void buildBody() {
        // TODO Auto-generated method stub
 　　　　msg.setBody("欢送内容");
    }

    @Override
    public void buildSubject() {
        // TODO Auto-generated method stub
 　　　　msg.setSubject("欢送标题");
    }

}
　　导演者Director，这个类提供一个construct()方法，此方法调用建造者的建造方法，包括buildTo()、 buildFrom()、buildSubject()、buildBody()、buildSendDate()等，从而一部分一部分地建造出产品对 象，既AutoMessage对象。

public class Director {
    Builder builder;
    /**
     * 构造子
     */
    public Director(Builder builder){
        this.builder = builder;
    }
    /**
     * 产品构造方法，负责调用各零件的建造方法
     */
    public void construct(String toAddress , String fromAddress){
        this.builder.buildTo(toAddress);
        this.builder.buildFrom(fromAddress);
        this.builder.buildSubject();
        this.builder.buildBody();
        this.builder.buildSendDate();
        this.builder.sendMessage();
    }
}
客户端Client

public class Client {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
 　　　　Builder builder = new WelcomeBuilder();
        Director director = new Director(builder);
        director.construct("toAddress@45126184@qq.com", "fromAddress@110.com");

    }

}
```
##### 五、使用建造模式构建复杂对象

　　考虑这样一个实际应用，要创建一个保险合同的对象，里面很多属性的值都有约束，要求创建出来的对象是满足这些约束规则的。约束规则比如：保险合 同通常情况下可以和个人签订，也可以和某个公司签订，但是一份保险合同不能同时与个人和公司签订。这个对象里有很多类似这样的约束，采用建造模式来构建复 杂的对象，通常会对建造模式进行一定的简化，因为目标明确，就是创建某个复杂对象，因此做适当简化会使程序更简洁。大致简化如下： 
●　　由于是用Builder模式来创建某个对象，因此就没有必要再定义一个Builder接口，直接提供一个具体的建造者类就可以了。 
●　　对于创建一个复杂的对象，可能会有很多种不同的选择和步骤，干脆去掉“导演者”，把导演者的功能和Client的功能合并起来，也就是说,Client这个时候就相当于导演者，它来指导构建器类去构建需要的复杂对象。 
保险合同类
```
/**
 * 保险合同对象
 */
public class InsuranceContract {
    // 保险合同编号
    private String contractId;
    /**
     * 被保险人员的名称，同一份保险合同，要么跟人员签订，要么跟公司签订 也就是说，“被保险人员”和“被保险公司”这两个属性，不可能同时有值
     */
    private String personName;
    // 被保险公司的名称
    private String companyName;
    // 保险开始生效日期
    private long beginDate;
    // 保险失效日期，一定会大于保险开始生效日期
    private long endDate;
    // 其他数据
    private String otherData;

    // 私有构造方法
    private InsuranceContract(ConcreteBuilder builder) {
        this.contractId = builder.contractId;
        this.personName = builder.personName;
        this.companyName = builder.companyName;
        this.beginDate = builder.beginDate;
        this.endDate = builder.endDate;
        this.otherData = builder.otherData;
    }

    /**
     * 保险合同的一些操作
     */
    public void someOperation() {
        System.out.println("当前正在操作的保险合同编号为【" + this.contractId + "】");
        if(personName!=null){
            System.out.println("被保险人名称:"+personName);
        }
        if(companyName!=null){
            System.out.println("被保险公司名称:"+companyName);
        }
    }
    //具体构建者角色
    public static class ConcreteBuilder {
        private String contractId;
        private String personName;
        private String companyName;
        private long beginDate;
        private long endDate;
        private String otherData;

        /**
         * 构造方法，传入必须要有的参数
         * 
         * @param contractId
         *            保险合同编号
         * @param beginDate
         *            保险合同开始生效日期
         * @param endDate
         *            保险合同失效日期
         */
        public ConcreteBuilder(String contractId, long beginDate, long endDate) {
            this.contractId = contractId;
            this.beginDate = beginDate;
            this.endDate = endDate;
        }

        // 建造方法 建造被保险人员的名称
        public ConcreteBuilder setPersonName(String personName) {
            this.personName = personName;
            return this;
        }

        // 建造方法  建造被保险公司的名称
        public ConcreteBuilder setCompanyName(String companyName) {
            this.companyName = companyName;
            return this;
        }

        // 建造方法  建造其他数据
        public ConcreteBuilder setOtherData(String otherData) {
            this.otherData = otherData;
            return this;
        }

        /**
         * 构建真正的对象并返回
         * 
         * @return 构建的保险合同对象
         */
        public InsuranceContract build() {
            if (contractId == null || contractId.trim().length() == 0) {
                throw new IllegalArgumentException("合同编号不能为空");
            }
            boolean signPerson = (personName != null && personName.trim().length() > 0);
            boolean signCompany = (companyName != null && companyName.trim().length() > 0);
            if (signPerson && signCompany) {
                throw new IllegalArgumentException("一份保险合同不能同时与个人和公司签订");
            }
            if (signPerson == false && signCompany == false) {
                throw new IllegalArgumentException("一份保险合同不能没有签订对象");
            }
            if (beginDate <= 0) {
                throw new IllegalArgumentException("一份保险合同必须有开始生效的日期");
            }
            if (endDate <= 0) {
                throw new IllegalArgumentException("一份保险合同必须有失效的日期");
            }
            if (endDate < beginDate) {
                throw new IllegalArgumentException("一份保险合同的失效日期必须大于生效日期");
            }
            return new InsuranceContract(this);
        }
    }
}
客户端

public class Client {

    public static void main(String[] args) {
        // 创建构建器对象
        InsuranceContract.ConcreteBuilder builder = new InsuranceContract.ConcreteBuilder("9527", 123L, 456L);
        // 设置需要的数据，然后返回保险合同对象
        InsuranceContract contract = builder.setPersonName("小明").setOtherData("test").build();
        // 操作保险合同对象的方法
        contract.someOperation();
    }
}
```
　　在本例中将具体建造者合并到了产品对象中，并将产品对象的构造函数私有化，防止客户端不使用构建器来构建产品对象，而是直接去使用new来构建产品对象所导致的问题。另外，这个构建器的功能就是为了创建被构建的对象，完全可以不用单独一个类。 

在什么情况下使用建造模式(看一看就行) 
创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化.

