---
title: 字典树
tags: 字典树
categories: 算法刷题
abbrlink: eea60a6a
date: 2019-07-29 14:12:23
---
字典树相关习题
<!--more-->
### 前缀树的结构

Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树或键树，是一种多叉树结构.
用于处理大量字符串，优点是：利用字符串的公共前缀，在存储时节约存储空间，并在查询时最大限度的减少无谓的字符串比较。
### 字典树的作用
1. 以最节约空间的方式存储大量字符串.且存好后是有序的

因为是有序的,故而字典树不仅可用于大量字符串的存储,还可用于大量字符串的排序.
2. 快速查询某字符串s在字典树中是否已存在,甚至出现过几次

因为当字典树预处理好之后,查询字符串s在当前的出现情况的效率为strlen(s),异常高效,故而常用于搜索引擎等.

版权声明：本文为博主原创文章，转载请附上博文链接！
### Trie树的基本性质：
1. 根节点不包含字符，除根节点以外的每一个子节点都包含一个字符。
2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符互不相同。
4. 从第一字符开始有连续重复的字符只占用一个节点.

### 前缀树的应用
1. 前缀匹配
2. 字符串检索
3. 词频统计
4. 字符串排序等。

__前缀匹配__
定义前缀树结构：
```
class Tries{
    Boolean isTrie ;
    HashMap<Character, Tries> children=new HashMap<Character, Tries>(); 
}
```
上面的 isTrie 用来标记单词是否遍历完。children表示该节点的子节点。
__建立前缀树__
```
    public static boolean insertNode(String str,Tries head)
    {
        if(str==null||str.length()==0)
            return false;
            //如果插入的单词为null 或者单词长度为0直接返回false，false代表该单词不是前缀树中某个单词的前缀，
            //或者前缀树中某个单词是该单词的前缀。
        char chs[]=str.toCharArray();
        int i=0;
        Tries cur=head;
        //将字符串的每个字符插入到前缀树中
        while(i<chs.length)
        {           
            if(!cur.children.containsKey(chs[i]))
            {

                cur.children.put(chs[i], new Tries());
                //如果当前节点中的子树节点中不包含当前字符，新建一个子节点。
            }
            //否则复用该节点
            cur=cur.children.get(chs[i]);
            if(cur.count==true)
            {
                System.out.println(" trie tree");
                return true;
                //判断前缀树中是否有字符串为当前字符串的前缀。
            }
            i++;
        }
        cur.count=true;
        if(cur.children.size()>0)
        {
            System.out.println(" trie tree");
            return true;
            //判断当前字符串是否是前缀树中某个字符的前缀。
        }
        return false;
    }
```
前缀树的建立过程就是插入字符串的过程，同时在插入节点的时候可以判断插入的字符串是否是前缀树里面某个单词的前缀，或者前缀树中的某个单词是否是该单词的前缀。

1. 先将字符串转换为字符数组，然后对每个字符进行处理，如果当前节点的子节点中包含有要处理的字符字节复用。否则新建一个子节点。
2. 判断是否是前缀单词的时候，有两个步骤，首先要看该字符串是否是其他字符串的前缀，还有看其他字符串是否是当前字符串的前缀。

判断前缀单词的完整代码：
```
public class isTrie {

    public static void main(String[] args) {
        Tries tries=new Tries();
        String strs[]={"abc","abd","b","abdc"};

        for(int i=0;i<strs.length;i++)  
            insertNode(strs[i], tries);                 
    }
public static boolean insertNode(String str,Tries head)
    {
        if(str==null||str.length()==0)
            return false;
        char chs[]=str.toCharArray();
        int i=0;
        Tries cur=head;
        while(i<chs.length)
        {           
            if(!cur.children.containsKey(chs[i]))
            {

                cur.children.put(chs[i], new Tries());
            }
            cur=cur.children.get(chs[i]);
            if(cur.count==true)
            {
                System.out.println(" trie tree");
                return true;
            }
            i++;
        }
        cur.count=true;
        if(cur.children.size()>0)
        {
            System.out.println(" trie tree");
            return true;
        }
        return false;
    }
}
class Tries{
    boolean isTrie;
    HashMap<Character, Tries> children=new HashMap<Character, Tries>(); 
}
```
###  模板代码：
1. 以数组模拟动态分配的只带增查的字典树模板
```
//一个只带添加字符串与查找字符串的字典树（为了效率以数组实现） 
 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int charmapping[256]; //字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] 
void init_charmapping(){
    for(int i='a';i<='z';i++){ //我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. 
        charmapping[i]=i-'a';
    } 
} 
 
const int maxn=26; //这里假设字符串中只出现26个小写字母 
const int maxm=100000;
struct treenode{
    bool end; //标志此节点是否是某字符串的结尾 
    treenode* next[maxn]; 
}head;
 
treenode memory[maxm]; //字典树所用到的数组空间
int mallocp=0;  //模拟内存分配
 
void init(){
    head.end=1;
    for(int i=0;i<maxn;i++) head.next[i]=NULL;
}
 
treenode* createnew(){
    treenode* newnode;
    newnode=&memory[mallocp++];
    newnode->end=0;
    for(int i=0;i<maxn;i++) newnode->next[i]=NULL;
    return newnode;
}
 
void update(char* s){
    int k=0,temp;
    treenode* t=&head;
    while(s[k]){
        temp=charmapping[s[k]];
        if(!t->next[temp]) t->next[temp]=createnew(); 
        t=t->next[temp];
        k++;
    }
    t->end=1;
}
 
bool search(char* s){
    int k=0,temp;
    treenode* t=&head;
    while(s[k]){
        temp=charmapping[s[k]];
        if(!t->next[temp]) return false;
        t=t->next[temp];
        k++;
    }
    if(t->end) return true;
    return false; 
}
 
int main(){
    init();
    char x[1000];
    char t;
    while(1){
        fflush(stdin);
        scanf("%c",&t);
        if(t=='q'){
            scanf("%s",&x);
            if(search(x)) printf("匹配成功！\n");
            else printf("匹配失败！\n"); 
        }
        else if(t=='u'){
            scanf("%s",&x);
            update(x);
            printf("更新完毕！\n");
        }
        else if(t=='e'){
            printf("退出ing....\n"); 
            break;
        }
        else printf("无效命令！,请重新输入！\n"); 
    } 
    return 0;
}
```
2. 以动态分配为实现的带增删改查的字典树模板
```
//一个以链表实现带删除功能允许重复字符串的字典树
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
 
int charmapping[256]; //字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] 
void init_charmapping(){
    for(int i='a';i<='z';i++){ //我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. 
        charmapping[i]=i-'a';
    } 
} 
 
const int maxn=26; //这里假设字符串中只出现26个小写字母 
const int maxm=100000;
struct treenode{
    int count; //标志此节点所表示字符串在所有字符串中以前缀形式出现的总次数 
    treenode* next[maxn]; 
}head;
 
void init_trie(){
    head.count=1; //初始化为1包括空串并且避免树头被删 
    for(int i=0;i<maxn;i++) head.next[i]=NULL;
}
 
treenode* createnew(){ //申请一个新结点并初始化它
    treenode* newnode;
    newnode=(treenode*)malloc(sizeof(treenode));
    newnode->count=0;
    for(int i=0;i<maxn;i++) newnode->next[i]=NULL;
    return newnode;
}
 
void update(char* s,int num){ //向字典树添加num个字符串s 
    int k=0,temp;
    treenode* t=&head;
    while(s[k]){
        t->count+=num;
        temp=charmapping[s[k]];
        if(!t->next[temp]) t->next[temp]=createnew(); 
        t=t->next[temp];
        k++;
    }
    t->count+=num;
}
 
bool search(char* s,int num){  //查找字典树中是否已经存在num个字符串s
    int k=0,temp;
    treenode* t=&head;
    while(s[k]){
        temp=charmapping[s[k]];
        if(!t->next[temp]||t->next[temp]->count<num) return false; //根本不存在字符串s或者存在的数目小于num直接失败 
        t=t->next[temp];
        k++;
    }
    int snum=t->count;
    for(int i=0;i<maxn;i++) if(t->next[i]) snum-=t->next[i]->count; //这里是核心!!!结点t代表的字符串出现的次数就是总次数减去所有子节点次数和 
    if(snum>=num) return true; //如果字符串s的数目snum大于等于num 
    return false;
}
 
void erase(char* s,int num){  //删除字典树中的num个字符串s并释放无用结点,删除前一定要先search是否存在 
    int k=0,temp;
    treenode* t=&head;
    treenode* t1; //t1后面的结点都是删除后需要被释放的 
    head.count-=num;
    while(s[k]){
        temp=charmapping[s[k]];
        t->next[temp]->count-=num;
        if(t->next[temp]->count==0){
            t1=t->next[temp];
            t->next[temp]=NULL;
            k++;
            break;
        }
        t=t->next[temp];
        k++;
    }
    while(s[k]){ //释放无用结点 
        temp=charmapping[s[k]];
        t=t1->next[temp];
        free(t1);
        t1=t;
        k++;
    }
    free(t1);
}
 
char temp[1000];
void printall(treenode* tnode,int pos){ //递归打印字典树咯,打出了就是字典序升序的 
    int count=tnode->count;
    for(int i=0;i<maxn;i++) if(tnode->next[i]) count-=tnode->next[i]->count;
    for(int i=0;i<count;i++) printf("\"%s\"\n",temp);
    for(int i='a';i<='z';i++){
        if(tnode->next[charmapping[i]]){
            temp[pos]=i;
            temp[++pos]='\0';
            printall(tnode->next[charmapping[i]],pos);
            temp[--pos]='\0';
        }
    }
}
 
int main(){
    init_charmapping(); //初始化映射 
    init_trie();        //初始化字典树 
    char x[1000];
    char order; //命令 
    int num;    //数目 
    printf("q：查询\nu：插入\nd：删除\np：打印字典树\ne：退出\n");
    while(1){
        printf("请输入命令：");
        fflush(stdin);
        scanf("%c",&order);
        if(order=='q'){
            printf("请输入要查找的字符串与数目：");
            scanf("%s%d",&x,&num);
            if(search(x,num)) printf("匹配成功。\n\n");
            else printf("匹配失败，不存在%d个\"%s\"\n\n",num,x); 
        }
        else if(order=='u'){
            printf("请输入要插入的字符串与数目：");
            scanf("%s%d",&x,&num);
            update(x,num);
            printf("%d个\"%s\"已加入字典树。\n\n",num,x);
        }
        else if(order=='d'){
            printf("请输入要删除的字符串与数目：");
            scanf("%s%d",&x,&num);
            if(!search(x,num)){
                printf("树中无%d个字符串\"%s\"请重新键入命令！\n\n",num,x);
                continue;
            }
            erase(x,num);
            printf("%d个\"%s\"已从字典树中删除。\n\n",num,x);
        }
        else if(order=='p'){
            printf("当前字典树内有如下字符串：\n");
            temp[0]='\0';
            printall(&head,0);
        }
        else if(order=='e'){
            printf("退出ing....\n"); 
            break;
        }
        else printf("无效命令,请重新输入！\n命令q：查询是否存在字符串\n命令u：往字典树加入字符串\n命令d：删除某个字符串\n命令p：按字典序升序输出字典树\n命令e：退出程序\n\n"); 
    } 
    return 0;
}
```



### 添加与搜索单词 - 数据结构设计
设计一个支持以下两种操作的数据结构：

void addWord(word)
bool search(word)

search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。

示例:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true

说明:

你可以假设所有单词都是由小写字母 a-z 组成的。
链接：https://leetcode-cn.com/problems/add-and-search-word-data-structure-design

Trie 树又称“前缀树”，它的典型应用对象是字符串，可以用于保存、统计。其特点是：用边表示字符，当走到叶子结点的时候，沿途所经过的边组成了一个字符串。其优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。


关于这道问题的难点是通配符 "." 的处理，其实也不难：在遇到 "." 的时候，使用递归方法，将该结点的每一个分支都看过去，只要有一个分支返回 true 就可以了，全部分支都走过去，都没有返回 true 的才返回 false。
这里要注意的是，一个结点指向孩子结点的“指针”（一般情况下多于 1 个），可以使用数组表示，也可以使用哈希表表示，如果题目中限制了测试用例“所有的输入都是由小写字母 a-z 构成的”，则可以使用数组表示。

1、一个结点指向孩子结点的“指针”们用数组表示；

```
public class WordDictionary {

    class Node {
        private Node[] next;
        private boolean isWord;

        public Node() {
            next = new Node[26];
            isWord = false;
        }
    }

    private Node root;

    /**
     * Initialize your data structure here.
     */
    public WordDictionary() {
        root = new Node();
    }

    /**
     * Adds a word into the data structure.
     */
    public void addWord(String word) {
        int len = word.length();
        Node curNode = root;
        for (int i = 0; i < len; i++) {
            char curChar = word.charAt(i);
            Node next = curNode.next[curChar - 'a'];
            if (next == null) {
                curNode.next[curChar - 'a'] = new Node();
            }
            curNode = curNode.next[curChar - 'a'];
        }
        if (!curNode.isWord) {
            curNode.isWord = true;
        }
    }

    /**
     * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
     */
    public boolean search(String word) {
        return match(word, root, 0);
    }

    private boolean match(String word, Node node, int start) {
        if (start == word.length()) {
            return node.isWord;
        }
        char alpha = word.charAt(start);
        if (alpha == '.') {
            for (int i = 0; i < 26; i++) {
                if (node.next[i] != null && match(word, node.next[i], start + 1)) {
                    return true;
                }
            }
            return false;
        } else {
            if (node.next[alpha - 'a'] == null) {
                return false;

            }
            return match(word, node.next[alpha - 'a'], start + 1);
        }
    }
}
```
2、一个结点指向孩子结点的“指针”们用哈希表表示。
```
import java.util.HashMap;
import java.util.Set;

public class WordDictionary {

    private Node root;

    private class Node {
        private boolean isWord;
        private HashMap<Character, Node> next;

        public Node() {
            this.next = new HashMap<>();
        }
    }

    /**
     * Initialize your data structure here.
     */
    public WordDictionary() {
        root = new Node();
    }

    /**
     * Adds a word into the data structure.
     */
    public void addWord(String word) {
        Node curNode = root;
        for (int i = 0; i < word.length(); i++) {
            Character c = word.charAt(i);
            if (!curNode.next.containsKey(c)) {
                curNode.next.put(c, new Node());
            }
            curNode = curNode.next.get(c);
        }
        if (!curNode.isWord) {
            curNode.isWord = true;
        }
    }

    /**
     * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
     */
    public boolean search(String word) {
        return search(root, word, 0);
    }

    private boolean search(Node node, String word, int depth) {
        if (depth == word.length()) {
            // 只要能搜索到最后，就表示文本与模式匹配
            // 这一步很容易被忽视
            return node.isWord;
        }
        Character c = word.charAt(depth);
        if (c == '.') {
            Set<Character> keys = node.next.keySet();
            for (Character key : keys) {
                Node nextNode = node.next.get(key);
                if (search(nextNode, word, depth + 1)) {
                    return true;
                }
            }
            // 循环都走完都没有找到，那就说明没有
            return false;
        } else {
            if (!node.next.containsKey(c)) {
                return false;
            }
            return search(node.next.get(c), word, depth + 1);
        }
    }

    public static void main(String[] args) {
        WordDictionary wordDictionary = new WordDictionary();
        wordDictionary.addWord("bad");
        wordDictionary.addWord("dad");
        wordDictionary.addWord("mad");
        boolean search1 = wordDictionary.search("pad");// -> false
        System.out.println(search1);
        boolean search2 = wordDictionary.search("bad"); // -> true
        System.out.println(search2);
        boolean search3 = wordDictionary.search(".ad"); // -> true
        System.out.println(search3);
        boolean search4 = wordDictionary.search("b.."); //-> true
        System.out.println(search4);
    }
}
```
