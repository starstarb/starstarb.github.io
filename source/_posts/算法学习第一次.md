---
title: 算法学习第一次
categories: 算法笔记
tags: 算法
abbrlink: 5bfcca0e
date: 2019-07-07 14:14:34
---
重学算法和数据结构，计划用多种编程语言实现同一个题，巩固知识。
<!--more-->
## 编程技巧
#### 《算法入门指南》
 C++
 输入调用简化<br>
```
int readint()
{
	int x;scanf("%d",&x); return x;
}
vector<int> vc;
vc.push_back(readint());
//读入数据函数调用方法
```

循环宏定义<br>
```
#define _for(i,a,b) for(int i=(a);i<(b);++i)
//简化代码，for
```
STL容器内容调试输出<br>
```
//使用C++的IO流对集合进行输出
template <typename T>
ostream& operator<<(ostream& os,const vector<T> & v){
	for(int i=0;i<v.size();i++)
	os<<v[i]<<" ";
	return os;
}

template <typename T>
ostream & operator<<(ostream &os,const set<T> & v){
	for(typename set<T>::iterator it=v.begin();it!=v.end;it++)
	os<<*it<<" ";
	return os;
}

//使用方法
vector<int> a;
a.push_back(1);
a.push_back(2);
a.push_back(3);
cout<<a;


set<string> b;b.insert("1");
b.insert("2");
b.insert("3");
cout<<b;

```
##### 题目一：统计字符串出现次数
给出一个由O和X组成的串（长度为1~80），统计得分。每个O的得分为目前连续出现的O的个数，X的得分为0。
输入 ：
15
OOOOXOOOOXOOOOX
输出：
30             

C++实现代码：
```
#include<stdio.h>
#include<string.h>
#define maxn 85
char buf[maxn];    // 输入的OX字符串缓冲区
int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%s", buf);
        int count = 0, score = 0;
        for(int i = 0; buf[i]; i++)
            if(buf[i] == 'O') score += (++count);
            else count = 0;
        printf("%d\n", score);
    }
    return 0;
}

```
Js代码：
```



```
java代码
```

```

##### 题目二：找出数组中重复的数字
给定一个长度为 nn 的整数数组 nums，数组中所有的数字都在 0∼n−10∼n−1 的范围内。

数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。

请找出数组中任意一个重复的数字。

注意：如果某些数字不在 0∼n−10∼n−1 的范围内，或数组中不包含重复数字，则返回 -1；

样例：

给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。

返回 2 或 3。


C++实现代码：
```
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        
    }
};




 
 
算法

(数组遍历) O(n)
首先遍历一遍数组，如果存在某个数不在0到n-1的范围内，则返回-1。

下面的算法的主要思想是把每个数放到对应的位置上，即让 nums[i] = i。

从前往后遍历数组中的所有数，假设当前遍历到的数是nums[i]=x，那么：

如果x != i && nums[x] == x，则说明 xx 出现了多次，直接返回 x 即可；
如果nums[x] != x，那我们就把 x 交换到正确的位置上，即 swap(nums[x], nums[i])，交换完之后如果nums[i] != i，则重复进行该操作。由于每次交换都会将一个数放在正确的位置上，所以swap操作最多会进行 n 次，不会发生死循环。
循环结束后，如果没有找到任何重复的数，则返回-1。

时间复杂度分析

每次swap操作都会将一个数放在正确的位置上，一共只有 n 个数和 n 个位置，所以swap最多会进行 n次。所以总时间复杂度是 O(n)

C++ 代码

class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size();
        for (auto x : nums)
            if (x < 0 || x >= n)
                return -1;
        for (int i = 0; i < n; i ++ ) {
            while (nums[nums[i]] != nums[i]) swap(nums[i], nums[nums[i]]);
            if (nums[i] != i && nums[nums[i]] == nums[i]) return nums[i];
        }
        return -1;
    }
};


//基于计数排序的算法
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> temp(n,0);
        for(int i=0;i<n;i++) 
        {
            if(nums[i]<0)
            {
                return -1;
            }
            temp[nums[i]]++;
        }
        for(int i=0;i<n;i++)
        {
            if(temp[i]>1)
            {
                return i;
            }
        }
        return -1;
    }
};


//简化版
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> temp(n,0);
        for(auto i:nums)
        {
            if(i<0 ||i>=n)
            {
                return -1;
            }
        }
        for(int i=0;i<n;i++) 
        {
            if(temp[nums[i]]++){
                return nums[i];
            }
        }
        return -1;
    }
};


```
Js代码：
```



```
java代码
```
class Solution {
    public int duplicateInArray(int[] nums) {
        
    }
}





算法1

将当前位置的数值放到他的位置上去，比如{2,2,3,3,4},将nums[0]的数应该放到nums[2]上，即将该数组放到他在数组中和他角标相等的位置，每次都检查要交换的位置上的数值是否一样，如果一样，则重复，如果不一样，则交换。

时间复杂度分析：o(n)
JAVA 代码

    public int duplicateInArray(int[] nums) {
        int len = nums.length;
        if(nums==null||len==0)
            return -1;
        Set<Integer> set = new HashSet<>();
        for(int i =0;i<len;i++){
            if(nums[i]<0||nums[i]>len-1)
                return -1;
        }
        // Arrays.sort(nums);
        for(int i = 0;i<len;i++){
            while(nums[i]!=i){
                if(nums[i]==nums[nums[i]])
                    return nums[i];

                int temp = nums[i];
                nums[i] = nums[temp];
                nums[temp] = temp;
            }
        }

        return -1;
    }
算法2

将数组进行排序，将当前位置和下一位置的数字进行对比，如果一样，则方法结束并返回

JAVA 代码

    public int duplicateInArray(int[] nums) {
        int len = nums.length;
        if(nums==null||len==0)
            return -1;
        Set<Integer> set = new HashSet<>();
        for(int i =0;i<len;i++){
            if(nums[i]<0||nums[i]>len-1)
                return -1;
        }
        Arrays.sort(nums);
        for(int i = 0;i<len-1;i++){
            if(nums[i]==nums[i+1])
                return nums[i];
        }

        return -1;
    }
算法3

用hashset的add方法，如果哈希表中没有这个数据，则返回true并加入，如果有，则返回false

JAVA 代码

    public int duplicateInArray(int[] nums) {
        int len = nums.length;
        if(nums==null||len==0)
            return -1;
        Set<Integer> set = new HashSet<>();
        for(int i =0;i<len;i++){
            if(nums[i]<0||nums[i]>len-1)
                return -1;
        }
        Arrays.sort(nums);
        for(int i = 0;i<len;i++){
            if(!set.add(nums[i]))
                return nums[i];
        }

        return -1;
    }

```

##### 题目三：给定一个数组arr，和一个数num，请把小于等于num的数放在数组左边，等于num的数放在数组的中间，大于num的数放在数组右边。   时间复杂度O（N），空间复杂度O（1）
    > 在使用partition-exchange排序算法时，如快速排序算法(即使选择了一个好的关键元素pivot values)，我们往往面临一个很尴尬的境地--当排序对象中有很多重复的元素，partition-exchange排序算法表现很不尽如人意。当所有元素都相等时，这就特别容易理解了。在每次递归中，左边部分是空的(没有元素比关键元素小)，而右边部分只能一个一个递减移动。结果导致耗费了二次方时间来排序相等元素。为了解决这个问题(有时叫做荷兰国旗问题)，我们详细介绍下解决这个问题的方法。
 C++实现代码：
```
#include<iostream>
#include<stdlib.h>
using namespace std;
#define N 10
//荷兰国旗问题 
void swap(int &v1,int &v2)
{
    int temp=v1;
    v1=v2;
    v2=temp;
}
void paixu(int *array)
{
    int current=0;
    int end=N-1;
    int begin=0;
    while(current<=end)
    {
        if(array[current]==0)
        {
            swap(array[current],array[begin]);
            current++;
            begin++;
        }
        else if(array[current]==1)
        {
            current++;
        }
        else{
            swap(array[current],array[end]);
            end--;
        }
    }
}
int main()
 {
      int a[N];
      int i;
      for( i=0 ; i<N; i++ )
      {
           a[i] = rand()%3;
           cout << a[i] << " ";
      }
      cout << endl;
      paixu(a);
      for( int i=0 ; i<N ; i++ )
      {
           cout << a[i] << " ";
      }
      cout << endl;
      return 0;
 }
```
改进算法(快排)：
```
package basic_class_01;

import java.util.Arrays;

public class Code_04_QuickSort {

    public static void quickSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }

    public static void quickSort(int[] arr, int l, int r) {
        if (l < r) {
            swap(arr, l + (int) (Math.random() * (r - l + 1)), r);//随机快排，O(nlog(n))
            int[] p = partition(arr, l, r);
            quickSort(arr, l, p[0] - 1);
            quickSort(arr, p[1] + 1, r);
        }
    }

    public static int[] partition(int[] arr, int l, int r) {
        int less = l - 1;
        int more = r;
        while (l < more) {
            if (arr[l] < arr[r]) {
                swap(arr, ++less, l++);
            } else if (arr[l] > arr[r]) {
                swap(arr, --more, l);
            } else {
                l++;
            }
        }
        swap(arr, more, r);
        return new int[] { less + 1, more };
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // for test
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // for test
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            quickSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                printArray(arr1);
                printArray(arr2);
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        quickSort(arr);
        printArray(arr);

    }

}

```
Js代码：
```



```
java代码
```
package basic_class_01;

public class Code_08_NetherlandsFlag {

    public static int[] partition(int[] arr, int l, int r, int p) {//p=num
        int less = l - 1;
        int more = r + 1;
        //cur=l;
        while (l < more) {
            if (arr[l] < p) {
                swap(arr, ++less, l++);//小于区域扩一个位置，current往下跳下一个，current和小于区域的下一个位置的数交换
            } else if (arr[l] > p) {
                swap(arr, --more, l);// 大于区域的前一个位置的数和当前的数交换，当前的数不变
            } else { //==num  大于区域不扩，小于区域不扩
                l++;
            }
        }
        return new int[] { less + 1, more - 1 };//等于区域的左边界和右边界 组成一个数组返回
    }

    // for test
    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // for test
    public static int[] generateArray() {
        int[] arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * 3);
        }
        return arr;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] test = generateArray();

        printArray(test);
        int[] res = partition(test, 0, test.length - 1, 1);
        printArray(test);
        System.out.println(res[0]);
        System.out.println(res[1]);

    }
}

```
##### 题目四：UVa227
 题目描述：

1. 有一个5*5的网格，只有一个格子是空格，其余的都是字母。
2. 4个指令 A,B,L,R，分别代表向上向下向左向右。
3. 输出执行完后的网格内的情况。
4. 若有越界则单独输出
原题链接：https://vjudge.net/problem/UVA-227
类似于华容道游戏
C++
直接模拟，四种方向和四种指令字符存放在一个数组中
```
#include<stdio.h>
#include<string.h>
int t=0,a,b,kase;
char x[6][6],s[10005];
int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},dt[26];
int legal(char ch,int &a,int &b)
{
    int ta=a,tb=b,tp=dt[ch-'A'];//保留之前的位置 
    a=ta+dx[tp],b=tb+dy[tp];//操作之后的位置 
    if(a<0||a>4||b<0||b>4)//判断是否合法 
    {
        return 0;
    }
    tp=x[ta][tb];x[ta][tb]=x[a][b];x[a][b]=tp;//交换，移动 
    return 1;
}
void slove()
{
    for(int i=0;i<5;++i)//定位空格！ 
    {
        for(int j=0;j<5;++j)
        {
            if(x[i][j]==' '||x[i][j]=='\0')//注意可能是空格，或者是空 
            {
                a=i;b=j;x[i][j]=' ';//记录位置 
            }
        }
    }
    for(int i=0;s[i]!='0';++i)//移动 
    {
        if(!legal(s[i],a,b))//判断是否合法 
        {
            printf("This puzzle has no final configuration.\n");//否则 
            return;
        }
    }
    for(int i=0;i<5;++i)//输出！ 
    {
        for(int j=0;j<4;++j)
        {
            printf("%c ",x[i][j]);
        }
        printf("%c\n",x[i][4]);
    }
}
int main()
{
    //freopen("shuju.txt","r",stdin);
    dt['A'-'A']=0;dt['B'-'A']=1;dt['L'-'A']=2;dt['R'-'A']=3;
    while(gets(x[0]))
    {
        if(x[0][0]=='Z')//结束判断 
        {
            return 0;
        }
        for(int i=1;i<5;++i)
        {
            gets(x[i]);
        }
        int cnt=0,tp;
        while((tp=getchar())!='0')//指令数组 
        {
            if(tp!='\n')
            {
                s[cnt++]=tp;
            }
        }
        s[cnt]='0';
        getchar();//读取最后的换行 
        if(t)
        {
            printf("\n");//格式 
        }
        printf("Puzzle #%d:\n",++t);
        slove();
    }
    return 0;
}

```

#### 题目五：Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

Note: For the purpose of this problem, we define empty string as valid palindrome.

Example 1:

Input: "A man, a plan, a canal: Panama"
Output: true
Example 2:

Input: "race a car"
Output: false


这是一道考察回文的题目，而且是最简单的形式，即判断一个字符串是否是回文。

针对这个问题，我们可以使用头尾双指针，

如果两个指针的元素不相同，则直接返回false,
如果两个指针的元素相同，我们同时更新头尾指针，循环。 直到头尾指针相遇。
时间复杂度为O(n).




JavaScript Code:
```
/*
 * @lc app=leetcode id=125 lang=javascript
 *
 * [125] Valid Palindrome
 */
// 只处理英文字符（题目忽略大小写，我们前面全部转化成了小写， 因此这里我们只判断小写）和数字
function isValid(c) {
  const charCode = c.charCodeAt(0);
  const isDigit =
    charCode >= "0".charCodeAt(0) && charCode <= "9".charCodeAt(0);
  const isChar = charCode >= "a".charCodeAt(0) && charCode <= "z".charCodeAt(0);

  return isDigit || isChar;
}
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
  s = s.toLowerCase();
  let left = 0;
  let right = s.length - 1;

  while (left < right) {
    if (!isValid(s[left])) {
      left++;
      continue;
    }
    if (!isValid(s[right])) {
      right--;
      continue;
    }

    if (s[left] === s[right]) {
      left++;
      right--;
    } else {
      break;
    }
  }

  return right <= left;
};
```
C++ Code:
```
class Solution {
public:
    bool isPalindrome(string s) {
        if (s.empty())
            return true;
        const char* s1 = s.c_str();
        const char* e = s1 + s.length() - 1;
        while (e > s1) {
            if (!isalnum(*s1)) {++s1; continue;}
            if (!isalnum(*e)) {--e; continue;}
            if (tolower(*s1) != tolower(*e)) return false;
            else {--e; ++s1;}
        }
        return true;
    }
};


class Solution{
public:
    bool isPalindrome(string s){
        int len=s.length(),l=0,r=len-1;
        while(l<r){
            if(!isalnum(s[l])) l++;
            else if(!isalnum(s[r])) r--;
            else if(tolower(s[l])==tolower(s[r])) {l++;r--;}
            else return false;
        }
        return true;
    }
};
```
  java
```



```

##### 题目六：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。

样例

输入:1->2->3->4->5->NULL

输出:5->4->3->2->1->NULL
     
     
java:
```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
              if(head == null){return null;}
        // 相当于设置头节点， 不需要考虑处理特殊情况(第一二个节点)
        ListNode pre = null;
        ListNode cur = head;

        while(cur != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;

    }
}

```
C++
```
算法1

(链表操作，迭代) O(n)O(n)
翻转即将所有节点的next指针指向前驱节点。
由于是单链表，我们在迭代时不能直接找到前驱节点，所以我们需要一个额外的指针保存前驱节点。同时在改变当前节点的next指针前，不要忘记保存它的后继节点。

空间复杂度分析：遍历时只有3个额外变量，所以额外的空间复杂度是 O(1)O(1)。
时间复杂度分析：只遍历一次链表，时间复杂度是 O(n)O(n)。

C++ 代码

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = nullptr;
        ListNode *cur = head;
        while (cur)
        {
            ListNode *next = cur->next;
            cur->next = prev;
            prev = cur, cur = next;
        }
        return prev;
    }
};
算法2

(链表操作，递归) O(n)O(n)
首先我们先考虑 reverseList 函数能做什么，它可以翻转一个链表，并返回新链表的头节点，也就是原链表的尾节点。
所以我们可以先递归处理 reverseList(head->next)，这样我们可以将以head->next为头节点的链表翻转，并得到原链表的尾节点tail，此时head->next是新链表的尾节点，我们令它的next指针指向head，并将head->next指向空即可将整个链表翻转，且新链表的头节点是tail。

空间复杂度分析：总共递归 nn 层，系统栈的空间复杂度是 O(n)O(n)，所以总共需要额外 O(n)O(n) 的空间。
时间复杂度分析：链表中每个节点只被遍历一次，所以时间复杂度是 O(n)O(n)。

C++ 代码：

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode *tail = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return tail;
    }
};

```
python:
```
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head is None or head.next is None:
            return head
        cur = None
        while head:
            tmp = head.next # 保存当前节点下一节点 可能为0 所以最后head会move到0 返回cur
            head.next = cur # 指向上一个循环的节点
            cur = head # 保存目前节点
            head = tmp # head指针往下移动
        return cur
```

##### 题目七：请实现一个函数按照之字形顺序从上向下打印二叉树。

即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

样例

输入如下图所示二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]
    8
   / \
  12  2
     / \
    6   4
输出：[[8], [2, 12], [6, 4]]
java:
```
算法1

(层序遍历，两个辅助栈) O(n)
一个队列只能从一个方向按顺序进入队列，没有办法做到两个方向的之字打印。

用两个栈，每个分别记录一层，第一层用stack1,第二层用stack2，交替使用，如果当前的栈不为空，则一直循环弹栈，然后将其左右子树压入另一个栈，直到栈为空。

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> printFromTopToBottom(TreeNode root) {
        
    }
}
*/

class Solution {
    public List<List<Integer>> printFromTopToBottom(TreeNode root) {
        List<List<Integer>> arr = new ArrayList<>();
        if(root==null)
            return arr;
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(root);

        while(!stack1.empty()||!stack2.empty()){
            if(!stack1.empty()){
                ArrayList<Integer> arr1 = new ArrayList<>();
                while(!stack1.empty()){
                    TreeNode node = stack1.pop();
                    arr1.add(node.val);
                    if(node.left!=null)
                        stack2.push(node.left);
                    if(node.right!=null)
                        stack2.push(node.right);
                }
                arr.add(arr1);
            }
            else{
                ArrayList<Integer> arr1 = new ArrayList<>();
                while(!stack2.empty()){
                    TreeNode node = stack2.pop();
                    arr1.add(node.val);
                    if(node.right!=null)
                        stack1.push(node.right);
                    if(node.left!=null)
                        stack1.push(node.left);
                }
                arr.add(arr1);
            }
        }
        return arr;
    }
}
```

C++:
```
算法

(BFS) O(n)
宽度优先遍历，一层一层来做。即：

将根节点插入队列中；
创建一个新队列，用来按顺序保存下一层的所有子节点；
对于当前队列中的所有节点，按顺序依次将儿子插入新队列；
按从左到右、从右到左的顺序交替保存队列中节点的值；
重复步骤2-4，直到队列为空为止。
时间复杂度

树中每个节点仅会进队出队一次，所以时间复杂度是 O(n)。

C++ 代码

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> get_val(vector<TreeNode*> level)
    {
        vector<int> res;
        for (auto &u : level)
            res.push_back(u->val);
        return res;
    }

    vector<vector<int>> printFromTopToBottom(TreeNode* root) {
        vector<vector<int>>res;
        if (!root) return res;
        vector<TreeNode*>level;
        level.push_back(root);
        res.push_back(get_val(level));
        bool zigzag = true;
        while (true)
        {
            vector<TreeNode*> newLevel;
            for (auto &u : level)
            {
                if (u->left) newLevel.push_back(u->left);
                if (u->right) newLevel.push_back(u->right);
            }
            if (newLevel.size())
            {
                vector<int>temp = get_val(newLevel);
                if (zigzag)
                    reverse(temp.begin(), temp.end());
                res.push_back(temp);
                level = newLevel;
            }
            else break;
            zigzag = !zigzag;
        }
        return res;
    }
};
```