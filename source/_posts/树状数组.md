---
title: 树状数组
tags: 树状数组
categories: 算法刷题
abbrlink: 59a0de58
date: 2019-07-29 14:11:44
---
树状数组
<!--more-->
### 区域和检索 --数组可修改
给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。

update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。

示例:

Given nums = [1, 3, 5]

sumRange(0, 2) -> 9
update(1, 2)
sumRange(0, 2) -> 8

说明:

    数组仅可以在 update 函数下进行修改。
    你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。

链接：https://leetcode-cn.com/problems/range-sum-query-mutable
算法思路：
方法一：
区域和检索的一个简单的解决方案 - RSQ(i, j) 是将数组从索引 i 迭代到 j 并对每个元素求和。
```
private int[] nums;
public int sumRange(int i, int j) {
    int sum = 0;
    for (int l = i; l <= j; l++) {
        sum += data[l];
    }
    return sum;
}

public int update(int i, int val) {
    nums[i] = val;
}
```
复杂度分析:

    时间复杂度：O(n)。区域和检索 O(1) 的更新查询 对于区域和检索，我们从数组中访问每个元素的时间是固定的，在最坏的情况下，我们访问 n 元素。因此，时间复杂度为 O(n)O。更新查询的时间复杂度为 O(1))。
    空间复杂度：O(1)
方法二：sqrt 分解

其思想是将数组分割成块，块的长度为 sqrt（n）
​。然后我们计算每个块的和，并将其存储在辅助存储器 b 中。
要查询 RSQ(i, j)，我们将添加位于内部的所有块和部分在范围[i…j] 重叠的块的总和。
```
private int[] b;
private int len;
private int[] nums;
public NumArray(int [] nums)
{
	this.nums=nums;
	double l=Math.sqrt(nums.length);
	len=(int) Math.ceil(nums.length/l);
	b=new int[len];
	for(int i=0;i<nums.length;i++)
	b[i/len]+=nums[i];
}
public int sumRange(int i,int j){
	int sum=0;
	int startBlock=i/len;
	int endBlock=j/len;
	if(startBlock==endBlock)
	{
		for(int k=i;k<=j;k++)
		sum+=nums[k];
	}
	else{
		for(int k=i;k<=(startBlock+1)*len-1;k++)
		sum+=nums[k];
		for(int k=startBlock+1;k<=endBlock-1;k++)
		sum+=b[k];
		for(int k=endBlock*len;k<=j;k++)
		sum+=nums[k];
	}
	return sum;
}
public void update(int i,int val)
{
	int b_l=i/len;
	b[b_l] = b[b_l] - nums[i] + val;
    nums[i] = val;
}
```





