---
title: 图论算法归类
tags: 图
categories: 图
abbrlink: '20024957'
date: 2019-07-22 12:44:35
---
图
<!--more-->
### 网络流
EK算法、dinic算法




### 拓扑排序树
定义：

        拓扑排序：图中的点以线性方式进行排序。即若图中有一条边是u->v,则最后的排序结果中u总在v前面。类似于先序图的概念，必须先到达u点才能到达v点，则u>v。
适用条件：

        并不是所有图都可以进行拓扑排序。这里有个重要的概念是离散数学中的偏序关系。

        偏序的大意就是，如果图中的两个点有确定的大小关系，例如一条边上的两个点，或没有直接的联系，即两个点不相通，则就是偏序关系。不能存在互相矛盾的关系，比如环路，例如a->b,b->a，这种就不满足偏序关系。所以，只要一个图中不存在环路，不管图中的点连通与否，都满足偏序关系。而拓扑排序的条件就是这个图是有向无环图（DAG），有向是为了确定两个点的先后顺序，若无向，则关系都乱了。
唯一性：

        图中顶点的拓扑关系并不像数字的大小关系那样简单，这里还有个重要的概念的离散数学中的全序关系。

        全序关系在图中的大意就是，每个点都与其他所有点有着确定的先后顺序，那么这个图就满足全序关系。

        这里用数组与图做对比来解释，任意两个不相等的数字之间有着确定的大小关系，所以数组就满足全序关系，这样排序后的结果就是惟一的。但是通常我们评价排序算法时，要考虑一个因素是稳定性，即相同数字的排序结果是否和出现的顺序一致。因为两个相同的数字的大小关系无法确定，不满足全序关系，那么他们在排序结果中的位置也就无法确定。

        回到图中，如果DAG中的每个点都与其他所有点有确定的先后顺序，那么这个DAG的拓扑排序结果是惟一的，但是如果存在两个点不直接相连，即无法确定他们的拓扑关系，那么它们在拓扑结果中的位置就无法确定，拓扑结果就不唯一了。
基本思想：

        拓扑排序有两种做法，一种是bfs的思路，一种是dfs的思路。本文介绍bfs方法，bfs是以入度为切入点，一个点的入度越小，则排在它前面的点就越少。基本思想是动态维护一个入度为0的顶点的队列。然后取一个点出发，依次将图中与该点相连
        的边去掉，如果在过程中又出现了新的入度为0的顶点，则加入队列中，直到队列为空。如果此时图中没有边了，则
        不存在环路，从而得到排序结果，这也说明bfs方法可以检测一个图是不是有向无环图。
数据结构：

        算法中涉及到的数据结构有以下几种：

        1、图的邻接矩阵，用来表示图。

        2、保存排序结果的集合，一般用vector。

        3、入度数组，用来保存每个点的入度。

        4、队列，用来保存当前入度为0并且没有遍历到的点。
算法过程：

        1、建图

        2、遍历图中的所有点，统计每个点的入度，存到入度数组中

        3、将入度为0的点入队

        4、对当前队列中的点进行遍历，取出点并将它存到结果集中。再从该点出发，去掉图中以该点为起点的边，并且将边的终点的入度-1。同时判断终点的入度是否减为0，若为0，则入队。

        5、重复4，直到队列为空。

```
#include<iostream>
#include<vector>
#include<string.h>
#include<queue>
using namespace std;
vector<int> *edge;//边集 
vector<int> res;//结果集 
queue<int> q;
int in[101];//入度数组 
int n,m,edges;//edges表示此时图中所剩的边数 
int main()
{
  int a,b;
  cin>>n>>m;
  edges=m;
  edge=new vector<int>[n];
  memset(in,0,sizeof(in));
  for(int i=0;i<m;i++)
  {
    cin>>a>>b;
    edge[a].push_back(b);
  }
  //统计入度 
  for(int i=0;i<n;i++)
    for(int j=0;j<edge[i].size();j++)
      in[edge[i][j]]++;
  //将入度为0的点入队 
  for(int i=0;i<n;i++)
    if(in[i]==0)
      q.push(i);
  int n;
  while(!q.empty())
  {
    //取出一个点加入结果集 
    n=q.front();
    q.pop();
    res.push_back(n);
    //遍历该点所引出的所有边 
    for(int i=0;i<edge[n].size();i++)
    {
      //edges--表示去掉了这条边 
      edges--;
      //同时终点的入度-1 
      in[edge[n][i]]--;
      if(in[edge[n][i]]==0)
        q.push(edge[n][i]);
    }
  }
  //若此时图中还存在边，则说明有环路。 
  if(edges!=0)
    cout<<"Has circles!";
  else
    for(int i=0;i<res.size();i++)
      cout<<res[i]<<" ";
  return 0;
}
```

### 最小高度树
对于一个具有树特征的无向图，我们可选择任何一个节点作为根。图因此可以成为树，在所有可能的树中，具有最小高度的树被称为最小高度树。给出这样的一个图，写出一个函数找到所有的最小高度树并返回他们的根节点。

**格式**

该图包含 n 个节点，标记为 0 到 n - 1。给定数字 n 和一个无向边 edges 列表（每一个边都是一对标签）。

你可以假设没有重复的边会出现在 edges 中。由于所有的边都是无向边， [0, 1]和 [1, 0] 是相同的，因此不会同时出现在 edges 里。

**示例 1:**

输入: n = 4, edges = [[1, 0], [1, 2], [1, 3]]

        0
        |
        1
       / \
      2   3 

输出: [1]

**示例 2:**

输入: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]

     0  1  2
      \ | /
        3
        |
        4
        |
        5 

输出: [3, 4]

说明:

     根据树的定义，树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。
    树的高度是指根节点和叶子节点之间最长向下路径上边的数量。
    
[点击链接](https://leetcode-cn.com/problems/minimum-height-trees)
 
每次总是删除“入度”个数最少的结点，因为树是无向无环图，删除了它们以后，与之相连的结点的入度也相应地减少 1，直到最后剩下 1 个结点或者 2 个结点。
使用了“邻接表”表示图，使用了“入度数组”，还使用了队列保存了下一轮要“剔除”的结点编号。


```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

public class Solution {


    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> res = new ArrayList<>();
        // 特判
        if (n <= 2) {
            for (int i = 0; i < n; i++) {
                res.add(i);
            }
            return res;
        }

        // 入度数组，每一次要把入度为 1 的结点剔除
        int[] inDegrees = new int[n];

        // 默认为 False，如果剔除，设置为 True
        boolean[] result = new boolean[n];

        // 因为是无向图，所以邻接表拿出一条边，两个结点都要存一下
        // 注意：右边就不要写具体的实现类了，等到实例化的时候再写具体的实现类
        Set<Integer>[] adjs = new Set[n];
        // 初始化
        for (int i = 0; i < n; i++) {
            adjs[i] = new HashSet<>();
        }

        for (int[] edge : edges) {
            int start = edge[0];
            int end = edge[1];
            adjs[start].add(end);
            adjs[end].add(start);
            inDegrees[start] += 1;
            inDegrees[end] += 1;
        }
        LinkedList<Integer> queue = new LinkedList<>();

        // 入度为 1 的结点入队
        for (int i = 0; i < n; i++) {
            if (inDegrees[i] == 1) {
                queue.addLast(i);
            }
        }

        // 注意边界条件 n == 2 和 n == 1 是如何分析出来的
        while (n > 2) {
            int size = queue.size();
            System.out.println(queue);
            // 一次减去这么多
            n -= size;
            for (int i = 0; i < size; i++) {
                int top = queue.removeFirst();
                result[top] = true;
                inDegrees[top] -= 1;
                // 把它和它的邻接结点的入度全部减 1
                Set<Integer> successors = adjs[top];
                for (Integer successor : successors) {
                    inDegrees[successor] -= 1;
                    if (inDegrees[successor] == 1) {
                        queue.addLast(successor);
                    }
                }
            }
        }
        n = result.length;
        for (int i = 0; i < n; i++) {
            if (!result[i]) {
                res.add(i);
            }
        }
        return res;
    }


    public static void main(String[] args) {
        int[][] edges = new int[][]{{1, 0}, {1, 2}, {1, 3}};
        int n = 4;
        Solution solution = new Solution();
        List<Integer> res = solution.findMinHeightTrees(n, edges);
        System.out.println(res);
    }
}


```
#####题目大意：

        把一个无向图想象成一棵树，每个结点都可以是树的根节点，然后找到最小的树的高度所对应的根结点。
思路解法：

        开始把这个题想得有点简单，我用dfs计算出了每个点作为根节点时的树的高度，然后用当前最小高度来剪枝。然而超时了，后来想想确实dfs的时间复杂度太高。后来在网上看到大神的思路，利用了拓扑排序的思想，简单易懂，复杂度低。拓扑排序的详解：https://blog.csdn.net/Q_M_X_D_D_/article/details/84862081

        本题的解法思路是：设立一个点集，保存当前图中度为1的点，即树的叶子结点。然后将这些结点从图中删去，此时，有可能会生成一些新的叶子结点，那么再将这些新的叶子结点加入点集中。不断重复这个过程，直到图中的剩下的点不超过3个。为什么是3个呢？举个例子，假设一个图有两个点，用一条边连起来，那么返回的结果就是这两个点。但如果图中有三个点，用两条边连起来，那么返回的结果就是中间的那一个点。代码如下：
```
class Solution {
public:
    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {
      vector<int> res;
      //储存每个点的度 
      vector<int> indegree(n,0);
      //储存图中边的信息 
        unordered_map<int,vector<int> > hash;
        for(int i=0;i<edges.size();i++)
        {
          //建图并统计点的度 
          hash[edges[i].first].push_back(edges[i].second);
          hash[edges[i].second].push_back(edges[i].first);
          indegree[edges[i].first]++;
          indegree[edges[i].second]++;
    }
    while(n>2)
    {
      vector<int> vec;
      //找到当前的所有叶子结点 
      for(int i=0;i<indegree.size();i++)
        if(indegree[i]==1)
          vec.push_back(i);
      for(int i=0;i<vec.size();i++)
      {
        //删去这个叶子结点，并将与之相连的点的度-1 
        indegree[vec[i]]=-1;
        n--;
        for(int j=0;j<hash[vec[i]].size();j++)
          indegree[hash[vec[i]][j]]--;
      }
    }
    for(int i=0;i<indegree.size();i++)
      if(indegree[i]>=0)
        res.push_back(i);
    return res;
    }
};
```