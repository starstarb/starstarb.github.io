---
title: CG平台刷题记录：CG2917
copyright: true
tags: 算法刷题
categories: 算法刷题
abbrlink: d32d4f56
date: 2019-10-28 14:22:17
---
环环相扣
<!--more-->
2917. 环环相扣

【问题描述】

给定三个字符串，试判断能否由前两个串中的字符组合出第三个字符串（要求：前两个串中的字符可以按任意顺序选取，但需保持其原来的顺序）。

例如，对于这样的三个字符串，字符串A：cat，字符串B：tree，字符串C：tcraete。分别从B中取字符't'，从A中取字符'c'，从B中取字符'r'，从A中取字符'a'，从B中取字符'e'，从A中取字符't'，最后从B中取字符'e'，这样组合出的字符串恰好为字符串C。

再举一个例子：字符串A：cat，字符串B：tree，字符串C：catrtee，字符串C可以由字符串A和字符串B组合而来。但是，由字符串A：cat和字符串B：tree却不能组合出字符串C：cttaree。

【输入形式】

输入文件中第一行是一个正整数（1和1000之间），表示接下来共有多少组测试数据。每组测试数据占一行，共有三个字符串，由一个空格隔开。所有字符串都只包含大写或小写字母。前两个字符串长度在1到200之间。第三个字符串的长度恰好为前两个字符串长度之和。

【输出形式】

对于输入文件中的每个测试数据，如果第三个字符串可以按前述规则由前两个字符串组合得到，那么，输出“Data set n: yes”；否则，输出“Data set n: no”。其中n是组号。

【样例输入】

3
cat tree tcraete
cat tree catrtee
cat tree cttaree

【样例输出】

Data set 1: yes
Data set 2: yes
Data set 3: no

```
#include<iostream>
#include<string>
#include<vector>
#include<string.h>
using namespace std;
/*
   动态规划： 
   dp(i,j)表示s1的前i个字符串和s2的前j个字符串能否构成s3的前i+j个字符串。
            1、如果s1[i-1]==s3[i+j-1]，则dp(i,j)=dp(i-1,j)
            2、如果s2[j-1]==s3[i+j-1]，则dp(i,j)=dp(i,j-1)
   注意点:由于上述两种情况可能同时发生，即s1[i]==s3[i+j-1]和s2[j]==s3[i+j-1]同时满足，
   所以只要其中一个成立则dp[i][j]=1，所以如果都满足的情况下，都要考虑。
 
 */
bool charge(string s1,string s2,string s3){
      /*  int len1=s1.length(),len2=s2.length(),len3=s3.length();
        
        if(len1+len2!=len3)
		    return false;//如果长度不等，直接返回false 
        vector<vector<int>> dp(len1+1,vector<int>(len2+1));///定义一个二维动态数组，数组大小要加1 
        for(int i=1;i<=len1&&s1[i-1]==s3[i-1];i++){   //从1开始遍历s1 条件必须是s1[i-1]==s3[i-1]  s2长度为0 
            dp[i][0]=1;//给dp(i，j)行 赋值为1 
        }
        for(int i=1;i<=len2&&s2[i-1]==s3[i-1];i++){//同理  s1长度为0 
            dp[0][i]=1;
        }
        for(int i=1;i<=len1;i++){   //s1和s2均长度不为0 如果上一行为1且s1[i-1]等于s3[i+j-1]或者上一列为1且s2[j-1]等于
		                           //s3[i+j-1]则dp[i][j]就为1，其他情况为0
                                  //初始化第一行和第一列时注意，dp[0][0]=1,因为空的s1和空的s2可以构成空的s3

            for(int j=1;j<=len2;j++){
                int k=i+j-1;
                if(s1[i-1]==s3[k]&&dp[i-1][j]==1){
                    dp[i][j]=1;
                }
                if(s2[j-1]==s3[k]&&dp[i][j-1]==1){
                    dp[i][j]=1;
                }
            }
        }
        return dp[len1][len2];*/
        int m = s1.length();
        int n = s2.length();
        int t = s3.length();
        if(t!=m+n)return false;
        int dp[m+1][n+1];
        memset(dp,0,sizeof(dp));
        dp[0][0]=1;
        for(int i=1;i<=m;i++){
            if(s3[i-1]==s1[i-1]&&dp[i-1][0]==1){
                dp[i][0]=1;
            }
            else{
                dp[i][0]=0;
            }
        }
        for(int j=1;j<=n;j++){
            if(s3[j-1]==s2[j-1]&&dp[0][j-1]==1){
                dp[0][j]=1;
            }
            else {
                dp[0][j]=0;
            }
        }
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(dp[i-1][j]==1&&s3[i+j-1]==s1[i-1]){
                    dp[i][j]=1;   
                }
                else if(dp[i][j-1]==1&&s3[i+j-1]==s2[j-1]){
                    dp[i][j]=1;
                }
                else {
                    dp[i][j]=0;
                }
            }
        }
        return dp[m][n];
}
void query(int n)
{	
    string s1;
	string s2;
	string s3;
	for(int i=1;i<=n;i++){
		cin>>s1>>s2>>s3;
	    if(charge(s1,s2,s3))
	    cout<<"Data set "<<i<<": yes"<<endl;
	    else cout<<"Data set "<<i<<": no"<<endl; 
       }
}

int main()
{
	int n;
	cin>>n;
	query(n);
	return 0;
}
```