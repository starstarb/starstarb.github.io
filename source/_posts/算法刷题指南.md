---
title: 算法刷题指南
copyright: true
tags: 算法
categories: 算法
abbrlink: 767618c6
date: 2019-08-24 16:35:14
---
算法进阶指南
<!--more-->

### 求 a 的 b 次方对 p 取模的值。

输入格式:

	三个整数 a,b,p ,在同一行用空格隔开。

输出格式: 
	输出一个整数，表示a^b mod p的值。

数据范围
	1≤a,b,p≤109
输入样例：
	3 2 7
输出样例：
	2
**算法1**
(暴力枚举) O(m)

暴力枚举也就是循环一遍即可
C++ 代码
```
#include <iostream>
using namespace std; 
#define ll long long //自定义ll为long long类型 
int main()
{
    ll a,b,c,ans=1;
    cin>>a>>b>>c;
    for (ll i=1;i<=b;i++)
        ans=ans*a%c;
    cout<<ans;
}
```
**算法二**
有BUG，主要是理解错误
```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
using namespace std;
#define ll long long
ll n,m,k;
ll power(ll n,ll m,ll k)
{
    ll ans=1;
    while(m)
    {
        if (m&1)
            ans=ans*n%k;//如果m为奇数，则需要乘以一遍n，m降次为偶数
        n=n*n%k; 
        ans=ans*n%k;//错误点，因为如果当前m为偶数的话，并不需要处理，只需要留到m为奇数时候处理
        m>>=1;
    }
    return (ans%k);
}
int main()
{
    cin>>n>>m>>k;
    cout<<power(n,m,k);
} 
```
正解
大致思路：我们知道，任何一个自然数都可以写成n=2^pi1+2^pi2+2^pi3+……2^pim,其中所有pi为非负整数，所以可以利用二分，将这一题次数m，转化一下即可
```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring> 
using namespace std;
#define ll long long
ll n,m,k;
ll power(ll n,ll m,ll k)
{
    ll ans=1%k;
    while(m)
    {
        if (m&1)//如果m为奇数
            ans=ans*n%k;
        n=n*n%k;//将上一次的n进行平方
        m>>=1;
    }
    return (ans%k);
}
int main()
{
    cin>>n>>m>>k;
    n%=k;
    cout<<power(n,m,k);
} 
```
[原文链接](https://www.acwing.com/solution/acwing/content/788/)
 > 注：本题是快速幂的模板题

![](https://github.com/starstarb/clouding/raw/master/js/快速幂.png)

### 求 a 乘 b 对 p 取模的值。

数据范围：
	1≤a,b,p≤10^18

输入样例：
```
3
4
5
```
输出样例：
```
2
```
**算法1**
(二进制思想) O(logn)

如果直接计算a乘b这会超过 long long 的最大范围，所以采用类似于快速幂的思想
把 b写成二进制形式，然后如果某位上为1就加上它a\*（2^n）次方（n与这位的位置有关）
并且每次计算后取模就可以了

例：计算 3\*7
```
7的二进制 111
3*(2^0)=3
3*(2^1)=6
3*(2^2)=12
```
观察可发现每次的可由前一次\*2推出(记得取模)

时间复杂度分析：logn
C++ 代码
```
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
int main()
{
    ll a,b,p,res;
    cin>>a>>b>>p;
    res=0;
    while(b)
    {
        if(b&1)
            res=(res+a)%p;
        b>>=1;
        a=2*a%p;
    }
    cout<<res<<endl;
    return 0;
}
```

[原文链接](https://www.acwing.com/solution/AcWing/content/844/)


### 防晒
有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。

每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。

求最多可以满足多少头奶牛进行日光浴。


**输入格式**

第一行输入整数C和L。

接下来的C行，按次序每行输入一头牛的minSPF和maxSPF值,即第i行输入minSPF[i]和maxSPF[i]。

再接下来的L行，按次序每行输入一种防晒霜的SPF和cover值,即第i行输入SPF[i]和cover[i]。

每行的数据之间用空格隔开。


**输出格式**

输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。
数据范围
```
1≤C,L≤2500
,
1≤minSPF≤maxSPF≤1000,
1≤SPF≤1000
```
输入样例：
```
3 2
3 10
2 5
1 5
6 2
4 1
```
输出样例：

2
```
#include <cstring>
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;
typedef pair<int,int> PII;
const int N = 2510;

int n, m;
PII cows[N];

int main()
{
    cin >> n >> m;
    map<int, int> spfs;
    for (int i = 0; i < n; i ++ ) cin >> cows[i].first >> cows[i].second;
    for (int i = 0; i < m; i ++ )
    {
        int spf, cover;
        cin >> spf >> cover;
        spfs[spf] += cover; // 注意这里要写 +=，因为数据中存在spf值相同的防晒霜
    }
    sort(cows, cows + n);
    int res = 0;
    spfs[0] = spfs[1001] = n;
    for (int i = n - 1; i >= 0; i -- )
    {
        auto spf = spfs.upper_bound(cows[i].second);
        spf --;
        if (spf->first >= cows[i].first)
        {
            res ++ ;
            if (--spf->second == 0)
                spfs.erase(spf);
        }
    }
    cout << res << endl;
    return 0;
}
```

### 奇怪的汉诺塔
题目描述

汉诺塔问题，条件如下：

1、这里有A、B、C和D四座塔。

2、这里有n个圆盘，n的数量是恒定的。

3、每个圆盘的尺寸都不相同。

4、所有的圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。

5、我们需要将所有的圆盘都从塔A转移到塔D上。

6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。

请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。
汉诺塔塔参考模型

输入格式
没有输入
输出格式
对于每一个整数n(1≤n≤12),输出一个满足条件的最小移动次数，每个结果占一行。

输入样例：
没有输入
输出样例：
参考输出格式
思路：

##### 正解 DP+递推
解题思路：首先，我们可以初步确定，这是一道递归/递推的题目。（因为是汉诺塔问题）

    我们先考虑三个塔的汉诺塔问题，最优秀方案：必然是先挪走n-1个圆盘，然后再挪走圆盘N，
    因此可以得出递推方程也就是 d[i]=d[i-1]*2+1;
    之所以要乘以2，是因为第一次挪到第二个塔，然后还要挪移回到第三个塔，下面四个塔也是这样的
    接着考虑四塔问题，我们可以这么思考，首先挪走j个塔，也就是有四个塔可以选择，然后再挪走剩下的n-j个塔，此时有三个塔可以选择，因此这就是我们的状态转移方程：f[i]=min(f[i],f[j]*2+d[n-j]);//i表示当前一共有几个塔，也就是上文所说的n

题解链接：https://www.acwing.com/solution/acwing/content/805/

```
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int d[21],f[21],i,j;
int main()
{
    for(i=1;i<=12;i++) d[i]=2*d[i-1]+1;
    memset(f,0x3f,sizeof(f));
    f[0]=0;
    for(i=1;i<=12;i++)
       for(j=0;j<i;j++)
           f[i]=min(f[i],f[j]+f[j]+d[i-j]);
    for(i=1;i<=12;i++)
       cout<<f[i]<<endl;
    return 0;
}
```