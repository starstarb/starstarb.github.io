---
title: 多线程笔试题
tags: 多线程笔试
categories: 面试题
abbrlink: 190a403c
date: 2019-07-29 14:11:32
---
多线程面试
<!--more-->
__补充基础知识：__

### 线程的概述（Introduction）

线程是一个程序的多个执行路径，执行调度的单位，依托于进程存在。 线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。

注意：Java中的多线程是一种抢占机制而不是分时机制。抢占机制指的是有多个线程处于可运行状态，但是只允许一个线程在运行，他们通过竞争的方式抢占CPU。


### 线程的定义（Defining）

  定义一个线程（Defining a Thread）有两种方法

  1) 继承java.lang.Thread类
```
/**
 * 使用继承java.lang.Thread类的方式创建一个线程
 * 
 */
public class ThreadTest extends Thread {

    /**
     * 重写（Override）run()方法 JVM会自动调用该方法
     */
    public void run() {
        System.out.println("I'm running!");
    }
}
```
注意：重写(override)run()方法在该线程的start()方法被调用后，JVM会自动调用run方法来执行任务；
  但是重载（overload）run()方法，该方法和普通的成员方法一样，并不会因调用该线程的start()方法而被JVM自动运行。 例如：
```
public class ThreadTest extends Thread {

    /**
     * 重写（Override）run()方法 JVM会自动调用该方法
     */
    @Override
    public void run() {
        System.out.println("I'm running!");
    }

    /**
     * 重载（Overload）run()方法 和普通的方法一样，并不会在该线程的start()方法被调用后被JVM自动运行
     */
    public void run(int times) {
        System.out.println("I'm running!(Overload)");
    }
}
```
__注意：__ 不建议使用此方法定义线程，因为采用继承Thread的方式定义线程后，你不能在继承其他的类了，导致程序的可扩展性大大降低。
  2) 实现java.lang.Runnable接口
  ```
  /**
 * 通过实现Runnable接口创建一个线程
 */
public class ThreadTest implements Runnable {
    public void run() {
            System.out.println("I'm running!");
    }
}
  ```
### 线程的启动（Starting）

  任何一个线程的执行的前提都是必须有Thread class的实例存在，并且通过调用run()方法启动线程。

  1）如果线程是继承Thread类，则创建方式如下： 
```
ThreadTest1 tt = new ThreadTest1();
tt.start();
```
  2）如果是实现Runnable接口，则创建方式如下：
  ```
ThreadTest2 tt = new ThreadTest2();
Thread t = new Thread(tt);
t.start();
  ```
### 线程的状态（State）

__新生状态（New)__： 当一个线程的实例被创建即使用new关键字和Thread类或其子类创建一个线程对象后，此时该线程处于新生(new)状态，处于新生状态的线程有自己的内存空间，但该线程并没有运行，此时线程还不是活着的（not alive）；

__就绪状态（Runnable）__： 通过调用线程实例的start()方法来启动线程使线程进入就绪状态(runnable)；处于就绪状态的线程已经具备了运行条件，但还没有被分配到CPU即不一定会被立即执行，此时处于线程就绪队列，等待系统为其分配CPCU，等待状态并不是执行状态； 此时线程是活着的（alive）；

__运行状态（Running)__： 一旦获取CPU(被JVM选中)，线程就进入运行(running)状态，线程的run()方法才开始被执行；在运行状态的线程执行自己的run()方法中的操作，直到调用其他的方法而终止、或者等待某种资源而阻塞、或者完成任务而死亡；如果在给定的时间片内没有执行结束，就会被系统给换下来回到线程的等待状态；此时线程是活着的（alive）；

__阻塞状态（Blocked）__：通过调用join()、sleep()、wait()或者资源被暂用使线程处于阻塞(blocked)状态；处于Blocking状态的线程仍然是活着的（alive）

__死亡状态（Dead）__：当一个线程的run()方法运行完毕或被中断或被异常退出，该线程到达死亡(dead)状态。此时可能仍然存在一个该Thread的实例对象，当该Thready已经不可能在被作为一个可被独立执行的线程对待了，线程的独立的call stack已经被dissolved。一旦某一线程进入Dead状态，他就再也不能进入一个独立线程的生命周期了。对于一个处于Dead状态的线程调用start()方法，会出现一个运行期(runtime exception)的异常；处于Dead状态的线程不是活着的（not alive）。

### 线程的方法（Method）、属性（Property）

1. 优先级（priority）

每个类都有自己的优先级，一般property用1-10的整数表示，默认优先级是5，优先级最高是10；优先级高的线程并不一定比优先级低的线程执行的机会高，只是执行的机率高；默认一个线程的优先级和创建他的线程优先级相同；

2. Thread.sleep()/sleep(long millis)

当前线程睡眠/millis的时间（millis指定睡眠时间是其最小的不执行时间，因为sleep(millis)休眠到达后，无法保证会被JVM立即调度）；sleep()是一个静态方法(static method) ，所以他不会停止其他的线程也处于休眠状态；线程sleep()时不会失去拥有的对象锁。 作用：保持对象锁，让出CPU，调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留一定的时间给其他线程执行的机会；

3. Thread.yield()

  让出CPU的使用权，给其他线程执行机会、让同等优先权的线程运行（但并不保证当前线程会被JVM再次调度、使该线程重新进入Running状态），如果没有同等优先权的线程，那么yield()方法将不会起作用。

4. thread.join()

 使用该方法的线程会在此之间执行完毕后再往下继续执行。

5. object.wait()

  当一个线程执行到wait()方法时，他就进入到一个和该对象相关的等待池(Waiting Pool)中，同时失去了对象的机锁—暂时的，wait后还要返还对象锁。当前线程必须拥有当前对象的锁，如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常,所以wait()必须在synchronized block中调用。

6. object.notify()/notifyAll()

  唤醒在当前对象等待池中等待的第一个线程/所有线程。notify()/notifyAll()也必须拥有相同对象锁，否则也会抛出IllegalMonitorStateException异常。

7. Synchronizing Block
 Synchronized Block/方法控制对类成员变量的访问；Java中的每一个对象都有唯一的一个内置的锁，每个Synchronized Block/方法只有持有调用该方法被锁定对象的锁才可以访问，否则所属线程阻塞；机锁具有独占性、一旦被一个Thread持有，其他的Thread就不能再拥有（不能访问其他同步方法），方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。

### 按序打印
我们提供了一个类：

public class Foo {
  public void one() { print("one"); }
  public void two() { print("two"); }
  public void three() { print("three"); }
}

三个不同的线程将会共用一个 Foo 实例。

    线程 A 将会调用 one() 方法
    线程 B 将会调用 two() 方法
    线程 C 将会调用 three() 方法

请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。

 

示例 1:

输入: [1,2,3]
输出: "onetwothree"
解释: 
有三个线程会被异步启动。
输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。
正确的输出是 "onetwothree"。

示例 2:

输入: [1,3,2]
输出: "onetwothree"
解释: 
输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。
正确的输出是 "onetwothree"。

 

注意:

尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。

你看到的输入格式主要是为了确保测试的全面性。
链接：https://leetcode-cn.com/problems/print-in-order
算法思路：

Java 中，我们使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除。
参考代码：
```
class Foo {
	private boolean firstFinished;
	private boolean secondFinished;
	private Object lock=new Object();

    public Foo() {
        
    }

    public void first(Runnable printFirst) throws InterruptedException {
        
        // printFirst.run() outputs "first". Do not change or remove this line.
       
       synchronized(lock){
       	printFirst.run();
       	firstFinished=true;
       	lock.notifyAll();
       	} 
    }

    public void second(Runnable printSecond) throws InterruptedException {
        
        // printSecond.run() outputs "second". Do not change or remove this line.
        
        synchronized(lock){
        	while(!firstFinished){
        		lock.wait();
        	}
        	printSecond.run();
        	secondFinished=true;
        	lock.notifyAll();
        }
    }

    public void third(Runnable printThird) throws InterruptedException {
        
        // printThird.run() outputs "third". Do not change or remove this line.
        synchronized(lock){
        	while(!secondFinished){
        		lock.wait();
        	}
        	printThird.run();
        }
        
    }
}
```
