---
title: 深度优先搜索
tags: DFS
categories: DFS
abbrlink: 1857aa15
date: 2019-07-29 14:12:02
---
DFS
<!--more-->
### 验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

    节点的左子树只包含小于当前节点的数。
    节点的右子树只包含大于当前节点的数。
    所有左子树和右子树自身必须也是二叉搜索树。

示例 1:

输入:
    2
   / \
  1   3
输出: true

示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
链接：https://leetcode-cn.com/problems/validate-binary-search-tree
算法思路：
1. 递归
首先将结点的值与上界和下界比较，然后对左右子树递归进行该过程。
时间复杂度：O(N)每个结点访问了一次
空间复杂度：O(N)整棵树
参考代码：
```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
 //1.递归
class Solution {
  public boolean help(TreeNode node, Integer lower, Integer upper) {
    if (node == null) return true;

    int val = node.val;
    if (lower != null && val <= lower) return false;
    if (upper != null && val >= upper) return false;

    if (! help(node.right, val, upper)) return false;
    if (! help(node.left, lower, val)) return false;
    return true;
  }

  public boolean isValidBST(TreeNode root) {
    return help(root, null, null);
  }
}

```
2. 迭代
通过使用栈，DFS比BFS快。
时间复杂度：O(N)每个结点访问了一次
空间复杂度：O(N)整棵树
参考代码：
```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    LinkedList<TreeNode> stack=new LinkedList();
    LinkedList<Integer> uppers=new LinkedList();
    LinkedList<Integer> lowers=new LinkedList();
    public void update(TreeNode root,Integer lower,Integer upper){
    	stack.add(root);
    	lowers.add(lower);
    	uppers.add(upper);
    }
    public boolean isValidBST(TreeNode root) {
        Integer lower=null,upper=null,val;
        update(root,lower,upper);
        while(!stack.isEmpty()){
        	root=stack.poll();
        	lower=lowers.poll();
        	upper=uppers.poll();
        	if(root==null)continue;
        	val=root.val;
        	if(lower!=null&& val<=lower) return false;
        	if(upper!=null&&val>=upper)return false;
        	update(root.right,val,upper);
        	update(root.left,lower,val);
        }
        return true;
    }
}
```

### 207课程表

现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？

示例 1:

输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。

示例 2:

输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。

说明:

    输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。
    你可以假定输入的先决条件中没有重复的边。

提示:

    这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
    通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。

    拓扑排序也可以通过 BFS 完成。
链接：https://leetcode-cn.com/problems/course-schedule
算法思路：
1. 拓扑排序
拓扑排序实际上应用的是贪心算法。贪心算法简而言之：每一步最优，全局就最优。

具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，我们可以设置一个入度数组，每一轮都输出入度为 0 的结点，并移除它、修改它指向的结点的入度（−1即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。

拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。拓扑排序还可以用于检测一个有向图是否有环。相关的概念还有 AOV 网，这里就不展开了。

算法流程：

1、在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 0 的结点放入队列。

2、只要队列非空，就从队首取出入度为 0的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减 1，在减 1 以后，如果这个被减 1 的结点的入度为 0，就继续入队。

3、当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。

思考这里为什么要使用队列？

在代码具体实现的时候，除了保存入度为 0 的队列，我们还需要两个辅助的数据结构：
1、邻接表：通过结点的索引，我们能够得到这个结点的后继结点；

2、入度数组：通过结点的索引，我们能够得到指向这个结点的结点个数。

这个两个数据结构在遍历题目给出的邻边以后就可以很方便地得到。

时间复杂度：O(E+V)。这里 E表示邻边的条数，V 表示结点的个数。初始化入度为 0的集合需要遍历整张图，具体做法是检查每个结点和每条边，因此复杂度为 O(E+V)，然后对该集合进行操作，又需要遍历整张图中的每个结点和每条边，复杂度也为 O(E+V)；
    
空间复杂度：O(V)：入度数组、邻接表的长度都是结点的个数 V，即使使用队列，队列最长的时候也不会超过 V，因此空间复杂度是 O(V)。

如果不使用队列，要想得到当前入度为 0 的结点，就得遍历一遍入度数组。使用队列即用空间换时间。

Java:

```
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if(numCourses<=0) return false;
        int plen=prerequisites.length;
        if(plen==0) return true;
        int[] inDegree=new int[numCourses];
        for(int[] p:prerequisites){
        	inDegree[p[0]]++;
        }
        LinkedList<Integer> queue=new LinkedList();
        // 首先加入入度为 0 的结点
        for(int i=0;i<numCourses;i++){
        	if(inDegree[i]==0) queue.addLast(i);
        }

        // 拓扑排序的结果
        List<Integer> res=new ArrayList();
        while(!queue.isEmpty()){
        	Integer num=queue.removeFirst();
        	res.add(num);
// 把邻边全部遍历一下
        	for(int[] p: prerequisites){
        		if(p[1]==num){
        			inDegree[p[0]]--;
        			if(inDegree[p[0]]==0){
        				queue.addLast(p[0]);
        			}
        		}
        	}
        }
           // System.out.println("拓扑排序结果：");
        // System.out.println(res);
        return res.size()==numCourses;
    }
}
```

2. DFS
深度优先遍历

这里要使用逆邻接表。其实就是检测这个有向图中有没有环，只要存在环，这些课程就不能按要求学完。

具体方法是：

第 1 步：构建逆邻接表；

第 2 步：递归处理每一个还没有被访问的结点，具体做法很简单：对于一个结点来说，先输出指向它的所有顶点，再输出自己。

第 3 步：如果这个顶点还没有被遍历过，就递归遍历它，把所有指向它的结点都输出了，再输出自己。注意：当访问一个结点的时候，应当先递归访问它的前驱结点，直至前驱结点没有前驱结点为止。
复杂度分析：

    时间复杂度：O(E+V)
    空间复杂度：O(V)
```
class Solution {
 public boolean canFinish(int numCourses, int[][] prerequisites) {
        if (numCourses <= 0) {
            return false;
        }
        int plen = prerequisites.length;
        if (plen == 0) {
            return true;
        }
        int[] marked = new int[numCourses];

        // 初始化有向图 begin
        HashSet<Integer>[] graph = new HashSet[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new HashSet<>();
        }
        // 初始化有向图 end
        // 有向图的 key 是前驱结点，value 是后继结点的集合
        for (int[] p : prerequisites) {
            graph[p[1]].add(p[0]);
        }

        for (int i = 0; i < numCourses; i++) {
            if (dfs(i, graph, marked)) {
                // 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回 false
                return false;
            }
        }
        // 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环
        // 所有课程任务可以完成，应该返回 true
        return true;
    }

    /**
     * 注意这个 dfs 方法的语义
     * @param i      当前访问的课程结点
     * @param graph
     * @param marked 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了
     * @return true 表示图中存在环，false 表示访问过了，不用再访问了
     */
    private boolean dfs(int i,
                        HashSet<Integer>[] graph,
                        int[] marked) {
        // 如果访问过了，就不用再访问了
        if (marked[i] == 1) {
            // 从正在访问中，到正在访问中，表示遇到了环
            return true;
        }

        if (marked[i] == 2) {
            // 表示在访问的过程中没有遇到环，这个节点访问过了
            return false;
        }
        // 走到这里，是因为初始化呢，此时 marked[i] == 0
        // 表示正在访问中
        marked[i] = 1;
        // 后继结点的集合
        HashSet<Integer> successorNodes = graph[i];

        for (Integer successor : successorNodes) {
            if (dfs(successor, graph, marked)) {
                // 层层递归返回 true ，表示图中存在环
                return true;
            }
        }
        // i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束
        // 状态设置为 2
        marked[i] = 2;
        // false 表示图中不存在环
        return false;
    }
}

```

### 恢复二叉搜索树
 二叉搜索树中的两个节点被错误地交换。

请在不改变其结构的情况下，恢复这棵树。

示例 1:

输入: [1,3,null,null,2]

   1
  /
 3
  \
   2

输出: [3,1,null,null,2]

   3
  /
 1
  \
   2

示例 2:

输入: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

输出: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3

进阶:

    使用 O(n) 空间复杂度的解法很容易实现。
    你能想出一个只使用常数空间的解决方案吗？

链接：https://leetcode-cn.com/problems/recover-binary-search-tree
算法思路：
因为只有两个节点错误，所以只要找出这两个节点然后交换值即可。
中序遍历,使用三个指针指示节点，cur为当前节点，wrong1为第一个错误节点，wrong2为找出的第二个错误节点。
1. 迭代
Java实现：
```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public void recoverTree(TreeNode root) {
        if(root==null) return;
        Deque<TreeNode> stack=new LinkedList<>();
        TreeNode wrong1=null;
        TreeNode wrong2=null;
        TreeNode pre=new TreeNode(Integer.MIN_VALUE);
        TreeNode cur=root;
        while(cur!=null||!stack.isEmpty()){
            while(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }
            cur=stack.pop();
            if(wrong1==null&&pre.val>cur.val) wrong1=pre;
            if(wrong1!=null&&pre.val>cur.val) wrong2=cur;
            pre=cur;
            cur=cur.right;
        }
        int tmp=wrong1.val;
        wrong1.val=wrong2.val;
        wrong2.val=tmp;
    }
}
```
2. 递归 11ms
```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
	    TreeNode wrong1=null;
        TreeNode wrong2=null;
        TreeNode pre=new TreeNode(Integer.MIN_VALUE);
    public void recoverTree(TreeNode root) {
         order(root);
         int tmp=wrong1.val;
         wrong1.val=wrong2.val;
         wrong2.val=tmp;
    }
    private void order(TreeNode root){
         if(root==null) return;
         order(root.left);
         if(wrong1==null&&pre.val>root.val) wrong1=pre;
         if(wrong1!=null&&pre.val>root.val)
         wrong2=root;

         pre=root;
         order(root.right);
    }
}
```

### 相同的树
给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true

示例 2:

输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false

示例 3:

输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
链接：https://leetcode-cn.com/problems/same-tree

算法思路：
1. 递归，首先判断p和q 是不是空，然后判断它们的值是否相等。
若以上判断通过，则递归对子节点做同样操作。


```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null) return true;
        if(q==null||p==null) return false;
        if(p.val!=q.val) return false;
        return isSameTree(p.right,q.right)&&isSameTree(p.left,q.left);
    }
}
```
### 133.克隆图
给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。

示例：

![error](https://github.com/starstarb/clouding/blob/master/leetcode/113_sample.png)
输入：
{"$id":"1","neighbors":[{"$id":"2","neighbors":[{"$ref":"1"},{"$id":"3","neighbors":[{"$ref":"2"},{"$id":"4","neighbors":[{"$ref":"3"},{"$ref":"1"}],"val":4}],"val":3}],"val":2},{"$ref":"4"}],"val":1}

解释：
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。

 

提示：

    节点数介于 1 到 100 之间。
    无向图是一个简单图，这意味着图中没有重复的边，也没有自环。
    由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。
    必须将给定节点的拷贝作为对克隆图的引用返回。

链接：https://leetcode-cn.com/problems/clone-graph


算法思路：
遍历整个图，记录已经访问的点，用一个字典记录
1. DFS


2. BFS



参考代码：

```
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> neighbors;

    public Node() {}

    public Node(int _val,List<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
};
*/
class Solution {
    public Node cloneGraph(Node node) {
        Map<Node,Node> lookup=new HashMap<>();
        return dfs(node,lookup);
    }

    private Node dfs(Node node,Map<Node,Node> lookup){
      if(node==null)return null;
      if(lookup.containsKey(node)) return lookup.get(node);
      Node clone=new Node(node.val,new ArrayList<>());
      lookup.put(node,clone);
      for(Node n: node.neighbors) clone.neighbors.add(dfs(n,lookup));
      return clone;
    }
}
```

```
class Solution {
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        Map<Node, Node> lookup = new HashMap<>();
        Node clone = new Node(node.val, new ArrayList<>());
        lookup.put(node, clone);
        Deque<Node> queue = new LinkedList<>();
        queue.offer(node);
        while (!queue.isEmpty()) {
            Node tmp = queue.poll();
            for (Node n : tmp.neighbors) {
                if (!lookup.containsKey(n)) {
                    lookup.put(n, new Node(n.val, new ArrayList<>()));
                    queue.offer(n);
                }
                lookup.get(tmp).neighbors.add(lookup.get(n));
            }
        }
        return clone;
    }
}
```

### 104. 二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7

返回它的最大深度 3 
链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree
1. 递归：
时间复杂度: O(N)
空间复杂度: O(N) 最好情况：完全平衡树：O(log(N))
```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) {
          return 0;
        }
        else{
          int left_height=maxDepth(root.left);
          int right_height=maxDepth(root.right);
          return java.lang.Math.max(left_height,right_height)+1;
        }
    }
}
```
DFS: 通过栈，将递归转化为迭代。 使用DFS访问每个节点，同时在每次访问时更新最大深度。
从包含根节点且相应深度为1的栈开始，将当前节点弹出栈并推入子节点，每一步都会更新深度。
时间、空间复杂度：O(N)
```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
import javafx.util.Pair;
import java.lang.Math;
class Solution{
  public int maxDepth(TreeNode root){
    Queue<Pair<TreeNode,Integer>> stack=new LinkedList<>();
    if(root!=null){
      stack.add(new Pair(root,1));
    }
    int depth=0;
    while(!stack.isEmpty()){
      Pair<TreeNode,Integer> current=stack.poll();
      root=current.getKey();
      int current_depth=current.getValue();
      if(root!=null){
        depth=Math.max(depth,current_depth);
        stack.add(new Pair(root.left,current_depth+1));
        stack.add(new Pair(root.right,current_depth+1));
      }
    }
    return depth;
  }
}

```

这里提一点，为什么在这里DFS比递归慢很多，因为测试的数据量太少，如果数据量大，选择DFS不会爆栈同时会比递归执行时间少很多，因此，以后在项目中要根据实际情况选择合适的算法。


### 祖玛游戏
回忆一下祖玛游戏。现在桌上有一串球，颜色有红色(R)，黄色(Y)，蓝色(B)，绿色(G)，还有白色(W)。 现在你手里也有几个球。

每一次，你可以从手里的球选一个，然后把这个球插入到一串球中的某个位置上（包括最左端，最右端）。接着，如果有出现三个或者三个以上颜色相同的球相连的话，就把它们移除掉。重复这一步骤直到桌上所有的球都被移除。

找到插入并可以移除掉桌上所有球所需的最少的球数。如果不能移除桌上所有的球，输出 -1 。

示例:
输入: "WRRBBW", "RB" 
输出: -1 
解释: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW （翻译者标注：手上球已经用完，桌上还剩两个球无法消除，返回-1）

输入: "WWRRBBWW", "WRBRW" 
输出: 2 
解释: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty

输入:"G", "GGGGG" 
输出: 2 
解释: G -> G[G] -> GG[G] -> empty 

输入: "RBYYBBRRB", "YRBGB" 
输出: 3 
解释: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty 

标注:

    你可以假设桌上一开始的球中，不会有三个及三个以上颜色相同且连着的球。
    桌上的球不会超过20个，输入的数据中代表这些球的字符串的名字是 "board" 。
    你手中的球不会超过5个，输入的数据中代表这些球的字符串的名字是 "hand"。
    输入的两个字符串均为非空字符串，且只包含字符 'R','Y','B','G','W'。
链接：https://leetcode-cn.com/problems/zuma-game

思路：
题目希望我们用最少的球来消掉桌上所有的球，如果不能完全消掉，返回-1。

我们使用哈希表来统计手中每种球的个数。

然后我们遍历桌上的球，我们找连续相同球的个数，在没有可以消除的情况下，连续的个数只能是1个或2个，然后我们用3减去连续个数，就是我们需要补充的球数以使其可以被消除，那么我们在哈希表表中看我们手中的该类型的球够不够，如果够就表示可以消除，我们在哈希表中减去需要使用掉的球数，然后将消掉的球移除。

然后对新的字符串调用递归，如果可以成功消除，会返回一个结果，该结果加上之前需要的球数用来更新结果res，注意调用完递归要恢复哈希表的状态(backtrack)。 


```
class Solution {
    int MAXCOUNT = 6;
    // the max balls you need will not exceed 6 since "The number of balls in your hand won't exceed 5"
    public int findMinStep(String board, String hand) {
        int[] handCount = new int[26];
        for (int i = 0; i < hand.length(); i++) {
            handCount[hand.charAt(i) - 'A']++;
        }
        int result = backtrack(board + "#", handCount);
        // append a "#" to avoid special process while j==board.length, make the code shorter.
        return result == MAXCOUNT ? -1 : result;
    }

    private int backtrack(String s, int[] h) {
        s = removeConsecutive(s);
        if (s.equals("#")) return 0;
        int rs = MAXCOUNT, need = 0;
        int i = 0;
        for (int j = 0 ; j < s.length(); ++j) {
            if (s.charAt(j) == s.charAt(i)) continue;
            need = 3 - (j - i);
            //balls need to remove current consecutive balls.
            if (h[s.charAt(i) - 'A'] >= need) {
                h[s.charAt(i) - 'A'] -= need;
                rs = Math.min(rs, need + backtrack(s.substring(0, i) + s.substring(j), h));
                h[s.charAt(i) - 'A'] += need;
            }
            i = j;
        }
        return rs;
    }
    //remove consecutive balls longer than 3
    private String removeConsecutive(String board) {
        int i = 0;
        for (int j = 0; j < board.length(); ++j) {
            if (board.charAt(j) == board.charAt(i)) continue;
            if (j - i >= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));
            else i = j;
        }
        return board;
    }
}

```

__算法__
(dfs)

我们先将手中的球用哈希表来存储一下，然后看桌上的球能否在哈希表里的球添加后消除，然后消除后递归处理剩下的。中间记录需要的球数，用来更新需要球数的最小值。如果最小值超出了手中球的个数，则无法消除。

时间复杂度分析：桌上的球不会超过20个，手中的球不会超过5个，所以时间复杂度为O(m+n).
C++ 代码
```
class Solution {
public:
    string del(string board){
        for(int i=0;i<board.size();){
            int j=i;
            while(j<board.size()&&board[i]==board[j])j++;
            if(j-i>=3)
                return del(board.substr(0,i)+board.substr(j));
            else i=j;
        }
        return board;
    }
    int dfs(string board, unordered_map<char,int>&hash){
        board=del(board);
        if(board.size()==0)return 0;
        int rs=6,need=0;
        for(int i=0;i<board.size();){
            int j=i;
            while(j<board.size()&&board[i]==board[j])j++;
            need=3-(j-i);
            if(hash[board[i]]>=need){
                hash[board[i]]-=need;
                rs=min(rs,need+dfs(board.substr(0,i)+board.substr(j),hash));
                hash[board[i]]+=need;
            }
            i=j;
        }
        return rs;
    }
    int findMinStep(string board, string hand) {
        unordered_map<char,int>hash;
        for(auto x:hand)hash[x]++;
        int res=dfs(board,hash);
        return res==6?-1:res;
    }
};

```